/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-modal.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { tap, delay } from 'rxjs/operators';
import { cycleTabs, getFocusElementList } from 'carbon-components-angular/common';
import { CommonModule } from '@angular/common';
import { ButtonModule } from 'carbon-components-angular/forms';
import { I18n, I18nModule } from 'carbon-components-angular/i18n';
import { PlaceholderService, PlaceholderModule } from 'carbon-components-angular/placeholder';
import { ExperimentalService, ExperimentalModule } from 'carbon-components-angular/experimental';
import { Output, EventEmitter, Input, Directive, Component, Inject, ViewChild, Optional, ComponentFactoryResolver, Injector, Injectable, HostListener, HostBinding, NgModule } from '@angular/core';
import { IconModule } from 'carbon-components-angular/icon';

/**
 * Extend `BaseModal` in your custom modal implementations to ensure consistent close behavior.
 *
 * `ModalService` depends on the `close` event to correctly clean up the component.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from 'carbon-components-angular/forms';
import * as ɵngcc3 from 'carbon-components-angular/i18n';
import * as ɵngcc4 from 'carbon-components-angular/experimental';
import * as ɵngcc5 from 'carbon-components-angular/icon';
import * as ɵngcc6 from 'carbon-components-angular/placeholder';

const _c0 = ["modalContent"];
function AlertModal_ibm_modal_footer_9_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "button", 9);
    ɵngcc0.ɵɵlistener("click", function AlertModal_ibm_modal_footer_9_ng_container_1_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r6); const i_r4 = ctx.index; const ctx_r5 = ɵngcc0.ɵɵnextContext(2); return ctx_r5.buttonClicked(i_r4); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const button_r3 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ibmButton", button_r3.type)("id", button_r3.id);
    ɵngcc0.ɵɵattribute("modal-primary-focus", button_r3.type.indexOf("primary") !== -1 ? "" : null);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", button_r3.text, " ");
} }
function AlertModal_ibm_modal_footer_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "ibm-modal-footer");
    ɵngcc0.ɵɵtemplate(1, AlertModal_ibm_modal_footer_9_ng_container_1_Template, 3, 4, "ng-container", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.buttons);
} }
const _c1 = ["*"];
const _c2 = ["modal"];
function Modal_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 4);
} }
const _c3 = function (a0, a1, a2) { return { "bx--modal-container--xs": a0, "bx--modal-container--sm": a1, "bx--modal-container--lg": a2 }; };
const _c4 = ["overlay"];
const _c5 = function (a0, a1) { return { "bx--modal--danger": a0, "is-visible": a1 }; };
class BaseModal {
    constructor() {
        /**
         * Base event emitter to propagate close events
         */
        this.close = new EventEmitter();
        /**
         * Controls the open state of the modal
         */
        this.open = false;
    }
    /**
     * Default method to handle closing the modal
     */
    closeModal() {
        this.close.emit();
    }
}
BaseModal.ɵfac = function BaseModal_Factory(t) { return new (t || BaseModal)(); };
BaseModal.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: BaseModal, selectors: [["", "ibmBaseModal", ""]], inputs: { open: "open" }, outputs: { close: "close" } });
BaseModal.propDecorators = {
    close: [{ type: Output }],
    open: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BaseModal, [{
        type: Directive,
        args: [{ selector: "[ibmBaseModal]" }]
    }], function () { return []; }, { close: [{
            type: Output
        }], open: [{
            type: Input
        }] }); })();

/**
 * Component to create standard modals for presenting content or asking for user's input.
 * It can show as a passive modal showing only text or show as a transactional modal with
 * multiple buttons for different actions for the user to choose from.
 *
 * Using a modal in your application requires `ibm-placeholder` which would generally be
 * placed near the end of your app component template (app.component.ts or app.component.html) as:
 *
 * ```html
 * <ibm-placeholder></ibm-placeholder>
 * ```
 *
 * Example of opening the modal:
 *
 * ```typescript
 * \@Component({
 *  selector: "app-modal-demo",
 *  template: `
 *   <button class="btn--primary" (click)="openModal()">Open modal</button>
 *   <ibm-placeholder></ibm-placeholder>`
 * })
 * export class ModalDemo {
 * 	openModal() {
 * 		this.modalService.show({
 *			modalType: "default",
 *			label: "optional header text",
 *			title: "Modal title",
 *			text: "Modal text",
 *			buttons: [{
 *				text: "Button text",
 *				type: "primary",
 *				click: clickFunction
 *			}]
 *		});
 * 	}
 * }
 * ```
 */
class AlertModal extends BaseModal {
    /**
     * Creates an instance of `AlertModal`.
     */
    constructor(type = "default", label, title, content, size, hasScrollingContent = null, buttons = [], onClose) {
        super();
        this.type = type;
        this.label = label;
        this.title = title;
        this.content = content;
        this.size = size;
        this.hasScrollingContent = hasScrollingContent;
        this.buttons = buttons;
        this.onClose = onClose;
        for (let i = 0; i < this.buttons.length; i++) {
            const button = this.buttons[i];
            if (!button.id) {
                button.id = `alert-modal-button-${i}`;
            }
            if (!button.type) {
                button.type = "secondary";
            }
        }
    }
    ngAfterViewInit() {
        if (!this.modalContent) {
            return false;
        }
        const element = this.modalContent.nativeElement;
        if (element.scrollHeight > element.clientHeight) {
            element.tabIndex = 0;
        }
        else {
            element.tabIndex = -1;
        }
    }
    buttonClicked(buttonIndex) {
        const button = this.buttons[buttonIndex];
        if (button.click) {
            button.click();
        }
        this.closeModal();
    }
    dismissModal(trigger) {
        if (this.onClose && this.onClose(trigger) === false) {
            return;
        }
        this.closeModal();
    }
}
AlertModal.ɵfac = function AlertModal_Factory(t) { return new (t || AlertModal)(ɵngcc0.ɵɵdirectiveInject("type", 8), ɵngcc0.ɵɵdirectiveInject("label", 8), ɵngcc0.ɵɵdirectiveInject("title", 8), ɵngcc0.ɵɵdirectiveInject("content", 8), ɵngcc0.ɵɵdirectiveInject("size", 8), ɵngcc0.ɵɵdirectiveInject("hasScrollingContent", 8), ɵngcc0.ɵɵdirectiveInject("buttons", 8), ɵngcc0.ɵɵdirectiveInject("close", 8)); };
AlertModal.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AlertModal, selectors: [["ibm-alert-modal"]], viewQuery: function AlertModal_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.modalContent = _t.first);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 10, vars: 9, consts: [[3, "size", "theme", "ariaLabel", "hasScrollingContent", "open", "overlaySelected"], [3, "closeSelect"], ["ibmModalHeaderLabel", "", 1, "bx--type-delta"], ["ibmModalHeaderHeading", "", 1, "bx--type-beta"], ["ibmModalContent", ""], ["modalContent", ""], [3, "innerHTML"], [4, "ngIf"], [4, "ngFor", "ngForOf"], [3, "ibmButton", "id", "click"]], template: function AlertModal_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ibm-modal", 0);
        ɵngcc0.ɵɵlistener("overlaySelected", function AlertModal_Template_ibm_modal_overlaySelected_0_listener() { return ctx.dismissModal("overlay"); });
        ɵngcc0.ɵɵelementStart(1, "ibm-modal-header", 1);
        ɵngcc0.ɵɵlistener("closeSelect", function AlertModal_Template_ibm_modal_header_closeSelect_1_listener() { return ctx.dismissModal("close"); });
        ɵngcc0.ɵɵelementStart(2, "p", 2);
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "p", 3);
        ɵngcc0.ɵɵtext(5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "div", 4, 5);
        ɵngcc0.ɵɵelement(8, "p", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(9, AlertModal_ibm_modal_footer_9_Template, 2, 1, "ibm-modal-footer", 7);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("size", ctx.size)("theme", ctx.type)("ariaLabel", ctx.title)("hasScrollingContent", ctx.hasScrollingContent)("open", ctx.open);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.label);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.title);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("innerHTML", ctx.content, ɵngcc0.ɵɵsanitizeHtml);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.buttons.length > 0);
    } }, directives: function () { return [Modal, ModalHeader, ModalHeaderLabel, ModalHeaderHeading, ModalContent, ɵngcc1.NgIf, ModalFooter, ɵngcc1.NgForOf, ɵngcc2.Button]; }, encapsulation: 2 });
/** @nocollapse */
AlertModal.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: ["type",] }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: ["label",] }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: ["title",] }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: ["content",] }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: ["size",] }] },
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: ["hasScrollingContent",] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: ["buttons",] }] },
    { type: Function, decorators: [{ type: Optional }, { type: Inject, args: ["close",] }] }
];
AlertModal.propDecorators = {
    modalContent: [{ type: ViewChild, args: ["modalContent", { static: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AlertModal, [{
        type: Component,
        args: [{
                selector: "ibm-alert-modal",
                template: `
		<ibm-modal
			[size]="size"
			[theme]="type"
			[ariaLabel]="title"
			[hasScrollingContent]="hasScrollingContent"
			[open]="open"
			(overlaySelected)="dismissModal('overlay')">
			<ibm-modal-header (closeSelect)="dismissModal('close')">
				<p ibmModalHeaderLabel class="bx--type-delta">{{label}}</p>
				<p ibmModalHeaderHeading class="bx--type-beta">{{title}}</p>
			</ibm-modal-header>
			<div ibmModalContent #modalContent>
				<p [innerHTML]="content"></p>
			</div>
			<ibm-modal-footer *ngIf="buttons.length > 0">
				<ng-container *ngFor="let button of buttons; let i = index">
					<button
						[ibmButton]="button.type"
						(click)="buttonClicked(i)"
						[id]="button.id"
						[attr.modal-primary-focus]="(button.type.indexOf('primary') !== -1 ? '' : null)">
						{{button.text}}
					</button>
				</ng-container>
			</ibm-modal-footer>
		</ibm-modal>
	`
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: ["type"]
            }] }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: ["label"]
            }] }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: ["title"]
            }] }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: ["content"]
            }] }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: ["size"]
            }] }, { type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: ["hasScrollingContent"]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: ["buttons"]
            }] }, { type: Function, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: ["close"]
            }] }]; }, { modalContent: [{
            type: ViewChild,
            args: ["modalContent", { static: true }]
        }] }); })();

var AlertModalType;
(function (AlertModalType) {
    AlertModalType["default"] = "default";
    AlertModalType["danger"] = "danger";
})(AlertModalType || (AlertModalType = {}));
var ModalButtonType;
(function (ModalButtonType) {
    ModalButtonType["primary"] = "primary";
    ModalButtonType["secondary"] = "secondary";
    ModalButtonType["tertiary"] = "tertiary";
    ModalButtonType["ghost"] = "ghost";
    ModalButtonType["danger"] = "danger";
    ModalButtonType["danger_primary"] = "danger--primary";
})(ModalButtonType || (ModalButtonType = {}));

class ModalFooter {
}
ModalFooter.ɵfac = function ModalFooter_Factory(t) { return new (t || ModalFooter)(); };
ModalFooter.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ModalFooter, selectors: [["ibm-modal-footer"]], ngContentSelectors: _c1, decls: 2, vars: 0, consts: [[1, "bx--modal-footer"]], template: function ModalFooter_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "footer", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ModalFooter, [{
        type: Component,
        args: [{
                selector: "ibm-modal-footer",
                template: `
		<footer class="bx--modal-footer">
			<ng-content></ng-content>
		</footer>
	`
            }]
    }], null, null); })();

/**
 * ***Inputs***
 * ```html
 * <ibm-modal-header>Header text</ibm-modal-header>
 * ```
 *
 * ***Outputs***
 * ```html
 * <ibm-modal-header (closeSelect)="closeModal()">Header text</ibm-modal-header>
 * ```
 */
class ModalHeader {
    constructor(i18n, experimental) {
        this.i18n = i18n;
        this.experimental = experimental;
        /**
         * Sets the style on the modal heading based on its category.
         */
        this.theme = "default";
        /**
         * Accessible label for the header close button.
         * Defaults to the `MODAL.CLOSE` value from the i18n service.
         */
        this.closeLabel = this.i18n.get().MODAL.CLOSE;
        /**
         * To emit the event of clicking on the close icon within the modal.
         */
        this.closeSelect = new EventEmitter();
    }
    /**
     * Handles click for the close icon button within the `Modal`.
     */
    onClose() {
        this.closeSelect.emit();
    }
}
ModalHeader.ɵfac = function ModalHeader_Factory(t) { return new (t || ModalHeader)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.I18n), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.ExperimentalService)); };
ModalHeader.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ModalHeader, selectors: [["ibm-modal-header"]], inputs: { theme: "theme", closeLabel: "closeLabel" }, outputs: { closeSelect: "closeSelect" }, ngContentSelectors: _c1, decls: 6, vars: 4, consts: [["type", "button", 1, "bx--modal-close", 3, "click"], [1, "bx--assistive-text"], ["ibmIcon", "close", "size", "20", 1, "bx--modal-close__icon"]], template: function ModalHeader_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "header");
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementStart(2, "button", 0);
        ɵngcc0.ɵɵlistener("click", function ModalHeader_Template_button_click_2_listener() { return ctx.onClose(); });
        ɵngcc0.ɵɵelementStart(3, "span", 1);
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(5, "svg", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMapInterpolate1("", ctx.theme, " bx--modal-header");
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵtextInterpolate(ctx.closeLabel);
    } }, directives: [ɵngcc5.IconDirective], encapsulation: 2 });
/** @nocollapse */
ModalHeader.ctorParameters = () => [
    { type: I18n },
    { type: ExperimentalService }
];
ModalHeader.propDecorators = {
    theme: [{ type: Input }],
    closeLabel: [{ type: Input }],
    closeSelect: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ModalHeader, [{
        type: Component,
        args: [{
                selector: "ibm-modal-header",
                template: `
		<header class="{{theme}} bx--modal-header">
			<ng-content></ng-content>
			<button
				type="button"
				class="bx--modal-close"
				(click)="onClose()">
				<span class="bx--assistive-text">{{ closeLabel }}</span>
				<svg ibmIcon="close" size="20" class="bx--modal-close__icon"></svg>
			</button>
		</header>

	`
            }]
    }], function () { return [{ type: ɵngcc3.I18n }, { type: ɵngcc4.ExperimentalService }]; }, { theme: [{
            type: Input
        }], closeLabel: [{
            type: Input
        }], closeSelect: [{
            type: Output
        }] }); })();

/**
 * Modal service handles instantiating and destroying modal instances.
 * Uses PlaceholderService to track open instances, and for it's placeholder view reference.
 */
class ModalService {
    /**
     * Creates an instance of `ModalService`.
     */
    constructor(resolver, placeholderService) {
        this.resolver = resolver;
        this.placeholderService = placeholderService;
    }
    /**
     * Creates and renders the modal component that is passed in.
     * `inputs` is an optional parameter of `data` that can be passed to the `Modal` component.
     */
    create(data) {
        let defaults = { inputs: {} };
        data = Object.assign({}, defaults, data);
        const inputProviders = Object.keys(data.inputs).map(inputName => ({
            provide: inputName,
            useValue: data.inputs[inputName]
        }));
        const injector = Injector.create(inputProviders);
        const factory = this.resolver.resolveComponentFactory(data.component);
        let focusedElement = document.activeElement;
        let component = this.placeholderService.createComponent(factory, injector);
        setTimeout(() => {
            component.instance.open = true;
        });
        component["previouslyFocusedElement"] = focusedElement; // used to return focus to previously focused element
        component.instance.close.pipe(
        // trigger the close animation
        tap(() => {
            component.instance.open = false;
        }), 
        // delay closing by an arbitrary amount to allow the animation to finish
        delay(150)).subscribe(() => {
            this.placeholderService.destroyComponent(component);
            // filter out our component
            ModalService.modalList = ModalService.modalList.filter(c => c !== component);
        });
        component.onDestroy(() => {
            focusedElement.focus();
        });
        ModalService.modalList.push(component);
        return component;
    }
    /**
     * Creates and renders a new alert modal component.
     * @param data You can pass in:
     * `type` - "default" | "danger" = "default",
     * `label` - a label shown over the title,
     * `title` - modal's title,
     * `content` - modal's content, could include HTML tags.
     * `buttons` is an array of objects
     * `close` custom close function
     * ```
     * {
     * 		text: "Button text",
     * 		type: "primary" | "secondary" | "tertiary" | "ghost" | "danger" | "danger--primary" = "primary",
     * 		click: clickFunction,
     * }
     * ```
     */
    show(data) {
        return this.create({
            component: AlertModal,
            inputs: {
                type: data.type,
                label: data.label,
                title: data.title,
                content: data.content,
                hasScrollingContent: data.hasScrollingContent || null,
                size: data.size,
                buttons: data.buttons || [],
                close: data.close || (() => { })
            }
        });
    }
    /**
     * Destroys the modal on the supplied index.
     * When called without parameters it destroys the most recently created/top most modal.
     */
    destroy(index = -1) {
        // return if nothing to destroy because it's already destroyed
        if (index >= ModalService.modalList.length || ModalService.modalList.length === 0) {
            return;
        }
        // on negative index destroy the last on the list (top modal)
        if (index < 0) {
            index = ModalService.modalList.length - 1;
        }
        this.placeholderService.destroyComponent(ModalService.modalList[index]);
        ModalService.modalList.splice(index, 1);
    }
}
ModalService.ɵfac = function ModalService_Factory(t) { return new (t || ModalService)(ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(ɵngcc6.PlaceholderService)); };
ModalService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ModalService, factory: ModalService.ɵfac });
// track all our open modals
ModalService.modalList = [];
/** @nocollapse */
ModalService.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: PlaceholderService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ModalService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc6.PlaceholderService }]; }, null); })();

/**
 * Component to create modals for presenting content.
 *
 * [See demo](../../?path=/story/modal--basic)
 *
 * Using a modal in your application requires `ibm-placeholder` which would generally be
 * placed near the end of your app component template (app.component.ts or app.component.html) as:
 *
```html
<ibm-placeholder></ibm-placeholder>
```
 *
 * A more complete example for `Modal` is given as follows:
 *
 * Example modal definition:
 *
```typescript
@Component({
    selector: "app-sample-modal",
    template: `
                <ibm-modal size="xl" (overlaySelected)="closeModal()">
                    <ibm-modal-header (closeSelect)="closeModal()">Header text</ibm-modal-header>
                        <section class="modal-body">
                            <h1>Sample modal works.</h1>
                            <button class="btn--icon-link" nPopover="Hello there" title="Popover title" placement="right" appendInline="true">
                                <svg ibmIcon="info" size="sm"></ibm-icon>
                            </button>
                            {{modalText}}
                        </section>
                    <ibm-modal-footer><button ibmButton="primary" (click)="closeModal()">Close</button></ibm-modal-footer>
                </ibm-modal>`,
    styleUrls: ["./sample-modal.component.scss"]
})
export class SampleModal extends BaseModal {
    modalText: string;
    constructor(protected injector: Injector) {
        super();
        this.modalText = this.injector.get("modalText");
    }
}
```
 *
 * Example of opening the modal:
 *
```typescript
@Component({
    selector: "app-modal-demo",
    template: `
                <button ibmButton="primary" (click)="openModal('drill')">Drill-down modal</button>
                <ibm-placeholder></ibm-placeholder>`
})
export class ModalDemo {
    openModal() {
        this.modalService.create({component: SampleModal, inputs: {modalText: "Hello universe."}});
    }
}
```
 *
 * <example-url>../../iframe.html?id=modal--basic</example-url>
 */
class Modal {
    /**
     * Creates an instance of `Modal`.
     */
    constructor(modalService) {
        this.modalService = modalService;
        /**
         * Classification of the modal.
         */
        this.theme = "default";
        this.ariaLabel = "default";
        /**
         * Controls the visibility of the modal when used directly in a template
         */
        this.open = false;
        /**
         * Specify whether the modal contains scrolling content. This property overrides the automatic
         * detection of the existence of scrolling content. Set this property to `true` to force
         * overflow indicator to show up or to `false` to force overflow indicator to disappear.
         * It is set to `null` by default which indicates not to override automatic detection.
         */
        this.hasScrollingContent = null;
        /**
         * Emits event when click occurs within `n-overlay` element. This is to track click events occurring outside bounds of the `Modal` object.
         */
        this.overlaySelected = new EventEmitter();
        /**
         * To emit the closing event of the modal window.
         */
        this.close = new EventEmitter();
        /**
         * An element should have 'modal-primary-focus' as an attribute to receive initial focus within the `Modal` component.
         */
        this.selectorPrimaryFocus = "[modal-primary-focus]";
    }
    /**
     * Label for the modal.
     *
     * @deprecated since v4
     */
    set modalLabel(value) {
        this.ariaLabel = value;
    }
    get modalLabel() {
        return this.ariaLabel;
    }
    ngOnChanges({ open }) {
        if (open) {
            if (open.currentValue) {
                // `100` is just enough time to allow the modal
                // to become visible, so that we can set focus
                setTimeout(() => this.focusInitialElement(), 100);
            }
            else if (this.trigger) {
                this.trigger.focus();
            }
        }
    }
    /**
     * Set document focus to be on the modal component after it is initialized.
     */
    ngAfterViewInit() {
        this.focusInitialElement();
    }
    /**
     * Handle keyboard events to close modal and tab through the content within the modal.
     */
    handleKeyboardEvent(event) {
        switch (event.key) {
            case "Escape": {
                event.stopImmediatePropagation(); // prevents events being fired for multiple modals if more than 2 open
                this.modalService.destroy(); // destroy top (latest) modal
                this.close.emit();
                break;
            }
            case "Tab": {
                cycleTabs(event, this.modal.nativeElement);
                break;
            }
        }
    }
    /**
     * This detects whether or not the modal contains scrolling content.
     *
     * To force trigger a detection (ie. on window resize), change or reset the value of the modal content.
     *
     * Use the `hasScrollingContent` input to manually override the overflow indicator.
     */
    get shouldShowScrollbar() {
        const modalContent = this.modal ? this.modal.nativeElement.querySelector(".bx--modal-content") : null;
        if (modalContent) {
            const modalContentHeight = modalContent.getBoundingClientRect().height;
            const modalContentScrollHeight = modalContent.scrollHeight;
            return modalContentScrollHeight > modalContentHeight;
        }
        else {
            return false;
        }
    }
    focusInitialElement() {
        const primaryFocusElement = this.modal.nativeElement.querySelector(this.selectorPrimaryFocus);
        if (primaryFocusElement && primaryFocusElement.focus) {
            setTimeout(() => primaryFocusElement.focus());
        }
        else if (getFocusElementList(this.modal.nativeElement).length > 0) {
            setTimeout(() => getFocusElementList(this.modal.nativeElement)[0].focus());
        }
        else {
            setTimeout(() => this.modal.nativeElement.focus());
        }
    }
}
Modal.ɵfac = function Modal_Factory(t) { return new (t || Modal)(ɵngcc0.ɵɵdirectiveInject(ModalService)); };
Modal.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: Modal, selectors: [["ibm-modal"]], viewQuery: function Modal_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c2, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.modal = _t.first);
    } }, hostBindings: function Modal_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function Modal_keydown_HostBindingHandler($event) { return ctx.handleKeyboardEvent($event); });
    } }, inputs: { theme: "theme", ariaLabel: "ariaLabel", open: "open", hasScrollingContent: "hasScrollingContent", modalLabel: "modalLabel", size: "size", trigger: "trigger" }, outputs: { overlaySelected: "overlaySelected", close: "close" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c1, decls: 5, vars: 9, consts: [[3, "theme", "open", "overlaySelect"], ["role", "dialog", "aria-modal", "true", 1, "bx--modal-container", 2, "z-index", "1", 3, "ngClass"], ["modal", ""], ["class", "bx--modal-content--overflow-indicator", 4, "ngIf"], [1, "bx--modal-content--overflow-indicator"]], template: function Modal_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "ibm-overlay", 0);
        ɵngcc0.ɵɵlistener("overlaySelect", function Modal_Template_ibm_overlay_overlaySelect_0_listener() { return ctx.overlaySelected.emit(); });
        ɵngcc0.ɵɵelementStart(1, "div", 1, 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵtemplate(4, Modal_div_4_Template, 1, 0, "div", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("theme", ctx.theme)("open", ctx.open);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction3(5, _c3, ctx.size === "xs", ctx.size === "sm", ctx.size === "lg"));
        ɵngcc0.ɵɵattribute("aria-label", ctx.ariaLabel);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasScrollingContent !== null ? ctx.hasScrollingContent : ctx.shouldShowScrollbar);
    } }, directives: function () { return [Overlay, ɵngcc1.NgClass, ɵngcc1.NgIf]; }, encapsulation: 2 });
/** @nocollapse */
Modal.ctorParameters = () => [
    { type: ModalService }
];
Modal.propDecorators = {
    size: [{ type: Input }],
    theme: [{ type: Input }],
    modalLabel: [{ type: Input }],
    ariaLabel: [{ type: Input }],
    open: [{ type: Input }],
    trigger: [{ type: Input }],
    hasScrollingContent: [{ type: Input }],
    overlaySelected: [{ type: Output }],
    close: [{ type: Output }],
    modal: [{ type: ViewChild, args: ["modal", { static: true },] }],
    handleKeyboardEvent: [{ type: HostListener, args: ["keydown", ["$event"],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Modal, [{
        type: Component,
        args: [{
                selector: "ibm-modal",
                template: `
		<ibm-overlay
			[theme]="theme"
			[open]="open"
			(overlaySelect)="overlaySelected.emit()">
			<div
				class="bx--modal-container"
				[ngClass]="{
					'bx--modal-container--xs': size === 'xs',
					'bx--modal-container--sm': size === 'sm',
					'bx--modal-container--lg': size === 'lg'
				}"
				role="dialog"
				aria-modal="true"
				style="z-index:1;"
				[attr.aria-label]="ariaLabel"
				#modal>
				<ng-content></ng-content>
				<div
					*ngIf="hasScrollingContent !== null ? hasScrollingContent : shouldShowScrollbar"
					class="bx--modal-content--overflow-indicator">
				</div>
			</div>
		</ibm-overlay>
	`
            }]
    }], function () { return [{ type: ModalService }]; }, { theme: [{
            type: Input
        }], ariaLabel: [{
            type: Input
        }], open: [{
            type: Input
        }], hasScrollingContent: [{
            type: Input
        }], overlaySelected: [{
            type: Output
        }], close: [{
            type: Output
        }], modalLabel: [{
            type: Input
        }], 
    /**
     * Handle keyboard events to close modal and tab through the content within the modal.
     */
    handleKeyboardEvent: [{
            type: HostListener,
            args: ["keydown", ["$event"]]
        }], size: [{
            type: Input
        }], trigger: [{
            type: Input
        }], modal: [{
            type: ViewChild,
            args: ["modal", { static: true }]
        }] }); })();

/**
 * Component for the overlay object that acts as a backdrop to the `Modal` component.
 *
 * The main purpose for this component is to be able to handle click events that fall outside
 * the bounds of the `Modal` component.
 */
class Overlay {
    constructor() {
        /**
         * Classification of the modal.
         */
        this.theme = "default";
        this.open = false;
        /**
         * To emit the event where the user selects the overlay behind the `Modal`.
         */
        this.overlaySelect = new EventEmitter();
    }
    /**
     * Handles the user clicking on the `Overlay` which resides outside the `Modal` object.
     */
    overlayClick(event) {
        if (event.target !== this.overlay.nativeElement) {
            return;
        }
        event.stopPropagation();
        this.overlaySelect.emit(event);
    }
}
Overlay.ɵfac = function Overlay_Factory(t) { return new (t || Overlay)(); };
Overlay.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: Overlay, selectors: [["ibm-overlay"]], viewQuery: function Overlay_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c4, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.overlay = _t.first);
    } }, inputs: { theme: "theme", open: "open" }, outputs: { overlaySelect: "overlaySelect" }, ngContentSelectors: _c1, decls: 3, vars: 4, consts: [[1, "bx--modal", "bx--modal-tall", 3, "ngClass", "click"], ["overlay", ""]], template: function Overlay_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "section", 0, 1);
        ɵngcc0.ɵɵlistener("click", function Overlay_Template_section_click_0_listener($event) { return ctx.overlayClick($event); });
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(1, _c5, ctx.theme === "danger", ctx.open));
    } }, directives: [ɵngcc1.NgClass], encapsulation: 2 });
Overlay.propDecorators = {
    theme: [{ type: Input }],
    open: [{ type: Input }],
    overlaySelect: [{ type: Output }],
    overlay: [{ type: ViewChild, args: ["overlay", { static: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Overlay, [{
        type: Component,
        args: [{
                selector: "ibm-overlay",
                template: `
		<section
			class="bx--modal bx--modal-tall"
			[ngClass]="{
				'bx--modal--danger': theme === 'danger',
				'is-visible': open
			}"
			(click)="overlayClick($event)"
			#overlay>
			<ng-content></ng-content>
		</section>
	`
            }]
    }], function () { return []; }, { theme: [{
            type: Input
        }], open: [{
            type: Input
        }], overlaySelect: [{
            type: Output
        }], overlay: [{
            type: ViewChild,
            args: ["overlay", { static: true }]
        }] }); })();

class ModalContent {
    constructor() {
        this.modalContentClass = true;
        /**
         * Provide whether the modal content has a form element.
         * If `true` is used here, non-form child content should have `bx--modal-content__regular-content` class.
         */
        this.hasForm = false;
    }
}
ModalContent.ɵfac = function ModalContent_Factory(t) { return new (t || ModalContent)(); };
ModalContent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ModalContent, selectors: [["", "ibmModalContent", ""]], hostVars: 4, hostBindings: function ModalContent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--modal-content", ctx.modalContentClass)("bx--modal-content--with-form", ctx.hasForm);
    } }, inputs: { hasForm: "hasForm" } });
ModalContent.propDecorators = {
    modalContentClass: [{ type: HostBinding, args: ["class.bx--modal-content",] }],
    hasForm: [{ type: HostBinding, args: ["class.bx--modal-content--with-form",] }, { type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ModalContent, [{
        type: Directive,
        args: [{
                selector: "[ibmModalContent]"
            }]
    }], function () { return []; }, { modalContentClass: [{
            type: HostBinding,
            args: ["class.bx--modal-content"]
        }], hasForm: [{
            type: HostBinding,
            args: ["class.bx--modal-content--with-form"]
        }, {
            type: Input
        }] }); })();

class ModalContentText {
    constructor() {
        this.modalContentTextClass = true;
    }
}
ModalContentText.ɵfac = function ModalContentText_Factory(t) { return new (t || ModalContentText)(); };
ModalContentText.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ModalContentText, selectors: [["", "ibmModalContentText", ""]], hostVars: 2, hostBindings: function ModalContentText_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--modal-content__text", ctx.modalContentTextClass);
    } } });
ModalContentText.propDecorators = {
    modalContentTextClass: [{ type: HostBinding, args: ["class.bx--modal-content__text",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ModalContentText, [{
        type: Directive,
        args: [{
                selector: "[ibmModalContentText]"
            }]
    }], function () { return []; }, { modalContentTextClass: [{
            type: HostBinding,
            args: ["class.bx--modal-content__text"]
        }] }); })();

class ModalHeaderHeading {
    constructor() {
        this.modalHeaderHeadingClass = true;
    }
}
ModalHeaderHeading.ɵfac = function ModalHeaderHeading_Factory(t) { return new (t || ModalHeaderHeading)(); };
ModalHeaderHeading.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ModalHeaderHeading, selectors: [["", "ibmModalHeaderHeading", ""]], hostVars: 2, hostBindings: function ModalHeaderHeading_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--modal-header__heading", ctx.modalHeaderHeadingClass);
    } } });
ModalHeaderHeading.propDecorators = {
    modalHeaderHeadingClass: [{ type: HostBinding, args: ["class.bx--modal-header__heading",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ModalHeaderHeading, [{
        type: Directive,
        args: [{
                selector: "[ibmModalHeaderHeading]"
            }]
    }], function () { return []; }, { modalHeaderHeadingClass: [{
            type: HostBinding,
            args: ["class.bx--modal-header__heading"]
        }] }); })();

class ModalHeaderLabel {
    constructor() {
        this.modalHeaderLabelClass = true;
    }
}
ModalHeaderLabel.ɵfac = function ModalHeaderLabel_Factory(t) { return new (t || ModalHeaderLabel)(); };
ModalHeaderLabel.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ModalHeaderLabel, selectors: [["", "ibmModalHeaderLabel", ""]], hostVars: 2, hostBindings: function ModalHeaderLabel_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--modal-header__label", ctx.modalHeaderLabelClass);
    } } });
ModalHeaderLabel.propDecorators = {
    modalHeaderLabelClass: [{ type: HostBinding, args: ["class.bx--modal-header__label",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ModalHeaderLabel, [{
        type: Directive,
        args: [{
                selector: "[ibmModalHeaderLabel]"
            }]
    }], function () { return []; }, { modalHeaderLabelClass: [{
            type: HostBinding,
            args: ["class.bx--modal-header__label"]
        }] }); })();

// modules
class ModalModule {
}
ModalModule.ɵfac = function ModalModule_Factory(t) { return new (t || ModalModule)(); };
ModalModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ModalModule });
ModalModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [ModalService], imports: [[
            CommonModule,
            ButtonModule,
            I18nModule,
            PlaceholderModule,
            ExperimentalModule,
            IconModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ModalModule, { declarations: function () { return [AlertModal, Modal, ModalHeader, ModalFooter, Overlay, ModalContent, ModalContentText, ModalHeaderHeading, ModalHeaderLabel, BaseModal]; }, imports: function () { return [CommonModule,
        ButtonModule,
        I18nModule,
        PlaceholderModule,
        ExperimentalModule,
        IconModule]; }, exports: function () { return [AlertModal, Modal, ModalHeader, ModalFooter, ModalContent, ModalContentText, ModalHeaderHeading, ModalHeaderLabel, BaseModal]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ModalModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    AlertModal,
                    Modal,
                    ModalHeader,
                    ModalFooter,
                    Overlay,
                    ModalContent,
                    ModalContentText,
                    ModalHeaderHeading,
                    ModalHeaderLabel,
                    BaseModal
                ],
                exports: [
                    AlertModal,
                    Modal,
                    ModalHeader,
                    ModalFooter,
                    ModalContent,
                    ModalContentText,
                    ModalHeaderHeading,
                    ModalHeaderLabel,
                    BaseModal
                ],
                entryComponents: [
                    AlertModal,
                    Modal,
                    ModalFooter,
                    ModalHeader
                ],
                providers: [ModalService],
                imports: [
                    CommonModule,
                    ButtonModule,
                    I18nModule,
                    PlaceholderModule,
                    ExperimentalModule,
                    IconModule
                ]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { AlertModal, AlertModalType, ModalButtonType, BaseModal, ModalFooter, ModalHeader, Modal, ModalModule, ModalService, Overlay, ModalContent, ModalContentText, ModalHeaderHeading, ModalHeaderLabel };

//# sourceMappingURL=carbon-components-angular-modal.js.map