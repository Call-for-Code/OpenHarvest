/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-experimental.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Injectable, NgModule, SkipSelf, Optional } from '@angular/core';

import * as ɵngcc0 from '@angular/core';
class ExperimentalService {
    constructor() {
        /**
         * Map to hold all our experiments
         */
        this.experiments = new Map();
    }
    /**
     * Adds an experiment if it doesn't exist.
     */
    addExperiment(name, options = { enabled: false }) {
        if (!this.experiments.has(name)) {
            this.experiments.set(name, options);
        }
    }
    /**
     * Enables an experiment by name
     * @param name name of the experiment to enable
     */
    enableExperiment(name) {
        const experiment = this.getExperiment(name);
        experiment.enabled = true;
    }
    /**
     * Disables an experiment by name
     * @param name name of the experiment to disable
     */
    disableExperiment(name) {
        const experiment = this.getExperiment(name);
        experiment.enabled = false;
    }
    /**
     * Get the options for an experiment by name
     * @param name name of experiment to get
     */
    getExperiment(name) {
        if (!this.experiments.has(name)) {
            this.addExperiment(name);
            return this.getExperiment(name);
        }
        return this.experiments.get(name);
    }
    /**
     * Get an array of tuples representing an experiment and it's options
     */
    getExperiments() {
        return Array.from(this.experiments.entries());
    }
}
ExperimentalService.ɵfac = function ExperimentalService_Factory(t) { return new (t || ExperimentalService)(); };
ExperimentalService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ExperimentalService, factory: ExperimentalService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExperimentalService, [{
        type: Injectable
    }], function () { return []; }, null); })();

// either provides a new instance of ExperimentalService, or returns the parent
function EXPERIMENTAL_SERVICE_PROVIDER_FACTORY(parentService) {
    return parentService || new ExperimentalService();
}
const EXPERIMENTAL_SERVICE_PROVIDER = {
    provide: ExperimentalService,
    deps: [[new Optional(), new SkipSelf(), ExperimentalService]],
    useFactory: EXPERIMENTAL_SERVICE_PROVIDER_FACTORY
};
class ExperimentalModule {
}
ExperimentalModule.ɵfac = function ExperimentalModule_Factory(t) { return new (t || ExperimentalModule)(); };
ExperimentalModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ExperimentalModule });
ExperimentalModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [
        ExperimentalService,
        EXPERIMENTAL_SERVICE_PROVIDER
    ] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExperimentalModule, [{
        type: NgModule,
        args: [{
                providers: [
                    ExperimentalService,
                    EXPERIMENTAL_SERVICE_PROVIDER
                ]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { EXPERIMENTAL_SERVICE_PROVIDER_FACTORY, EXPERIMENTAL_SERVICE_PROVIDER, ExperimentalModule, ExperimentalService };

//# sourceMappingURL=carbon-components-angular-experimental.js.map