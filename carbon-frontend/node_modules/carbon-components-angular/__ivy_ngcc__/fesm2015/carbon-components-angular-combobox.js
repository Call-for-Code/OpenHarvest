/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-combobox.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { filter } from 'rxjs/operators';
import { Component, ContentChild, Input, Output, HostListener, ElementRef, ViewChild, EventEmitter, HostBinding, TemplateRef, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { AbstractDropdownView, DropdownService, DropdownModule } from 'carbon-components-angular/dropdown';
import { I18n, I18nModule } from 'carbon-components-angular/i18n';
import { DocumentService, hasScrollableParents, UtilsModule } from 'carbon-components-angular/utils';
import { IconModule } from 'carbon-components-angular/icon';

/**
 * ComboBoxes are similar to dropdowns, except a combobox provides an input field for users to search items and (optionally) add their own.
 * Multi-select comboboxes also provide "pills" of selected items.
 *
 * [See demo](../../?path=/story/combobox--basic)
 *
 * <example-url>../../iframe.html?id=combobox--basic</example-url>
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from 'carbon-components-angular/utils';
import * as ɵngcc2 from 'carbon-components-angular/dropdown';
import * as ɵngcc3 from 'carbon-components-angular/i18n';
import * as ɵngcc4 from '@angular/common';
import * as ɵngcc5 from 'carbon-components-angular/icon';

const _c0 = ["dropdownMenu"];
const _c1 = ["input"];
const _c2 = ["listbox"];
function ComboBox_label_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r10.label);
} }
function ComboBox_label_0_2_ng_template_0_Template(rf, ctx) { }
function ComboBox_label_0_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ComboBox_label_0_2_ng_template_0_Template, 0, 0, "ng-template", 15);
} if (rf & 2) {
    const ctx_r11 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r11.label);
} }
const _c3 = function (a0) { return { "bx--label--disabled": a0 }; };
function ComboBox_label_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 14);
    ɵngcc0.ɵɵtemplate(1, ComboBox_label_0_ng_container_1_Template, 2, 1, "ng-container", 11);
    ɵngcc0.ɵɵtemplate(2, ComboBox_label_0_2_Template, 1, 1, undefined, 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("for", ctx_r0.id)("ngClass", ɵngcc0.ɵɵpureFunction1(4, _c3, ctx_r0.disabled));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.label));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.label));
} }
function ComboBox_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r14 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 16);
    ɵngcc0.ɵɵlistener("click", function ComboBox_button_4_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r14); const ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.clearSelected(); })("blur", function ComboBox_button_4_Template_button_blur_0_listener() { ɵngcc0.ɵɵrestoreView(_r14); const ctx_r15 = ɵngcc0.ɵɵnextContext(); return ctx_r15.onBlur(); })("keydown.enter", function ComboBox_button_4_Template_button_keydown_enter_0_listener() { ɵngcc0.ɵɵrestoreView(_r14); const ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.clearSelected(); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(2, "svg", 17);
    ɵngcc0.ɵɵelement(3, "path", 18);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("title", ctx_r2.clearSelectionsTitle);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r2.clearSelectionAria);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r2.pills.length, " ");
} }
function ComboBox__svg_svg_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 19);
} }
function ComboBox_div_8_Template(rf, ctx) { if (rf & 1) {
    const _r18 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 20);
    ɵngcc0.ɵɵlistener("keyup.enter", function ComboBox_div_8_Template_div_keyup_enter_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r18); const ctx_r17 = ɵngcc0.ɵɵnextContext(); return ctx_r17.clearInput($event); })("click", function ComboBox_div_8_Template_div_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r18); const ctx_r19 = ɵngcc0.ɵɵnextContext(); return ctx_r19.clearInput($event); })("blur", function ComboBox_div_8_Template_div_blur_0_listener() { ɵngcc0.ɵɵrestoreView(_r18); const ctx_r20 = ɵngcc0.ɵɵnextContext(); return ctx_r20.onBlur(); });
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(1, "svg", 21);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("title", ctx_r5.clearSelectionTitle);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r5.clearSelectionAria);
} }
function ComboBox_ng_content_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 0, ["*ngIf", "open"]);
} }
function ComboBox_div_13_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r21 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r21.helperText);
} }
function ComboBox_div_13_2_ng_template_0_Template(rf, ctx) { }
function ComboBox_div_13_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ComboBox_div_13_2_ng_template_0_Template, 0, 0, "ng-template", 15);
} if (rf & 2) {
    const ctx_r22 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r22.helperText);
} }
const _c4 = function (a0) { return { "bx--form__helper-text--disabled": a0 }; };
function ComboBox_div_13_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 22);
    ɵngcc0.ɵɵtemplate(1, ComboBox_div_13_ng_container_1_Template, 2, 1, "ng-container", 11);
    ɵngcc0.ɵɵtemplate(2, ComboBox_div_13_2_Template, 1, 1, undefined, 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(3, _c4, ctx_r8.disabled));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r8.isTemplate(ctx_r8.helperText));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r8.isTemplate(ctx_r8.helperText));
} }
function ComboBox_div_14_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r24 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r24.invalidText);
} }
function ComboBox_div_14_2_ng_template_0_Template(rf, ctx) { }
function ComboBox_div_14_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, ComboBox_div_14_2_ng_template_0_Template, 0, 0, "ng-template", 15);
} if (rf & 2) {
    const ctx_r25 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r25.invalidText);
} }
function ComboBox_div_14_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 23);
    ɵngcc0.ɵɵtemplate(1, ComboBox_div_14_ng_container_1_Template, 2, 1, "ng-container", 11);
    ɵngcc0.ɵɵtemplate(2, ComboBox_div_14_2_Template, 1, 1, undefined, 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r9.isTemplate(ctx_r9.invalidText));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r9.isTemplate(ctx_r9.invalidText));
} }
const _c5 = function (a0, a1, a2, a3, a4, a5, a6) { return { "bx--multi-select": a0, "bx--combo-box": a1, "bx--list-box--light": a2, "bx--list-box--expanded": a3, "bx--list-box--sm": a4, "bx--list-box--xl": a5, "bx--list-box--disabled": a6 }; };
const _c6 = function (a0) { return { "bx--text-input--empty": a0 }; };
const _c7 = function (a0) { return { "bx--list-box__menu-icon--open": a0 }; };
const _c8 = ["*"];
class ComboBox {
    /**
     * Creates an instance of ComboBox.
     */
    constructor(elementRef, documentService, dropdownService, i18n) {
        this.elementRef = elementRef;
        this.documentService = documentService;
        this.dropdownService = dropdownService;
        this.i18n = i18n;
        this.id = `dropdown-${ComboBox.comboBoxCount++}`;
        /**
         * List of items to fill the content with.
         *
         * **Example:**
         * ```javascript
         * items = [
         *		{
         *			content: "Abacus",
         *			selected: false
         *		},
         *		{
         *			content: "Byte",
         *			selected: false,
         *		},
         *		{
         *			content: "Computer",
         *			selected: false
         *		},
         *		{
         *			content: "Digital",
         *			selected: false
         *		}
         * ];
         * ```
         *
         */
        this.items = [];
        /**
         * Combo box type (supporting single or multi selection of items).
         */
        this.type = "single";
        /**
         * Combo box render size.
         *
         * @deprecated since v4
         */
        this.size = "md";
        /**
         * set to `true` to place the dropdown view inline with the component
         */
        this.appendInline = null;
        /**
         * Set to `true` for invalid state.
         */
        this.invalid = false;
        /**
         * Max length value to limit input characters
         */
        this.maxLength = null;
        /**
         * `light` or `dark` dropdown theme
         */
        this.theme = "dark";
        /**
         * Specify feedback (mode) of the selection.
         * `top`: selected item jumps to top
         * `fixed`: selected item stays at its position
         * `top-after-reopen`: selected item jump to top after reopen dropdown
         */
        this.selectionFeedback = "top-after-reopen";
        /**
         * Specify autocomplete attribute of text input
         */
        this.autocomplete = "list";
        /**
         * Set to `true` to disable combobox.
         */
        this.disabled = false;
        /**
         * Emits a ListItem
         *
         * Example:
         * ```javascript
         * {
         * 		content: "one",
         * 		selected: true
         * }
         * ```
         */
        this.selected = new EventEmitter();
        /**
         * Intended to be used to add items to the list.
         *
         * Emits an event that includes the current item list, the suggested index for the new item, and a simple ListItem
         *
         * Example:
         * ```javascript
         *	{
         *		items: [{content: "one", selected: true}, {content: "two", selected: true}],
         *		index: 1,
         *		value: {
         *			content: "some user string",
         *			selected: false
         *		}
         *	}
         * ```
         *
         *
         * Example:
         * ```javascript
         * {
         *	after: 1,
         *	value: "some user string"
         * }
         * ```
         */
        this.submit = new EventEmitter();
        /** emits an empty event when the menu is closed */
        this.close = new EventEmitter();
        /** emits the search string from the input */
        this.search = new EventEmitter();
        this.hostClass = true;
        // @HostBinding("attr.role") role = "combobox";
        this.display = "block";
        this.open = false;
        this.showClearButton = false;
        /** Selected items for multi-select combo-boxes. */
        this.pills = [];
        /** used to update the displayValue */
        this.selectedValue = "";
        this.keyboardNav = this._keyboardNav.bind(this);
        this.noop = this._noop.bind(this);
        this.onTouchedCallback = this._noop;
        this.propagateChangeCallback = this._noop;
        this._placeholder = this.i18n.getOverridable("COMBOBOX.PLACEHOLDER");
        this._closeMenuAria = this.i18n.getOverridable("COMBOBOX.A11Y.CLOSE_MENU");
        this._openMenuAria = this.i18n.getOverridable("COMBOBOX.A11Y.OPEN_MENU");
        this._clearSelectionsTitle = this.i18n.getOverridable("COMBOBOX.CLEAR_SELECTIONS");
        this._clearSelectionsAria = this.i18n.getOverridable("COMBOBOX.A11Y.CLEAR_SELECTIONS");
        this._clearSelectionTitle = this.i18n.getOverridable("COMBOBOX.CLEAR_SELECTED");
        this._clearSelectionAria = this.i18n.getOverridable("COMBOBOX.A11Y.CLEAR_SELECTED");
    }
    /**
     * Text to show when nothing is selected.
     */
    set placeholder(value) {
        this._placeholder.override(value);
    }
    get placeholder() {
        return this._placeholder.value;
    }
    /**
     * Value to display for accessibility purposes on the combobox control menu when closed
     */
    set openMenuAria(value) {
        this._openMenuAria.override(value);
    }
    get openMenuAria() {
        return this._openMenuAria.value;
    }
    /**
     * Value to display for accessibility purposes on the combobox control menu when opened
     */
    set closeMenuAria(value) {
        this._closeMenuAria.override(value);
    }
    get closeMenuAria() {
        return this._closeMenuAria.value;
    }
    /**
     * Value to display on the clear selections icon, when multi is selected
     */
    set clearSelectionsTitle(value) {
        this._clearSelectionsTitle.override(value);
    }
    get clearSelectionsTitle() {
        return this._clearSelectionsTitle.value;
    }
    /**
     * Value to display for accessibility purposes to clear selections, when multi is selected
     */
    set clearSelectionsAria(value) {
        this._clearSelectionsAria.override(value);
    }
    get clearSelectionsAria() {
        return this._clearSelectionsAria.value;
    }
    /**
     * Value to display on the clear the selected item icon, when single is selected
     */
    set clearSelectionTitle(value) {
        this._clearSelectionTitle.override(value);
    }
    get clearSelectionTitle() {
        return this._clearSelectionTitle.value;
    }
    /**
     * Value to display for accessibility purposes on the clear the selected item icon, when single is selected
     */
    set clearSelectionAria(value) {
        this._clearSelectionAria.override(value);
    }
    get clearSelectionAria() {
        return this._clearSelectionAria.value;
    }
    /**
     * Lifecycle hook.
     * Updates pills if necessary.
     *
     */
    ngOnChanges(changes) {
        if (changes.items) {
            this.view.items = changes.items.currentValue;
            // If new items are added into the combobox while there is search input,
            // repeat the search.
            this.onSearch(this.input.nativeElement.value, false);
            this.updateSelected();
        }
    }
    /**
     * Sets initial state that depends on child components
     * Subscribes to select events and handles focus/filtering/initial list updates
     */
    ngAfterContentInit() {
        if (this.view) {
            this.view.type = this.type;
            this.view.select.subscribe(event => {
                if (this.type === "multi") {
                    this.updatePills();
                    if (this.itemValueKey && this.view.getSelected()) {
                        const values = this.view.getSelected().map(item => item[this.itemValueKey]);
                        this.propagateChangeCallback(values);
                        // otherwise just pass up the values from `getSelected`
                    }
                    else {
                        this.propagateChangeCallback(this.view.getSelected());
                    }
                }
                else {
                    if (event.item && event.item.selected) {
                        this.showClearButton = true;
                        this.selectedValue = event.item.content;
                        if (this.itemValueKey) {
                            this.propagateChangeCallback(event.item[this.itemValueKey]);
                        }
                        else {
                            this.propagateChangeCallback(event.item);
                        }
                    }
                    else {
                        this.selectedValue = "";
                        this.propagateChangeCallback(null);
                    }
                    // not guarding these since the nativeElement has to be loaded
                    // for select to even fire
                    // only focus for "organic" selections
                    if (event && !event.isUpdate) {
                        this.elementRef.nativeElement.querySelector("input").focus();
                        this.view.filterBy("");
                    }
                    this.closeDropdown();
                }
                if (event && !event.isUpdate) {
                    this.selected.emit(event);
                }
            });
            // update the rest of combobox with any pre-selected items
            // setTimeout just defers the call to the next check cycle
            setTimeout(() => {
                this.updateSelected();
            });
            this.view.blurIntent.pipe(filter(v => v === "top")).subscribe(() => {
                this.elementRef.nativeElement.querySelector(".bx--text-input").focus();
            });
        }
    }
    /**
     * Binds event handlers against the rendered view
     */
    ngAfterViewInit() {
        this.documentService.handleClick(event => {
            if (!this.elementRef.nativeElement.contains(event.target) &&
                !this.dropdownMenu.nativeElement.contains(event.target)) {
                if (this.open) {
                    this.closeDropdown();
                }
            }
        });
        // if appendInline is default valued (null) we should:
        // 1. if there are scrollable parents (not including body) don't append inline
        //    this should also cover the case where the dropdown is in a modal
        //    (where we _do_ want to append to the placeholder)
        if (this.appendInline === null && hasScrollableParents(this.elementRef.nativeElement)) {
            this.appendInline = false;
            // 2. otherwise we should append inline
        }
        else if (this.appendInline === null) {
            this.appendInline = true;
        }
    }
    /**
     * Removing the `Dropdown` from the body if it is appended to the body.
     */
    ngOnDestroy() {
        if (!this.appendInline) {
            this._appendToDropdown();
        }
    }
    /**
     * Handles `Escape/Tab` key closing the dropdown, and arrow up/down focus to/from the dropdown list.
     */
    hostkeys(ev) {
        if (ev.key === "Escape") {
            this.closeDropdown();
        }
        else if ((ev.key === "ArrowDown" || ev.key === "Down") // `"Down"` is IE specific value
            && (!this.dropdownMenu || !this.dropdownMenu.nativeElement.contains(ev.target))) {
            ev.stopPropagation();
            this.openDropdown();
            setTimeout(() => this.view.getCurrentElement().focus(), 0);
        }
        if (this.open && ev.key === "Tab" &&
            (this.dropdownMenu.nativeElement.contains(ev.target) || ev.target === this.input.nativeElement)) {
            this.closeDropdown();
        }
        if (this.open && ev.key === "Tab" && ev.shiftKey) {
            this.closeDropdown();
        }
    }
    /*
     * no-op method for null event listeners, and other no op calls
     */
    _noop() { }
    /*
     * propagates the value provided from ngModel
     */
    writeValue(value) {
        if (this.type === "single") {
            if (this.itemValueKey) {
                // clone the specified item and update its state
                const newValue = Object.assign({}, this.view.getListItems().find(item => item[this.itemValueKey] === value));
                newValue.selected = true;
                this.view.propagateSelected([newValue]);
            }
            else {
                // all items in propagateSelected must be iterable
                this.view.propagateSelected([value || ""]);
            }
            this.showClearButton = !!(value && this.view.getSelected().length);
        }
        else {
            if (this.itemValueKey) {
                // clone the items and update their state based on the received value array
                // this way we don't lose any additional metadata that may be passed in via the `items` Input
                let newValues = [];
                for (const v of value) {
                    for (const item of this.view.getListItems()) {
                        if (item[this.itemValueKey] === v) {
                            newValues.push(Object.assign({}, item, { selected: true }));
                        }
                    }
                }
                this.view.propagateSelected(newValues);
            }
            else {
                this.view.propagateSelected(value ? value : [""]);
            }
        }
        this.updateSelected();
    }
    onBlur() {
        this.onTouchedCallback();
    }
    registerOnChange(fn) {
        this.propagateChangeCallback = fn;
    }
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * `ControlValueAccessor` method to programmatically disable the combobox.
     *
     * ex: `this.formGroup.get("myCoolCombobox").disable();`
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * Called by `n-pill-input` when the selected pills have changed.
     */
    updatePills() {
        this.pills = this.view.getSelected() || [];
        this.checkForReorder();
    }
    clearSelected() {
        this.items = this.items.map(item => {
            if (!item.disabled) {
                item.selected = false;
            }
            return item;
        });
        this.view.items = this.items;
        this.updatePills();
        // clearSelected can only fire on type=multi
        // so we just emit getSelected() (just in case there's any disabled but selected items)
        const selected = this.view.getSelected();
        this.propagateChangeCallback(selected);
        this.selected.emit(selected);
    }
    /**
     * Closes the dropdown and emits the close event.
     */
    closeDropdown() {
        this.open = false;
        this.checkForReorder();
        this.close.emit();
        if (!this.appendInline) {
            this._appendToDropdown();
        }
    }
    /**
     * Opens the dropdown.
     */
    openDropdown() {
        if (this.disabled) {
            return;
        }
        this.open = true;
        if (!this.appendInline) {
            this._appendToBody();
        }
    }
    /**
     * Toggles the dropdown.
     */
    toggleDropdown() {
        if (this.open) {
            this.closeDropdown();
        }
        else {
            this.openDropdown();
        }
    }
    /**
     * Sets the list group filter, and manages single select item selection.
     */
    onSearch(searchString, shouldEmitSearch = true) {
        if (shouldEmitSearch) {
            this.search.emit(searchString);
        }
        this.showClearButton = !!searchString;
        this.view.filterBy(searchString);
        if (searchString !== "") {
            this.openDropdown();
        }
        else {
            this.selectedValue = "";
            if (this.type === "multi" &&
                (this.selectionFeedback === "top" || this.selectionFeedback === "top-after-reopen")) {
                this.view.reorderSelected();
            }
        }
        if (this.type === "single") {
            // deselect if the input doesn't match the content
            // of any given item
            const matches = this.view.getListItems().some(item => item.content.toLowerCase().includes(searchString.toLowerCase()));
            if (!matches) {
                const selected = this.view.getSelected();
                if (!selected || !selected[0]) {
                    this.view.filterBy("");
                }
            }
        }
    }
    /**
     * Intended to be used to add items to the list.
     */
    onSubmit(event) {
        this.submit.emit({
            items: this.view.getListItems(),
            index: 0,
            value: {
                content: event.target.value,
                selected: false
            }
        });
    }
    clearInput(event) {
        event.stopPropagation();
        event.preventDefault();
        if (this.type === "single") { // don't want to clear selected or close if multi
            this.clearSelected();
            this.closeDropdown();
        }
        this.selectedValue = "";
        this.input.nativeElement.value = "";
        this.showClearButton = false;
        this.input.nativeElement.focus();
        this.onSearch(this.input.nativeElement.value);
    }
    isTemplate(value) {
        return value instanceof TemplateRef;
    }
    /**
     * Handles keyboard events so users are controlling the `Dropdown` instead of unintentionally controlling outside elements.
     */
    _keyboardNav(event) {
        // "Esc" is an IE specific value
        if ((event.key === "Escape" || event.key === "Esc") && this.open) {
            event.stopImmediatePropagation(); // don't unintentionally close modal if inside of it
        }
        if (event.key === "Escape" || event.key === "Esc") {
            event.preventDefault();
            this.closeDropdown();
            this.input.nativeElement.focus();
        }
        else if (this.open && event.key === "Tab") {
            // this way focus will start on the next focusable item from the dropdown
            // not the top of the body!
            this.input.nativeElement.focus();
            this.input.nativeElement.dispatchEvent(new KeyboardEvent("keydown", { bubbles: true, cancelable: true, key: "Tab" }));
            this.closeDropdown();
        }
    }
    /**
     * Creates the `Dropdown` list as an element that is appended to the DOM body.
     */
    _appendToBody() {
        this.dropdownService.appendToBody(this.listbox.nativeElement, this.dropdownMenu.nativeElement, `${this.elementRef.nativeElement.className}${this.open ? " bx--list-box--expanded" : ""}`);
        this.dropdownMenu.nativeElement.addEventListener("keydown", this.keyboardNav, true);
    }
    /**
     * Creates the `Dropdown` list appending it to the dropdown parent object instead of the body.
     */
    _appendToDropdown() {
        this.dropdownService.appendToDropdown(this.elementRef.nativeElement);
        this.dropdownMenu.nativeElement.removeEventListener("keydown", this.keyboardNav, true);
    }
    updateSelected() {
        const selected = this.view.getSelected();
        if (this.type === "multi") {
            this.updatePills();
        }
        else if (selected) {
            const value = selected[0] ? selected[0].content : "";
            const changeCallbackValue = selected[0] ? selected[0] : "";
            this.selectedValue = value;
            this.showClearButton = !!value;
        }
    }
    checkForReorder() {
        const topAfterReopen = !this.open && this.selectionFeedback === "top-after-reopen";
        if ((this.type === "multi") && (topAfterReopen || this.selectionFeedback === "top")) {
            this.view.reorderSelected(this.selectionFeedback === "top");
        }
    }
}
ComboBox.ɵfac = function ComboBox_Factory(t) { return new (t || ComboBox)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.DocumentService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.DropdownService), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.I18n)); };
ComboBox.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ComboBox, selectors: [["ibm-combo-box"]], contentQueries: function ComboBox_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, AbstractDropdownView, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.view = _t.first);
    } }, viewQuery: function ComboBox_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 1);
        ɵngcc0.ɵɵviewQuery(_c1, 3);
        ɵngcc0.ɵɵviewQuery(_c2, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropdownMenu = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.listbox = _t.first);
    } }, hostVars: 5, hostBindings: function ComboBox_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function ComboBox_keydown_HostBindingHandler($event) { return ctx.hostkeys($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-disabled", ctx.disabled);
        ɵngcc0.ɵɵstyleProp("display", ctx.display);
        ɵngcc0.ɵɵclassProp("bx--list-box__wrapper", ctx.hostClass);
    } }, inputs: { id: "id", items: "items", type: "type", size: "size", appendInline: "appendInline", invalid: "invalid", maxLength: "maxLength", theme: "theme", selectionFeedback: "selectionFeedback", autocomplete: "autocomplete", disabled: "disabled", placeholder: "placeholder", openMenuAria: "openMenuAria", closeMenuAria: "closeMenuAria", clearSelectionsTitle: "clearSelectionsTitle", clearSelectionsAria: "clearSelectionsAria", clearSelectionTitle: "clearSelectionTitle", clearSelectionAria: "clearSelectionAria", itemValueKey: "itemValueKey", label: "label", helperText: "helperText", invalidText: "invalidText" }, outputs: { selected: "selected", submit: "submit", close: "close", search: "search" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: ComboBox,
                multi: true
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c8, decls: 15, vars: 33, consts: [["class", "bx--label", 3, "for", "ngClass", 4, "ngIf"], ["role", "combobox", 1, "bx--combo-box", "bx--list-box", 3, "ngClass", "id"], ["listbox", ""], ["role", "button", "type", "button", "tabindex", "-1", "aria-haspopup", "true", 1, "bx--list-box__field", 3, "click", "blur"], ["type", "button", "class", "bx--tag--filter bx--list-box__selection--multi", 3, "title", "click", "blur", "keydown.enter", 4, "ngIf"], ["type", "text", "role", "searchbox", "tabindex", "0", "aria-haspopup", "true", 1, "bx--text-input", 3, "disabled", "value", "ngClass", "placeholder", "input", "blur", "keydown.enter"], ["input", ""], ["ibmIcon", "warning--filled", "size", "16", "class", "bx--list-box__invalid-icon", 4, "ngIf"], ["role", "button", "class", "bx--list-box__selection", "tabindex", "0", 3, "title", "keyup.enter", "click", "blur", 4, "ngIf"], ["ibmIcon", "chevron--down", "size", "16", 1, "bx--list-box__menu-icon", 3, "ngClass", "title", "ariaLabel"], ["dropdownMenu", ""], [4, "ngIf"], ["class", "bx--form__helper-text", 3, "ngClass", 4, "ngIf"], ["class", "bx--form-requirement", 4, "ngIf"], [1, "bx--label", 3, "for", "ngClass"], [3, "ngTemplateOutlet"], ["type", "button", 1, "bx--tag--filter", "bx--list-box__selection--multi", 3, "title", "click", "blur", "keydown.enter"], ["focusable", "false", "preserveAspectRatio", "xMidYMid meet", "role", "img", "xmlns", "http://www.w3.org/2000/svg", "width", "16", "height", "16", "viewBox", "0 0 16 16", "aria-hidden", "true", 2, "will-change", "transform"], ["d", "M12 4.7l-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8z"], ["ibmIcon", "warning--filled", "size", "16", 1, "bx--list-box__invalid-icon"], ["role", "button", "tabindex", "0", 1, "bx--list-box__selection", 3, "title", "keyup.enter", "click", "blur"], ["ibmIcon", "close", "size", "16"], [1, "bx--form__helper-text", 3, "ngClass"], [1, "bx--form-requirement"]], template: function ComboBox_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, ComboBox_label_0_Template, 3, 6, "label", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1, 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵlistener("click", function ComboBox_Template_div_click_3_listener() { return ctx.toggleDropdown(); })("blur", function ComboBox_Template_div_blur_3_listener() { return ctx.onBlur(); });
        ɵngcc0.ɵɵtemplate(4, ComboBox_button_4_Template, 4, 3, "button", 4);
        ɵngcc0.ɵɵelementStart(5, "input", 5, 6);
        ɵngcc0.ɵɵlistener("input", function ComboBox_Template_input_input_5_listener($event) { return ctx.onSearch($event.target.value); })("blur", function ComboBox_Template_input_blur_5_listener() { return ctx.onBlur(); })("keydown.enter", function ComboBox_Template_input_keydown_enter_5_listener($event) { return ctx.onSubmit($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, ComboBox__svg_svg_7_Template, 1, 0, "svg", 7);
        ɵngcc0.ɵɵtemplate(8, ComboBox_div_8_Template, 2, 2, "div", 8);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(9, "svg", 9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelementStart(10, "div", null, 10);
        ɵngcc0.ɵɵtemplate(12, ComboBox_ng_content_12_Template, 1, 0, "ng-content", 11);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(13, ComboBox_div_13_Template, 3, 5, "div", 12);
        ɵngcc0.ɵɵtemplate(14, ComboBox_div_14_Template, 3, 2, "div", 13);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.label);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction7(21, _c5, ctx.type === "multi", ctx.type === "single" || !ctx.pills.length, ctx.theme === "light", ctx.open, ctx.size === "sm", ctx.size === "xl", ctx.disabled))("id", ctx.id);
        ɵngcc0.ɵɵattribute("data-invalid", ctx.invalid ? true : null);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("aria-expanded", ctx.open);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.type === "multi" && ctx.pills.length > 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled)("value", ctx.selectedValue)("ngClass", ɵngcc0.ɵɵpureFunction1(29, _c6, !ctx.showClearButton))("placeholder", ctx.placeholder);
        ɵngcc0.ɵɵattribute("aria-labelledby", ctx.id)("maxlength", ctx.maxLength)("aria-autocomplete", ctx.autocomplete);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showClearButton);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(31, _c7, ctx.open))("title", ctx.open ? ctx.closeMenuAria : ctx.openMenuAria)("ariaLabel", ctx.open ? ctx.closeMenuAria : ctx.openMenuAria);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.open);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.helperText && !ctx.invalid);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
    } }, directives: [ɵngcc4.NgIf, ɵngcc4.NgClass, ɵngcc5.IconDirective, ɵngcc4.NgTemplateOutlet], encapsulation: 2 });
ComboBox.comboBoxCount = 0;
/** @nocollapse */
ComboBox.ctorParameters = () => [
    { type: ElementRef },
    { type: DocumentService },
    { type: DropdownService },
    { type: I18n }
];
ComboBox.propDecorators = {
    placeholder: [{ type: Input }],
    openMenuAria: [{ type: Input }],
    closeMenuAria: [{ type: Input }],
    clearSelectionsTitle: [{ type: Input }],
    clearSelectionsAria: [{ type: Input }],
    clearSelectionTitle: [{ type: Input }],
    clearSelectionAria: [{ type: Input }],
    id: [{ type: Input }],
    items: [{ type: Input }],
    type: [{ type: Input }],
    size: [{ type: Input }],
    itemValueKey: [{ type: Input }],
    label: [{ type: Input }],
    helperText: [{ type: Input }],
    appendInline: [{ type: Input }],
    invalid: [{ type: Input }],
    invalidText: [{ type: Input }],
    maxLength: [{ type: Input }],
    theme: [{ type: Input }],
    selectionFeedback: [{ type: Input }],
    autocomplete: [{ type: Input }],
    disabled: [{ type: HostBinding, args: ["attr.aria-disabled",] }, { type: Input }],
    selected: [{ type: Output }],
    submit: [{ type: Output }],
    close: [{ type: Output }],
    search: [{ type: Output }],
    view: [{ type: ContentChild, args: [AbstractDropdownView, { static: true },] }],
    dropdownMenu: [{ type: ViewChild, args: ["dropdownMenu", { static: false },] }],
    input: [{ type: ViewChild, args: ["input", { static: true },] }],
    listbox: [{ type: ViewChild, args: ["listbox", { static: true },] }],
    hostClass: [{ type: HostBinding, args: ["class.bx--list-box__wrapper",] }],
    display: [{ type: HostBinding, args: ["style.display",] }],
    hostkeys: [{ type: HostListener, args: ["keydown", ["$event"],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ComboBox, [{
        type: Component,
        args: [{
                selector: "ibm-combo-box",
                template: `
		<label
			*ngIf="label"
			[for]="id"
			class="bx--label"
			[ngClass]="{'bx--label--disabled': disabled}">
			<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
			<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
		</label>
		<div
			#listbox
			[ngClass]="{
				'bx--multi-select': type === 'multi',
				'bx--combo-box': type === 'single' || !pills.length,
				'bx--list-box--light': theme === 'light',
				'bx--list-box--expanded': open,
				'bx--list-box--sm': size === 'sm',
				'bx--list-box--xl': size === 'xl',
				'bx--list-box--disabled': disabled
			}"
			class="bx--combo-box bx--list-box"
			role="combobox"
			[id]="id"
			[attr.data-invalid]="(invalid ? true : null)">
			<div
				[attr.aria-expanded]="open"
				role="button"
				class="bx--list-box__field"
				type="button"
				tabindex="-1"
				aria-haspopup="true"
				(click)="toggleDropdown()"
				(blur)="onBlur()">
				<button
					*ngIf="type === 'multi' && pills.length > 0"
					type="button"
					(click)="clearSelected()"
					(blur)="onBlur()"
					(keydown.enter)="clearSelected()"
					class="bx--tag--filter bx--list-box__selection--multi"
					[title]="clearSelectionsTitle"
					[attr.aria-label]="clearSelectionAria">
					{{ pills.length }}
					<svg
						focusable="false"
						preserveAspectRatio="xMidYMid meet"
						style="will-change: transform;"
						role="img"
						xmlns="http://www.w3.org/2000/svg"
						width="16"
						height="16"
						viewBox="0 0 16 16"
						aria-hidden="true">
						<path d="M12 4.7l-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8z"></path>
					</svg>
				</button>
				<input
					#input
					type="text"
					role="searchbox"
					[disabled]="disabled"
					(input)="onSearch($event.target.value)"
					(blur)="onBlur()"
					(keydown.enter)="onSubmit($event)"
					[value]="selectedValue"
					class="bx--text-input"
					[ngClass]="{'bx--text-input--empty': !showClearButton}"
					tabindex="0"
					[attr.aria-labelledby]="id"
					[attr.maxlength]="maxLength"
					aria-haspopup="true"
					[attr.aria-autocomplete]="autocomplete"
					[placeholder]="placeholder"/>
				<svg
					*ngIf="invalid"
					ibmIcon="warning--filled"
					size="16"
					class="bx--list-box__invalid-icon">
				</svg>
				<div
					*ngIf="showClearButton"
					role="button"
					class="bx--list-box__selection"
					tabindex="0"
					[attr.aria-label]="clearSelectionAria"
					[title]="clearSelectionTitle"
					(keyup.enter)="clearInput($event)"
					(click)="clearInput($event)"
					(blur)="onBlur()">
					<svg ibmIcon="close" size="16"></svg>
				</div>
				<svg
					ibmIcon="chevron--down"
					size="16"
					[ngClass]="{'bx--list-box__menu-icon--open': open}"
					class="bx--list-box__menu-icon"
					[title]="open ? closeMenuAria : openMenuAria"
					[ariaLabel]="open ? closeMenuAria : openMenuAria">
				</svg>
			</div>
			<div #dropdownMenu>
				<ng-content *ngIf="open"></ng-content>
			</div>
		</div>
		<div
			*ngIf="helperText && !invalid"
			class="bx--form__helper-text"
			[ngClass]="{'bx--form__helper-text--disabled': disabled}">
			<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
			<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
		</div>
		<div *ngIf="invalid" class="bx--form-requirement">
			<ng-container *ngIf="!isTemplate(invalidText)">{{ invalidText }}</ng-container>
			<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
		</div>
	`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: ComboBox,
                        multi: true
                    }
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.DocumentService }, { type: ɵngcc2.DropdownService }, { type: ɵngcc3.I18n }]; }, { id: [{
            type: Input
        }], items: [{
            type: Input
        }], type: [{
            type: Input
        }], size: [{
            type: Input
        }], appendInline: [{
            type: Input
        }], invalid: [{
            type: Input
        }], maxLength: [{
            type: Input
        }], theme: [{
            type: Input
        }], selectionFeedback: [{
            type: Input
        }], autocomplete: [{
            type: Input
        }], disabled: [{
            type: HostBinding,
            args: ["attr.aria-disabled"]
        }, {
            type: Input
        }], selected: [{
            type: Output
        }], submit: [{
            type: Output
        }], close: [{
            type: Output
        }], search: [{
            type: Output
        }], hostClass: [{
            type: HostBinding,
            args: ["class.bx--list-box__wrapper"]
        }], display: [{
            type: HostBinding,
            args: ["style.display"]
        }], placeholder: [{
            type: Input
        }], openMenuAria: [{
            type: Input
        }], closeMenuAria: [{
            type: Input
        }], clearSelectionsTitle: [{
            type: Input
        }], clearSelectionsAria: [{
            type: Input
        }], clearSelectionTitle: [{
            type: Input
        }], clearSelectionAria: [{
            type: Input
        }], 
    /**
     * Handles `Escape/Tab` key closing the dropdown, and arrow up/down focus to/from the dropdown list.
     */
    hostkeys: [{
            type: HostListener,
            args: ["keydown", ["$event"]]
        }], itemValueKey: [{
            type: Input
        }], label: [{
            type: Input
        }], helperText: [{
            type: Input
        }], invalidText: [{
            type: Input
        }], view: [{
            type: ContentChild,
            args: [AbstractDropdownView, { static: true }]
        }], dropdownMenu: [{
            type: ViewChild,
            args: ["dropdownMenu", { static: false }]
        }], input: [{
            type: ViewChild,
            args: ["input", { static: true }]
        }], listbox: [{
            type: ViewChild,
            args: ["listbox", { static: true }]
        }] }); })();

class ComboBoxModule {
}
ComboBoxModule.ɵfac = function ComboBoxModule_Factory(t) { return new (t || ComboBoxModule)(); };
ComboBoxModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ComboBoxModule });
ComboBoxModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [DropdownService], imports: [[
            CommonModule,
            DropdownModule,
            I18nModule,
            UtilsModule,
            IconModule
        ], DropdownModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ComboBoxModule, { declarations: function () { return [ComboBox]; }, imports: function () { return [CommonModule,
        DropdownModule,
        I18nModule,
        UtilsModule,
        IconModule]; }, exports: function () { return [ComboBox, DropdownModule]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ComboBoxModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    ComboBox
                ],
                exports: [
                    ComboBox,
                    DropdownModule
                ],
                imports: [
                    CommonModule,
                    DropdownModule,
                    I18nModule,
                    UtilsModule,
                    IconModule
                ],
                providers: [DropdownService]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { ComboBox, ComboBoxModule };

//# sourceMappingURL=carbon-components-angular-combobox.js.map