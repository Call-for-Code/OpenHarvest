/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-notification.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { of, isObservable } from 'rxjs';
import { ButtonModule } from 'carbon-components-angular/button';
import { CommonModule } from '@angular/common';
import { Injectable, ApplicationRef, Directive, HostBinding, Component, Input, Output, EventEmitter, ViewChild, ComponentFactoryResolver, Injector, NgZone, NgModule } from '@angular/core';
import { I18n, I18nModule } from 'carbon-components-angular/i18n';
import { ExperimentalService, ExperimentalModule } from 'carbon-components-angular/experimental';
import { LinkModule } from 'carbon-components-angular/link';
import { IconModule } from 'carbon-components-angular/icon';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from 'carbon-components-angular/i18n';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from 'carbon-components-angular/icon';
import * as ɵngcc4 from 'carbon-components-angular/link';
import * as ɵngcc5 from 'carbon-components-angular/button';
import * as ɵngcc6 from 'carbon-components-angular/experimental';

const _c0 = ["notification"];
function Notification__svg_svg_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 11);
} }
function Notification__svg_svg_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 12);
} }
function Notification__svg_svg_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 13);
} }
function Notification__svg_svg_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 14);
} }
function Notification_p_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "p", 15);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r4.notificationObj.title, ɵngcc0.ɵɵsanitizeHtml);
} }
function Notification_div_7_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "a", 18);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const link_r10 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("href", link_r10.href, ɵngcc0.ɵɵsanitizeUrl);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", link_r10.text, "");
} }
function Notification_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 16);
    ɵngcc0.ɵɵelement(1, "span", 17);
    ɵngcc0.ɵɵtemplate(2, Notification_div_7_ng_container_2_Template, 3, 2, "ng-container", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r5.notificationObj.message, ɵngcc0.ɵɵsanitizeHtml);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r5.notificationObj.links);
} }
function Notification_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function Notification_div_9_Template(rf, ctx) { if (rf & 1) {
    const _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵelementStart(1, "button", 19);
    ɵngcc0.ɵɵlistener("click", function Notification_div_9_Template_button_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); const action_r11 = ctx.$implicit; const ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onClick(action_r11, $event); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const action_r11 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", action_r11.text, " ");
} }
function Notification_button_10_Template(rf, ctx) { if (rf & 1) {
    const _r15 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 20);
    ɵngcc0.ɵɵlistener("click", function Notification_button_10_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r15); const ctx_r14 = ɵngcc0.ɵɵnextContext(); return ctx_r14.onClose(); });
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(2, "svg", 21);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("aria-label", ɵngcc0.ɵɵpipeBind1(1, 1, ctx_r8.notificationObj.closeLabel));
} }
const _c1 = function (a0) { return { $implicit: a0 }; };
function Toast__svg_svg_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 10);
} }
function Toast__svg_svg_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 11);
} }
function Toast__svg_svg_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 12);
} }
function Toast__svg_svg_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 13);
} }
function Toast_h3_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "h3", 14);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r4.notificationObj.title, ɵngcc0.ɵɵsanitizeHtml);
} }
function Toast_div_6_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "a", 18);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const link_r10 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("href", link_r10.href, ɵngcc0.ɵɵsanitizeUrl);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", link_r10.text, "");
} }
function Toast_div_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 15);
    ɵngcc0.ɵɵelement(1, "span", 16);
    ɵngcc0.ɵɵtemplate(2, Toast_div_6_ng_container_2_Template, 3, 2, "ng-container", 17);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r5.notificationObj.subtitle, ɵngcc0.ɵɵsanitizeHtml);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r5.notificationObj.links);
} }
function Toast_p_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "p", 19);
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r6.notificationObj.caption, ɵngcc0.ɵɵsanitizeHtml);
} }
function Toast_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function Toast_button_9_Template(rf, ctx) { if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 20);
    ɵngcc0.ɵɵlistener("click", function Toast_button_9_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onClose(); });
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(1, "svg", 21);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("aria-label", ctx_r8.notificationObj.closeLabel);
} }
class NotificationDisplayService {
    constructor(applicationRef) {
        this.applicationRef = applicationRef;
    }
    /**
     * Programatically closes notification based on `notificationRef`.	 *
     */
    close(notificationRef) {
        if (notificationRef.hostView) {
            setTimeout(() => {
                this.applicationRef.detachView(notificationRef.hostView);
                notificationRef.destroy();
            }, 200);
        }
    }
}
NotificationDisplayService.ɵfac = function NotificationDisplayService_Factory(t) { return new (t || NotificationDisplayService)(ɵngcc0.ɵɵinject(ɵngcc0.ApplicationRef)); };
NotificationDisplayService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NotificationDisplayService, factory: NotificationDisplayService.ɵfac });
/** @nocollapse */
NotificationDisplayService.ctorParameters = () => [
    { type: ApplicationRef }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NotificationDisplayService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.ApplicationRef }]; }, null); })();

class NotificationSubtitle {
    constructor() {
        this.baseClass = true;
    }
}
NotificationSubtitle.ɵfac = function NotificationSubtitle_Factory(t) { return new (t || NotificationSubtitle)(); };
NotificationSubtitle.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NotificationSubtitle, selectors: [["", "ibmNotificationSubtitle", ""]], hostVars: 2, hostBindings: function NotificationSubtitle_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--inline-notification__subtitle", ctx.baseClass);
    } } });
NotificationSubtitle.propDecorators = {
    baseClass: [{ type: HostBinding, args: ["class.bx--inline-notification__subtitle",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NotificationSubtitle, [{
        type: Directive,
        args: [{
                selector: "[ibmNotificationSubtitle]"
            }]
    }], function () { return []; }, { baseClass: [{
            type: HostBinding,
            args: ["class.bx--inline-notification__subtitle"]
        }] }); })();

class NotificationTitle {
    constructor() {
        this.baseClass = true;
    }
}
NotificationTitle.ɵfac = function NotificationTitle_Factory(t) { return new (t || NotificationTitle)(); };
NotificationTitle.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NotificationTitle, selectors: [["", "ibmNotificationTitle", ""]], hostVars: 2, hostBindings: function NotificationTitle_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--inline-notification__title", ctx.baseClass);
    } } });
NotificationTitle.propDecorators = {
    baseClass: [{ type: HostBinding, args: ["class.bx--inline-notification__title",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NotificationTitle, [{
        type: Directive,
        args: [{
                selector: "[ibmNotificationTitle]"
            }]
    }], function () { return []; }, { baseClass: [{
            type: HostBinding,
            args: ["class.bx--inline-notification__title"]
        }] }); })();

/**
 * Notification messages are displayed toward the top of the UI and do not interrupt user’s work.
 *
 * [See demo](../../?path=/story/notification--basic)
 *
 * <example-url>../../iframe.html?id=notification--basic</example-url>
 */
class Notification {
    constructor(notificationDisplayService, i18n) {
        this.notificationDisplayService = notificationDisplayService;
        this.i18n = i18n;
        /**
         * Emits on close.
         */
        this.close = new EventEmitter();
        this.notificationID = `notification-${Notification.notificationCount++}`;
        this.notificationClass = true;
        this.role = "alert";
        this.defaultNotificationObj = {
            title: "",
            message: "",
            type: "info",
            showClose: true,
            closeLabel: this.i18n.get("NOTIFICATION.CLOSE_BUTTON")
        };
        this._notificationObj = Object.assign({}, this.defaultNotificationObj);
    }
    /**
     * Can have `type`, `title`, and `message` members.
     *
     * `type` can be one of `"info"`, `"warning"`, `"error"`, `"success"`
     *
     * `message` is the message to display
     */
    get notificationObj() {
        return this._notificationObj;
    }
    set notificationObj(obj) {
        if (obj.closeLabel) {
            obj.closeLabel = of(obj.closeLabel);
        }
        this._notificationObj = Object.assign({}, this.defaultNotificationObj, obj);
    }
    get isError() { return this.notificationObj.type === "error"; }
    get isInfo() { return this.notificationObj.type === "info"; }
    get isSuccess() { return this.notificationObj.type === "success"; }
    get isWarning() { return this.notificationObj.type === "warning"; }
    get isLowContrast() { return this.notificationObj.lowContrast; }
    get isCloseHidden() { return !this._notificationObj.showClose; }
    /**
     * Emits close event.
     */
    onClose() {
        this.close.emit();
    }
    onClick(action, event) {
        if (!action.click) {
            return;
        }
        if (isObservable(action.click)) {
            action.click.next({ event, action });
        }
        else {
            action.click({ event, action });
        }
    }
    destroy() {
        this.notificationDisplayService.close(this);
    }
}
Notification.ɵfac = function Notification_Factory(t) { return new (t || Notification)(ɵngcc0.ɵɵdirectiveInject(NotificationDisplayService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n)); };
Notification.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: Notification, selectors: [["ibm-notification"]], viewQuery: function Notification_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.notification = _t.first);
    } }, hostVars: 16, hostBindings: function Notification_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.notificationID)("role", ctx.role);
        ɵngcc0.ɵɵclassProp("bx--inline-notification", ctx.notificationClass)("bx--inline-notification--error", ctx.isError)("bx--inline-notification--info", ctx.isInfo)("bx--inline-notification--success", ctx.isSuccess)("bx--inline-notification--warning", ctx.isWarning)("bx--inline-notification--low-contrast", ctx.isLowContrast)("bx--inline-notification--hide-close-button", ctx.isCloseHidden);
    } }, inputs: { notificationObj: "notificationObj" }, outputs: { close: "close" }, decls: 11, vars: 12, consts: [[1, "bx--inline-notification__details"], ["ibmIcon", "error--filled", "size", "16", "class", "bx--inline-notification__icon", 4, "ngIf"], ["ibmIcon", "warning--filled", "size", "16", "class", "bx--inline-notification__icon", 4, "ngIf"], ["ibmIcon", "checkmark--filled", "size", "16", "class", "bx--inline-notification__icon", 4, "ngIf"], ["ibmIcon", "information--filled", "size", "16", "class", "bx--inline-notification__icon", 4, "ngIf"], [1, "bx--inline-notification__text-wrapper"], ["ibmNotificationTitle", "", 3, "innerHTML", 4, "ngIf"], ["ibmNotificationSubtitle", "", 4, "ngIf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [4, "ngFor", "ngForOf"], ["class", "bx--inline-notification__close-button", "type", "button", 3, "click", 4, "ngIf"], ["ibmIcon", "error--filled", "size", "16", 1, "bx--inline-notification__icon"], ["ibmIcon", "warning--filled", "size", "16", 1, "bx--inline-notification__icon"], ["ibmIcon", "checkmark--filled", "size", "16", 1, "bx--inline-notification__icon"], ["ibmIcon", "information--filled", "size", "16", 1, "bx--inline-notification__icon"], ["ibmNotificationTitle", "", 3, "innerHTML"], ["ibmNotificationSubtitle", ""], [3, "innerHTML"], ["ibmLink", "", 3, "href"], ["ibmButton", "ghost", "size", "sm", "type", "button", 1, "bx--inline-notification__action-button", 3, "click"], ["type", "button", 1, "bx--inline-notification__close-button", 3, "click"], ["ibmIcon", "close", "size", "16", 1, "bx--inline-notification__close-icon"]], template: function Notification_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, Notification__svg_svg_1_Template, 1, 0, "svg", 1);
        ɵngcc0.ɵɵtemplate(2, Notification__svg_svg_2_Template, 1, 0, "svg", 2);
        ɵngcc0.ɵɵtemplate(3, Notification__svg_svg_3_Template, 1, 0, "svg", 3);
        ɵngcc0.ɵɵtemplate(4, Notification__svg_svg_4_Template, 1, 0, "svg", 4);
        ɵngcc0.ɵɵelementStart(5, "div", 5);
        ɵngcc0.ɵɵtemplate(6, Notification_p_6_Template, 1, 1, "p", 6);
        ɵngcc0.ɵɵtemplate(7, Notification_div_7_Template, 3, 2, "div", 7);
        ɵngcc0.ɵɵtemplate(8, Notification_ng_container_8_Template, 1, 0, "ng-container", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(9, Notification_div_9_Template, 3, 1, "div", 9);
        ɵngcc0.ɵɵtemplate(10, Notification_button_10_Template, 3, 3, "button", 10);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.notificationObj.type === "error");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.notificationObj.type === "warning");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.notificationObj.type === "success");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.notificationObj.type === "info");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.notificationObj.template);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.notificationObj.template);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.notificationObj.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(10, _c1, ctx.notificationObj));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.notificationObj.actions);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isCloseHidden);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgForOf, ɵngcc3.IconDirective, NotificationTitle, NotificationSubtitle, ɵngcc4.Link, ɵngcc5.Button], pipes: [ɵngcc2.AsyncPipe], encapsulation: 2 });
Notification.notificationCount = 0;
/** @nocollapse */
Notification.ctorParameters = () => [
    { type: NotificationDisplayService },
    { type: I18n }
];
Notification.propDecorators = {
    notificationObj: [{ type: Input }],
    close: [{ type: Output }],
    notification: [{ type: ViewChild, args: ["notification", { static: false },] }],
    notificationID: [{ type: HostBinding, args: ["attr.id",] }],
    notificationClass: [{ type: HostBinding, args: ["class.bx--inline-notification",] }],
    role: [{ type: HostBinding, args: ["attr.role",] }],
    isError: [{ type: HostBinding, args: ["class.bx--inline-notification--error",] }],
    isInfo: [{ type: HostBinding, args: ["class.bx--inline-notification--info",] }],
    isSuccess: [{ type: HostBinding, args: ["class.bx--inline-notification--success",] }],
    isWarning: [{ type: HostBinding, args: ["class.bx--inline-notification--warning",] }],
    isLowContrast: [{ type: HostBinding, args: ["class.bx--inline-notification--low-contrast",] }],
    isCloseHidden: [{ type: HostBinding, args: ["class.bx--inline-notification--hide-close-button",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Notification, [{
        type: Component,
        args: [{
                selector: "ibm-notification",
                template: `
		<div class="bx--inline-notification__details">
			<svg
				ibmIcon="error--filled"
				size="16"
				*ngIf="notificationObj.type === 'error'"
				class="bx--inline-notification__icon">
			</svg>
			<svg
				ibmIcon="warning--filled"
				size="16"
				*ngIf="notificationObj.type === 'warning'"
				class="bx--inline-notification__icon">
			</svg>
			<svg
				ibmIcon="checkmark--filled"
				size="16"
				*ngIf="notificationObj.type === 'success'"
				class="bx--inline-notification__icon">
			</svg>
			<svg
				ibmIcon="information--filled"
				size="16"
				*ngIf="notificationObj.type === 'info'"
				class="bx--inline-notification__icon">
			</svg>
			<div class="bx--inline-notification__text-wrapper">
				<p *ngIf="!notificationObj.template" ibmNotificationTitle [innerHTML]="notificationObj.title"></p>
				<div *ngIf="!notificationObj.template" ibmNotificationSubtitle>
					<span [innerHTML]="notificationObj.message"></span>
					<ng-container *ngFor="let link of notificationObj.links">
						<a ibmLink [href]="link.href"> {{link.text}}</a>
					</ng-container>
				</div>
				<ng-container *ngTemplateOutlet="notificationObj.template; context: { $implicit: notificationObj}"></ng-container>
			</div>
		</div>
		<div *ngFor="let action of notificationObj.actions">
			<button
				(click)="onClick(action, $event)"
				ibmButton="ghost"
				size="sm"
				class="bx--inline-notification__action-button"
				type="button">
				{{action.text}}
			</button>
		</div>
		<button
			*ngIf="!isCloseHidden"
			(click)="onClose()"
			class="bx--inline-notification__close-button"
			[attr.aria-label]="notificationObj.closeLabel | async"
			type="button">
			<svg ibmIcon="close" size="16" class="bx--inline-notification__close-icon"></svg>
		</button>
	`
            }]
    }], function () { return [{ type: NotificationDisplayService }, { type: ɵngcc1.I18n }]; }, { close: [{
            type: Output
        }], notificationID: [{
            type: HostBinding,
            args: ["attr.id"]
        }], notificationClass: [{
            type: HostBinding,
            args: ["class.bx--inline-notification"]
        }], role: [{
            type: HostBinding,
            args: ["attr.role"]
        }], notificationObj: [{
            type: Input
        }], isError: [{
            type: HostBinding,
            args: ["class.bx--inline-notification--error"]
        }], isInfo: [{
            type: HostBinding,
            args: ["class.bx--inline-notification--info"]
        }], isSuccess: [{
            type: HostBinding,
            args: ["class.bx--inline-notification--success"]
        }], isWarning: [{
            type: HostBinding,
            args: ["class.bx--inline-notification--warning"]
        }], isLowContrast: [{
            type: HostBinding,
            args: ["class.bx--inline-notification--low-contrast"]
        }], isCloseHidden: [{
            type: HostBinding,
            args: ["class.bx--inline-notification--hide-close-button"]
        }], notification: [{
            type: ViewChild,
            args: ["notification", { static: false }]
        }] }); })();

/**
 * Toast messages are displayed toward the top of the UI and do not interrupt user’s work.
 *
 * [See demo](../../?path=/story/notification--toast)
 *
 * <example-url>../../iframe.html?id=notification--toast</example-url>
 */
class Toast extends Notification {
    constructor(notificationDisplayService, i18n, experimental) {
        super(notificationDisplayService, i18n);
        this.notificationDisplayService = notificationDisplayService;
        this.i18n = i18n;
        this.experimental = experimental;
        this.toastID = `toast-${Toast.toastCount++}`;
        this.toastClass = true;
        this.role = "alert";
        // disable inline notification styles
        this.notificationClass = false;
    }
    get isError() { return this.notificationObj["type"] === "error"; }
    get isInfo() { return this.notificationObj["type"] === "info"; }
    get isSuccess() { return this.notificationObj["type"] === "success"; }
    get isWarning() { return this.notificationObj["type"] === "warning"; }
    get isLowContrast() { return this.notificationObj.lowContrast; }
    ngOnInit() {
        if (!this.notificationObj.closeLabel) {
            this.notificationObj.closeLabel = this.i18n.get().NOTIFICATION.CLOSE_BUTTON;
        }
    }
}
Toast.ɵfac = function Toast_Factory(t) { return new (t || Toast)(ɵngcc0.ɵɵdirectiveInject(NotificationDisplayService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n), ɵngcc0.ɵɵdirectiveInject(ɵngcc6.ExperimentalService)); };
Toast.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: Toast, selectors: [["ibm-toast"]], hostVars: 14, hostBindings: function Toast_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.toastID)("role", ctx.role);
        ɵngcc0.ɵɵclassProp("bx--toast-notification", ctx.toastClass)("bx--toast-notification--error", ctx.isError)("bx--toast-notification--info", ctx.isInfo)("bx--toast-notification--success", ctx.isSuccess)("bx--toast-notification--warning", ctx.isWarning)("bx--toast-notification--low-contrast", ctx.isLowContrast);
    } }, inputs: { notificationObj: "notificationObj" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 10, vars: 12, consts: [["ibmIcon", "error--filled", "size", "16", "class", "bx--toast-notification__icon", 4, "ngIf"], ["ibmIcon", "warning--filled", "size", "16", "class", "bx--toast-notification__icon", 4, "ngIf"], ["ibmIcon", "checkmark--filled", "size", "16", "class", "bx--toast-notification__icon", 4, "ngIf"], ["ibmIcon", "information--filled", "size", "16", "class", "bx--toast-notification__icon", 4, "ngIf"], [1, "bx--toast-notification__details"], ["ibmToastTitle", "", 3, "innerHTML", 4, "ngIf"], ["ibmToastSubtitle", "", 4, "ngIf"], ["ibmToastCaption", "", 3, "innerHTML", 4, "ngIf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "bx--toast-notification__close-button", "type", "button", 3, "click", 4, "ngIf"], ["ibmIcon", "error--filled", "size", "16", 1, "bx--toast-notification__icon"], ["ibmIcon", "warning--filled", "size", "16", 1, "bx--toast-notification__icon"], ["ibmIcon", "checkmark--filled", "size", "16", 1, "bx--toast-notification__icon"], ["ibmIcon", "information--filled", "size", "16", 1, "bx--toast-notification__icon"], ["ibmToastTitle", "", 3, "innerHTML"], ["ibmToastSubtitle", ""], [3, "innerHTML"], [4, "ngFor", "ngForOf"], ["ibmLink", "", 3, "href"], ["ibmToastCaption", "", 3, "innerHTML"], ["type", "button", 1, "bx--toast-notification__close-button", 3, "click"], ["ibmIcon", "close", "size", "16", 1, "bx--toast-notification__close-icon"]], template: function Toast_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, Toast__svg_svg_0_Template, 1, 0, "svg", 0);
        ɵngcc0.ɵɵtemplate(1, Toast__svg_svg_1_Template, 1, 0, "svg", 1);
        ɵngcc0.ɵɵtemplate(2, Toast__svg_svg_2_Template, 1, 0, "svg", 2);
        ɵngcc0.ɵɵtemplate(3, Toast__svg_svg_3_Template, 1, 0, "svg", 3);
        ɵngcc0.ɵɵelementStart(4, "div", 4);
        ɵngcc0.ɵɵtemplate(5, Toast_h3_5_Template, 1, 1, "h3", 5);
        ɵngcc0.ɵɵtemplate(6, Toast_div_6_Template, 3, 2, "div", 6);
        ɵngcc0.ɵɵtemplate(7, Toast_p_7_Template, 1, 1, "p", 7);
        ɵngcc0.ɵɵtemplate(8, Toast_ng_container_8_Template, 1, 0, "ng-container", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(9, Toast_button_9_Template, 2, 1, "button", 9);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.notificationObj.type === "error");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.notificationObj.type === "warning");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.notificationObj.type === "success");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.notificationObj.type === "info");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.notificationObj.template);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.notificationObj.template);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.notificationObj.template);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.notificationObj.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(10, _c1, ctx.notificationObj));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isCloseHidden);
    } }, directives: function () { return [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, ɵngcc3.IconDirective, ToastTitle, ToastSubtitle, ɵngcc2.NgForOf, ɵngcc4.Link, ToastCaption]; }, encapsulation: 2 });
Toast.toastCount = 0;
/** @nocollapse */
Toast.ctorParameters = () => [
    { type: NotificationDisplayService },
    { type: I18n },
    { type: ExperimentalService }
];
Toast.propDecorators = {
    notificationObj: [{ type: Input }],
    toastID: [{ type: HostBinding, args: ["attr.id",] }],
    toastClass: [{ type: HostBinding, args: ["class.bx--toast-notification",] }],
    role: [{ type: HostBinding, args: ["attr.role",] }],
    isError: [{ type: HostBinding, args: ["class.bx--toast-notification--error",] }],
    isInfo: [{ type: HostBinding, args: ["class.bx--toast-notification--info",] }],
    isSuccess: [{ type: HostBinding, args: ["class.bx--toast-notification--success",] }],
    isWarning: [{ type: HostBinding, args: ["class.bx--toast-notification--warning",] }],
    isLowContrast: [{ type: HostBinding, args: ["class.bx--toast-notification--low-contrast",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Toast, [{
        type: Component,
        args: [{
                selector: "ibm-toast",
                template: `
		<svg
			ibmIcon="error--filled"
			size="16"
			*ngIf="notificationObj.type === 'error'"
			class="bx--toast-notification__icon">
		</svg>
		<svg
			ibmIcon="warning--filled"
			size="16"
			*ngIf="notificationObj.type === 'warning'"
			class="bx--toast-notification__icon">
		</svg>
		<svg
			ibmIcon="checkmark--filled"
			size="16"
			*ngIf="notificationObj.type === 'success'"
			class="bx--toast-notification__icon">
		</svg>
		<svg
			ibmIcon="information--filled"
			size="16"
			*ngIf="notificationObj.type === 'info'"
			class="bx--toast-notification__icon">
		</svg>
		<div class="bx--toast-notification__details">
			<h3 *ngIf="!notificationObj.template" ibmToastTitle [innerHTML]="notificationObj.title"></h3>
			<div *ngIf="!notificationObj.template" ibmToastSubtitle>
				<span [innerHTML]="notificationObj.subtitle"></span>
				<ng-container *ngFor="let link of notificationObj.links">
					<a ibmLink [href]="link.href"> {{link.text}}</a>
				</ng-container>
			</div>
			<p *ngIf="!notificationObj.template" ibmToastCaption [innerHTML]="notificationObj.caption"></p>
			<ng-container *ngTemplateOutlet="notificationObj.template; context: { $implicit: notificationObj}"></ng-container>
		</div>
		<button
			*ngIf="!isCloseHidden"
			class="bx--toast-notification__close-button"
			type="button"
			[attr.aria-label]="notificationObj.closeLabel"
			(click)="onClose()">
			<svg ibmIcon="close" size="16" class="bx--toast-notification__close-icon"></svg>
		</button>
	`
            }]
    }], function () { return [{ type: NotificationDisplayService }, { type: ɵngcc1.I18n }, { type: ɵngcc6.ExperimentalService }]; }, { toastID: [{
            type: HostBinding,
            args: ["attr.id"]
        }], toastClass: [{
            type: HostBinding,
            args: ["class.bx--toast-notification"]
        }], role: [{
            type: HostBinding,
            args: ["attr.role"]
        }], isError: [{
            type: HostBinding,
            args: ["class.bx--toast-notification--error"]
        }], isInfo: [{
            type: HostBinding,
            args: ["class.bx--toast-notification--info"]
        }], isSuccess: [{
            type: HostBinding,
            args: ["class.bx--toast-notification--success"]
        }], isWarning: [{
            type: HostBinding,
            args: ["class.bx--toast-notification--warning"]
        }], isLowContrast: [{
            type: HostBinding,
            args: ["class.bx--toast-notification--low-contrast"]
        }], notificationObj: [{
            type: Input
        }] }); })();

class ToastTitle {
    constructor() {
        this.baseClass = true;
    }
}
ToastTitle.ɵfac = function ToastTitle_Factory(t) { return new (t || ToastTitle)(); };
ToastTitle.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ToastTitle, selectors: [["", "ibmToastTitle", ""]], hostVars: 2, hostBindings: function ToastTitle_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--toast-notification__title", ctx.baseClass);
    } } });
ToastTitle.propDecorators = {
    baseClass: [{ type: HostBinding, args: ["class.bx--toast-notification__title",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ToastTitle, [{
        type: Directive,
        args: [{
                selector: "[ibmToastTitle]"
            }]
    }], function () { return []; }, { baseClass: [{
            type: HostBinding,
            args: ["class.bx--toast-notification__title"]
        }] }); })();

class ToastSubtitle {
    constructor() {
        this.baseClass = true;
    }
}
ToastSubtitle.ɵfac = function ToastSubtitle_Factory(t) { return new (t || ToastSubtitle)(); };
ToastSubtitle.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ToastSubtitle, selectors: [["", "ibmToastSubtitle", ""]], hostVars: 2, hostBindings: function ToastSubtitle_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--toast-notification__subtitle", ctx.baseClass);
    } } });
ToastSubtitle.propDecorators = {
    baseClass: [{ type: HostBinding, args: ["class.bx--toast-notification__subtitle",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ToastSubtitle, [{
        type: Directive,
        args: [{
                selector: "[ibmToastSubtitle]"
            }]
    }], function () { return []; }, { baseClass: [{
            type: HostBinding,
            args: ["class.bx--toast-notification__subtitle"]
        }] }); })();

class ToastCaption {
    constructor() {
        this.baseClass = true;
    }
}
ToastCaption.ɵfac = function ToastCaption_Factory(t) { return new (t || ToastCaption)(); };
ToastCaption.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ToastCaption, selectors: [["", "ibmToastCaption", ""]], hostVars: 2, hostBindings: function ToastCaption_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--toast-notification__caption", ctx.baseClass);
    } } });
ToastCaption.propDecorators = {
    baseClass: [{ type: HostBinding, args: ["class.bx--toast-notification__caption",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ToastCaption, [{
        type: Directive,
        args: [{
                selector: "[ibmToastCaption]"
            }]
    }], function () { return []; }, { baseClass: [{
            type: HostBinding,
            args: ["class.bx--toast-notification__caption"]
        }] }); })();

/**
 * Provides a way to use the notification component.
 *
 * Notifications are displayed toward the top of the UI and do not interrupt the user’s work.
 */
class NotificationService {
    /**
     * Constructs NotificationService.
     *
     * @param injector
     * @param componentFactoryResolver
     * @param applicationRef
     */
    constructor(injector, componentFactoryResolver, applicationRef, ngZone) {
        this.injector = injector;
        this.componentFactoryResolver = componentFactoryResolver;
        this.applicationRef = applicationRef;
        this.ngZone = ngZone;
        /**
         * An array containing `ComponentRef`s to all the notifications this service instance
         * is responsible for.
         *
         */
        this.notificationRefs = new Array();
        this.onClose = new EventEmitter();
    }
    /**
     * Shows the notification based on the `notificationObj`.
     *
     * @param notificationObj Can have `type`, `message`, `target`, `duration` and `smart` members.
     *
     * **Members:**
     *
     * * `type` can be one of `"info"`, `"warning"`, `"danger"`, `"success"`
     * * `message` is message for notification to display
     * * `target` is css selector defining an element to append notification to. If not provided,
     * `showNotification()` creates a place for the notification in `body`
     * * `duration` is number of ms to close the notification after. If used in combination with `smart`,
     * it's added to the calculated timeout
     * * `smart`, set to `true` if you want to use smart notification.
     *
     * **Example:**
     * ```typescript
     * // Info notification, saying "Sample message." added to the element with id notification-container
     * // uses smart timeout with added duration of 1 second.
     * {
     *	type: "info",
     *	message: "Sample message.",
     *	target: "#notification-container",
     *	duration: 1000,
     *	smart: true
     * }
     * ```
     *
     * @param [notificationComp=Notification] If provided, used to resolve component factory
     */
    showNotification(notificationObj, notificationComp = Notification) {
        const componentFactory = this.componentFactoryResolver.resolveComponentFactory(notificationComp);
        let notificationRef = componentFactory.create(this.injector);
        notificationRef.instance.notificationObj = notificationObj; // typescript isn't being very smart here, so we type to any
        this.notificationRefs.push(notificationRef);
        this.onClose = notificationRef.instance.close;
        this.applicationRef.attachView(notificationRef.hostView);
        if (notificationObj.target) {
            document.querySelector(notificationObj.target).appendChild(notificationRef.location.nativeElement);
        }
        else {
            let body = document.querySelector("body");
            // get or create a container for alert list
            let notificationClassName = "notification-overlay";
            let notificationList = body.querySelector(`.${notificationClassName}`);
            if (!notificationList) {
                notificationList = document.createElement("div");
                notificationList.className = notificationClassName;
                body.appendChild(notificationList);
            }
            // add the notification to the top of the list
            if (notificationList.firstChild) {
                notificationList.insertBefore(notificationRef.location.nativeElement, notificationList.firstChild);
            }
            else {
                notificationList.appendChild(notificationRef.location.nativeElement);
            }
        }
        if (notificationObj.duration && notificationObj.duration > 0) {
            this.ngZone.runOutsideAngular(() => {
                setTimeout(() => {
                    this.ngZone.run(() => {
                        this.close(notificationRef);
                    });
                }, notificationObj.duration);
            });
        }
        if (notificationObj.smart) {
            this.ngZone.runOutsideAngular(() => {
                // let it disappear after calculated timeout
                setTimeout(() => {
                    this.ngZone.run(() => {
                        this.close(notificationRef);
                    });
                }, this.getSmartTimeout(notificationObj));
            });
        }
        this.onClose.subscribe(() => {
            this.close(notificationRef);
        });
        notificationRef.instance.componentRef = notificationRef;
        return notificationRef.instance;
    }
    showToast(notificationObj, notificationComp = Toast) {
        return this.showNotification(notificationObj, notificationComp);
    }
    /**
     * Programatically closes notification based on `notificationRef`.
     *
     * @param notificationRef `ComponentRef` of a notification or `Notification` component you wish to close
     */
    close(notificationRef) {
        if (notificationRef) {
            if (notificationRef instanceof Notification) {
                this.close(notificationRef.componentRef);
            }
            else {
                this.applicationRef.detachView(notificationRef.hostView);
                notificationRef.destroy();
                const index = this.notificationRefs.indexOf(notificationRef);
                if (index !== -1) {
                    this.notificationRefs.splice(index, 1);
                }
            }
        }
    }
    /**
     * Calculates the amount of time user needs to read the message in the notification.
     *
     * @param notificationObj Same object used to instantiate notification.
     *
     * In addition to `type` and `message` members, use `duration` member to add
     * some extra time (in ms) to timeout if you need to.
     * @returns calculated timeout (in ms) for smart notification
     */
    getSmartTimeout(notificationObj) {
        // calculate timeout
        let timeout = 600; // start with reaction time
        // custom duration
        timeout += notificationObj.duration || 0;
        // message type
        switch (notificationObj.type) {
            case "info":
            case "success":
            default: {
                break;
            }
            case "danger": {
                timeout += 3000;
                break;
            }
            case "warning": {
                timeout += 1500;
                break;
            }
        }
        // message length
        // average reader reads around 200 words per minute, or it takes them ~0.3s per word
        // let's use 1.5 factor for below average speed readers and have 0.45s per word
        let wordCount = notificationObj.message.trim().split(/\s+/).length;
        timeout += wordCount * 450;
        return timeout;
    }
    /**
     * OnDestroy hook.
     *
     * Destroys all living notifications it is responsible for.
     *
     */
    ngOnDestroy() {
        if (this.notificationRefs.length > 0) {
            for (let i = 0; i < this.notificationRefs.length; i++) {
                let notificationRef = this.notificationRefs[i];
                this.applicationRef.detachView(notificationRef.hostView);
                notificationRef.destroy();
            }
            this.notificationRefs.length = 0;
        }
    }
}
NotificationService.ɵfac = function NotificationService_Factory(t) { return new (t || NotificationService)(ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
NotificationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NotificationService, factory: NotificationService.ɵfac });
/** @nocollapse */
NotificationService.ctorParameters = () => [
    { type: Injector },
    { type: ComponentFactoryResolver },
    { type: ApplicationRef },
    { type: NgZone }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NotificationService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.Injector }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ApplicationRef }, { type: ɵngcc0.NgZone }]; }, null); })();

class NotificationModule {
}
NotificationModule.ɵfac = function NotificationModule_Factory(t) { return new (t || NotificationModule)(); };
NotificationModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NotificationModule });
NotificationModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [NotificationService, NotificationDisplayService], imports: [[
            ButtonModule,
            CommonModule,
            I18nModule,
            ExperimentalModule,
            LinkModule,
            IconModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NotificationModule, { declarations: function () { return [Notification, Toast, ToastTitle, ToastSubtitle, ToastCaption, NotificationTitle, NotificationSubtitle]; }, imports: function () { return [ButtonModule,
        CommonModule,
        I18nModule,
        ExperimentalModule,
        LinkModule,
        IconModule]; }, exports: function () { return [Notification, Toast, ToastTitle, ToastSubtitle, ToastCaption, NotificationTitle, NotificationSubtitle]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NotificationModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    Notification,
                    Toast,
                    ToastTitle,
                    ToastSubtitle,
                    ToastCaption,
                    NotificationTitle,
                    NotificationSubtitle
                ],
                exports: [
                    Notification,
                    Toast,
                    ToastTitle,
                    ToastSubtitle,
                    ToastCaption,
                    NotificationTitle,
                    NotificationSubtitle
                ],
                entryComponents: [Notification, Toast],
                imports: [
                    ButtonModule,
                    CommonModule,
                    I18nModule,
                    ExperimentalModule,
                    LinkModule,
                    IconModule
                ],
                providers: [NotificationService, NotificationDisplayService]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { NotificationDisplayService, NotificationSubtitle, NotificationTitle, Notification, NotificationModule, NotificationService, ToastCaption, ToastSubtitle, ToastTitle, Toast };

//# sourceMappingURL=carbon-components-angular-notification.js.map