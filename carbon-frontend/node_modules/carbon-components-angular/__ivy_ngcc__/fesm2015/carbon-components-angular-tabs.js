/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-tabs.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Subscription } from 'rxjs';
import { Component, Input, Output, EventEmitter, TemplateRef, HostBinding, ViewChild, ElementRef, HostListener, ContentChildren, ChangeDetectorRef, ViewChildren, ContentChild, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { EventService, UtilsModule } from 'carbon-components-angular/utils';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from 'carbon-components-angular/utils';

const _c0 = function (a0) { return { "display": a0 }; };
function Tab_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(3, _c0, ctx_r0.active ? null : "none"));
    ɵngcc0.ɵɵattribute("tabindex", ctx_r0.tabIndex)("aria-labelledby", ctx_r0.id + "-header");
} }
const _c1 = ["*"];
const _c2 = ["tabItem"];
const _c3 = function (a0, a1) { return { "bx--tabs__nav-item--selected bx--tabs--scrollable__nav-item--selected": a0, "bx--tabs__nav-item--disabled bx--tabs--scrollable__nav-item--disabled": a1 }; };
const _c4 = ["tabList"];
const _c5 = ["rightOverflowNavButton"];
const _c6 = ["leftOverflowNavButton"];
function TabHeaderGroup_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelement(0, "div", 13);
} }
function TabHeaderGroup_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 14);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r3.contentBefore);
} }
function TabHeaderGroup_ng_container_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 14);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r4.contentAfter);
} }
function TabHeaderGroup_div_13_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 15);
} }
const _c7 = function (a0, a1) { return { "bx--skeleton": a0, "bx--tabs--container bx--tabs--scrollable--container": a1 }; };
const _c8 = function (a0, a1) { return { "bx--tab--overflow-nav-button": a0, "bx--tab--overflow-nav-button--hidden": a1 }; };
function TabHeaders_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelement(0, "div", 14);
} }
function TabHeaders_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 15);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r3.contentBefore);
} }
function TabHeaders_li_10_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const tab_r8 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", tab_r8.heading, " ");
} }
function TabHeaders_li_10_4_ng_template_0_Template(rf, ctx) { }
const _c9 = function (a0) { return { $implicit: a0 }; };
function TabHeaders_li_10_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TabHeaders_li_10_4_ng_template_0_Template, 0, 0, "ng-template", 20);
} if (rf & 2) {
    const tab_r8 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", tab_r8.heading)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c9, tab_r8.context));
} }
function TabHeaders_li_10_Template(rf, ctx) { if (rf & 1) {
    const _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 16);
    ɵngcc0.ɵɵlistener("click", function TabHeaders_li_10_Template_li_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); const tab_r8 = ctx.$implicit; const i_r9 = ctx.index; const _r10 = ɵngcc0.ɵɵreference(2); const ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.selectTab(_r10, tab_r8, i_r9); });
    ɵngcc0.ɵɵelementStart(1, "button", 17, 18);
    ɵngcc0.ɵɵlistener("focus", function TabHeaders_li_10_Template_button_focus_1_listener() { ɵngcc0.ɵɵrestoreView(_r17); const i_r9 = ctx.index; const _r10 = ɵngcc0.ɵɵreference(2); const ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.onTabFocus(_r10, i_r9); })("click", function TabHeaders_li_10_Template_button_click_1_listener($event) { return $event.preventDefault(); });
    ɵngcc0.ɵɵtemplate(3, TabHeaders_li_10_ng_container_3_Template, 2, 1, "ng-container", 19);
    ɵngcc0.ɵɵtemplate(4, TabHeaders_li_10_4_Template, 1, 4, undefined, 19);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r8 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(9, _c3, tab_r8.active, tab_r8.disabled));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵpropertyInterpolate1("id", "", tab_r8.id, "-header");
    ɵngcc0.ɵɵproperty("title", tab_r8.title ? tab_r8.title : tab_r8.heading);
    ɵngcc0.ɵɵattribute("aria-selected", tab_r8.active)("tabindex", tab_r8.active ? 0 : -1)("aria-controls", tab_r8.id)("aria-disabled", tab_r8.disabled);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", !tab_r8.headingIsTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", tab_r8.headingIsTemplate);
} }
function TabHeaders_ng_container_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 15);
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r5.contentAfter);
} }
function TabHeaders_div_13_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 21);
} }
function Tabs_ibm_tab_headers_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ibm-tab-headers", 4);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    const _r1 = ɵngcc0.ɵɵreference(3);
    const _r3 = ɵngcc0.ɵɵreference(5);
    ɵngcc0.ɵɵproperty("skeleton", ctx_r0.skeleton)("tabs", ctx_r0.tabs)("followFocus", ctx_r0.followFocus)("cacheActive", ctx_r0.cacheActive)("contentBefore", _r1)("contentAfter", _r3)("ariaLabel", ctx_r0.ariaLabel)("ariaLabelledby", ctx_r0.ariaLabelledby)("type", ctx_r0.type);
} }
function Tabs_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 1);
} }
function Tabs_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 2);
} }
function Tabs_ibm_tab_headers_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ibm-tab-headers", 5);
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("skeleton", ctx_r5.skeleton)("tabs", ctx_r5.tabs)("cacheActive", ctx_r5.cacheActive)("type", ctx_r5.type);
} }
const _c10 = ["*", [["", "before", ""]], [["", "after", ""]]];
const _c11 = ["*", "[before]", "[after]"];
let nextId = 0;
/**
* The `Tab` component is a child of the `Tabs` component.
* It represents one `Tab` item and its content within a panel of other `Tab` items.
*
*
* `Tab` takes a string or `TemplateRef` for the header, and any content for the body of the tab.
* Disabled states should be handled by the application (ie. switch to the tab, but display some
* indication as to _why_ the tab is disabled).
*
* When the tab is selected the `select` output will be triggered.
* The `select` output will also be triggered for the active tab when the tabs are loaded or updated.
*
*
* Tab with string header:
*
* ```html
* <ibm-tab heading='tab1'>
* 	tab 1 content
* </ibm-tab>
* ```
*
* Tab with custom header:
*
* ```html
* <ng-template #tabHeading>
* 	<svg ibmIcon="facebook"
* 		size="sm"
* 		style="margin-right: 7px;">
* 	</svg>
* 	Hello Tab 1
* </ng-template>
* <ibm-tabs>
* 	<ibm-tab [heading]="tabHeading">
* 		Tab 1 content <svg ibmIcon="alert" size="lg"></svg>
* 	</ibm-tab>
* 	<ibm-tab heading='Tab2'>
* 		Tab 2 content
* 	</ibm-tab>
* 	<ibm-tab heading='Tab3'>
* 		Tab 3 content
* 	</ibm-tab>
* </ibm-tabs>
* ```
*/
class Tab {
    constructor() {
        /**
         * Boolean value reflects if the `Tab` is using a custom template for the heading.
         * Default value is false.
         */
        this.headingIsTemplate = false;
        /**
         * Indicates whether the `Tab` is active/selected.
         * Determines whether it's `TabPanel` is rendered.
         */
        this.active = false;
        /**
         * Indicates whether or not the `Tab` item is disabled.
         */
        this.disabled = false;
        this.tabIndex = 0;
        // do we need id's?
        /**
         * Sets the id of the `Tab`. Will be uniquely generated if not provided.
         */
        this.id = `n-tab-${nextId++}`;
        /**
         * Value 'selected' to be emitted after a new `Tab` is selected.
         */
        this.selected = new EventEmitter();
        /**
         * Used to set the id property on the element.
         */
        this.attrClass = this.id;
        this._cacheActive = false;
    }
    /**
     * Set to true to have Tab items cached and not reloaded on tab switching.
     */
    set cacheActive(shouldCache) {
        this._cacheActive = shouldCache;
    }
    get cacheActive() {
        return this._cacheActive;
    }
    /**
     * Checks for custom heading template on initialization and updates the value
     * of the boolean 'headingIsTemplate'.
     */
    ngOnInit() {
        if (this.heading instanceof TemplateRef) {
            this.headingIsTemplate = true;
        }
    }
    /**
     * Emit the status of the `Tab`, specifically 'select' and 'selected' properties.
     */
    doSelect() {
        this.selected.emit();
    }
    /**
    * Returns value indicating whether this `Tab` should be rendered in a `TabPanel`.
    */
    shouldRender() {
        return this.active || this.cacheActive;
    }
}
Tab.ɵfac = function Tab_Factory(t) { return new (t || Tab)(); };
Tab.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: Tab, selectors: [["ibm-tab"]], hostVars: 1, hostBindings: function Tab_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.attrClass);
    } }, inputs: { active: "active", disabled: "disabled", tabIndex: "tabIndex", id: "id", cacheActive: "cacheActive", heading: "heading", title: "title", context: "context" }, outputs: { selected: "selected" }, ngContentSelectors: _c1, decls: 1, vars: 1, consts: [["role", "tabpanel", "class", "bx--tab-content", "aria-live", "polite", 3, "ngStyle", 4, "ngIf"], ["role", "tabpanel", "aria-live", "polite", 1, "bx--tab-content", 3, "ngStyle"]], template: function Tab_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, Tab_div_0_Template, 2, 5, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.shouldRender());
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgStyle], encapsulation: 2 });
Tab.propDecorators = {
    heading: [{ type: Input }],
    title: [{ type: Input }],
    context: [{ type: Input }],
    active: [{ type: Input }],
    disabled: [{ type: Input }],
    tabIndex: [{ type: Input }],
    id: [{ type: Input }],
    cacheActive: [{ type: Input }],
    selected: [{ type: Output }],
    attrClass: [{ type: HostBinding, args: ["attr.id",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Tab, [{
        type: Component,
        args: [{
                selector: "ibm-tab",
                template: `
		<div
			[attr.tabindex]="tabIndex"
			role="tabpanel"
			*ngIf="shouldRender()"
			class="bx--tab-content"
			[ngStyle]="{'display': active ? null : 'none'}"
			[attr.aria-labelledby]="id + '-header'"
			aria-live="polite">
			<ng-content></ng-content>
		</div>
	`
            }]
    }], function () { return []; }, { active: [{
            type: Input
        }], disabled: [{
            type: Input
        }], tabIndex: [{
            type: Input
        }], id: [{
            type: Input
        }], selected: [{
            type: Output
        }], attrClass: [{
            type: HostBinding,
            args: ["attr.id"]
        }], cacheActive: [{
            type: Input
        }], heading: [{
            type: Input
        }], title: [{
            type: Input
        }], context: [{
            type: Input
        }] }); })();

class TabHeader {
    constructor() {
        /**
         * Indicates whether the `Tab` is active/selected.
         * Determines whether it's `TabPanel` is rendered.
         */
        this.active = false;
        /**
         * Indicates whether or not the `Tab` item is disabled.
         */
        this.disabled = false;
        /**
         * Value 'selected' to be emitted after a new `Tab` is selected.
         */
        this.selected = new EventEmitter();
        this._cacheActive = false;
    }
    /**
     * Set to 'true' to have pane reference cached and not reloaded on tab switching.
     */
    set cacheActive(shouldCache) {
        this._cacheActive = shouldCache;
        // Updates the pane references associated with the tab header when cache active is changed.
        if (this.paneReference) {
            this.paneReference.cacheActive = this.cacheActive;
        }
    }
    set paneTabIndex(tabIndex) {
        if (this.paneReference) {
            this.paneReference.tabIndex = tabIndex;
        }
    }
    get cacheActive() {
        return this._cacheActive;
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.title = this.title ? this.title : this.tabItem.nativeElement.textContent;
        });
    }
    selectTab() {
        this.tabItem.nativeElement.focus();
        if (!this.disabled) {
            this.selected.emit();
            this.active = true;
            if (this.paneReference) {
                this.paneReference.active = true;
            }
        }
    }
}
TabHeader.ɵfac = function TabHeader_Factory(t) { return new (t || TabHeader)(); };
TabHeader.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TabHeader, selectors: [["ibm-tab-header"]], viewQuery: function TabHeader_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c2, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabItem = _t.first);
    } }, inputs: { active: "active", disabled: "disabled", cacheActive: "cacheActive", paneTabIndex: "paneTabIndex", title: "title", paneReference: "paneReference" }, outputs: { selected: "selected" }, ngContentSelectors: _c1, decls: 4, vars: 7, consts: [["role", "presentation", 1, "bx--tabs--scrollable__nav-item", 3, "ngClass", "click"], ["draggable", "false", "href", "javascript:void(0)", "role", "tab", 1, "bx--tabs--scrollable__nav-link", 3, "title"], ["tabItem", ""]], template: function TabHeader_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "li", 0);
        ɵngcc0.ɵɵlistener("click", function TabHeader_Template_li_click_0_listener() { return ctx.selectTab(); });
        ɵngcc0.ɵɵelementStart(1, "button", 1, 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(4, _c3, ctx.active, ctx.disabled));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("title", ctx.title);
        ɵngcc0.ɵɵattribute("aria-selected", ctx.active)("tabindex", ctx.active ? 0 : -1);
    } }, directives: [ɵngcc1.NgClass], encapsulation: 2 });
TabHeader.propDecorators = {
    active: [{ type: Input }],
    disabled: [{ type: Input }],
    paneReference: [{ type: Input }],
    title: [{ type: Input }],
    cacheActive: [{ type: Input }],
    paneTabIndex: [{ type: Input }],
    selected: [{ type: Output }],
    tabItem: [{ type: ViewChild, args: ["tabItem", { static: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabHeader, [{
        type: Component,
        args: [{
                selector: "ibm-tab-header",
                template: `
		<li
			[ngClass]="{
				'bx--tabs__nav-item--selected bx--tabs--scrollable__nav-item--selected': active,
				'bx--tabs__nav-item--disabled bx--tabs--scrollable__nav-item--disabled': disabled
			}"
			class="bx--tabs--scrollable__nav-item"
			role="presentation"
			(click)="selectTab()">
			<button
				#tabItem
				[attr.aria-selected]="active"
				draggable="false"
				class="bx--tabs--scrollable__nav-link"
				href="javascript:void(0)"
				[title]="title"
				[attr.tabindex]="(active? 0 : -1)"
				role="tab">
				<ng-content></ng-content>
			</button>
		</li>
	`
            }]
    }], function () { return []; }, { active: [{
            type: Input
        }], disabled: [{
            type: Input
        }], selected: [{
            type: Output
        }], cacheActive: [{
            type: Input
        }], paneTabIndex: [{
            type: Input
        }], title: [{
            type: Input
        }], paneReference: [{
            type: Input
        }], tabItem: [{
            type: ViewChild,
            args: ["tabItem", { static: true }]
        }] }); })();

class TabHeaderGroup {
    constructor(elementRef, changeDetectorRef, eventService) {
        this.elementRef = elementRef;
        this.changeDetectorRef = changeDetectorRef;
        this.eventService = eventService;
        /**
         * Set to `true` to put tabs in a loading state.
         */
        this.skeleton = false;
        /**
         * Set to 'true' to have all pane references associated with each tab header
         * in the tab header group cached and not reloaded on tab switching.
         */
        this.cacheActive = false;
        this.isNavigation = false;
        this.type = "default";
        /**
         * Keeps track of all the subscriptions to the tab header selection events.
         */
        this.selectedSubscriptionTracker = new Subscription();
        /**
         * Controls the manual focusing done by tabbing through headings.
         */
        this.currentSelectedIndex = 0;
        // width of the overflow buttons
        this.OVERFLOW_BUTTON_OFFSET = 40;
        this._cacheActive = false;
    }
    get hasHorizontalOverflow() {
        const tabList = this.headerContainer.nativeElement;
        return tabList.scrollWidth > tabList.clientWidth;
    }
    get leftOverflowNavButtonHidden() {
        const tabList = this.headerContainer.nativeElement;
        return !this.hasHorizontalOverflow || !tabList.scrollLeft;
    }
    get rightOverflowNavButtonHidden() {
        const tabList = this.headerContainer.nativeElement;
        return !this.hasHorizontalOverflow ||
            (tabList.scrollLeft + tabList.clientWidth) === tabList.scrollWidth;
    }
    // keyboard accessibility
    /**
     * Controls the keydown events used for tabbing through the headings.
     */
    keyboardInput(event) {
        let tabHeadersArray = Array.from(this.tabHeaderQuery);
        if (event.key === "Right" || event.key === "ArrowRight") {
            if (this.currentSelectedIndex < tabHeadersArray.length - 1) {
                event.preventDefault();
                if (this.followFocus && !tabHeadersArray[this.currentSelectedIndex + 1].disabled) {
                    tabHeadersArray[this.currentSelectedIndex + 1].selectTab();
                }
                else {
                    tabHeadersArray[this.currentSelectedIndex + 1].tabItem.nativeElement.focus();
                    this.currentSelectedIndex++;
                }
            }
            else {
                event.preventDefault();
                if (this.followFocus && !tabHeadersArray[0].disabled) {
                    tabHeadersArray[0].selectTab();
                }
                else {
                    tabHeadersArray[0].tabItem.nativeElement.focus();
                    this.currentSelectedIndex = 0;
                }
            }
        }
        if (event.key === "Left" || event.key === "ArrowLeft") {
            if (this.currentSelectedIndex > 0) {
                event.preventDefault();
                if (this.followFocus && !tabHeadersArray[this.currentSelectedIndex - 1].disabled) {
                    tabHeadersArray[this.currentSelectedIndex - 1].selectTab();
                }
                else {
                    tabHeadersArray[this.currentSelectedIndex - 1].tabItem.nativeElement.focus();
                    this.currentSelectedIndex--;
                }
            }
            else {
                event.preventDefault();
                if (this.followFocus && !tabHeadersArray[tabHeadersArray.length - 1].disabled) {
                    tabHeadersArray[tabHeadersArray.length - 1].selectTab();
                }
                else {
                    tabHeadersArray[tabHeadersArray.length - 1].tabItem.nativeElement.focus();
                    this.currentSelectedIndex = tabHeadersArray.length - 1;
                }
            }
        }
        if (event.key === "Home") {
            event.preventDefault();
            if (this.followFocus && !tabHeadersArray[0].disabled) {
                tabHeadersArray[0].selectTab();
            }
            else {
                tabHeadersArray[0].tabItem.nativeElement.focus();
                this.currentSelectedIndex = 0;
            }
        }
        if (event.key === "End") {
            event.preventDefault();
            if (this.followFocus && !tabHeadersArray[tabHeadersArray.length - 1].disabled) {
                tabHeadersArray[tabHeadersArray.length - 1].selectTab();
            }
            else {
                tabHeadersArray[tabHeadersArray.length - 1].tabItem.nativeElement.focus();
                this.currentSelectedIndex = tabHeadersArray.length - 1;
            }
        }
        // `"Spacebar"` is IE11 specific value
        if ((event.key === " " || event.key === "Spacebar") && !this.followFocus) {
            tabHeadersArray[this.currentSelectedIndex].selectTab();
        }
    }
    ngOnInit() {
        this.eventService.on(window, "resize", () => this.handleScroll());
    }
    ngAfterContentInit() {
        this.selectedSubscriptionTracker.unsubscribe();
        if (this.tabHeaderQuery) {
            this.tabHeaderQuery.toArray()
                .forEach(tabHeader => {
                tabHeader.cacheActive = this.cacheActive;
                tabHeader.paneTabIndex = this.isNavigation ? null : 0;
            });
        }
        const selectedSubscriptions = this.tabHeaderQuery.toArray().forEach(tabHeader => {
            tabHeader.selected.subscribe(() => {
                this.currentSelectedIndex = this.tabHeaderQuery.toArray().indexOf(tabHeader);
                // The Filter takes the current selected tab out, then all other headers are
                // deactivated and their associated pane references are also deactivated.
                this.tabHeaderQuery.toArray().filter(header => header !== tabHeader)
                    .forEach(filteredHeader => {
                    filteredHeader.active = false;
                    if (filteredHeader.paneReference) {
                        filteredHeader.paneReference.active = false;
                    }
                });
            });
        });
        this.selectedSubscriptionTracker.add(selectedSubscriptions);
        setTimeout(() => this.tabHeaderQuery.toArray()[this.currentSelectedIndex].selectTab());
    }
    ngOnChanges(changes) {
        if (this.tabHeaderQuery) {
            if (changes.cacheActive) {
                this.tabHeaderQuery.toArray().forEach(tabHeader => tabHeader.cacheActive = this.cacheActive);
            }
            if (changes.isNavigation) {
                this.tabHeaderQuery.toArray()
                    .forEach(tabHeader => tabHeader.paneTabIndex = this.isNavigation ? null : 0);
            }
        }
    }
    getSelectedTab() {
        const selected = this.tabHeaderQuery.toArray()[this.currentSelectedIndex];
        if (selected) {
            return selected;
        }
        return {
            headingIsTemplate: false,
            heading: ""
        };
    }
    handleScroll() {
        this.changeDetectorRef.markForCheck();
    }
    handleOverflowNavClick(direction, multiplier = 15) {
        const tabList = this.headerContainer.nativeElement;
        const { clientWidth, scrollLeft, scrollWidth } = tabList;
        if (direction === 1 && !scrollLeft) {
            tabList.scrollLeft += this.OVERFLOW_BUTTON_OFFSET;
        }
        tabList.scrollLeft += direction * multiplier;
        const leftEdgeReached = direction === -1 && scrollLeft < this.OVERFLOW_BUTTON_OFFSET;
        const rightEdgeReached = direction === 1 &&
            scrollLeft + clientWidth >= scrollWidth - this.OVERFLOW_BUTTON_OFFSET;
        if (leftEdgeReached) {
            this.rightOverflowNavButton.nativeElement.focus();
        }
        if (rightEdgeReached) {
            this.leftOverflowNavButton.nativeElement.focus();
        }
    }
    handleOverflowNavMouseDown(direction) {
        const tabList = this.headerContainer.nativeElement;
        this.overflowNavInterval = setInterval(() => {
            const { clientWidth, scrollLeft, scrollWidth } = tabList;
            // clear interval if scroll reaches left or right edge
            const leftEdgeReached = direction === -1 && scrollLeft < this.OVERFLOW_BUTTON_OFFSET;
            const rightEdgeReached = direction === 1 &&
                scrollLeft + clientWidth >= scrollWidth - this.OVERFLOW_BUTTON_OFFSET;
            if (leftEdgeReached || rightEdgeReached) {
                clearInterval(this.overflowNavInterval);
            }
            // account for overflow button appearing and causing tablist width change
            this.handleOverflowNavClick(direction);
        });
    }
    handleOverflowNavMouseUp() {
        clearInterval(this.overflowNavInterval);
    }
}
TabHeaderGroup.ɵfac = function TabHeaderGroup_Factory(t) { return new (t || TabHeaderGroup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.EventService)); };
TabHeaderGroup.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TabHeaderGroup, selectors: [["ibm-tab-header-group"]], contentQueries: function TabHeaderGroup_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TabHeader, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabHeaderQuery = _t);
    } }, viewQuery: function TabHeaderGroup_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c4, 3);
        ɵngcc0.ɵɵviewQuery(_c5, 3);
        ɵngcc0.ɵɵviewQuery(_c6, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rightOverflowNavButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.leftOverflowNavButton = _t.first);
    } }, hostBindings: function TabHeaderGroup_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function TabHeaderGroup_keydown_HostBindingHandler($event) { return ctx.keyboardInput($event); });
    } }, inputs: { skeleton: "skeleton", cacheActive: "cacheActive", isNavigation: "isNavigation", type: "type", followFocus: "followFocus", ariaLabel: "ariaLabel", ariaLabelledby: "ariaLabelledby", contentAfter: "contentAfter", contentBefore: "contentBefore" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c1, decls: 18, vars: 18, consts: [["role", "navigation", 1, "bx--tabs", "bx--tabs--scrollable", 3, "ngClass"], ["type", "button", 3, "ngClass", "click", "mousedown", "mouseup"], ["leftOverflowNavButton", ""], ["focusable", "false", "preserveAspectRatio", "xMidYMid meet", "xmlns", "http://www.w3.org/2000/svg", "fill", "currentColor", "width", "16", "height", "16", "viewBox", "0 0 16 16", "aria-hidden", "true"], ["d", "M5 8L10 3 10.7 3.7 6.4 8 10.7 12.3 10 13z"], ["class", "bx--tabs__overflow-indicator--left", 4, "ngIf"], ["role", "tablist", 1, "bx--tabs--scrollable__nav", 3, "scroll"], ["tabList", ""], ["role", "presentation"], [3, "ngTemplateOutlet", 4, "ngIf"], ["class", "bx--tabs__overflow-indicator--right", 4, "ngIf"], ["rightOverflowNavButton", ""], ["d", "M11 8L6 13 5.3 12.3 9.6 8 5.3 3.7 6 3z"], [1, "bx--tabs__overflow-indicator--left"], [3, "ngTemplateOutlet"], [1, "bx--tabs__overflow-indicator--right"]], template: function TabHeaderGroup_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "nav", 0);
        ɵngcc0.ɵɵelementStart(1, "button", 1, 2);
        ɵngcc0.ɵɵlistener("click", function TabHeaderGroup_Template_button_click_1_listener() { return ctx.handleOverflowNavClick(-1); })("mousedown", function TabHeaderGroup_Template_button_mousedown_1_listener() { return ctx.handleOverflowNavMouseDown(-1); })("mouseup", function TabHeaderGroup_Template_button_mouseup_1_listener() { return ctx.handleOverflowNavMouseUp(); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(3, "svg", 3);
        ɵngcc0.ɵɵelement(4, "path", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, TabHeaderGroup_div_5_Template, 1, 0, "div", 5);
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelementStart(6, "ul", 6, 7);
        ɵngcc0.ɵɵlistener("scroll", function TabHeaderGroup_Template_ul_scroll_6_listener() { return ctx.handleScroll(); });
        ɵngcc0.ɵɵelementStart(8, "li", 8);
        ɵngcc0.ɵɵtemplate(9, TabHeaderGroup_ng_container_9_Template, 1, 1, "ng-container", 9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(10);
        ɵngcc0.ɵɵelementStart(11, "li", 8);
        ɵngcc0.ɵɵtemplate(12, TabHeaderGroup_ng_container_12_Template, 1, 1, "ng-container", 9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(13, TabHeaderGroup_div_13_Template, 1, 0, "div", 10);
        ɵngcc0.ɵɵelementStart(14, "button", 1, 11);
        ɵngcc0.ɵɵlistener("click", function TabHeaderGroup_Template_button_click_14_listener() { return ctx.handleOverflowNavClick(1); })("mousedown", function TabHeaderGroup_Template_button_mousedown_14_listener() { return ctx.handleOverflowNavMouseDown(1); })("mouseup", function TabHeaderGroup_Template_button_mouseup_14_listener() { return ctx.handleOverflowNavMouseUp(); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(16, "svg", 3);
        ɵngcc0.ɵɵelement(17, "path", 12);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(9, _c7, ctx.skeleton, ctx.type === "container"));
        ɵngcc0.ɵɵattribute("aria-label", ctx.ariaLabel)("aria-labelledby", ctx.ariaLabelledby);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(12, _c8, ctx.hasHorizontalOverflow, ctx.leftOverflowNavButtonHidden));
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.leftOverflowNavButtonHidden);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.contentBefore);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.contentAfter);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.rightOverflowNavButtonHidden);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(15, _c8, ctx.hasHorizontalOverflow, ctx.rightOverflowNavButtonHidden));
    } }, directives: [ɵngcc1.NgClass, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], encapsulation: 2 });
/** @nocollapse */
TabHeaderGroup.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: EventService }
];
TabHeaderGroup.propDecorators = {
    followFocus: [{ type: Input }],
    skeleton: [{ type: Input }],
    ariaLabel: [{ type: Input }],
    ariaLabelledby: [{ type: Input }],
    contentAfter: [{ type: Input }],
    contentBefore: [{ type: Input }],
    cacheActive: [{ type: Input }],
    isNavigation: [{ type: Input }],
    type: [{ type: Input }],
    tabHeaderQuery: [{ type: ContentChildren, args: [TabHeader,] }],
    headerContainer: [{ type: ViewChild, args: ["tabList", { static: true },] }],
    rightOverflowNavButton: [{ type: ViewChild, args: ["rightOverflowNavButton", { static: true },] }],
    leftOverflowNavButton: [{ type: ViewChild, args: ["leftOverflowNavButton", { static: true },] }],
    keyboardInput: [{ type: HostListener, args: ["keydown", ["$event"],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabHeaderGroup, [{
        type: Component,
        args: [{
                selector: "ibm-tab-header-group",
                template: `
	<nav
		class="bx--tabs bx--tabs--scrollable"
		[ngClass]="{
			'bx--skeleton': skeleton,
			'bx--tabs--container bx--tabs--scrollable--container': type === 'container'
		}"
		role="navigation"
		[attr.aria-label]="ariaLabel"
		[attr.aria-labelledby]="ariaLabelledby">
		<button
			#leftOverflowNavButton
			type="button"
			[ngClass]="{
				'bx--tab--overflow-nav-button': hasHorizontalOverflow,
				'bx--tab--overflow-nav-button--hidden': leftOverflowNavButtonHidden
			}"
			(click)="handleOverflowNavClick(-1)"
			(mousedown)="handleOverflowNavMouseDown(-1)"
			(mouseup)="handleOverflowNavMouseUp()">
			<svg
				focusable="false"
				preserveAspectRatio="xMidYMid meet"
				xmlns="http://www.w3.org/2000/svg"
				fill="currentColor"
				width="16"
				height="16"
				viewBox="0 0 16 16"
				aria-hidden="true">
				<path d="M5 8L10 3 10.7 3.7 6.4 8 10.7 12.3 10 13z"></path>
			</svg>
		</button>
		<div *ngIf="!leftOverflowNavButtonHidden" class="bx--tabs__overflow-indicator--left"></div>
		<ul
			#tabList
			class="bx--tabs--scrollable__nav"
			role="tablist"
			(scroll)="handleScroll()">
			<li role="presentation">
				<ng-container *ngIf="contentBefore" [ngTemplateOutlet]="contentBefore"></ng-container>
			</li>
			<ng-content></ng-content>
			<li role="presentation">
				<ng-container *ngIf="contentAfter" [ngTemplateOutlet]="contentAfter"></ng-container>
			</li>
		</ul>
		<div *ngIf="!rightOverflowNavButtonHidden" class="bx--tabs__overflow-indicator--right"></div>
		<button
			#rightOverflowNavButton
			type="button"
			[ngClass]="{
				'bx--tab--overflow-nav-button': hasHorizontalOverflow,
				'bx--tab--overflow-nav-button--hidden': rightOverflowNavButtonHidden
			}"
			(click)="handleOverflowNavClick(1)"
			(mousedown)="handleOverflowNavMouseDown(1)"
			(mouseup)="handleOverflowNavMouseUp()">
			<svg
				focusable="false"
				preserveAspectRatio="xMidYMid meet"
				xmlns="http://www.w3.org/2000/svg"
				fill="currentColor"
				width="16"
				height="16"
				viewBox="0 0 16 16"
				aria-hidden="true">
				<path d="M11 8L6 13 5.3 12.3 9.6 8 5.3 3.7 6 3z"></path>
			</svg>
		</button>
	</nav>
	`
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc2.EventService }]; }, { skeleton: [{
            type: Input
        }], cacheActive: [{
            type: Input
        }], isNavigation: [{
            type: Input
        }], type: [{
            type: Input
        }], 
    // keyboard accessibility
    /**
     * Controls the keydown events used for tabbing through the headings.
     */
    keyboardInput: [{
            type: HostListener,
            args: ["keydown", ["$event"]]
        }], followFocus: [{
            type: Input
        }], ariaLabel: [{
            type: Input
        }], ariaLabelledby: [{
            type: Input
        }], contentAfter: [{
            type: Input
        }], contentBefore: [{
            type: Input
        }], tabHeaderQuery: [{
            type: ContentChildren,
            args: [TabHeader]
        }], headerContainer: [{
            type: ViewChild,
            args: ["tabList", { static: true }]
        }], rightOverflowNavButton: [{
            type: ViewChild,
            args: ["rightOverflowNavButton", { static: true }]
        }], leftOverflowNavButton: [{
            type: ViewChild,
            args: ["leftOverflowNavButton", { static: true }]
        }] }); })();

/**
 * The `TabHeaders` component contains the `Tab` items and controls scroll functionality
 * if content has overflow.
 */
class TabHeaders {
    constructor(elementRef, changeDetectorRef, eventService) {
        this.elementRef = elementRef;
        this.changeDetectorRef = changeDetectorRef;
        this.eventService = eventService;
        /**
         * Set to 'true' to have `Tab` items cached and not reloaded on tab switching.
         * Duplicate from `n-tabs` to support standalone headers
         */
        this.cacheActive = false;
        /**
         * Set to `true` to put tabs in a loading state.
         */
        this.skeleton = false;
        this.type = "default";
        /**
         * The index of the first visible tab.
         */
        this.firstVisibleTab = 0;
        // width of the overflow buttons
        this.OVERFLOW_BUTTON_OFFSET = 40;
    }
    get hasHorizontalOverflow() {
        const tabList = this.headerContainer.nativeElement;
        return tabList.scrollWidth > tabList.clientWidth;
    }
    get leftOverflowNavButtonHidden() {
        const tabList = this.headerContainer.nativeElement;
        return !this.hasHorizontalOverflow || !tabList.scrollLeft;
    }
    get rightOverflowNavButtonHidden() {
        const tabList = this.headerContainer.nativeElement;
        return !this.hasHorizontalOverflow ||
            (tabList.scrollLeft + tabList.clientWidth) === tabList.scrollWidth;
    }
    // keyboard accessibility
    /**
     * Controls the keydown events used for tabbing through the headings.
     */
    keyboardInput(event) {
        let tabsArray = Array.from(this.tabs);
        // "Right" is an ie11 specific value
        if (event.key === "Right" || event.key === "ArrowRight") {
            if (this.currentSelectedTab < this.allTabHeaders.length - 1) {
                event.preventDefault();
                if (this.followFocus) {
                    this.selectTab(event.target, tabsArray[this.currentSelectedTab + 1], this.currentSelectedTab);
                }
                this.allTabHeaders.toArray()[this.currentSelectedTab + 1].nativeElement.focus();
            }
            else {
                event.preventDefault();
                if (this.followFocus) {
                    this.selectTab(event.target, tabsArray[0], 0);
                }
                this.allTabHeaders.first.nativeElement.focus();
            }
        }
        // "Left" is an ie11 specific value
        if (event.key === "Left" || event.key === "ArrowLeft") {
            if (this.currentSelectedTab > 0) {
                event.preventDefault();
                if (this.followFocus) {
                    this.selectTab(event.target, tabsArray[this.currentSelectedTab - 1], this.currentSelectedTab);
                }
                this.allTabHeaders.toArray()[this.currentSelectedTab - 1].nativeElement.focus();
            }
            else {
                event.preventDefault();
                if (this.followFocus) {
                    this.selectTab(event.target, tabsArray[this.allTabHeaders.length - 1], this.allTabHeaders.length);
                }
                this.allTabHeaders.toArray()[this.allTabHeaders.length - 1].nativeElement.focus();
            }
        }
        if (event.key === "Home") {
            event.preventDefault();
            if (this.followFocus) {
                this.selectTab(event.target, tabsArray[0], 0);
            }
            this.allTabHeaders.toArray()[0].nativeElement.focus();
        }
        if (event.key === "End") {
            event.preventDefault();
            if (this.followFocus) {
                this.selectTab(event.target, tabsArray[this.allTabHeaders.length - 1], this.allTabHeaders.length);
            }
            this.allTabHeaders.toArray()[this.allTabHeaders.length - 1].nativeElement.focus();
        }
        // `"Spacebar"` is IE11 specific value
        if ((event.key === " " || event.key === "Spacebar") && !this.followFocus) {
            this.selectTab(event.target, tabsArray[this.currentSelectedTab], this.currentSelectedTab);
        }
    }
    ngOnInit() {
        this.eventService.on(window, "resize", () => this.handleScroll());
    }
    ngAfterContentInit() {
        if (!this.tabInput) {
            this.tabs = this.tabQuery;
        }
        else {
            this.tabs = this.tabInput;
        }
        this.tabs.forEach(tab => tab.cacheActive = this.cacheActive);
        this.tabs.changes.subscribe(() => {
            this.setFirstTab();
        });
        this.setFirstTab();
    }
    ngOnChanges(changes) {
        if (this.tabs && changes.cacheActive) {
            this.tabs.forEach(tab => tab.cacheActive = this.cacheActive);
        }
    }
    /**
     * Controls manually focusing tabs.
     */
    onTabFocus(ref, index) {
        this.currentSelectedTab = index;
        // reset scroll left because we're already handling it
        this.headerContainer.nativeElement.parentElement.scrollLeft = 0;
    }
    getSelectedTab() {
        const selected = this.tabs.find(tab => tab.active);
        if (selected) {
            return selected;
        }
        return { headingIsTemplate: false, heading: "" };
    }
    /**
     * Selects `Tab` 'tab' and moves it into view on the view DOM if it is not already.
     */
    selectTab(ref, tab, tabIndex) {
        if (tab.disabled) {
            return;
        }
        this.currentSelectedTab = tabIndex;
        this.tabs.forEach(_tab => _tab.active = false);
        tab.active = true;
        tab.doSelect();
    }
    handleScroll() {
        this.changeDetectorRef.markForCheck();
    }
    handleOverflowNavClick(direction, multiplier = 15) {
        const tabList = this.headerContainer.nativeElement;
        const { clientWidth, scrollLeft, scrollWidth } = tabList;
        if (direction === 1 && !scrollLeft) {
            tabList.scrollLeft += this.OVERFLOW_BUTTON_OFFSET;
        }
        tabList.scrollLeft += direction * multiplier;
        const leftEdgeReached = direction === -1 && scrollLeft < this.OVERFLOW_BUTTON_OFFSET;
        const rightEdgeReached = direction === 1 &&
            scrollLeft + clientWidth >= scrollWidth - this.OVERFLOW_BUTTON_OFFSET;
        if (leftEdgeReached) {
            this.rightOverflowNavButton.nativeElement.focus();
        }
        if (rightEdgeReached) {
            this.leftOverflowNavButton.nativeElement.focus();
        }
    }
    handleOverflowNavMouseDown(direction) {
        const tabList = this.headerContainer.nativeElement;
        this.overflowNavInterval = setInterval(() => {
            const { clientWidth, scrollLeft, scrollWidth } = tabList;
            // clear interval if scroll reaches left or right edge
            const leftEdgeReached = direction === -1 && scrollLeft < this.OVERFLOW_BUTTON_OFFSET;
            const rightEdgeReached = direction === 1 &&
                scrollLeft + clientWidth >= scrollWidth - this.OVERFLOW_BUTTON_OFFSET;
            if (leftEdgeReached || rightEdgeReached) {
                clearInterval(this.overflowNavInterval);
            }
            // account for overflow button appearing and causing tablist width change
            this.handleOverflowNavClick(direction);
        });
    }
    handleOverflowNavMouseUp() {
        clearInterval(this.overflowNavInterval);
    }
    /**
     * Determines which `Tab` is initially selected.
     */
    setFirstTab() {
        setTimeout(() => {
            let firstTab = this.tabs.find(tab => tab.active);
            if (!firstTab && this.tabs.first) {
                firstTab = this.tabs.first;
                firstTab.active = true;
            }
            if (firstTab) {
                firstTab.doSelect();
            }
        });
    }
}
TabHeaders.ɵfac = function TabHeaders_Factory(t) { return new (t || TabHeaders)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.EventService)); };
TabHeaders.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TabHeaders, selectors: [["ibm-tab-headers"]], contentQueries: function TabHeaders_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, Tab, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabQuery = _t);
    } }, viewQuery: function TabHeaders_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c4, 3);
        ɵngcc0.ɵɵviewQuery(_c5, 3);
        ɵngcc0.ɵɵviewQuery(_c6, 3);
        ɵngcc0.ɵɵviewQuery(_c2, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rightOverflowNavButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.leftOverflowNavButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.allTabHeaders = _t);
    } }, hostBindings: function TabHeaders_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function TabHeaders_keydown_HostBindingHandler($event) { return ctx.keyboardInput($event); });
    } }, inputs: { cacheActive: "cacheActive", skeleton: "skeleton", type: "type", tabInput: ["tabs", "tabInput"], followFocus: "followFocus", ariaLabel: "ariaLabel", ariaLabelledby: "ariaLabelledby", contentBefore: "contentBefore", contentAfter: "contentAfter" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 18, vars: 19, consts: [["role", "navigation", 1, "bx--tabs--scrollable", 3, "ngClass"], ["type", "button", 3, "ngClass", "click", "mousedown", "mouseup"], ["leftOverflowNavButton", ""], ["focusable", "false", "preserveAspectRatio", "xMidYMid meet", "xmlns", "http://www.w3.org/2000/svg", "fill", "currentColor", "width", "16", "height", "16", "viewBox", "0 0 16 16", "aria-hidden", "true"], ["d", "M5 8L10 3 10.7 3.7 6.4 8 10.7 12.3 10 13z"], ["class", "bx--tabs__overflow-indicator--left", 4, "ngIf"], ["role", "tablist", 1, "bx--tabs--scrollable__nav", 3, "scroll"], ["tabList", ""], ["role", "presentation"], [3, "ngTemplateOutlet", 4, "ngIf"], ["class", "bx--tabs--scrollable__nav-item", "role", "presentation", 3, "ngClass", "click", 4, "ngFor", "ngForOf"], ["class", "bx--tabs__overflow-indicator--right", 4, "ngIf"], ["rightOverflowNavButton", ""], ["d", "M11 8L6 13 5.3 12.3 9.6 8 5.3 3.7 6 3z"], [1, "bx--tabs__overflow-indicator--left"], [3, "ngTemplateOutlet"], ["role", "presentation", 1, "bx--tabs--scrollable__nav-item", 3, "ngClass", "click"], ["draggable", "false", "href", "#", "role", "tab", 1, "bx--tabs--scrollable__nav-link", 3, "id", "title", "focus", "click"], ["tabItem", ""], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "bx--tabs__overflow-indicator--right"]], template: function TabHeaders_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "nav", 0);
        ɵngcc0.ɵɵelementStart(1, "button", 1, 2);
        ɵngcc0.ɵɵlistener("click", function TabHeaders_Template_button_click_1_listener() { return ctx.handleOverflowNavClick(-1); })("mousedown", function TabHeaders_Template_button_mousedown_1_listener() { return ctx.handleOverflowNavMouseDown(-1); })("mouseup", function TabHeaders_Template_button_mouseup_1_listener() { return ctx.handleOverflowNavMouseUp(); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(3, "svg", 3);
        ɵngcc0.ɵɵelement(4, "path", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, TabHeaders_div_5_Template, 1, 0, "div", 5);
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelementStart(6, "ul", 6, 7);
        ɵngcc0.ɵɵlistener("scroll", function TabHeaders_Template_ul_scroll_6_listener() { return ctx.handleScroll(); });
        ɵngcc0.ɵɵelementStart(8, "li", 8);
        ɵngcc0.ɵɵtemplate(9, TabHeaders_ng_container_9_Template, 1, 1, "ng-container", 9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, TabHeaders_li_10_Template, 5, 12, "li", 10);
        ɵngcc0.ɵɵelementStart(11, "li", 8);
        ɵngcc0.ɵɵtemplate(12, TabHeaders_ng_container_12_Template, 1, 1, "ng-container", 9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(13, TabHeaders_div_13_Template, 1, 0, "div", 11);
        ɵngcc0.ɵɵelementStart(14, "button", 1, 12);
        ɵngcc0.ɵɵlistener("click", function TabHeaders_Template_button_click_14_listener() { return ctx.handleOverflowNavClick(1); })("mousedown", function TabHeaders_Template_button_mousedown_14_listener() { return ctx.handleOverflowNavMouseDown(1); })("mouseup", function TabHeaders_Template_button_mouseup_14_listener() { return ctx.handleOverflowNavMouseUp(); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(16, "svg", 3);
        ɵngcc0.ɵɵelement(17, "path", 13);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(10, _c7, ctx.skeleton, ctx.type === "container"));
        ɵngcc0.ɵɵattribute("aria-label", ctx.ariaLabel)("aria-labelledby", ctx.ariaLabelledby);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(13, _c8, ctx.hasHorizontalOverflow, ctx.leftOverflowNavButtonHidden));
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.leftOverflowNavButtonHidden);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.contentBefore);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.tabs);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.contentAfter);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.rightOverflowNavButtonHidden);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(16, _c8, ctx.hasHorizontalOverflow, ctx.rightOverflowNavButtonHidden));
    } }, directives: [ɵngcc1.NgClass, ɵngcc1.NgIf, ɵngcc1.NgForOf, ɵngcc1.NgTemplateOutlet], encapsulation: 2 });
/** @nocollapse */
TabHeaders.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: EventService }
];
TabHeaders.propDecorators = {
    tabInput: [{ type: Input, args: ["tabs",] }],
    cacheActive: [{ type: Input }],
    followFocus: [{ type: Input }],
    skeleton: [{ type: Input }],
    ariaLabel: [{ type: Input }],
    ariaLabelledby: [{ type: Input }],
    contentBefore: [{ type: Input }],
    contentAfter: [{ type: Input }],
    type: [{ type: Input }],
    headerContainer: [{ type: ViewChild, args: ["tabList", { static: true },] }],
    rightOverflowNavButton: [{ type: ViewChild, args: ["rightOverflowNavButton", { static: true },] }],
    leftOverflowNavButton: [{ type: ViewChild, args: ["leftOverflowNavButton", { static: true },] }],
    tabQuery: [{ type: ContentChildren, args: [Tab,] }],
    allTabHeaders: [{ type: ViewChildren, args: ["tabItem",] }],
    keyboardInput: [{ type: HostListener, args: ["keydown", ["$event"],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabHeaders, [{
        type: Component,
        args: [{
                selector: "ibm-tab-headers",
                template: `
		<nav
			class="bx--tabs--scrollable"
			[ngClass]="{
				'bx--skeleton': skeleton,
				'bx--tabs--container bx--tabs--scrollable--container': type === 'container'
			}"
			role="navigation"
			[attr.aria-label]="ariaLabel"
			[attr.aria-labelledby]="ariaLabelledby">
			<button
				#leftOverflowNavButton
				type="button"
				[ngClass]="{
					'bx--tab--overflow-nav-button': hasHorizontalOverflow,
					'bx--tab--overflow-nav-button--hidden': leftOverflowNavButtonHidden
				}"
				(click)="handleOverflowNavClick(-1)"
				(mousedown)="handleOverflowNavMouseDown(-1)"
				(mouseup)="handleOverflowNavMouseUp()">
				<svg
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					xmlns="http://www.w3.org/2000/svg"
					fill="currentColor"
					width="16"
					height="16"
					viewBox="0 0 16 16"
					aria-hidden="true">
					<path d="M5 8L10 3 10.7 3.7 6.4 8 10.7 12.3 10 13z"></path>
				</svg>
			</button>
			<div *ngIf="!leftOverflowNavButtonHidden" class="bx--tabs__overflow-indicator--left"></div>
			<ul
				#tabList
				class="bx--tabs--scrollable__nav"
				role="tablist"
				(scroll)="handleScroll()">
				<li role="presentation">
					<ng-container *ngIf="contentBefore" [ngTemplateOutlet]="contentBefore"></ng-container>
				</li>
				<li
					*ngFor="let tab of tabs; let i = index;"
					[ngClass]="{
						'bx--tabs__nav-item--selected bx--tabs--scrollable__nav-item--selected': tab.active,
						'bx--tabs__nav-item--disabled bx--tabs--scrollable__nav-item--disabled': tab.disabled
					}"
					class="bx--tabs--scrollable__nav-item"
					role="presentation"
					(click)="selectTab(tabItem, tab, i)">
					<button
						#tabItem
						[attr.aria-selected]="tab.active"
						[attr.tabindex]="(tab.active?0:-1)"
						[attr.aria-controls]="tab.id"
						[attr.aria-disabled]="tab.disabled"
						(focus)="onTabFocus(tabItem, i)"
						(click)="$event.preventDefault()"
						draggable="false"
						id="{{tab.id}}-header"
						class="bx--tabs--scrollable__nav-link"
						[title]="tab.title ? tab.title : tab.heading"
						href="#"
						role="tab">
						<ng-container *ngIf="!tab.headingIsTemplate">
							{{ tab.heading }}
						</ng-container>
						<ng-template
							*ngIf="tab.headingIsTemplate"
							[ngTemplateOutlet]="tab.heading"
							[ngTemplateOutletContext]="{$implicit: tab.context}">
						</ng-template>
					</button>
				</li>
				<li role="presentation">
					<ng-container *ngIf="contentAfter" [ngTemplateOutlet]="contentAfter"></ng-container>
				</li>
			</ul>
			<div *ngIf="!rightOverflowNavButtonHidden" class="bx--tabs__overflow-indicator--right"></div>
			<button
				#rightOverflowNavButton
				type="button"
				[ngClass]="{
					'bx--tab--overflow-nav-button': hasHorizontalOverflow,
					'bx--tab--overflow-nav-button--hidden': rightOverflowNavButtonHidden
				}"
				(click)="handleOverflowNavClick(1)"
				(mousedown)="handleOverflowNavMouseDown(1)"
				(mouseup)="handleOverflowNavMouseUp()">
				<svg
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					xmlns="http://www.w3.org/2000/svg"
					fill="currentColor"
					width="16"
					height="16"
					viewBox="0 0 16 16"
					aria-hidden="true">
					<path d="M11 8L6 13 5.3 12.3 9.6 8 5.3 3.7 6 3z"></path>
				</svg>
			</button>
		</nav>
	`
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc2.EventService }]; }, { cacheActive: [{
            type: Input
        }], skeleton: [{
            type: Input
        }], type: [{
            type: Input
        }], 
    // keyboard accessibility
    /**
     * Controls the keydown events used for tabbing through the headings.
     */
    keyboardInput: [{
            type: HostListener,
            args: ["keydown", ["$event"]]
        }], tabInput: [{
            type: Input,
            args: ["tabs"]
        }], followFocus: [{
            type: Input
        }], ariaLabel: [{
            type: Input
        }], ariaLabelledby: [{
            type: Input
        }], contentBefore: [{
            type: Input
        }], contentAfter: [{
            type: Input
        }], headerContainer: [{
            type: ViewChild,
            args: ["tabList", { static: true }]
        }], rightOverflowNavButton: [{
            type: ViewChild,
            args: ["rightOverflowNavButton", { static: true }]
        }], leftOverflowNavButton: [{
            type: ViewChild,
            args: ["leftOverflowNavButton", { static: true }]
        }], tabQuery: [{
            type: ContentChildren,
            args: [Tab]
        }], allTabHeaders: [{
            type: ViewChildren,
            args: ["tabItem"]
        }] }); })();

/**
 * Build out your application's tabs using this component.
 * This is the parent of the `Tab` and `TabHeader` components.
 *
 * [See demo](../../?path=/story/tabs--basic)
 *
 * `Tabs` expects a set of `n-tab` elements
 *
 * ```html
 * <ibm-tabs>
 * 	<ibm-tab heading='tab1'>
 * 		tab 1 content
 * 	</ibm-tab>
 * 	<ibm-tab heading='tab1'>
 * 		tab 2 content
 * 	</ibm-tab>
 * 	<!-- ... -->
 * 	<ibm-tab heading='tab1'>
 * 		tab n content
 * 	</ibm-tab>
 * </ibm-tabs>
 * ```
 *
 * <example-url>../../iframe.html?id=tabs--basic</example-url>
 */
class Tabs {
    constructor() {
        /**
         * Takes either the string value 'top' or 'bottom' to place TabHeader
         * relative to the `TabPanel`s.
         */
        this.position = "top";
        /**
         * Set to 'true' to have `Tab` items cached and not reloaded on tab switching.
         */
        this.cacheActive = false;
        /**
         * Set to 'true' to have tabs automatically activated and have their content displayed when they receive focus.
         */
        this.followFocus = true;
        /**
         * Set to `true` to put tabs in a loading state.
         */
        this.skeleton = false;
        /**
         * Set to `true` to have the tabIndex of the all tabpanels be -1.
         */
        this.isNavigation = false;
        /**
         * Sets the type of the `TabHeader`s
         */
        this.type = "default";
    }
    /**
     * After content is initialized update `Tab`s to cache (if turned on) and set the initial
     * selected Tab item.
     */
    ngAfterContentInit() {
        if (this.tabHeaders) {
            this.tabHeaders.cacheActive = this.cacheActive;
        }
        this.tabs.forEach(tab => {
            tab.tabIndex = this.isNavigation ? null : 0;
        });
    }
    ngOnChanges(changes) {
        if (this.tabHeaders && changes.cacheActive) {
            this.tabHeaders.cacheActive = this.cacheActive;
        }
        if (this.tabs && changes.isNavigation) {
            this.tabs.forEach(tab => {
                tab.tabIndex = this.isNavigation ? null : 0;
            });
        }
    }
    /**
     * true if the n-tab's are passed directly to the component as children
     */
    hasTabHeaders() {
        return this.tabs.length > 0;
    }
}
Tabs.ɵfac = function Tabs_Factory(t) { return new (t || Tabs)(); };
Tabs.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: Tabs, selectors: [["ibm-tabs"]], contentQueries: function Tabs_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TabHeaders, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, Tab, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabHeaders = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabs = _t);
    } }, inputs: { position: "position", cacheActive: "cacheActive", followFocus: "followFocus", skeleton: "skeleton", isNavigation: "isNavigation", type: "type", ariaLabel: "ariaLabel", ariaLabelledby: "ariaLabelledby" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c11, decls: 7, vars: 2, consts: [[3, "skeleton", "tabs", "followFocus", "cacheActive", "contentBefore", "contentAfter", "ariaLabel", "ariaLabelledby", "type", 4, "ngIf"], ["before", ""], ["after", ""], [3, "skeleton", "tabs", "cacheActive", "type", 4, "ngIf"], [3, "skeleton", "tabs", "followFocus", "cacheActive", "contentBefore", "contentAfter", "ariaLabel", "ariaLabelledby", "type"], [3, "skeleton", "tabs", "cacheActive", "type"]], template: function Tabs_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c10);
        ɵngcc0.ɵɵtemplate(0, Tabs_ibm_tab_headers_0_Template, 1, 9, "ibm-tab-headers", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵtemplate(2, Tabs_ng_template_2_Template, 1, 0, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, Tabs_ng_template_4_Template, 1, 0, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, Tabs_ibm_tab_headers_6_Template, 1, 4, "ibm-tab-headers", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasTabHeaders() && ctx.position === "top");
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasTabHeaders() && ctx.position === "bottom");
    } }, directives: [ɵngcc1.NgIf, TabHeaders], encapsulation: 2 });
Tabs.propDecorators = {
    position: [{ type: Input }],
    cacheActive: [{ type: Input }],
    followFocus: [{ type: Input }],
    skeleton: [{ type: Input }],
    isNavigation: [{ type: Input }],
    ariaLabel: [{ type: Input }],
    ariaLabelledby: [{ type: Input }],
    type: [{ type: Input }],
    tabs: [{ type: ContentChildren, args: [Tab, { descendants: false },] }],
    tabHeaders: [{ type: ContentChild, args: [TabHeaders, { static: false },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Tabs, [{
        type: Component,
        args: [{
                selector: "ibm-tabs",
                template: `
			<ibm-tab-headers
				*ngIf="hasTabHeaders() && position === 'top'"
				[skeleton]="skeleton"
				[tabs]="tabs"
				[followFocus]="followFocus"
				[cacheActive]="cacheActive"
				[contentBefore]="before"
				[contentAfter]="after"
				[ariaLabel]="ariaLabel"
				[ariaLabelledby]="ariaLabelledby"
				[type]="type">
			</ibm-tab-headers>
			<ng-content></ng-content>
			<ng-template #before>
				<ng-content select="[before]"></ng-content>
			</ng-template>
			<ng-template #after>
				<ng-content select="[after]"></ng-content>
			</ng-template>
			<ibm-tab-headers
				*ngIf="hasTabHeaders() && position === 'bottom'"
				[skeleton]="skeleton"
				[tabs]="tabs"
				[cacheActive]="cacheActive"
				[type]="type">
			</ibm-tab-headers>
	`
            }]
    }], function () { return []; }, { position: [{
            type: Input
        }], cacheActive: [{
            type: Input
        }], followFocus: [{
            type: Input
        }], skeleton: [{
            type: Input
        }], isNavigation: [{
            type: Input
        }], type: [{
            type: Input
        }], ariaLabel: [{
            type: Input
        }], ariaLabelledby: [{
            type: Input
        }], tabs: [{
            type: ContentChildren,
            args: [Tab, { descendants: false }]
        }], tabHeaders: [{
            type: ContentChild,
            args: [TabHeaders, { static: false }]
        }] }); })();

class TabsModule {
}
TabsModule.ɵfac = function TabsModule_Factory(t) { return new (t || TabsModule)(); };
TabsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TabsModule });
TabsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            UtilsModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TabsModule, { declarations: function () { return [Tabs, Tab, TabHeaders, TabHeader, TabHeaderGroup]; }, imports: function () { return [CommonModule,
        UtilsModule]; }, exports: function () { return [Tabs, Tab, TabHeaders, TabHeader, TabHeaderGroup]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabsModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    Tabs,
                    Tab,
                    TabHeaders,
                    TabHeader,
                    TabHeaderGroup
                ],
                exports: [
                    Tabs,
                    Tab,
                    TabHeaders,
                    TabHeader,
                    TabHeaderGroup
                ],
                imports: [
                    CommonModule,
                    UtilsModule
                ]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { TabHeaderGroup, TabHeader, TabHeaders, Tab, Tabs, TabsModule };

//# sourceMappingURL=carbon-components-angular-tabs.js.map