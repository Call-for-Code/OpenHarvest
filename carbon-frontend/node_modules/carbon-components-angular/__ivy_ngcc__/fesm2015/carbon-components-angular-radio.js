/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-radio.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Component, Input, HostBinding, Output, EventEmitter, ContentChildren, forwardRef, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';

/**
 * Used to emit changes performed on a `Radio`.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

function Radio_input_0_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "input", 4);
    ɵngcc0.ɵɵlistener("change", function Radio_input_0_Template_input_change_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onChange($event); })("click", function Radio_input_0_Template_input_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.onClick($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("checked", ctx_r0.checked)("disabled", ctx_r0.disabled)("name", ctx_r0.name)("id", ctx_r0.id)("required", ctx_r0.required)("value", ctx_r0.value);
    ɵngcc0.ɵɵattribute("aria-labelledby", ctx_r0.ariaLabelledby);
} }
function Radio_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 5);
} }
const _c0 = function (a0) { return { "bx--skeleton": a0 }; };
const _c1 = ["*"];
const _c2 = function (a0, a1) { return { "bx--radio-button-group--vertical": a0, "bx--radio-button-group--label-left": a1 }; };
class RadioChange {
    constructor(source, value) {
        this.source = source;
        this.value = value;
    }
}

/**
 * class: Radio (extends Checkbox)
 *
 * selector: `n-radio`
 *
 * source: `src/forms/radio.component.ts`
 *
 * ```html
 * <ibm-radio [(ngModel)]="radioState">Radio</ibm-radio>
 * ```
 *
 * Also see: [`RadioGroup`](#ibm-radio-group)
 */
class Radio {
    constructor() {
        this.checked = false;
        this.name = "";
        this.disabled = false;
        this.labelPlacement = "right";
        /**
         * Used to set the `aria-label` attribute on the input label.
         */
        this.ariaLabel = "";
        /**
         * Sets the HTML required attribute
         */
        this.required = false;
        /**
         * The value of the `Radio`.
         */
        this.value = "";
        /**
         * Set to `true` for a loading table.
         */
        this.skeleton = false;
        /**
         * The id for the `Radio`.
         */
        this.id = `radio-${Radio.radioCount++}`;
        /**
         * emits when the state of the radio changes
         */
        this.change = new EventEmitter();
        this.hostClass = true;
        this._labelledby = "";
        /**
         * Handler provided by the `RadioGroup` to bubble events up
         */
        this.radioChangeHandler = (event) => { };
    }
    set ariaLabelledby(value) {
        this._labelledby = value;
    }
    get ariaLabelledby() {
        if (this._labelledby) {
            return this._labelledby;
        }
        return `label-${this.id}`;
    }
    get labelLeft() {
        return this.labelPlacement === "left";
    }
    /**
     * Synchronizes with the `RadioGroup` in the event of a changed `Radio`.
     * Emits the changes of both the `RadioGroup` and `Radio`.
     */
    onChange(event) {
        event.stopPropagation();
    }
    onClick(event) {
        this.checked = event.target.checked;
        const radioEvent = new RadioChange(this, this.value);
        this.change.emit(radioEvent);
        this.radioChangeHandler(radioEvent);
    }
    /**
     * Method called by `RadioGroup` with a callback function to bubble `RadioChange` events
     * @param fn callback that expects a `RadioChange` as an argument
     */
    registerRadioChangeHandler(fn) {
        this.radioChangeHandler = fn;
    }
}
Radio.ɵfac = function Radio_Factory(t) { return new (t || Radio)(); };
Radio.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: Radio, selectors: [["ibm-radio"]], hostVars: 4, hostBindings: function Radio_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--radio-button-wrapper", ctx.hostClass)("bx--radio-button-wrapper--label-left", ctx.labelLeft);
    } }, inputs: { checked: "checked", name: "name", disabled: "disabled", labelPlacement: "labelPlacement", ariaLabel: "ariaLabel", required: "required", value: "value", skeleton: "skeleton", id: "id", ariaLabelledby: "ariaLabelledby" }, outputs: { change: "change" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: Radio,
                multi: true
            }
        ])], ngContentSelectors: _c1, decls: 5, vars: 8, consts: [["class", "bx--radio-button", "type", "radio", 3, "checked", "disabled", "name", "id", "required", "value", "change", "click", 4, "ngIf"], ["class", "bx--radio-button bx--skeleton", 4, "ngIf"], [1, "bx--radio-button__label", 3, "ngClass", "for", "id"], [1, "bx--radio-button__appearance"], ["type", "radio", 1, "bx--radio-button", 3, "checked", "disabled", "name", "id", "required", "value", "change", "click"], [1, "bx--radio-button", "bx--skeleton"]], template: function Radio_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, Radio_input_0_Template, 1, 7, "input", 0);
        ɵngcc0.ɵɵtemplate(1, Radio_div_1_Template, 1, 0, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "label", 2);
        ɵngcc0.ɵɵelement(3, "span", 3);
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.skeleton);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.skeleton);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵpropertyInterpolate1("id", "label-", ctx.id, "");
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(6, _c0, ctx.skeleton))("for", ctx.id);
        ɵngcc0.ɵɵattribute("aria-label", ctx.ariaLabel);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass], encapsulation: 2 });
/**
 * Used to dynamically create unique ids for the `Radio`.
 */
Radio.radioCount = 0;
Radio.propDecorators = {
    checked: [{ type: Input }],
    name: [{ type: Input }],
    disabled: [{ type: Input }],
    labelPlacement: [{ type: Input }],
    ariaLabelledby: [{ type: Input }],
    ariaLabel: [{ type: Input }],
    required: [{ type: Input }],
    value: [{ type: Input }],
    skeleton: [{ type: Input }],
    id: [{ type: Input }],
    change: [{ type: Output }],
    hostClass: [{ type: HostBinding, args: ["class.bx--radio-button-wrapper",] }],
    labelLeft: [{ type: HostBinding, args: ["class.bx--radio-button-wrapper--label-left",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Radio, [{
        type: Component,
        args: [{
                selector: "ibm-radio",
                template: `
		<input
			*ngIf="!skeleton"
			class="bx--radio-button"
			type="radio"
			[checked]="checked"
			[disabled]="disabled"
			[name]="name"
			[id]="id"
			[required]="required"
			[value]="value"
			[attr.aria-labelledby]="ariaLabelledby"
			(change)="onChange($event)"
			(click)="onClick($event)">
		<div *ngIf="skeleton" class="bx--radio-button bx--skeleton"></div>
		<label
			class="bx--radio-button__label"
			[attr.aria-label]="ariaLabel"
			[ngClass]="{
				'bx--skeleton': skeleton
			}"
			[for]="id"
			id="label-{{id}}">
			<span class="bx--radio-button__appearance"></span>
			<ng-content></ng-content>
		</label>
	`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: Radio,
                        multi: true
                    }
                ]
            }]
    }], function () { return []; }, { checked: [{
            type: Input
        }], name: [{
            type: Input
        }], disabled: [{
            type: Input
        }], labelPlacement: [{
            type: Input
        }], ariaLabel: [{
            type: Input
        }], required: [{
            type: Input
        }], value: [{
            type: Input
        }], skeleton: [{
            type: Input
        }], id: [{
            type: Input
        }], change: [{
            type: Output
        }], hostClass: [{
            type: HostBinding,
            args: ["class.bx--radio-button-wrapper"]
        }], ariaLabelledby: [{
            type: Input
        }], labelLeft: [{
            type: HostBinding,
            args: ["class.bx--radio-button-wrapper--label-left"]
        }] }); })();

/**
 * [See demo](../../?path=/story/radio--basic)
 *
 * class: RadioGroup
 *
 * selector: `ibm-radio-group`
 *
 * source: `src/forms/radio.component.ts`
 *
 *
 * Ex:
 * ```html
 * <ibm-radio-group [(ngModel)]="radio">
 * 	<ibm-radio *ngFor="let one of manyRadios" [value]="one">
 *		Radio {{one}}
 * 	</ibm-radio>
 * </ibm-radio-group>
 *
 * Radio selected: {{radio}}
 * ```
 *
 * ```typescript
 * manyRadios = ["one", "two", "three", "four", "five", "six"];
 * ```
 *
 * Also see: [`Radio`](#ibm-radio)
 *
 * <example-url>../../iframe.html?id=radio--basic</example-url>
 */
class RadioGroup {
    constructor() {
        this.orientation = "horizontal";
        this.labelPlacement = "right";
        /**
         * Emits event notifying other classes of a change using a `RadioChange` class.
         */
        this.change = new EventEmitter();
        /**
         * Set to true to disable the whole radio group
         */
        this.disabled = false;
        /**
         * Binds 'bx--form-item' value to the class for `RadioGroup`.
         */
        this.radioButtonGroupClass = true;
        /**
         * To track whether the `RadioGroup` has been initialized.
         */
        this.isInitialized = false;
        /**
         * Reflects whether or not the input is disabled and cannot be selected.
         */
        this._disabled = false;
        /**
         * Reflects whether or not the dropdown is loading.
         */
        this._skeleton = false;
        /**
         * The value of the selected option within the `RadioGroup`.
         */
        this._value = null;
        /**
         * The `Radio` within the `RadioGroup` that is selected.
         */
        this._selected = null;
        /**
         * The name attribute associated with the `RadioGroup`.
         */
        this._name = `radio-group-${RadioGroup.radioGroupCount++}`;
        /**
         * Needed to properly implement ControlValueAccessor.
         */
        this.onTouched = () => { };
        /**
         * Method set in registerOnChange to propagate changes back to the form.
         */
        this.propagateChange = (_) => { };
    }
    /**
     * Sets the passed in `Radio` item as the selected input within the `RadioGroup`.
     */
    set selected(selected) {
        this._selected = selected;
        this.value = selected ? selected.value : null;
        this.checkSelectedRadio();
    }
    /**
     * Returns the `Radio` that is selected within the `RadioGroup`.
     */
    get selected() {
        return this._selected;
    }
    /**
     * Sets the value/state of the selected `Radio` within the `RadioGroup` to the passed in value.
     */
    set value(newValue) {
        if (this._value !== newValue) {
            this._value = newValue;
            this.updateSelectedRadioFromValue();
            this.checkSelectedRadio();
        }
    }
    /**
     * Returns the value/state of the selected `Radio` within the `RadioGroup`.
     */
    get value() {
        return this._value;
    }
    /**
     * Replaces the name associated with the `RadioGroup` with the provided parameter.
     */
    set name(name) {
        this._name = name;
        this.updateRadios();
    }
    /**
     * Returns the associated name of the `RadioGroup`.
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the skeleton value in the `RadioGroup` if there is one.
     */
    get skeleton() {
        return this._skeleton;
    }
    /**
     * Sets the skeleton value for all `Radio` to the skeleton value of `RadioGroup`.
     */
    set skeleton(value) {
        this._skeleton = value;
        this.updateChildren();
    }
    /**
     * Updates the selected `Radio` to be checked (selected).
     */
    checkSelectedRadio() {
        if (this.selected && !this._selected.checked) {
            this.selected.checked = true;
        }
    }
    /**
     * Use the value of the `RadioGroup` to update the selected radio to the right state (selected state).
     */
    updateSelectedRadioFromValue() {
        let alreadySelected = this._selected != null && this._selected.value === this._value;
        if (this.radios && !alreadySelected) {
            this._selected = null;
            this.radios.forEach(radio => {
                if (radio.checked || radio.value === this._value) {
                    this._selected = radio;
                }
            });
        }
    }
    /**
     * Creates a class of `RadioChange` to emit the change in the `RadioGroup`.
     */
    emitChangeEvent(event) {
        this.change.emit(event);
        this.propagateChange(event.value);
        this.onTouched();
    }
    /**
     * Synchronizes radio properties.
     */
    updateRadios() {
        if (this.radios) {
            setTimeout(() => {
                this.radios.forEach(radio => radio.name = this.name);
                if (this.labelPlacement === "left") {
                    this.radios.forEach(radio => radio.labelPlacement = "left");
                }
            });
        }
    }
    /**
     * Updates the value of the `RadioGroup` using the provided parameter.
     */
    writeValue(value) {
        this.value = value;
        setTimeout(() => {
            this.updateSelectedRadioFromValue();
            this.checkSelectedRadio();
        });
    }
    ngAfterContentInit() {
        this.radios.changes.subscribe(() => {
            this.updateRadios();
            this.updateRadioChangeHandler();
        });
        this.updateChildren();
        this.updateRadioChangeHandler();
    }
    ngAfterViewInit() {
        this.updateRadios();
    }
    /**
     * Used to set method to propagate changes back to the form.
     */
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    /**
     * Registers a callback to be triggered when the control has been touched.
     * @param fn Callback to be triggered when the checkbox is touched.
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    updateChildren() {
        if (this.radios) {
            this.radios.forEach(child => child.skeleton = this.skeleton);
        }
    }
    updateRadioChangeHandler() {
        this.radios.forEach(radio => {
            radio.registerRadioChangeHandler((event) => {
                // update selected and value from the event
                this._selected = event.source;
                this._value = event.value;
                // bubble the event
                this.emitChangeEvent(event);
            });
        });
    }
}
RadioGroup.ɵfac = function RadioGroup_Factory(t) { return new (t || RadioGroup)(); };
RadioGroup.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: RadioGroup, selectors: [["ibm-radio-group"]], contentQueries: function RadioGroup_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, Radio, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.radios = _t);
    } }, hostVars: 2, hostBindings: function RadioGroup_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--form-item", ctx.radioButtonGroupClass);
    } }, inputs: { orientation: "orientation", labelPlacement: "labelPlacement", disabled: "disabled", selected: "selected", value: "value", name: "name", skeleton: "skeleton", ariaLabel: "ariaLabel", ariaLabelledby: "ariaLabelledby" }, outputs: { change: "change" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: RadioGroup,
                multi: true
            }
        ])], ngContentSelectors: _c1, decls: 2, vars: 6, consts: [[1, "bx--radio-button-group", 3, "ngClass"]], template: function RadioGroup_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(3, _c2, ctx.orientation === "vertical", ctx.orientation === "vertical" && ctx.labelPlacement === "left"));
        ɵngcc0.ɵɵattribute("aria-label", ctx.ariaLabel)("aria-labelledby", ctx.ariaLabelledby);
    } }, directives: [ɵngcc1.NgClass], encapsulation: 2 });
/**
 * Used for creating the `RadioGroup` 'name' property dynamically.
 */
RadioGroup.radioGroupCount = 0;
RadioGroup.propDecorators = {
    orientation: [{ type: Input }],
    labelPlacement: [{ type: Input }],
    ariaLabel: [{ type: Input }],
    ariaLabelledby: [{ type: Input }],
    change: [{ type: Output }],
    radios: [{ type: ContentChildren, args: [forwardRef(() => Radio),] }],
    selected: [{ type: Input }],
    value: [{ type: Input }],
    name: [{ type: Input }],
    disabled: [{ type: Input }],
    skeleton: [{ type: Input }],
    radioButtonGroupClass: [{ type: HostBinding, args: ["class.bx--form-item",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RadioGroup, [{
        type: Component,
        args: [{
                selector: "ibm-radio-group",
                template: `
		<div
			class="bx--radio-button-group"
			[attr.aria-label]="ariaLabel"
			[attr.aria-labelledby]="ariaLabelledby"
			[ngClass]="{
				'bx--radio-button-group--vertical': orientation === 'vertical',
				'bx--radio-button-group--label-left': orientation === 'vertical' && labelPlacement === 'left'
			}">
			<ng-content></ng-content>
		</div>
	`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: RadioGroup,
                        multi: true
                    }
                ]
            }]
    }], function () { return []; }, { orientation: [{
            type: Input
        }], labelPlacement: [{
            type: Input
        }], change: [{
            type: Output
        }], disabled: [{
            type: Input
        }], radioButtonGroupClass: [{
            type: HostBinding,
            args: ["class.bx--form-item"]
        }], selected: [{
            type: Input
        }], value: [{
            type: Input
        }], name: [{
            type: Input
        }], skeleton: [{
            type: Input
        }], ariaLabel: [{
            type: Input
        }], ariaLabelledby: [{
            type: Input
        }], radios: [{
            type: ContentChildren,
            args: [forwardRef(() => Radio)]
        }] }); })();

// modules
class RadioModule {
}
RadioModule.ɵfac = function RadioModule_Factory(t) { return new (t || RadioModule)(); };
RadioModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: RadioModule });
RadioModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            FormsModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(RadioModule, { declarations: function () { return [Radio, RadioGroup]; }, imports: function () { return [CommonModule,
        FormsModule]; }, exports: function () { return [Radio, RadioGroup]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RadioModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    Radio,
                    RadioGroup
                ],
                exports: [
                    Radio,
                    RadioGroup
                ],
                imports: [
                    CommonModule,
                    FormsModule
                ]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { RadioChange, RadioGroup, Radio, RadioModule };

//# sourceMappingURL=carbon-components-angular-radio.js.map