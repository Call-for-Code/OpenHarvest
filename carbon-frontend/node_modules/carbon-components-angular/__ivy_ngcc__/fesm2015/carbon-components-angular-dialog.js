/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-dialog.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Subscription } from 'rxjs';
import { tabbableSelector, cycleTabs, getFocusElementList, isFocusInLastItem, isFocusInFirstItem } from 'carbon-components-angular/common';
import Position, { position } from '@carbon/utils-position';
import { Injector, ComponentFactoryResolver, Injectable, Component, Input, Output, EventEmitter, ElementRef, ViewChild, HostListener, Optional, Directive, ViewContainerRef, HostBinding, TemplateRef, ContentChild, ViewEncapsulation, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { I18n, I18nModule } from 'carbon-components-angular/i18n';
import { PlaceholderService, PlaceholderModule } from 'carbon-components-angular/placeholder';
import { ExperimentalService, ExperimentalModule } from 'carbon-components-angular/experimental';
import { AnimationFrameService, ElementService, EventService, closestAttr, UtilsModule } from 'carbon-components-angular/utils';
import { IconModule } from 'carbon-components-angular/icon';

/**
 * An enum of the various reasons a dialog may close. For use with `CloseMeta` and `shouldClose`
 *
 * It's expected that `interaction` will be a common closure reason.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from 'carbon-components-angular/placeholder';
import * as ɵngcc2 from 'carbon-components-angular/utils';
import * as ɵngcc3 from '@angular/common';
import * as ɵngcc4 from 'carbon-components-angular/i18n';
import * as ɵngcc5 from 'carbon-components-angular/experimental';
import * as ɵngcc6 from 'carbon-components-angular/icon';

const _c0 = ["dialog"];
function Tooltip_3_ng_template_0_Template(rf, ctx) { }
const _c1 = function (a0) { return { tooltip: a0 }; };
function Tooltip_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, Tooltip_3_ng_template_0_Template, 0, 0, "ng-template", 4);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.dialogConfig.content)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c1, ctx_r1));
} }
function Tooltip_p_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "p");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r2.dialogConfig.content, " ");
} }
const _c2 = function (a0, a1, a2, a3, a4) { return { "bx--tooltip--bottom": a0, "bx--tooltip--top": a1, "bx--tooltip--align-start": a2, "bx--tooltip--align-center": a3, "bx--tooltip--align-end": a4 }; };
const _c3 = ["*"];
const _c4 = function (a0, a1, a2, a3, a4, a5, a6) { return { "bx--tooltip--bottom": a0, "bx--tooltip--top": a1, "bx--tooltip--left": a2, "bx--tooltip--right": a3, "bx--tooltip--align-start": a4, "bx--tooltip--align-center": a5, "bx--tooltip--align-end": a6 }; };
function OverflowMenuPane_ng_template_2_Template(rf, ctx) { }
const _c5 = function (a0) { return { "bx--overflow-menu--flip": a0 }; };
const _c6 = function (a0) { return { overflowMenu: a0 }; };
function OverflowMenuCustomPane_ng_template_2_Template(rf, ctx) { }
function OverflowMenu_1_ng_template_0_Template(rf, ctx) { }
function OverflowMenu_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, OverflowMenu_1_ng_template_0_Template, 0, 0, "ng-template", 4);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r0.customTrigger);
} }
function OverflowMenu_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
function OverflowMenu_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 5);
} }
const _c7 = function (a0) { return { "bx--overflow-menu--open": a0 }; };
function OverflowMenuOption_button_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function OverflowMenuOption_button_0_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 3);
    ɵngcc0.ɵɵlistener("focus", function OverflowMenuOption_button_0_Template_button_focus_0_listener() { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.onFocus(); })("blur", function OverflowMenuOption_button_0_Template_button_blur_0_listener() { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.onBlur(); })("click", function OverflowMenuOption_button_0_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.onClick(); });
    ɵngcc0.ɵɵtemplate(1, OverflowMenuOption_button_0_ng_container_1_Template, 1, 0, "ng-container", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    const _r2 = ɵngcc0.ɵɵreference(3);
    ɵngcc0.ɵɵproperty("tabindex", ctx_r0.tabIndex)("disabled", ctx_r0.disabled);
    ɵngcc0.ɵɵattribute("title", ctx_r0.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2);
} }
function OverflowMenuOption_a_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function OverflowMenuOption_a_1_Template(rf, ctx) { if (rf & 1) {
    const _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 5);
    ɵngcc0.ɵɵlistener("focus", function OverflowMenuOption_a_1_Template_a_focus_0_listener() { ɵngcc0.ɵɵrestoreView(_r11); const ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.onFocus(); })("blur", function OverflowMenuOption_a_1_Template_a_blur_0_listener() { ɵngcc0.ɵɵrestoreView(_r11); const ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onBlur(); })("click", function OverflowMenuOption_a_1_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r11); const ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onClick(); });
    ɵngcc0.ɵɵtemplate(1, OverflowMenuOption_a_1_ng_container_1_Template, 1, 0, "ng-container", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    const _r2 = ɵngcc0.ɵɵreference(3);
    ɵngcc0.ɵɵproperty("tabindex", ctx_r1.tabIndex)("href", ctx_r1.href, ɵngcc0.ɵɵsanitizeUrl);
    ɵngcc0.ɵɵattribute("disabled", ctx_r1.disabled)("target", ctx_r1.target)("rel", ctx_r1.rel)("title", ctx_r1.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r2);
} }
function OverflowMenuOption_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} }
var CloseReasons;
(function (CloseReasons) {
    /**
     * For when the component is closed by being destroyed
     */
    CloseReasons[CloseReasons["destroyed"] = 0] = "destroyed";
    /**
     * For use in cases where the dialog closes for programmatic reasons other than destruction
     */
    CloseReasons[CloseReasons["programmatic"] = 1] = "programmatic";
    /**
     * interaction reasons will also provide a target for the interaction
     */
    CloseReasons[CloseReasons["interaction"] = 2] = "interaction";
    /**
     * For use in cases where the dialog closes due to being hidden
     */
    CloseReasons[CloseReasons["hidden"] = 3] = "hidden";
})(CloseReasons || (CloseReasons = {}));

/**
 * `Dialog` object to be injected into other components.
 */
class DialogService {
    /**
     * Creates an instance of `DialogService`.
     */
    constructor(componentFactoryResolver, injector, placeholderService) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.injector = injector;
        this.placeholderService = placeholderService;
    }
    /**
     * Closes all known `Dialog`s. Does not focus any previous elements, since we can't know which would be correct
     */
    static closeAll() {
        DialogService.dialogRefs.forEach(ref => ref.instance.doClose({
            reason: CloseReasons.programmatic
        }));
        DialogService.dialogRefs.clear();
    }
    /**
     * Set the context for the service. For example, the `component` property can be used to set the
     * default component that should be created by the service, for a given instance of the service.
     * @param options `{ component: any }` where `component` is a component that extends `dialog.component`
     */
    setContext(options) {
        this.componentFactory = this.componentFactoryResolver.resolveComponentFactory(options.component);
    }
    /**
     * If `dialogRef` is defined, the Dialog is already open. If
     * `dialogRef` is undefined, we create the `Dialog` component and reference to it.
     * A subscription is created to track if the `Dialog` should close.
     *
     * @param viewContainer a `ViewContainerRef` to instantiate the component against.
     * May be `null` if an `ibm-placeholder` exists and `dialogConfig.appendInline` is false
     * @param dialogConfig the `DialogConfig` for the component
     */
    open(viewContainer, dialogConfig, component) {
        let componentFactory = this.componentFactory;
        if (component) {
            componentFactory = this.componentFactoryResolver.resolveComponentFactory(component);
        }
        let dialogRef;
        if (dialogConfig.appendInline) {
            // add our component to the view
            dialogRef = viewContainer.createComponent(componentFactory, 0, this.injector);
        }
        else if (!this.placeholderService.hasPlaceholderRef()) {
            dialogRef = viewContainer.createComponent(componentFactory, 0, this.injector);
            if (dialogRef) {
                setTimeout(() => {
                    window.document.querySelector("body").appendChild(dialogRef.location.nativeElement);
                });
            }
        }
        else {
            dialogRef = this.placeholderService.createComponent(componentFactory, this.injector);
        }
        // keep track of all initialized dialogs
        DialogService.dialogRefs.add(dialogRef);
        // initialize some extra options
        dialogConfig["previouslyFocusedElement"] = document.activeElement;
        dialogRef.instance.dialogConfig = dialogConfig;
        dialogRef.instance.elementRef.nativeElement.focus();
        return dialogRef;
    }
    /**
     * On close of `Dialog` item, sets focus back to previous item, unsets
     * the current `dialogRef` item. Unsubscribes to the event of `Dialog` close.
     *
     * @param dialogRef the dialogRef to close
     */
    close(dialogRef) {
        // to handle the case where we have a null `this.dialogRef`
        if (!dialogRef) {
            return;
        }
        const elementToFocus = dialogRef.instance.dialogConfig["previouslyFocusedElement"];
        dialogRef.destroy();
        // update the globally tracked dialogRefs
        if (DialogService.dialogRefs.has(dialogRef)) {
            DialogService.dialogRefs.delete(dialogRef);
        }
        // Keeps the focus on the dialog trigger if there are no focusable elements. Change focus to previously focused element
        // if there are focusable elements in the dialog.
        if (!dialogRef.location.nativeElement.querySelectorAll(tabbableSelector)) {
            elementToFocus.focus();
        }
    }
    /**
     * Closes all known `Dialog`s. Does not focus any previous elements, since we can't know which would be correct
     *
     * @deprecated since v4. Use the static `DialogService.closeAll` instead
     */
    closeAll() {
        DialogService.closeAll();
    }
    /**
     * Fix for safari hijacking clicks.
     *
     * Runs on `ngOnInit` of every dialog. Ensures we don't have multiple listeners
     * because having many of them could degrade performance in certain cases (and is
     * not necessary for our use case)
     *
     * This is an internally used function, can change at any point (even get removed)
     * and changes to it won't be considered a breaking change. Use at your own risk.
     */
    singletonClickListen() {
        if (!DialogService.listeningForBodyClicks) {
            document.body.firstElementChild.addEventListener("click", () => null, true);
            DialogService.listeningForBodyClicks = true;
        }
    }
}
DialogService.ɵfac = function DialogService_Factory(t) { return new (t || DialogService)(ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(ɵngcc1.PlaceholderService)); };
DialogService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DialogService, factory: DialogService.ɵfac });
/**
 * Used in `singletonClickListen`, don't count on its existence and values.
 */
DialogService.listeningForBodyClicks = false;
/**
 * A set of all known dialog components
 */
DialogService.dialogRefs = new Set();
/** @nocollapse */
DialogService.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: Injector },
    { type: PlaceholderService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DialogService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.Injector }, { type: ɵngcc1.PlaceholderService }]; }, null); })();

/**
 * Implements a `Dialog` that can be positioned anywhere on the page.
 * Used to implement a popover or tooltip.
 */
class Dialog {
    /**
     * Creates an instance of `Dialog`.
     * @param elementRef
     * @param elementService
     */
    constructor(elementRef, elementService, animationFrameService = null) {
        this.elementRef = elementRef;
        this.elementService = elementService;
        this.animationFrameService = animationFrameService;
        /**
         * Emits event that handles the closing of a `Dialog` object.
         */
        this.close = new EventEmitter();
        /**
         * Stores the data received from `dialogConfig`.
         */
        this.data = {};
        this.visibilitySubscription = new Subscription();
        this.animationFrameSubscription = new Subscription();
        /**
         * Handles offsetting the `Dialog` item based on the defined position
         * to not obscure the content beneath.
         */
        this.addGap = {
            "left": pos => position.addOffset(pos, 0, -this.dialogConfig.gap),
            "right": pos => position.addOffset(pos, 0, this.dialogConfig.gap),
            "top": pos => position.addOffset(pos, -this.dialogConfig.gap),
            "bottom": pos => position.addOffset(pos, this.dialogConfig.gap),
            "left-bottom": pos => position.addOffset(pos, 0, -this.dialogConfig.gap),
            "right-bottom": pos => position.addOffset(pos, 0, this.dialogConfig.gap)
        };
        /**
         * Extra placements. Child classes can add to this for use in `placeDialog`.
         */
        this.placements = {};
    }
    /**
     * Initialize the `Dialog`, set the placement and gap, and add a `Subscription` to resize events.
     */
    ngOnInit() {
        this.placement = this.dialogConfig.placement.split(",")[0];
        this.data = this.dialogConfig.data;
        // run any additional initialization code that consuming classes may have
        this.onDialogInit();
    }
    /**
     * After the DOM is ready, focus is set and dialog is placed
     * in respect to the parent element.
     */
    ngAfterViewInit() {
        const dialogElement = this.dialog.nativeElement;
        // split the wrapper class list and apply separately to avoid IE
        // 1. throwing an error due to assigning a readonly property (classList)
        // 2. throwing a SyntaxError due to passing an empty string to `add`
        if (this.dialogConfig.wrapperClass) {
            for (const extraClass of this.dialogConfig.wrapperClass.split(" ")) {
                dialogElement.classList.add(extraClass);
            }
        }
        // only focus the dialog if there are focusable elements within the dialog
        if (getFocusElementList(this.dialog.nativeElement).length > 0) {
            dialogElement.focus();
        }
        const parentElement = this.dialogConfig.parentRef.nativeElement;
        if (this.animationFrameService) {
            this.animationFrameSubscription = this.animationFrameService.tick.subscribe(() => {
                this.placeDialog();
            });
        }
        if (this.dialogConfig.closeWhenHidden) {
            this.visibilitySubscription = this.elementService
                .visibility(parentElement, parentElement)
                .subscribe(value => {
                this.placeDialog();
                if (!value.visible) {
                    this.doClose({
                        reason: CloseReasons.hidden
                    });
                }
            });
        }
        this.placeDialog();
        // run afterDialogViewInit on the next tick
        setTimeout(() => this.afterDialogViewInit());
    }
    /**
     * Empty method to be overridden by consuming classes to run any additional initialization code.
     */
    onDialogInit() { }
    /**
     * Empty method to be overridden by consuming classes to run any additional initialization code after the view is available.
     * NOTE: this does _not_ guarantee the dialog will be positioned, simply that it will exist in the DOM
     */
    afterDialogViewInit() { }
    /**
     * Uses the position service to position the `Dialog` in screen space
     */
    placeDialog() {
        const positionService = new Position(this.placements);
        // helper to find the position based on the current/given environment
        const findPosition = (reference, target, placement) => {
            let pos;
            if (this.dialogConfig.appendInline) {
                pos = this.addGap[placement](positionService.findRelative(reference, target, placement));
            }
            else {
                pos = this.addGap[placement](positionService.findAbsolute(reference, target, placement));
            }
            if (this.dialogConfig.offset) {
                // Apply vertical and horizontal offsets given through the dialogConfig
                pos.top = pos.top + this.dialogConfig.offset.y;
                pos.left = pos.left + this.dialogConfig.offset.x;
            }
            return pos;
        };
        let parentEl = this.dialogConfig.parentRef.nativeElement;
        let el = this.dialog.nativeElement;
        let dialogPlacement = this.placement;
        // split always returns an array, so we can just use the auto position logic
        // for single positions too
        const placements = this.dialogConfig.placement.split(",");
        // find the best placement
        dialogPlacement = positionService.findBestPlacement(parentEl, el, placements);
        // calculate the final position
        const pos = findPosition(parentEl, el, dialogPlacement);
        // update the element
        positionService.setElement(el, pos);
        setTimeout(() => { this.placement = dialogPlacement; });
    }
    /**
     * Sets up a KeyboardEvent to close `Dialog` with Escape key.
     * @param event
     */
    escapeClose(event) {
        switch (event.key) {
            case "Esc": // IE specific value
            case "Escape": {
                event.stopImmediatePropagation();
                this.doClose({
                    reason: CloseReasons.interaction,
                    target: event.target
                });
                break;
            }
            case "Tab": {
                cycleTabs(event, this.elementRef.nativeElement);
                break;
            }
        }
    }
    /**
     * Sets up a event Listener to close `Dialog` if click event occurs outside
     * `Dialog` object.
     * @param event
     */
    clickClose(event) {
        if (!this.elementRef.nativeElement.contains(event.target)
            && !this.dialogConfig.parentRef.nativeElement.contains(event.target)) {
            this.doClose({
                reason: CloseReasons.interaction,
                target: event.target
            });
        }
    }
    /**
     * Closes `Dialog` object by emitting the close event upwards to parents.
     */
    doClose(meta = { reason: CloseReasons.interaction }) {
        this.close.emit(meta);
    }
    /**
     * At destruction of component, `Dialog` unsubscribes from all the subscriptions.
     */
    ngOnDestroy() {
        this.visibilitySubscription.unsubscribe();
        if (this.animationFrameSubscription) {
            this.animationFrameSubscription.unsubscribe();
        }
    }
}
Dialog.ɵfac = function Dialog_Factory(t) { return new (t || Dialog)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ElementService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.AnimationFrameService, 8)); };
Dialog.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: Dialog, selectors: [["ibm-dialog"]], viewQuery: function Dialog_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dialog = _t.first);
    } }, hostBindings: function Dialog_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function Dialog_keydown_HostBindingHandler($event) { return ctx.escapeClose($event); })("click", function Dialog_click_HostBindingHandler($event) { return ctx.clickClose($event); }, false, ɵngcc0.ɵɵresolveDocument);
    } }, inputs: { dialogConfig: "dialogConfig" }, outputs: { close: "close" }, decls: 0, vars: 0, template: function Dialog_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
Dialog.ctorParameters = () => [
    { type: ElementRef },
    { type: ElementService },
    { type: AnimationFrameService, decorators: [{ type: Optional }] }
];
Dialog.propDecorators = {
    close: [{ type: Output }],
    dialogConfig: [{ type: Input }],
    dialog: [{ type: ViewChild, args: ["dialog", { static: false },] }],
    escapeClose: [{ type: HostListener, args: ["keydown", ["$event"],] }],
    clickClose: [{ type: HostListener, args: ["document:click", ["$event"],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Dialog, [{
        type: Component,
        args: [{
                selector: "ibm-dialog",
                template: ""
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc2.ElementService }, { type: ɵngcc2.AnimationFrameService, decorators: [{
                type: Optional
            }] }]; }, { close: [{
            type: Output
        }], 
    /**
     * Sets up a KeyboardEvent to close `Dialog` with Escape key.
     * @param event
     */
    escapeClose: [{
            type: HostListener,
            args: ["keydown", ["$event"]]
        }], 
    /**
     * Sets up a event Listener to close `Dialog` if click event occurs outside
     * `Dialog` object.
     * @param event
     */
    clickClose: [{
            type: HostListener,
            args: ["document:click", ["$event"]]
        }], dialogConfig: [{
            type: Input
        }], dialog: [{
            type: ViewChild,
            args: ["dialog", { static: false }]
        }] }); })();

/**
 * A generic directive that can be inherited from to create dialogs (for example, a tooltip or popover)
 *
 * This class contains the relevant initialization code, specific templates, options, and additional inputs
 * should be specified in the derived class.
 *
 * NOTE: All child classes should add `DialogService` as a provider, otherwise they will lose context that
 * the service relies on.
 */
class DialogDirective {
    /**
     * Creates an instance of DialogDirective.
     * @param elementRef
     * @param viewContainerRef
     * @param dialogService
     * @param eventService
     */
    constructor(elementRef, viewContainerRef, dialogService, eventService) {
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
        this.dialogService = dialogService;
        this.eventService = eventService;
        /**
         * Title for the dialog
         */
        this.title = "";
        /**
         * Defines how the Dialog is triggered.(Hover and click behave the same on mobile - both respond to a single tap).
         * Do not add focusable elements if trigger is `hover` or `mouseenter`.
         */
        this.trigger = "click";
        /**
         * Defines how the Dialog close event is triggered.
         *
         * [See here](https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseleave_event)
         * for more on the difference between `mouseleave` and `mouseout`.
         *
         * Defaults to `click` when `trigger` is set to `click`.
         */
        this.closeTrigger = "mouseleave";
        /**
         * Placement of the dialog, usually relative to the element the directive is on.
         */
        this.placement = "left";
        /**
         * Spacing between the dialog and it's triggering element
         */
        this.gap = 0;
        /**
         * Set to `true` to open the dialog next to the triggering component
         */
        this.appendInline = false;
        /**
         * Optional data for templates
         */
        this.data = {};
        this.isOpen = false;
        /**
         * This prevents the dialog from being toggled
         */
        this.disabled = false;
        /**
         * Emits an event when the dialog is closed
         */
        this.onClose = new EventEmitter();
        /**
         * Emits an event when the dialog is opened
         */
        this.onOpen = new EventEmitter();
        /**
         * Emits an event when the state of `isOpen` changes. Allows `isOpen` to be double bound
         */
        this.isOpenChange = new EventEmitter();
        this.role = "button";
        this.hasPopup = true;
    }
    get ariaOwns() {
        return this.isOpen ? this.dialogConfig.compID : null;
    }
    ngOnChanges(changes) {
        // set the config object (this can [and should!] be added to in child classes depending on what they need)
        this.dialogConfig = {
            title: this.title,
            content: this.ibmDialog,
            placement: this.placement,
            parentRef: this.elementRef,
            gap: this.gap,
            trigger: this.trigger,
            closeTrigger: this.closeTrigger,
            shouldClose: this.shouldClose || (() => true),
            appendInline: this.appendInline,
            wrapperClass: this.wrapperClass,
            data: this.data,
            offset: this.offset,
            disabled: this.disabled
        };
        if (changes.isOpen) {
            if (changes.isOpen.currentValue) {
                this.open();
            }
            else {
                this.close({
                    reason: CloseReasons.programmatic
                });
            }
        }
        // Run any code a child class may need.
        this.onDialogChanges(changes);
        this.updateConfig();
    }
    /**
     * Sets the config object and binds events for hovering or clicking before
     * running code from child class.
     */
    ngOnInit() {
        // fix for safari hijacking clicks
        this.dialogService.singletonClickListen();
        const element = this.elementRef.nativeElement;
        this.eventService.on(element, "keydown", (event) => {
            // "Esc" is an IE specific value
            if (event.target === this.dialogConfig.parentRef.nativeElement &&
                (event.key === "Tab" || event.key === "Tab" && event.shiftKey) ||
                event.key === "Escape" || event.key === "Esc") {
                this.close({
                    reason: CloseReasons.interaction,
                    target: event.target
                });
            }
        });
        // bind events for hovering or clicking the host
        if (this.trigger === "hover" || this.trigger === "mouseenter") {
            this.eventService.on(element, "mouseenter", this.open.bind(this));
            this.eventService.on(element, this.closeTrigger, (event) => {
                this.close({
                    reason: CloseReasons.interaction,
                    target: event.target
                });
            });
            this.eventService.on(element, "focus", this.open.bind(this));
            this.eventService.on(element, "blur", (event) => {
                this.close({
                    reason: CloseReasons.interaction,
                    target: event.target
                });
            });
        }
        else {
            this.eventService.on(element, "click", (event) => {
                this.toggle({
                    reason: CloseReasons.interaction,
                    target: event.target
                });
            });
            this.eventService.on(element, "keydown", (event) => {
                // "Spacebar" is an IE specific value
                if (event.key === "Enter" || event.key === " " || event.key === "Spacebar") {
                    setTimeout(() => {
                        this.open();
                    });
                }
            });
        }
        DialogDirective.dialogCounter++;
        this.dialogConfig.compID = "dialog-" + DialogDirective.dialogCounter;
        // run any code a child class may need
        this.onDialogInit();
        this.updateConfig();
    }
    /**
     * When the host dies, kill the popover.
     * - Useful for use in a modal or similar.
     */
    ngOnDestroy() {
        this.close({
            reason: CloseReasons.destroyed
        });
    }
    /**
     * Helper method to call dialogService 'open'.
     * - Enforce accessibility by updating an aria attr for nativeElement.
     */
    open() {
        // don't allow dialogs to be opened if they're already open
        if (this.dialogRef || this.disabled) {
            return;
        }
        // actually open the dialog, emit events, and set the open state
        this.dialogRef = this.dialogService.open(this.viewContainerRef, this.dialogConfig);
        this.isOpen = true;
        this.onOpen.emit();
        this.isOpenChange.emit(true);
        // Handles emitting all the close events to clean everything up
        // Also enforce accessibility on close by updating an aria attr on the nativeElement.
        this.dialogRef.instance.close.subscribe((meta) => {
            if (!this.dialogRef) {
                return;
            }
            if (this.dialogConfig.shouldClose && this.dialogConfig.shouldClose(meta)) {
                // close the dialog, emit events, and clear out the open states
                this.dialogService.close(this.dialogRef);
                this.dialogRef = null;
                this.isOpen = false;
                this.onClose.emit();
                this.isOpenChange.emit(false);
            }
        });
        return this.dialogRef;
    }
    /**
     * Helper method to toggle the open state of the dialog
     */
    toggle(meta = { reason: CloseReasons.interaction }) {
        if (!this.isOpen) {
            this.open();
        }
        else {
            this.close(meta);
        }
    }
    /**
     * Helper method to close the dialogRef.
     */
    close(meta = { reason: CloseReasons.interaction }) {
        if (this.dialogRef) {
            setTimeout(() => {
                this.dialogRef.instance.doClose(meta);
            });
        }
    }
    /**
     * Empty method for child classes to override and specify additional init steps.
     * Run after DialogDirective completes it's ngOnInit.
     */
    onDialogInit() { }
    /**
     * Empty method for child to override and specify additional on changes steps.
     * run after DialogDirective completes it's ngOnChanges.
     */
    onDialogChanges(_changes) { }
    updateConfig() { }
}
DialogDirective.ɵfac = function DialogDirective_Factory(t) { return new (t || DialogDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DialogService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.EventService)); };
DialogDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DialogDirective, selectors: [["", "ibmDialog", ""]], hostVars: 4, hostBindings: function DialogDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-expanded", ctx.isOpen)("role", ctx.role)("aria-haspopup", ctx.hasPopup)("aria-owns", ctx.ariaOwns);
    } }, inputs: { title: "title", trigger: "trigger", closeTrigger: "closeTrigger", placement: "placement", gap: "gap", appendInline: "appendInline", data: "data", isOpen: "isOpen", disabled: "disabled", ibmDialog: "ibmDialog", offset: "offset", wrapperClass: "wrapperClass", shouldClose: "shouldClose" }, outputs: { onClose: "onClose", onOpen: "onOpen", isOpenChange: "isOpenChange" }, exportAs: ["ibmDialog"], features: [ɵngcc0.ɵɵProvidersFeature([
            DialogService
        ]), ɵngcc0.ɵɵNgOnChangesFeature] });
DialogDirective.dialogCounter = 0;
/** @nocollapse */
DialogDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: DialogService },
    { type: EventService }
];
DialogDirective.propDecorators = {
    title: [{ type: Input }],
    ibmDialog: [{ type: Input }],
    trigger: [{ type: Input }],
    closeTrigger: [{ type: Input }],
    placement: [{ type: Input }],
    offset: [{ type: Input }],
    wrapperClass: [{ type: Input }],
    gap: [{ type: Input }],
    appendInline: [{ type: Input }],
    data: [{ type: Input }],
    isOpen: [{ type: Input }, { type: HostBinding, args: ["attr.aria-expanded",] }],
    disabled: [{ type: Input }],
    shouldClose: [{ type: Input }],
    onClose: [{ type: Output }],
    onOpen: [{ type: Output }],
    isOpenChange: [{ type: Output }],
    role: [{ type: HostBinding, args: ["attr.role",] }],
    hasPopup: [{ type: HostBinding, args: ["attr.aria-haspopup",] }],
    ariaOwns: [{ type: HostBinding, args: ["attr.aria-owns",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DialogDirective, [{
        type: Directive,
        args: [{
                selector: "[ibmDialog]",
                exportAs: "ibmDialog",
                providers: [
                    DialogService
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ViewContainerRef }, { type: DialogService }, { type: ɵngcc2.EventService }]; }, { title: [{
            type: Input
        }], trigger: [{
            type: Input
        }], closeTrigger: [{
            type: Input
        }], placement: [{
            type: Input
        }], gap: [{
            type: Input
        }], appendInline: [{
            type: Input
        }], data: [{
            type: Input
        }], isOpen: [{
            type: Input
        }, {
            type: HostBinding,
            args: ["attr.aria-expanded"]
        }], disabled: [{
            type: Input
        }], onClose: [{
            type: Output
        }], onOpen: [{
            type: Output
        }], isOpenChange: [{
            type: Output
        }], role: [{
            type: HostBinding,
            args: ["attr.role"]
        }], hasPopup: [{
            type: HostBinding,
            args: ["attr.aria-haspopup"]
        }], ariaOwns: [{
            type: HostBinding,
            args: ["attr.aria-owns"]
        }], ibmDialog: [{
            type: Input
        }], offset: [{
            type: Input
        }], wrapperClass: [{
            type: Input
        }], shouldClose: [{
            type: Input
        }] }); })();

/**
 * Extend the `Dialog` component to create a tooltip for exposing content.
 */
class Tooltip extends Dialog {
    constructor(elementRef, elementService, animationFrameService = null) {
        super(elementRef, elementService, animationFrameService);
        this.elementRef = elementRef;
        this.elementService = elementService;
        this.animationFrameService = animationFrameService;
        this.style = "inline-block";
        /**
         * Value is set to `true` if the `Tooltip` is to display a `TemplateRef` instead of a string.
         */
        this.hasContentTemplate = false;
        /**
         * Sets the role of the tooltip. If there's no focusable content we leave it as a `tooltip`,
         * if there _is_ focusable content we switch to the interactive `dialog` role.
         */
        this.role = "tooltip";
    }
    /**
     * Check whether there is a template for the `Tooltip` content.
     */
    onDialogInit() {
        this.addGap["bottom"] = pos => {
            const adjustedOffset = this.getAdjustOffset();
            return position.addOffset(pos, 3 + adjustedOffset.top, 0 + adjustedOffset.left);
        };
        this.addGap["top"] = pos => {
            const adjustedOffset = this.getAdjustOffset();
            return position.addOffset(pos, -10 + adjustedOffset.top, 0 + adjustedOffset.left);
        };
        this.addGap["left"] = pos => {
            const adjustedOffset = this.getAdjustOffset();
            return position.addOffset(pos, -3 + adjustedOffset.top, -6 + adjustedOffset.left);
        };
        this.addGap["right"] = pos => {
            const adjustedOffset = this.getAdjustOffset();
            return position.addOffset(pos, -3 + adjustedOffset.top, 6 + adjustedOffset.left);
        };
        this.hasContentTemplate = this.dialogConfig.content instanceof TemplateRef;
    }
    getAdjustOffset() {
        const closestWithPos = closestAttr("position", ["relative", "fixed", "absolute"], this.elementRef.nativeElement.parentElement);
        const topPos = closestWithPos ? closestWithPos.getBoundingClientRect().top * -1 : 0;
        const leftPos = closestWithPos ? closestWithPos.getBoundingClientRect().left * -1 : 0;
        return { top: topPos, left: leftPos };
    }
    afterDialogViewInit() {
        const focusableElements = getFocusElementList(this.dialog.nativeElement);
        if (focusableElements.length > 0) {
            this.role = "dialog";
            focusableElements[0].focus();
        }
    }
}
Tooltip.ɵfac = function Tooltip_Factory(t) { return new (t || Tooltip)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ElementService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.AnimationFrameService, 8)); };
Tooltip.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: Tooltip, selectors: [["ibm-tooltip"]], hostVars: 2, hostBindings: function Tooltip_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("display", ctx.style);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 5, consts: [[1, "bx--tooltip", "bx--tooltip--shown", 3, "id"], ["dialog", ""], ["aria-hidden", "true", 1, "bx--tooltip__caret"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function Tooltip_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵelement(2, "span", 2);
        ɵngcc0.ɵɵtemplate(3, Tooltip_3_Template, 1, 4, undefined, 3);
        ɵngcc0.ɵɵtemplate(4, Tooltip_p_4_Template, 2, 1, "p", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.dialogConfig.compID);
        ɵngcc0.ɵɵattribute("role", ctx.role)("data-floating-menu-direction", ctx.placement);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasContentTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.hasContentTemplate);
    } }, directives: [ɵngcc3.NgIf, ɵngcc3.NgTemplateOutlet], encapsulation: 2 });
/** @nocollapse */
Tooltip.ctorParameters = () => [
    { type: ElementRef },
    { type: ElementService },
    { type: AnimationFrameService, decorators: [{ type: Optional }] }
];
Tooltip.propDecorators = {
    style: [{ type: HostBinding, args: ["style.display",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Tooltip, [{
        type: Component,
        args: [{
                selector: "ibm-tooltip",
                template: `
		<div
			#dialog
			[id]="dialogConfig.compID"
			[attr.role]="role"
			[attr.data-floating-menu-direction]="placement"
			class="bx--tooltip bx--tooltip--shown">
			<span class="bx--tooltip__caret" aria-hidden="true"></span>
			<ng-template
					*ngIf="hasContentTemplate"
					[ngTemplateOutlet]="dialogConfig.content"
					[ngTemplateOutletContext]="{tooltip: this}">
			</ng-template>
			<p
				*ngIf="!hasContentTemplate">
				{{dialogConfig.content}}
			</p>
		</div>
		`
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc2.ElementService }, { type: ɵngcc2.AnimationFrameService, decorators: [{
                type: Optional
            }] }]; }, { style: [{
            type: HostBinding,
            args: ["style.display"]
        }] }); })();

class TooltipDefinition {
    constructor() {
        this.id = `definition-tooltip-${TooltipDefinition.tooltipItemCount++}`;
        /**
         * The placement in which the `TooltipDefinition` appears.
         * Set to `"top"` to have it positioned above the trigger text
         */
        this.placement = "bottom";
        this.alignment = "start";
        this.className = true;
        this.accessibility = true;
    }
}
TooltipDefinition.ɵfac = function TooltipDefinition_Factory(t) { return new (t || TooltipDefinition)(); };
TooltipDefinition.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TooltipDefinition, selectors: [["ibm-tooltip-definition"]], hostVars: 4, hostBindings: function TooltipDefinition_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--tooltip--definition", ctx.className)("bx--tooltip--a11y", ctx.accessibility);
    } }, inputs: { id: "id", placement: "placement", alignment: "alignment", content: "content" }, ngContentSelectors: _c3, decls: 4, vars: 10, consts: [["type", "button", 1, "bx--tooltip__trigger", "bx--tooltip--a11y", "bx--tooltip__trigger--definition", 3, "ngClass"], ["role", "tooltip", 1, "bx--assistive-text", 3, "id"]], template: function TooltipDefinition_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction5(4, _c2, ctx.placement === "bottom", ctx.placement === "top", ctx.alignment === "start", ctx.alignment === "center", ctx.alignment === "end"));
        ɵngcc0.ɵɵattribute("aria-describedby", ctx.id);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("id", ctx.id);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.content);
    } }, directives: [ɵngcc3.NgClass], encapsulation: 2 });
TooltipDefinition.tooltipItemCount = 0;
TooltipDefinition.propDecorators = {
    id: [{ type: Input }],
    content: [{ type: Input }],
    placement: [{ type: Input }],
    alignment: [{ type: Input }],
    className: [{ type: HostBinding, args: ["class.bx--tooltip--definition",] }],
    accessibility: [{ type: HostBinding, args: ["class.bx--tooltip--a11y",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TooltipDefinition, [{
        type: Component,
        args: [{
                selector: "ibm-tooltip-definition",
                template: `
		<button
			type="button"
			[ngClass]="{
				'bx--tooltip--bottom' : placement === 'bottom',
				'bx--tooltip--top' : placement === 'top',
				'bx--tooltip--align-start' : alignment === 'start',
				'bx--tooltip--align-center' : alignment === 'center',
				'bx--tooltip--align-end' : alignment === 'end'
			}"
			class="bx--tooltip__trigger bx--tooltip--a11y bx--tooltip__trigger--definition"
			[attr.aria-describedby]="id">
			<ng-content></ng-content>
		</button>
		<div class="bx--assistive-text" [id]="id" role="tooltip">{{content}}</div>
	`
            }]
    }], function () { return []; }, { id: [{
            type: Input
        }], placement: [{
            type: Input
        }], alignment: [{
            type: Input
        }], className: [{
            type: HostBinding,
            args: ["class.bx--tooltip--definition"]
        }], accessibility: [{
            type: HostBinding,
            args: ["class.bx--tooltip--a11y"]
        }], content: [{
            type: Input
        }] }); })();

class TooltipIcon {
    constructor() {
        /**
         * The placement in which the `TooltipIcon` appears.
         * Set to `"top"` to have it positioned above the icon
         */
        this.placement = "bottom";
        this.alignment = "start";
        this.className = true;
    }
}
TooltipIcon.ɵfac = function TooltipIcon_Factory(t) { return new (t || TooltipIcon)(); };
TooltipIcon.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TooltipIcon, selectors: [["ibm-tooltip-icon"]], hostVars: 2, hostBindings: function TooltipIcon_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--tooltip-icon", ctx.className);
    } }, inputs: { placement: "placement", alignment: "alignment", content: "content" }, ngContentSelectors: _c3, decls: 4, vars: 10, consts: [["type", "button", 1, "bx--tooltip__trigger", "bx--tooltip--a11y", 3, "ngClass"], [1, "bx--assistive-text"]], template: function TooltipIcon_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵelementStart(1, "span", 1);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction7(2, _c4, ctx.placement === "bottom", ctx.placement === "top", ctx.placement === "left", ctx.placement === "right", ctx.alignment === "start", ctx.alignment === "center", ctx.alignment === "end"));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.content);
    } }, directives: [ɵngcc3.NgClass], encapsulation: 2 });
TooltipIcon.propDecorators = {
    content: [{ type: Input }],
    placement: [{ type: Input }],
    alignment: [{ type: Input }],
    className: [{ type: HostBinding, args: ["class.bx--tooltip-icon",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TooltipIcon, [{
        type: Component,
        args: [{
                selector: "ibm-tooltip-icon",
                template: `
		<button
			type="button"
			class="bx--tooltip__trigger bx--tooltip--a11y"
			[ngClass]="{
				'bx--tooltip--bottom' : placement === 'bottom',
				'bx--tooltip--top' : placement === 'top',
				'bx--tooltip--left' : placement === 'left',
				'bx--tooltip--right' : placement === 'right',
				'bx--tooltip--align-start' : alignment === 'start',
				'bx--tooltip--align-center' : alignment === 'center',
				'bx--tooltip--align-end' : alignment === 'end'
			}">
			<span class="bx--assistive-text">{{content}}</span>
			<ng-content></ng-content>
		</button>
	`
            }]
    }], function () { return []; }, { placement: [{
            type: Input
        }], alignment: [{
            type: Input
        }], className: [{
            type: HostBinding,
            args: ["class.bx--tooltip-icon"]
        }], content: [{
            type: Input
        }] }); })();

/**
 * Directive for extending `Dialog` to create tooltips.
 *
 * [See demo](../../?path=/story/tooltip--basic)
 *
 * class: TooltipDirective (extends PopoverDirective)
 *
 *
 * selector: `nTooltip`
 *
 *
 * ```html
 * <button nTooltip="I am a tooltip" placement="right" trigger="mouseenter" type="danger">Tooltip Right</button>
 * <button nTooltip="I am a tooltip" type="warning">Tooltip Top warning on click</button>
 * ```
 *
 * <example-url>../../iframe.html?id=tooltip--basic</example-url>
 */
class TooltipDirective extends DialogDirective {
    /**
     * Creates an instance of `TooltipDirective`.
     */
    constructor(elementRef, viewContainerRef, dialogService, eventService) {
        super(elementRef, viewContainerRef, dialogService, eventService);
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
        this.dialogService = dialogService;
        this.eventService = eventService;
        /**
         * Set tooltip type to reflect 'warning' or 'error' styles.
         */
        // tslint:disable-next-line:no-input-rename
        this.tooltipType = "";
        this.tabIndex = 0;
        this.className = true;
        dialogService.setContext({ component: Tooltip });
    }
    get descriptorId() {
        return this.isOpen ? this.dialogConfig.compID : null;
    }
    updateConfig() {
        this.dialogConfig.content = this.ibmTooltip;
        this.dialogConfig.type = this.tooltipType;
        this.dialogConfig.offset = this.offset;
    }
}
TooltipDirective.ɵfac = function TooltipDirective_Factory(t) { return new (t || TooltipDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DialogService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.EventService)); };
TooltipDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TooltipDirective, selectors: [["", "ibmTooltip", ""]], hostVars: 4, hostBindings: function TooltipDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("tabindex", ctx.tabIndex);
        ɵngcc0.ɵɵattribute("aria-describedby", ctx.descriptorId);
        ɵngcc0.ɵɵclassProp("bx--tooltip__trigger", ctx.className);
    } }, inputs: { tooltipType: ["tooltip-type", "tooltipType"], ibmTooltip: "ibmTooltip" }, exportAs: ["ibmTooltip"], features: [ɵngcc0.ɵɵProvidersFeature([
            DialogService
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
TooltipDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: DialogService },
    { type: EventService }
];
TooltipDirective.propDecorators = {
    ibmTooltip: [{ type: Input }],
    tooltipType: [{ type: Input, args: ["tooltip-type",] }],
    tabIndex: [{ type: HostBinding, args: ["tabindex",] }],
    className: [{ type: HostBinding, args: ["class.bx--tooltip__trigger",] }],
    descriptorId: [{ type: HostBinding, args: ["attr.aria-describedby",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TooltipDirective, [{
        type: Directive,
        args: [{
                selector: "[ibmTooltip]",
                exportAs: "ibmTooltip",
                providers: [
                    DialogService
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ViewContainerRef }, { type: DialogService }, { type: ɵngcc2.EventService }]; }, { tooltipType: [{
            type: Input,
            args: ["tooltip-type"]
        }], tabIndex: [{
            type: HostBinding,
            args: ["tabindex"]
        }], className: [{
            type: HostBinding,
            args: ["class.bx--tooltip__trigger"]
        }], descriptorId: [{
            type: HostBinding,
            args: ["attr.aria-describedby"]
        }], ibmTooltip: [{
            type: Input
        }] }); })();

/**
 * A directive that creates a tooltip `Dialog` for exposing truncated text.
 *
 * class: EllipsisTooltip (extends PopoverDirective)
 *
 * selector: `nEllipsisTooltip`
 *
 * ```html
 * <div class="ellipsis" nEllipsisTooltip>Tooltip for ellipsis because I can and I am really really long</div>
 * ```
 */
class EllipsisTooltip extends TooltipDirective {
    /**
     * If text is truncated, this appends the text to the dialog as content.
     * @returns null
     * @memberof EllipsisTooltip
     */
    updateTooltipContent() {
        if (this.elementRef.nativeElement.scrollWidth <= this.elementRef.nativeElement.offsetWidth) {
            this.disabled = true;
            return;
        }
        this.disabled = false;
        this.dialogConfig.content = this.elementRef.nativeElement.innerText;
    }
    onClick() {
        if (this.trigger === "click") {
            this.updateTooltipContent();
        }
    }
    onHover() {
        if (this.trigger === "hover" || this.trigger === "mouseenter") {
            this.updateTooltipContent();
        }
    }
    onFocus() {
        this.updateTooltipContent();
    }
}
EllipsisTooltip.ɵfac = function EllipsisTooltip_Factory(t) { return ɵEllipsisTooltip_BaseFactory(t || EllipsisTooltip); };
EllipsisTooltip.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: EllipsisTooltip, selectors: [["", "ibmEllipsisTooltip", ""]], hostBindings: function EllipsisTooltip_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function EllipsisTooltip_click_HostBindingHandler() { return ctx.onClick(); })("mouseenter", function EllipsisTooltip_mouseenter_HostBindingHandler() { return ctx.onHover(); })("focus", function EllipsisTooltip_focus_HostBindingHandler() { return ctx.onFocus(); });
    } }, features: [ɵngcc0.ɵɵProvidersFeature([
            DialogService
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
EllipsisTooltip.propDecorators = {
    onClick: [{ type: HostListener, args: ["click",] }],
    onHover: [{ type: HostListener, args: ["mouseenter",] }],
    onFocus: [{ type: HostListener, args: ["focus",] }]
};
const ɵEllipsisTooltip_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(EllipsisTooltip);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EllipsisTooltip, [{
        type: Directive,
        args: [{
                selector: "[ibmEllipsisTooltip]",
                providers: [
                    DialogService
                ]
            }]
    }], null, { onClick: [{
            type: HostListener,
            args: ["click"]
        }], onHover: [{
            type: HostListener,
            args: ["mouseenter"]
        }], onFocus: [{
            type: HostListener,
            args: ["focus"]
        }] }); })();

/**
 * Extend the `Dialog` component to create an overflow menu.
 *
 * Not used directly. See overflow-menu.component and overflow-menu.directive for more
 */
class OverflowMenuPane extends Dialog {
    constructor(elementRef, i18n, experimental, animationFrameService = null, 
    // mark `elementService` as optional since making it mandatory would be a breaking change
    elementService = null) {
        super(elementRef, elementService, animationFrameService);
        this.elementRef = elementRef;
        this.i18n = i18n;
        this.experimental = experimental;
        this.animationFrameService = animationFrameService;
        this.elementService = elementService;
    }
    onDialogInit() {
        const positionOverflowMenu = pos => {
            let offset;
            /*
            * 20 is half the width of the overflow menu trigger element.
            * we also move the element by half of it's own width, since
            * position service will try and center everything
            */
            const closestRel = closestAttr("position", ["relative", "fixed", "absolute"], this.elementRef.nativeElement);
            const topFix = closestRel ? closestRel.getBoundingClientRect().top * -1 : 0;
            const leftFix = closestRel ? closestRel.getBoundingClientRect().left * -1 : 0;
            offset = Math.round(this.dialog.nativeElement.offsetWidth / 2) - 20;
            if (this.dialogConfig.flip) {
                return position.addOffset(pos, topFix, (-offset + leftFix));
            }
            return position.addOffset(pos, topFix, (offset + leftFix));
        };
        this.addGap["bottom"] = positionOverflowMenu;
        this.addGap["top"] = positionOverflowMenu;
        if (!this.dialogConfig.menuLabel) {
            this.dialogConfig.menuLabel = this.i18n.get().OVERFLOW_MENU.OVERFLOW;
        }
    }
    hostkeys(event) {
        const listItems = this.listItems();
        switch (event.key) {
            case "Down": // IE specific value
            case "ArrowDown":
                event.preventDefault();
                if (!isFocusInLastItem(event, listItems)) {
                    const index = listItems.findIndex(item => item === event.target);
                    listItems[index + 1].focus();
                }
                else {
                    listItems[0].focus();
                }
                break;
            case "Up": // IE specific value
            case "ArrowUp":
                event.preventDefault();
                if (!isFocusInFirstItem(event, listItems)) {
                    const index = listItems.findIndex(item => item === event.target);
                    listItems[index - 1].focus();
                }
                else {
                    listItems[listItems.length - 1].focus();
                }
                break;
            case "Home":
                event.preventDefault();
                listItems[0].focus();
                break;
            case "End":
                event.preventDefault();
                listItems[listItems.length - 1].focus();
                break;
            case "Esc": // IE specific value
            case "Escape":
            case "Tab":
                event.stopImmediatePropagation();
                this.doClose({
                    reason: CloseReasons.interaction,
                    target: event.target
                });
                break;
            default: break;
        }
    }
    onClose(event) {
        this.doClose({
            reason: CloseReasons.interaction,
            target: event.target
        });
    }
    afterDialogViewInit() {
        const focusElementList = this.listItems();
        focusElementList.forEach(button => {
            // Allows user to set tabindex to 0.
            if (button.getAttribute("tabindex") === null) {
                button.tabIndex = -1;
            }
        });
        if (focusElementList[0]) {
            focusElementList[0].tabIndex = 0;
            focusElementList[0].focus();
        }
    }
    listItems() {
        const selector = ".bx--overflow-menu-options__option:not([disabled]) .bx--overflow-menu-options__btn";
        return Array.from(this.elementRef.nativeElement.querySelectorAll(selector));
    }
}
OverflowMenuPane.ɵfac = function OverflowMenuPane_Factory(t) { return new (t || OverflowMenuPane)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.I18n), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.ExperimentalService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.AnimationFrameService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ElementService, 8)); };
OverflowMenuPane.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: OverflowMenuPane, selectors: [["ibm-overflow-menu-pane"]], hostBindings: function OverflowMenuPane_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function OverflowMenuPane_keydown_HostBindingHandler($event) { return ctx.hostkeys($event); });
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 9, consts: [["role", "menu", "role", "menu", 1, "bx--overflow-menu-options", "bx--overflow-menu-options--open", 3, "ngClass", "click"], ["dialog", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function OverflowMenuPane_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ul", 0, 1);
        ɵngcc0.ɵɵlistener("click", function OverflowMenuPane_Template_ul_click_0_listener($event) { return ctx.onClose($event); });
        ɵngcc0.ɵɵtemplate(2, OverflowMenuPane_ng_template_2_Template, 0, 0, "ng-template", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(5, _c5, ctx.dialogConfig.flip));
        ɵngcc0.ɵɵattribute("aria-label", ctx.dialogConfig.menuLabel)("aria-label", ctx.dialogConfig.menuLabel);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.dialogConfig.content)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(7, _c6, ctx));
    } }, directives: [ɵngcc3.NgClass, ɵngcc3.NgTemplateOutlet], encapsulation: 2 });
/** @nocollapse */
OverflowMenuPane.ctorParameters = () => [
    { type: ElementRef },
    { type: I18n },
    { type: ExperimentalService },
    { type: AnimationFrameService, decorators: [{ type: Optional }] },
    { type: ElementService, decorators: [{ type: Optional }] }
];
OverflowMenuPane.propDecorators = {
    hostkeys: [{ type: HostListener, args: ["keydown", ["$event"],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(OverflowMenuPane, [{
        type: Component,
        args: [{
                selector: "ibm-overflow-menu-pane",
                template: `
		<ul
			[attr.aria-label]="dialogConfig.menuLabel"
			[ngClass]="{'bx--overflow-menu--flip': dialogConfig.flip}"
			role="menu"
			#dialog
			class="bx--overflow-menu-options bx--overflow-menu-options--open"
			role="menu"
			(click)="onClose($event)"
			[attr.aria-label]="dialogConfig.menuLabel">
			<ng-template
				[ngTemplateOutlet]="dialogConfig.content"
				[ngTemplateOutletContext]="{overflowMenu: this}">
			</ng-template>
		</ul>
	`
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc4.I18n }, { type: ɵngcc5.ExperimentalService }, { type: ɵngcc2.AnimationFrameService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc2.ElementService, decorators: [{
                type: Optional
            }] }]; }, { hostkeys: [{
            type: HostListener,
            args: ["keydown", ["$event"]]
        }] }); })();

class OverflowMenuCustomPane extends Dialog {
    constructor(elementRef, i18n, animationFrameService = null, 
    // mark `elementService` as optional since making it mandatory would be a breaking change
    elementService = null) {
        super(elementRef, elementService, animationFrameService);
        this.elementRef = elementRef;
        this.i18n = i18n;
        this.animationFrameService = animationFrameService;
        this.elementService = elementService;
    }
    onDialogInit() {
        const positionOverflowMenu = pos => {
            let offset;
            /*
            * 20 is half the width of the overflow menu trigger element.
            * we also move the element by half of it's own width, since
            * position service will try and center everything
            */
            const closestRel = closestAttr("position", ["relative", "fixed", "absolute"], this.elementRef.nativeElement);
            const topFix = closestRel ? closestRel.getBoundingClientRect().top * -1 : 0;
            const leftFix = closestRel ? closestRel.getBoundingClientRect().left * -1 : 0;
            offset = Math.round(this.dialog.nativeElement.offsetWidth / 2) - 20;
            if (this.dialogConfig.flip) {
                return position.addOffset(pos, topFix, (-offset + leftFix));
            }
            return position.addOffset(pos, topFix, (offset + leftFix));
        };
        this.addGap["bottom"] = positionOverflowMenu;
        this.addGap["top"] = positionOverflowMenu;
        if (!this.dialogConfig.menuLabel) {
            this.dialogConfig.menuLabel = this.i18n.get().OVERFLOW_MENU.OVERFLOW;
        }
    }
}
OverflowMenuCustomPane.ɵfac = function OverflowMenuCustomPane_Factory(t) { return new (t || OverflowMenuCustomPane)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.I18n), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.AnimationFrameService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ElementService, 8)); };
OverflowMenuCustomPane.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: OverflowMenuCustomPane, selectors: [["ibm-overflow-custom-menu-pane"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 9, consts: [["role", "menu", 1, "bx--overflow-menu-options", "bx--overflow-menu-options--open", 3, "ngClass", "click"], ["dialog", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function OverflowMenuCustomPane_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵlistener("click", function OverflowMenuCustomPane_Template_div_click_0_listener() { return ctx.doClose(); });
        ɵngcc0.ɵɵtemplate(2, OverflowMenuCustomPane_ng_template_2_Template, 0, 0, "ng-template", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(5, _c5, ctx.dialogConfig.flip));
        ɵngcc0.ɵɵattribute("aria-label", ctx.dialogConfig.menuLabel)("aria-label", ctx.dialogConfig.menuLabel);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.dialogConfig.content)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(7, _c6, ctx));
    } }, directives: [ɵngcc3.NgClass, ɵngcc3.NgTemplateOutlet], encapsulation: 2 });
/** @nocollapse */
OverflowMenuCustomPane.ctorParameters = () => [
    { type: ElementRef },
    { type: I18n },
    { type: AnimationFrameService, decorators: [{ type: Optional }] },
    { type: ElementService, decorators: [{ type: Optional }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(OverflowMenuCustomPane, [{
        type: Component,
        args: [{
                selector: "ibm-overflow-custom-menu-pane",
                template: `
		<div
			[attr.aria-label]="dialogConfig.menuLabel"
			[ngClass]="{'bx--overflow-menu--flip': dialogConfig.flip}"
			class="bx--overflow-menu-options bx--overflow-menu-options--open"
			role="menu"
			(click)="doClose()"
			#dialog
			[attr.aria-label]="dialogConfig.menuLabel">
			<ng-template
				[ngTemplateOutlet]="dialogConfig.content"
				[ngTemplateOutletContext]="{overflowMenu: this}">
			</ng-template>
		</div>
	`
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc4.I18n }, { type: ɵngcc2.AnimationFrameService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc2.ElementService, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Directive for extending `Dialog` to create overflow menus.
 *
 * class: OverflowMenuDirective (extends DialogDirective)
 *
 *
 * selector: `ibmOverflowMenu`
 *
 *
 * ```html
 * <div [ibmOverflowMenu]="templateRef"></div>
 * <ng-template #templateRef>
 * 	<!-- overflow menu options here -->
 * </ng-template>
 * ```
 *
 * ```html
 * <div [ibmOverflowMenu]="templateRef" [customPane]="true"></div>
 * <ng-template #templateRef>
 *  <!-- custom content goes here -->
 * </ng-template>
 * ```
 */
class OverflowMenuDirective extends DialogDirective {
    /**
     * Creates an instance of `OverflowMenuDirective`.
     */
    constructor(elementRef, viewContainerRef, dialogService, eventService) {
        super(elementRef, viewContainerRef, dialogService, eventService);
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
        this.dialogService = dialogService;
        this.eventService = eventService;
        /**
         * Controls wether the overflow menu is flipped
         */
        this.flip = false;
        /**
         * Classes to add to the dialog container
         */
        this.wrapperClass = "";
        /**
         * Set to true to for custom content
         */
        this.customPane = false;
    }
    ngAfterContentInit() {
        this.dialogService.setContext({ component: this.customPane ? OverflowMenuCustomPane : OverflowMenuPane });
    }
    updateConfig() {
        this.dialogConfig.content = this.ibmOverflowMenu;
        this.dialogConfig.flip = this.flip;
        this.dialogConfig.offset = this.offset;
        this.dialogConfig.wrapperClass = this.wrapperClass;
    }
    hostkeys(event) {
        switch (event.key) {
            case "Enter":
            case " ":
                event.preventDefault();
                break;
        }
    }
}
OverflowMenuDirective.ɵfac = function OverflowMenuDirective_Factory(t) { return new (t || OverflowMenuDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DialogService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.EventService)); };
OverflowMenuDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: OverflowMenuDirective, selectors: [["", "ibmOverflowMenu", ""]], hostBindings: function OverflowMenuDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function OverflowMenuDirective_keydown_HostBindingHandler($event) { return ctx.hostkeys($event); });
    } }, inputs: { flip: "flip", wrapperClass: "wrapperClass", customPane: "customPane", ibmOverflowMenu: "ibmOverflowMenu", offset: "offset" }, exportAs: ["ibmOverflowMenu"], features: [ɵngcc0.ɵɵProvidersFeature([
            DialogService
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
OverflowMenuDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: DialogService },
    { type: EventService }
];
OverflowMenuDirective.propDecorators = {
    ibmOverflowMenu: [{ type: Input }],
    flip: [{ type: Input }],
    offset: [{ type: Input }],
    wrapperClass: [{ type: Input }],
    customPane: [{ type: Input }],
    hostkeys: [{ type: HostListener, args: ["keydown", ["$event"],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(OverflowMenuDirective, [{
        type: Directive,
        args: [{
                selector: "[ibmOverflowMenu]",
                exportAs: "ibmOverflowMenu",
                providers: [
                    DialogService
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ViewContainerRef }, { type: DialogService }, { type: ɵngcc2.EventService }]; }, { flip: [{
            type: Input
        }], wrapperClass: [{
            type: Input
        }], customPane: [{
            type: Input
        }], hostkeys: [{
            type: HostListener,
            args: ["keydown", ["$event"]]
        }], ibmOverflowMenu: [{
            type: Input
        }], offset: [{
            type: Input
        }] }); })();

/**
 * The OverFlow menu component encapsulates the OverFlowMenu directive, and the menu iconography into one convienent component
 *
 * [See demo](../../?path=/story/overflow-menu--basic)
 *
 * html:
 * ```
 * <ibm-overflow-menu>
 *	<ibm-overflow-menu-option>Option 1</ibm-overflow-menu-option>
 *	<ibm-overflow-menu-option>Option 2</ibm-overflow-menu-option>
 * </ibm-overflow-menu>
 * ```
 *
 * <example-url>../../iframe.html?id=overflow-menu--basic</example-url>
 */
class OverflowMenu {
    constructor(elementRef, i18n) {
        this.elementRef = elementRef;
        this.i18n = i18n;
        this.buttonLabel = this.i18n.get().OVERFLOW_MENU.OVERFLOW;
        this.flip = false;
        this.placement = "bottom";
        this.open = false;
        this.openChange = new EventEmitter();
        this.wrapperClass = "";
        /**
         * This appends additional classes to the overflow trigger/button.
         */
        this.triggerClass = "";
    }
    handleOpenChange(event) {
        this.open = event;
        this.openChange.emit(event);
    }
}
OverflowMenu.ɵfac = function OverflowMenu_Factory(t) { return new (t || OverflowMenu)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.I18n)); };
OverflowMenu.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: OverflowMenu, selectors: [["ibm-overflow-menu"]], contentQueries: function OverflowMenu_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, OverflowMenuDirective, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.overflowMenuDirective = _t.first);
    } }, inputs: { buttonLabel: "buttonLabel", flip: "flip", placement: "placement", open: "open", wrapperClass: "wrapperClass", triggerClass: "triggerClass", customTrigger: "customTrigger", offset: "offset" }, outputs: { openChange: "openChange" }, ngContentSelectors: _c3, decls: 6, vars: 15, consts: [["aria-haspopup", "true", "type", "button", 1, "bx--overflow-menu", 3, "ibmOverflowMenu", "ngClass", "flip", "isOpen", "offset", "wrapperClass", "placement", "isOpenChange"], [4, "ngIf", "ngIfElse"], ["options", ""], ["defaultIcon", ""], [3, "ngTemplateOutlet"], ["ibmIcon", "overflow-menu--vertical", "size", "16", 1, "bx--overflow-menu__icon"]], template: function OverflowMenu_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("isOpenChange", function OverflowMenu_Template_button_isOpenChange_0_listener($event) { return ctx.handleOpenChange($event); });
        ɵngcc0.ɵɵtemplate(1, OverflowMenu_1_Template, 1, 1, undefined, 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, OverflowMenu_ng_template_2_Template, 1, 0, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, OverflowMenu_ng_template_4_Template, 1, 0, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(3);
        const _r3 = ɵngcc0.ɵɵreference(5);
        ɵngcc0.ɵɵclassMapInterpolate1("bx--overflow-menu ", ctx.triggerClass, "");
        ɵngcc0.ɵɵproperty("ibmOverflowMenu", _r1)("ngClass", ɵngcc0.ɵɵpureFunction1(13, _c7, ctx.open))("flip", ctx.flip)("isOpen", ctx.open)("offset", ctx.offset)("wrapperClass", ctx.wrapperClass)("placement", ctx.placement);
        ɵngcc0.ɵɵattribute("aria-label", ctx.buttonLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.customTrigger)("ngIfElse", _r3);
    } }, directives: [OverflowMenuDirective, ɵngcc3.NgClass, ɵngcc3.NgIf, ɵngcc3.NgTemplateOutlet, ɵngcc6.IconDirective], styles: ["\n\t\t.bx--overflow-menu--open {\n\t\t\topacity: 1\n\t\t}\n\n\t\t/*\n\t\tRotate the overflow menu container as well as the icon, since\n\t\twe calculate our menu position based on the container, not the icon.\n\t\t*/\n\t\t.bx--data-table-v2 .bx--overflow-menu {\n\t\t\ttransform: rotate(90deg);\n\t\t}\n\n\t\t.bx--data-table-v2 .bx--overflow-menu__icon {\n\t\t\ttransform: rotate(180deg);\n\t\t}\n\t"], encapsulation: 2 });
/** @nocollapse */
OverflowMenu.ctorParameters = () => [
    { type: ElementRef },
    { type: I18n }
];
OverflowMenu.propDecorators = {
    buttonLabel: [{ type: Input }],
    flip: [{ type: Input }],
    placement: [{ type: Input }],
    open: [{ type: Input }],
    openChange: [{ type: Output }],
    customTrigger: [{ type: Input }],
    offset: [{ type: Input }],
    wrapperClass: [{ type: Input }],
    triggerClass: [{ type: Input }],
    overflowMenuDirective: [{ type: ContentChild, args: [OverflowMenuDirective, { static: false },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(OverflowMenu, [{
        type: Component,
        args: [{
                selector: "ibm-overflow-menu",
                template: `
		<button
			[ibmOverflowMenu]="options"
			[ngClass]="{'bx--overflow-menu--open': open}"
			class="bx--overflow-menu {{triggerClass}}"
			[attr.aria-label]="buttonLabel"
			[flip]="flip"
			[isOpen]="open"
			(isOpenChange)="handleOpenChange($event)"
			[offset]="offset"
			[wrapperClass]="wrapperClass"
			aria-haspopup="true"
			class="bx--overflow-menu"
			type="button"
			[placement]="placement">
			<ng-template *ngIf="customTrigger; else defaultIcon" [ngTemplateOutlet]="customTrigger"></ng-template>
		</button>
		<ng-template #options>
			<ng-content></ng-content>
		</ng-template>
		<ng-template #defaultIcon>
			<svg ibmIcon="overflow-menu--vertical" size="16" class="bx--overflow-menu__icon"></svg>
		</ng-template>
	`,
                encapsulation: ViewEncapsulation.None,
                styles: [`
		.bx--overflow-menu--open {
			opacity: 1
		}

		/*
		Rotate the overflow menu container as well as the icon, since
		we calculate our menu position based on the container, not the icon.
		*/
		.bx--data-table-v2 .bx--overflow-menu {
			transform: rotate(90deg);
		}

		.bx--data-table-v2 .bx--overflow-menu__icon {
			transform: rotate(180deg);
		}
	`]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc4.I18n }]; }, { buttonLabel: [{
            type: Input
        }], flip: [{
            type: Input
        }], placement: [{
            type: Input
        }], open: [{
            type: Input
        }], openChange: [{
            type: Output
        }], wrapperClass: [{
            type: Input
        }], triggerClass: [{
            type: Input
        }], customTrigger: [{
            type: Input
        }], offset: [{
            type: Input
        }], overflowMenuDirective: [{
            type: ContentChild,
            args: [OverflowMenuDirective, { static: false }]
        }] }); })();

/**
 * Available HTML anchor targets
 */
var Target;
(function (Target) {
    Target["self"] = "_self";
    Target["blank"] = "_blank";
    Target["parent"] = "_parent";
    Target["top"] = "_top";
})(Target || (Target = {}));
/**
 * Security HTML anchor rel when target is set
 */
const REL = "noreferrer noopener";
/**
 * `OverflowMenuOption` represents a single option in an overflow menu
 *
 * Presently it has three possible states - normal, disabled, and danger:
 * ```
 * <ibm-overflow-menu-option>Simple option</ibm-overflow-menu-option>
 * <ibm-overflow-menu-option disabled="true">Disabled</ibm-overflow-menu-option>
 * <ibm-overflow-menu-option type="danger">Danger option</ibm-overflow-menu-option>
 * ```
 *
 * For content that expands beyond the overflow menu `OverflowMenuOption` automatically adds a title attribute.
 */
class OverflowMenuOption {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.optionClass = "bx--overflow-menu-options__option";
        this.role = "presentation";
        /**
         * toggles between `normal` and `danger` states
         */
        this.type = "normal";
        /**
         * disable/enable interactions
         */
        this.disabled = false;
        this.selected = new EventEmitter();
        this.tabIndex = -1;
        // note: title must be a real attribute (i.e. not a getter) as of Angular@6 due to
        // change after checked errors
        this.title = null;
    }
    get isDanger() {
        return this.type === "danger";
    }
    get isDisabled() {
        return this.disabled;
    }
    /**
     * Allows to add a target to the anchor
     */
    set target(value) {
        if (!Object.values(Target).includes(value)) {
            console.warn(`\`target\` must have one of the following values: ${Object.values(Target).join(", ")}.
Please use the \`Target\` enum exported by carbon-components-angular`);
            return;
        }
        this._target = value;
    }
    get target() {
        return this._target;
    }
    /**
     * rel only returns its value if target is defined
     */
    get rel() {
        return this._target ? REL : null;
    }
    onClick() {
        this.selected.emit();
    }
    onFocus() {
        setTimeout(() => this.tabIndex = 0);
    }
    onBlur() {
        setTimeout(() => this.tabIndex = -1);
    }
    ngAfterViewInit() {
        const button = this.elementRef.nativeElement.querySelector("button, a");
        const textContainer = button.querySelector(".bx--overflow-menu-options__option-content");
        if (textContainer.scrollWidth > textContainer.offsetWidth) {
            this.title = button.textContent;
        }
    }
}
OverflowMenuOption.ɵfac = function OverflowMenuOption_Factory(t) { return new (t || OverflowMenuOption)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
OverflowMenuOption.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: OverflowMenuOption, selectors: [["ibm-overflow-menu-option"]], hostVars: 7, hostBindings: function OverflowMenuOption_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
        ɵngcc0.ɵɵclassMap(ctx.optionClass);
        ɵngcc0.ɵɵclassProp("bx--overflow-menu-options__option--danger", ctx.isDanger)("bx--overflow-menu-options__option--disabled", ctx.isDisabled);
    } }, inputs: { type: "type", disabled: "disabled", target: "target", href: "href" }, outputs: { selected: "selected" }, ngContentSelectors: _c3, decls: 4, vars: 2, consts: [["class", "bx--overflow-menu-options__btn", "role", "menuitem", 3, "tabindex", "disabled", "focus", "blur", "click", 4, "ngIf"], ["class", "bx--overflow-menu-options__btn", "role", "menuitem", 3, "tabindex", "href", "focus", "blur", "click", 4, "ngIf"], ["tempOutlet", ""], ["role", "menuitem", 1, "bx--overflow-menu-options__btn", 3, "tabindex", "disabled", "focus", "blur", "click"], [4, "ngTemplateOutlet"], ["role", "menuitem", 1, "bx--overflow-menu-options__btn", 3, "tabindex", "href", "focus", "blur", "click"], [1, "bx--overflow-menu-options__option-content"]], template: function OverflowMenuOption_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, OverflowMenuOption_button_0_Template, 2, 4, "button", 0);
        ɵngcc0.ɵɵtemplate(1, OverflowMenuOption_a_1_Template, 2, 7, "a", 1);
        ɵngcc0.ɵɵtemplate(2, OverflowMenuOption_ng_template_2_Template, 2, 0, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.href);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.href);
    } }, directives: [ɵngcc3.NgIf, ɵngcc3.NgTemplateOutlet], encapsulation: 2 });
/** @nocollapse */
OverflowMenuOption.ctorParameters = () => [
    { type: ElementRef }
];
OverflowMenuOption.propDecorators = {
    optionClass: [{ type: HostBinding, args: ["class",] }],
    role: [{ type: HostBinding, args: ["attr.role",] }],
    isDanger: [{ type: HostBinding, args: ["class.bx--overflow-menu-options__option--danger",] }],
    isDisabled: [{ type: HostBinding, args: ["class.bx--overflow-menu-options__option--disabled",] }],
    type: [{ type: Input }],
    disabled: [{ type: Input }],
    href: [{ type: Input }],
    target: [{ type: Input }],
    selected: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(OverflowMenuOption, [{
        type: Component,
        args: [{
                selector: "ibm-overflow-menu-option",
                template: `
		<button
			*ngIf="!href"
			class="bx--overflow-menu-options__btn"
			role="menuitem"
			[tabindex]="tabIndex"
			(focus)="onFocus()"
			(blur)="onBlur()"
			(click)="onClick()"
			[disabled]="disabled"
			[attr.title]="title">
			<ng-container *ngTemplateOutlet="tempOutlet"></ng-container>
		</button>

		<a
			*ngIf="href"
			class="bx--overflow-menu-options__btn"
			role="menuitem"
			[tabindex]="tabIndex"
			(focus)="onFocus()"
			(blur)="onBlur()"
			(click)="onClick()"
			[attr.disabled]="disabled"
			[href]="href"
			[attr.target]="target"
			[attr.rel]="rel"
			[attr.title]="title">
			<ng-container *ngTemplateOutlet="tempOutlet"></ng-container>
		</a>

		<ng-template #tempOutlet>
			<div class="bx--overflow-menu-options__option-content">
				<ng-content></ng-content>
			</div>
		</ng-template>
	`
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { optionClass: [{
            type: HostBinding,
            args: ["class"]
        }], role: [{
            type: HostBinding,
            args: ["attr.role"]
        }], type: [{
            type: Input
        }], disabled: [{
            type: Input
        }], selected: [{
            type: Output
        }], isDanger: [{
            type: HostBinding,
            args: ["class.bx--overflow-menu-options__option--danger"]
        }], isDisabled: [{
            type: HostBinding,
            args: ["class.bx--overflow-menu-options__option--disabled"]
        }], target: [{
            type: Input
        }], href: [{
            type: Input
        }] }); })();

// modules
class DialogModule {
}
DialogModule.ɵfac = function DialogModule_Factory(t) { return new (t || DialogModule)(); };
DialogModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: DialogModule });
DialogModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [DialogService], imports: [[
            CommonModule,
            I18nModule,
            PlaceholderModule,
            ExperimentalModule,
            UtilsModule,
            IconModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DialogModule, { declarations: function () { return [Dialog, Tooltip, TooltipDefinition, TooltipIcon, OverflowMenu, OverflowMenuPane, OverflowMenuCustomPane, DialogDirective, TooltipDirective, EllipsisTooltip, OverflowMenuDirective, OverflowMenuOption]; }, imports: function () { return [CommonModule,
        I18nModule,
        PlaceholderModule,
        ExperimentalModule,
        UtilsModule,
        IconModule]; }, exports: function () { return [Dialog, Tooltip, TooltipDefinition, TooltipIcon, OverflowMenu, OverflowMenuPane, OverflowMenuCustomPane, DialogDirective, TooltipDirective, EllipsisTooltip, OverflowMenuDirective, OverflowMenuOption]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DialogModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    Dialog,
                    Tooltip,
                    TooltipDefinition,
                    TooltipIcon,
                    OverflowMenu,
                    OverflowMenuPane,
                    OverflowMenuCustomPane,
                    DialogDirective,
                    TooltipDirective,
                    EllipsisTooltip,
                    OverflowMenuDirective,
                    OverflowMenuOption
                ],
                exports: [
                    Dialog,
                    Tooltip,
                    TooltipDefinition,
                    TooltipIcon,
                    OverflowMenu,
                    OverflowMenuPane,
                    OverflowMenuCustomPane,
                    DialogDirective,
                    TooltipDirective,
                    EllipsisTooltip,
                    OverflowMenuDirective,
                    OverflowMenuOption
                ],
                providers: [DialogService],
                entryComponents: [
                    Dialog,
                    Tooltip,
                    OverflowMenuPane,
                    OverflowMenuCustomPane
                ],
                imports: [
                    CommonModule,
                    I18nModule,
                    PlaceholderModule,
                    ExperimentalModule,
                    UtilsModule,
                    IconModule
                ]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { DialogService, Dialog, DialogDirective, Tooltip, TooltipDefinition, TooltipIcon, TooltipDirective, EllipsisTooltip, OverflowMenu, OverflowMenuPane, OverflowMenuCustomPane, OverflowMenuDirective, OverflowMenuOption, CloseReasons, DialogModule };

//# sourceMappingURL=carbon-components-angular-dialog.js.map