/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-table.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Subject, BehaviorSubject, combineLatest, Subscription, fromEvent } from 'rxjs';
import { tabbableSelectorIgnoreTabIndex, getFocusElementList } from 'carbon-components-angular/common';
import { merge, getScrollbarWidth } from 'carbon-components-angular/utils';
import { map } from 'rxjs/operators';
import { EventEmitter, Component, Input, Output, HostBinding, Directive, HostListener, ApplicationRef, ElementRef, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { NFormsModule } from 'carbon-components-angular/forms';
import { DialogModule } from 'carbon-components-angular/dialog';
import { I18n, I18nModule } from 'carbon-components-angular/i18n';
import { ButtonModule } from 'carbon-components-angular/button';
import { Search, SearchModule } from 'carbon-components-angular/search';
import { IconModule } from 'carbon-components-angular/icon';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from 'carbon-components-angular/i18n';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from 'carbon-components-angular/button';
import * as ɵngcc4 from 'carbon-components-angular/icon';
import * as ɵngcc5 from 'carbon-components-angular/dialog';
import * as ɵngcc6 from 'carbon-components-angular/checkbox';
import * as ɵngcc7 from 'carbon-components-angular/radio';

function TableToolbar_div_1_p_8_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const legacyText_r6 = ctx.ngIf;
    const n_r2 = ɵngcc0.ɵɵnextContext().ngIf;
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(n_r2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", legacyText_r6, " ");
} }
function TableToolbar_div_1_p_8_ng_template_3_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵpipe(2, "async");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r8._batchTextSingle.subject));
} }
const _c0 = function (a0) { return { count: a0 }; };
function TableToolbar_div_1_p_8_ng_template_3_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵpipe(2, "async");
    ɵngcc0.ɵɵpipe(3, "i18nReplace");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const n_r2 = ɵngcc0.ɵɵnextContext(2).ngIf;
    const ctx_r9 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind1(2, 1, ɵngcc0.ɵɵpipeBind2(3, 3, ctx_r9._batchTextMultiple.subject, ɵngcc0.ɵɵpureFunction1(6, _c0, n_r2))));
} }
function TableToolbar_div_1_p_8_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TableToolbar_div_1_p_8_ng_template_3_span_0_Template, 3, 3, "span", 10);
    ɵngcc0.ɵɵtemplate(1, TableToolbar_div_1_p_8_ng_template_3_span_1_Template, 4, 8, "span", 10);
} if (rf & 2) {
    const n_r2 = ɵngcc0.ɵɵnextContext().ngIf;
    ɵngcc0.ɵɵproperty("ngIf", n_r2 === 1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", n_r2 !== 1);
} }
function TableToolbar_div_1_p_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "p", 7);
    ɵngcc0.ɵɵtemplate(1, TableToolbar_div_1_p_8_ng_container_1_Template, 4, 2, "ng-container", 8);
    ɵngcc0.ɵɵpipe(2, "async");
    ɵngcc0.ɵɵtemplate(3, TableToolbar_div_1_p_8_ng_template_3_Template, 2, 2, "ng-template", null, 9, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r4 = ɵngcc0.ɵɵreference(4);
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ɵngcc0.ɵɵpipeBind1(2, 2, ctx_r1._batchTextLegacy.subject))("ngIfElse", _r4);
} }
const _c1 = function (a0) { return { "bx--batch-actions--active": a0 }; };
function TableToolbar_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵelementStart(2, "div", 3);
    ɵngcc0.ɵɵprojection(3, 1);
    ɵngcc0.ɵɵelementStart(4, "button", 4);
    ɵngcc0.ɵɵlistener("click", function TableToolbar_div_1_Template_button_click_4_listener() { ɵngcc0.ɵɵrestoreView(_r13); const ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onCancel(); });
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵpipe(6, "async");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(7, "div", 5);
    ɵngcc0.ɵɵtemplate(8, TableToolbar_div_1_p_8_Template, 5, 4, "p", 6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(9, _c1, ctx_r0.selected));
    ɵngcc0.ɵɵattribute("aria-label", ɵngcc0.ɵɵpipeBind1(1, 5, ctx_r0.actionBarLabel.subject));
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("tabindex", ctx_r0.selected ? 0 : -1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ɵngcc0.ɵɵpipeBind1(6, 7, ctx_r0._cancelText.subject), " ");
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.count);
} }
const _c2 = ["*", [["ibm-table-toolbar-actions"]]];
const _c3 = function (a0) { return { "bx--table-toolbar--small": a0 }; };
const _c4 = ["*", "ibm-table-toolbar-actions"];
const _c5 = ["*"];
function TableToolbarSearch_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 5);
} }
function TableToolbarSearch_ng_template_4_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 10);
    ɵngcc0.ɵɵlistener("click", function TableToolbarSearch_ng_template_4_button_2_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r7 = ɵngcc0.ɵɵnextContext(2); return ctx_r7.openSearch(); });
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(1, "svg", 11);
    ɵngcc0.ɵɵelementEnd();
} }
function TableToolbarSearch_ng_template_4__svg_svg_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 11);
} }
function TableToolbarSearch_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    const _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "input", 6, 7);
    ɵngcc0.ɵɵlistener("input", function TableToolbarSearch_ng_template_4_Template_input_input_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.onSearch($event.target.value); })("keyup.enter", function TableToolbarSearch_ng_template_4_Template_input_keyup_enter_0_listener() { ɵngcc0.ɵɵrestoreView(_r10); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onEnter(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, TableToolbarSearch_ng_template_4_button_2_Template, 2, 0, "button", 8);
    ɵngcc0.ɵɵtemplate(3, TableToolbarSearch_ng_template_4__svg_svg_3_Template, 1, 0, "svg", 9);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("type", ctx_r2.tableSearch || !ctx_r2.toolbar ? "text" : "search")("id", ctx_r2.id)("value", ctx_r2.value)("autocomplete", ctx_r2.autocomplete)("placeholder", ctx_r2.placeholder)("disabled", ctx_r2.disabled)("required", ctx_r2.required);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r2.tableSearch && ctx_r2.toolbar);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.tableSearch || !ctx_r2.toolbar);
} }
const _c6 = function (a0) { return { "bx--search-close--hidden": a0 }; };
function TableToolbarSearch_button_6_Template(rf, ctx) { if (rf & 1) {
    const _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 12);
    ɵngcc0.ɵɵlistener("click", function TableToolbarSearch_button_6_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r13); const ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.clearSearch(); });
    ɵngcc0.ɵɵelementStart(1, "span", 13);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(3, "svg", 14);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(3, _c6, !ctx_r3.value || ctx_r3.value.length === 0))("title", ctx_r3.clearButtonTitle);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.clearButtonTitle);
} }
const _c7 = function (a0, a1, a2, a3, a4, a5, a6) { return { "bx--search--sm": a0, "bx--search--lg": a1, "bx--search--xl": a2, "bx--search--light": a3, "bx--skeleton": a4, "bx--toolbar-search": a5, "bx--toolbar-search--active": a6 }; };
const _c8 = function () { return { "overflow-y": "scroll" }; };
function Table_tbody_2_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "tbody", 6);
    ɵngcc0.ɵɵlistener("deselectRow", function Table_tbody_2_Template_tbody_deselectRow_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.onSelectRow($event); })("scroll", function Table_tbody_2_Template_tbody_scroll_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.onScroll($event); })("selectRow", function Table_tbody_2_Template_tbody_selectRow_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.onSelectRow($event); })("rowClick", function Table_tbody_2_Template_tbody_rowClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.onRowClick($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("checkboxRowLabel", ctx_r0.getCheckboxRowLabel())("enableSingleSelect", ctx_r0.enableSingleSelect)("expandButtonAriaLabel", ctx_r0.expandButtonAriaLabel)("model", ctx_r0.model)("size", ctx_r0.size)("ngStyle", ɵngcc0.ɵɵpureFunction0(9, _c8))("selectionLabelColumn", ctx_r0.selectionLabelColumn)("showSelectionColumn", ctx_r0.showSelectionColumn)("skeleton", ctx_r0.skeleton);
} }
function Table_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
function Table_ng_template_6_Template(rf, ctx) { }
function Table_tr_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr");
    ɵngcc0.ɵɵelementStart(1, "td", 7);
    ɵngcc0.ɵɵelementStart(2, "div", 8);
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(3, "svg", 9);
    ɵngcc0.ɵɵelement(4, "circle", 10);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
function Table_tr_8_Template(rf, ctx) { if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "tr");
    ɵngcc0.ɵɵelementStart(1, "td", 11);
    ɵngcc0.ɵɵelementStart(2, "h5");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵpipe(4, "async");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "button", 12);
    ɵngcc0.ɵɵlistener("click", function Table_tr_8_Template_button_click_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.scrollToTop($event); });
    ɵngcc0.ɵɵtext(6);
    ɵngcc0.ɵɵpipe(7, "async");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind1(4, 2, ctx_r5.getEndOfDataText()));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate1(" ", ɵngcc0.ɵɵpipeBind1(7, 4, ctx_r5.getScrollTopText()), " ");
} }
const _c9 = function (a0) { return { "bx--data-table--sticky-header": a0 }; };
const _c10 = ["ibmTableHead", ""];
const _c11 = function (a0) { return { "bx--table-expand-v2": a0 }; };
function TableHead_ng_container_0_th_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "th", 6);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(2, _c11, ctx_r1.stickyHeader))("id", ctx_r1.model.getId("expand"));
} }
function TableHead_ng_container_0_th_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "th", 7);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("id", ctx_r2.model.getId("select"));
} }
function TableHead_ng_container_0_th_4_Template(rf, ctx) { if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "th", 8);
    ɵngcc0.ɵɵlistener("change", function TableHead_ng_container_0_th_4_Template_th_change_0_listener() { ɵngcc0.ɵɵrestoreView(_r7); const ctx_r6 = ɵngcc0.ɵɵnextContext(2); return ctx_r6.onSelectAllCheckboxChange(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("checked", ctx_r3.selectAllCheckbox)("indeterminate", ctx_r3.selectAllCheckboxSomeSelected)("ariaLabel", ctx_r3.getCheckboxHeaderLabel())("size", ctx_r3.size)("skeleton", ctx_r3.skeleton)("name", ctx_r3.model.getHeaderId("select"))("id", ctx_r3.model.getId("select"));
} }
function TableHead_ng_container_0_ng_container_5_th_1_Template(rf, ctx) { if (rf & 1) {
    const _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "th", 10);
    ɵngcc0.ɵɵlistener("sort", function TableHead_ng_container_0_ng_container_5_th_1_Template_th_sort_0_listener() { ɵngcc0.ɵɵrestoreView(_r13); const i_r9 = ɵngcc0.ɵɵnextContext().index; const ctx_r11 = ɵngcc0.ɵɵnextContext(2); return ctx_r11.sort.emit(i_r9); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r14 = ɵngcc0.ɵɵnextContext();
    const column_r8 = ctx_r14.$implicit;
    const i_r9 = ctx_r14.index;
    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵclassMap(column_r8.className);
    ɵngcc0.ɵɵproperty("ngStyle", column_r8.style)("sortable", ctx_r10.sortable)("skeleton", ctx_r10.skeleton)("id", ctx_r10.model.getId(i_r9))("column", column_r8)("skeleton", ctx_r10.skeleton)("filterTitle", ctx_r10.getFilterTitle());
    ɵngcc0.ɵɵattribute("colspan", column_r8.colSpan)("rowspan", column_r8.rowSpan);
} }
function TableHead_ng_container_0_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TableHead_ng_container_0_ng_container_5_th_1_Template, 1, 11, "th", 9);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const column_r8 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", column_r8 && column_r8.visible);
} }
const _c12 = function (a0) { return { "width": a0, "padding": 0, "border": 0 }; };
function TableHead_ng_container_0_th_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "th", 11);
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(1, _c12, ctx_r5.scrollbarWidth + "px"));
} }
function TableHead_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "tr");
    ɵngcc0.ɵɵtemplate(2, TableHead_ng_container_0_th_2_Template, 1, 4, "th", 1);
    ɵngcc0.ɵɵtemplate(3, TableHead_ng_container_0_th_3_Template, 1, 1, "th", 2);
    ɵngcc0.ɵɵtemplate(4, TableHead_ng_container_0_th_4_Template, 1, 7, "th", 3);
    ɵngcc0.ɵɵtemplate(5, TableHead_ng_container_0_ng_container_5_Template, 2, 1, "ng-container", 4);
    ɵngcc0.ɵɵtemplate(6, TableHead_ng_container_0_th_6_Template, 1, 3, "th", 5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.model.hasExpandableRows());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.skeleton && ctx_r0.showSelectionColumn && ctx_r0.enableSingleSelect);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.skeleton && ctx_r0.showSelectionColumn && !ctx_r0.enableSingleSelect);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.model.header);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.skeleton && ctx_r0.stickyHeader && ctx_r0.scrollbarWidth);
} }
const _c13 = ["ibmTableHeadCell", ""];
function TableHeadCell_button_0_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r3.column.data, " ");
} }
function TableHeadCell_button_0_4_ng_template_0_Template(rf, ctx) { }
const _c14 = function (a0) { return { data: a0 }; };
function TableHeadCell_button_0_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TableHeadCell_button_0_4_ng_template_0_Template, 0, 0, "ng-template", 10);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r4.column.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c14, ctx_r4.column.data));
} }
function TableHeadCell_button_0__svg_svg_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "svg", 11);
    ɵngcc0.ɵɵelement(1, "path", 12);
    ɵngcc0.ɵɵelementEnd();
} }
function TableHeadCell_button_0__svg_svg_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "svg", 13);
    ɵngcc0.ɵɵelement(1, "path", 14);
    ɵngcc0.ɵɵelementEnd();
} }
const _c15 = function (a0, a1) { return { "bx--table-sort--active": a0, "bx--table-sort--ascending": a1 }; };
function TableHeadCell_button_0_Template(rf, ctx) { if (rf & 1) {
    const _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 3);
    ɵngcc0.ɵɵlistener("click", function TableHeadCell_button_0_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r9); const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.onClick(); });
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵelementStart(2, "span", 4);
    ɵngcc0.ɵɵtemplate(3, TableHeadCell_button_0_div_3_Template, 2, 1, "div", 5);
    ɵngcc0.ɵɵtemplate(4, TableHeadCell_button_0_4_Template, 1, 4, undefined, 6);
    ɵngcc0.ɵɵtemplate(5, TableHeadCell_button_0__svg_svg_5_Template, 2, 0, "svg", 7);
    ɵngcc0.ɵɵtemplate(6, TableHeadCell_button_0__svg_svg_6_Template, 2, 0, "svg", 8);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(9, _c15, ctx_r0.column.sorted, ctx_r0.column.ascending));
    ɵngcc0.ɵɵattribute("aria-label", ɵngcc0.ɵɵpipeBind1(1, 7, ctx_r0.column.sorted && ctx_r0.column.ascending ? ctx_r0.getSortDescendingLabel() : ctx_r0.getSortAscendingLabel()));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("title", ctx_r0.column.data);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.skeleton && !ctx_r0.column.template);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.skeleton && ctx_r0.column.template);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.skeleton);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.skeleton);
} }
function TableHeadCell_div_1_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 17);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("title", ctx_r10.column.data);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r10.column.data);
} }
function TableHeadCell_div_1_ng_template_2_Template(rf, ctx) { }
function TableHeadCell_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 15);
    ɵngcc0.ɵɵtemplate(1, TableHeadCell_div_1_span_1_Template, 2, 2, "span", 16);
    ɵngcc0.ɵɵtemplate(2, TableHeadCell_div_1_ng_template_2_Template, 0, 0, "ng-template", 10);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.column.template);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.column.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(3, _c14, ctx_r1.column.data));
} }
function TableHeadCell_button_2_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r12.column.filterCount, " ");
} }
const _c16 = function (a0) { return { "active": a0 }; };
function TableHeadCell_button_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "button", 18);
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(2, "svg", 19);
    ɵngcc0.ɵɵelement(3, "path", 20);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, TableHeadCell_button_2_span_4_Template, 2, 1, "span", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(7, _c16, ctx_r2.column.filterCount > 0))("ibmTooltip", ctx_r2.column.filterTemplate)("title", ɵngcc0.ɵɵpipeBind1(1, 5, ctx_r2.getFilterTitle()))("data", ctx_r2.column.filterData);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.column.filterCount > 0);
} }
const _c17 = ["ibmTableHeadCheckbox", ""];
function TableHeadCheckbox_ibm_checkbox_0_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ibm-checkbox", 1);
    ɵngcc0.ɵɵlistener("checkedChange", function TableHeadCheckbox_ibm_checkbox_0_Template_ibm_checkbox_checkedChange_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.change.emit(); });
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("size", ctx_r0.size !== "sm" ? "md" : "sm")("name", ctx_r0.name)("checked", ctx_r0.checked)("indeterminate", ctx_r0.indeterminate)("aria-label", ɵngcc0.ɵɵpipeBind1(1, 5, ctx_r0.getAriaLabel()));
} }
const _c18 = ["ibmTableHeadExpand", ""];
const _c19 = ["ibmTableBody", ""];
const _c20 = function (a0, a1, a2, a3) { return { "tbody_row--success": a0, "tbody_row--warning": a1, "tbody_row--info": a2, "tbody_row--error": a3 }; };
function TableBody_ng_container_0_ng_container_1_tr_1_Template(rf, ctx) { if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "tr", 3);
    ɵngcc0.ɵɵlistener("selectRow", function TableBody_ng_container_0_ng_container_1_tr_1_Template_tr_selectRow_0_listener() { ɵngcc0.ɵɵrestoreView(_r8); const i_r3 = ɵngcc0.ɵɵnextContext().index; const ctx_r6 = ɵngcc0.ɵɵnextContext(2); return ctx_r6.onRowCheckboxChange(i_r3); })("deselectRow", function TableBody_ng_container_0_ng_container_1_tr_1_Template_tr_deselectRow_0_listener() { ɵngcc0.ɵɵrestoreView(_r8); const i_r3 = ɵngcc0.ɵɵnextContext().index; const ctx_r9 = ɵngcc0.ɵɵnextContext(2); return ctx_r9.onRowCheckboxChange(i_r3); })("expandRow", function TableBody_ng_container_0_ng_container_1_tr_1_Template_tr_expandRow_0_listener() { ɵngcc0.ɵɵrestoreView(_r8); const i_r3 = ɵngcc0.ɵɵnextContext().index; const ctx_r11 = ɵngcc0.ɵɵnextContext(2); return ctx_r11.model.expandRow(i_r3, !ctx_r11.model.isRowExpanded(i_r3)); })("rowClick", function TableBody_ng_container_0_ng_container_1_tr_1_Template_tr_rowClick_0_listener() { ɵngcc0.ɵɵrestoreView(_r8); const i_r3 = ɵngcc0.ɵɵnextContext().index; const ctx_r13 = ɵngcc0.ɵɵnextContext(2); return ctx_r13.onRowClick(i_r3); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r15 = ɵngcc0.ɵɵnextContext();
    const i_r3 = ctx_r15.index;
    const row_r2 = ctx_r15.$implicit;
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵclassMap(ctx_r4.model.rowsClass[i_r3] ? ctx_r4.model.rowsClass[i_r3] : null);
    ɵngcc0.ɵɵproperty("model", ctx_r4.model)("row", row_r2)("size", ctx_r4.size)("selected", ctx_r4.model.isRowSelected(i_r3))("expandable", ctx_r4.model.isRowExpandable(i_r3))("expanded", ctx_r4.model.isRowExpanded(i_r3))("checkboxLabel", ctx_r4.getCheckboxRowLabel())("expandButtonAriaLabel", ctx_r4.getExpandButtonAriaLabel())("showSelectionColumn", ctx_r4.showSelectionColumn)("enableSingleSelect", ctx_r4.enableSingleSelect)("skeleton", ctx_r4.skeleton)("ngClass", ɵngcc0.ɵɵpureFunction4(14, _c20, !ctx_r4.model.isRowSelected(i_r3) && ctx_r4.model.getRowContext(i_r3) === "success", !ctx_r4.model.isRowSelected(i_r3) && ctx_r4.model.getRowContext(i_r3) === "warning", !ctx_r4.model.isRowSelected(i_r3) && ctx_r4.model.getRowContext(i_r3) === "info", !ctx_r4.model.isRowSelected(i_r3) && ctx_r4.model.getRowContext(i_r3) === "error"));
} }
function TableBody_ng_container_0_ng_container_1_ng_container_2_tr_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "tr", 6);
} if (rf & 2) {
    const ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    const row_r2 = ctx_r19.$implicit;
    const i_r3 = ctx_r19.index;
    const ctx_r16 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("row", row_r2)("expanded", ctx_r16.model.isRowExpanded(i_r3))("skeleton", ctx_r16.skeleton);
} }
function TableBody_ng_container_0_ng_container_1_ng_container_2_ng_template_2_tr_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "tr", 8);
} if (rf & 2) {
    const expandedDataRow_r21 = ctx.$implicit;
    const ctx_r20 = ɵngcc0.ɵɵnextContext(5);
    ɵngcc0.ɵɵproperty("model", ctx_r20.model)("showSelectionColumnCheckbox", false)("showSelectionColumn", ctx_r20.showSelectionColumn)("row", expandedDataRow_r21)("size", ctx_r20.size)("skeleton", ctx_r20.skeleton);
} }
function TableBody_ng_container_0_ng_container_1_ng_container_2_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TableBody_ng_container_0_ng_container_1_ng_container_2_ng_template_2_tr_0_Template, 1, 6, "tr", 7);
} if (rf & 2) {
    const row_r2 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r18 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r18.firstExpandedDataInRow(row_r2));
} }
function TableBody_ng_container_0_ng_container_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TableBody_ng_container_0_ng_container_1_ng_container_2_tr_1_Template, 1, 3, "tr", 4);
    ɵngcc0.ɵɵtemplate(2, TableBody_ng_container_0_ng_container_1_ng_container_2_ng_template_2_Template, 1, 1, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const _r17 = ɵngcc0.ɵɵreference(3);
    const row_r2 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r5.shouldExpandAsTable(row_r2))("ngIfElse", _r17);
} }
function TableBody_ng_container_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TableBody_ng_container_0_ng_container_1_tr_1_Template, 1, 19, "tr", 2);
    ɵngcc0.ɵɵtemplate(2, TableBody_ng_container_0_ng_container_1_ng_container_2_Template, 4, 2, "ng-container", 0);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const i_r3 = ctx.index;
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.model.isRowFiltered(i_r3));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.model.isRowExpanded(i_r3) && !ctx_r1.model.isRowFiltered(i_r3));
} }
function TableBody_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TableBody_ng_container_0_ng_container_1_Template, 3, 2, "ng-container", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.model.data);
} }
const _c21 = ["ibmTableRow", ""];
function TableRowComponent_ng_container_0_td_1_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td", 4);
    ɵngcc0.ɵɵlistener("expandRow", function TableRowComponent_ng_container_0_td_1_Template_td_expandRow_0_listener() { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r5 = ɵngcc0.ɵɵnextContext(2); return ctx_r5.expandRow.emit(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("expanded", ctx_r1.expanded)("expandable", ctx_r1.expandable)("skeleton", ctx_r1.skeleton)("ariaLabel", ctx_r1.getExpandButtonAriaLabel())("headers", ctx_r1.model.getHeaderId("expand"));
} }
function TableRowComponent_ng_container_0_ng_container_2_td_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td");
} }
function TableRowComponent_ng_container_0_ng_container_2_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    const _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td", 7);
    ɵngcc0.ɵɵlistener("change", function TableRowComponent_ng_container_0_ng_container_2_ng_template_2_Template_td_change_0_listener() { ɵngcc0.ɵɵrestoreView(_r11); const ctx_r10 = ɵngcc0.ɵɵnextContext(3); return ctx_r10.onSelectionChange(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("size", ctx_r9.size)("selected", ctx_r9.selected)("label", ctx_r9.getCheckboxLabel())("row", ctx_r9.row)("skeleton", ctx_r9.skeleton)("headers", ctx_r9.model.getHeaderId("select"));
} }
function TableRowComponent_ng_container_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TableRowComponent_ng_container_0_ng_container_2_td_1_Template, 1, 0, "td", 5);
    ɵngcc0.ɵɵtemplate(2, TableRowComponent_ng_container_0_ng_container_2_ng_template_2_Template, 1, 6, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const _r8 = ɵngcc0.ɵɵreference(3);
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r2.showSelectionColumnCheckbox)("ngIfElse", _r8);
} }
function TableRowComponent_ng_container_0_td_3_Template(rf, ctx) { if (rf & 1) {
    const _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td", 8);
    ɵngcc0.ɵɵlistener("change", function TableRowComponent_ng_container_0_td_3_Template_td_change_0_listener() { ɵngcc0.ɵɵrestoreView(_r13); const ctx_r12 = ɵngcc0.ɵɵnextContext(2); return ctx_r12.onSelectionChange(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("selected", ctx_r3.selected)("label", ctx_r3.getCheckboxLabel())("row", ctx_r3.row)("skeleton", ctx_r3.skeleton)("headers", ctx_r3.model.getHeaderId("select"));
} }
function TableRowComponent_ng_container_0_ng_container_4_td_1_Template(rf, ctx) { if (rf & 1) {
    const _r19 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td", 11);
    ɵngcc0.ɵɵlistener("click", function TableRowComponent_ng_container_0_ng_container_4_td_1_Template_td_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r19); const ctx_r18 = ɵngcc0.ɵɵnextContext(3); return ctx_r18.onRowClick(); })("keydown.enter", function TableRowComponent_ng_container_0_ng_container_4_td_1_Template_td_keydown_enter_0_listener() { ɵngcc0.ɵɵrestoreView(_r19); const ctx_r20 = ɵngcc0.ɵɵnextContext(3); return ctx_r20.onRowClick(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r21 = ɵngcc0.ɵɵnextContext();
    const j_r15 = ctx_r21.index;
    const item_r14 = ctx_r21.$implicit;
    const ctx_r16 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵclassMap(ctx_r16.model.getHeader(j_r15).className);
    ɵngcc0.ɵɵproperty("headers", ctx_r16.model.getHeaderId(j_r15, item_r14.colSpan))("item", item_r14)("title", item_r14.title)("ngStyle", ctx_r16.model.getHeader(j_r15).style)("skeleton", ctx_r16.skeleton);
    ɵngcc0.ɵɵattribute("colspan", item_r14.colSpan)("rowspan", item_r14.rowSpan);
} }
function TableRowComponent_ng_container_0_ng_container_4_td_2_Template(rf, ctx) { if (rf & 1) {
    const _r23 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td", 12);
    ɵngcc0.ɵɵlistener("click", function TableRowComponent_ng_container_0_ng_container_4_td_2_Template_td_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r23); const ctx_r22 = ɵngcc0.ɵɵnextContext(3); return ctx_r22.onRowClick(); })("keydown.enter", function TableRowComponent_ng_container_0_ng_container_4_td_2_Template_td_keydown_enter_0_listener() { ɵngcc0.ɵɵrestoreView(_r23); const ctx_r24 = ɵngcc0.ɵɵnextContext(3); return ctx_r24.onRowClick(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r25 = ɵngcc0.ɵɵnextContext();
    const j_r15 = ctx_r25.index;
    const item_r14 = ctx_r25.$implicit;
    const ctx_r17 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("headers", ctx_r17.model.getHeaderId(j_r15, item_r14.colSpan))("item", item_r14)("title", item_r14.title)("skeleton", ctx_r17.skeleton);
    ɵngcc0.ɵɵattribute("colspan", item_r14.colSpan)("rowspan", item_r14.rowSpan);
} }
function TableRowComponent_ng_container_0_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TableRowComponent_ng_container_0_ng_container_4_td_1_Template, 1, 9, "td", 9);
    ɵngcc0.ɵɵtemplate(2, TableRowComponent_ng_container_0_ng_container_4_td_2_Template, 1, 6, "td", 10);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r14 = ctx.$implicit;
    const j_r15 = ctx.index;
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", item_r14 && ctx_r4.model.getHeader(j_r15) && ctx_r4.model.getHeader(j_r15).visible);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", item_r14 && ctx_r4.model.getHeader(j_r15) == null);
} }
function TableRowComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TableRowComponent_ng_container_0_td_1_Template, 1, 5, "td", 1);
    ɵngcc0.ɵɵtemplate(2, TableRowComponent_ng_container_0_ng_container_2_Template, 4, 2, "ng-container", 0);
    ɵngcc0.ɵɵtemplate(3, TableRowComponent_ng_container_0_td_3_Template, 1, 5, "td", 2);
    ɵngcc0.ɵɵtemplate(4, TableRowComponent_ng_container_0_ng_container_4_Template, 3, 2, "ng-container", 3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.model.hasExpandableRows());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.skeleton && ctx_r0.showSelectionColumn && !ctx_r0.enableSingleSelect);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.skeleton && ctx_r0.showSelectionColumn && ctx_r0.enableSingleSelect);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.row);
} }
const _c22 = ["ibmTableExpandedRow", ""];
function TableExpandedRow_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.firstExpandedDataInRow(ctx_r0.row), " ");
} }
function TableExpandedRow_ng_template_2_Template(rf, ctx) { }
const _c23 = ["ibmTableData", ""];
function TableData_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.item.data);
} }
function TableData_1_ng_template_0_Template(rf, ctx) { }
function TableData_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TableData_1_ng_template_0_Template, 0, 0, "ng-template", 1);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.item.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c14, ctx_r1.item.data));
} }
const _c24 = ["ibmTableCheckbox", ""];
function TableCheckbox_ibm_checkbox_0_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ibm-checkbox", 1);
    ɵngcc0.ɵɵlistener("change", function TableCheckbox_ibm_checkbox_0_Template_ibm_checkbox_change_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.change.emit(); });
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵpipe(2, "i18nReplace");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("name", ctx_r0.name)("aria-label", ɵngcc0.ɵɵpipeBind1(1, 5, ɵngcc0.ɵɵpipeBind2(2, 7, ctx_r0.getLabel(), ctx_r0.getSelectionLabelValue(ctx_r0.row))))("size", ctx_r0.size !== "sm" ? "md" : "sm")("checked", ctx_r0.selected)("disabled", ctx_r0.disabled);
} }
const _c25 = ["ibmTableRadio", ""];
function TableRadio_ibm_radio_0_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ibm-radio", 1);
    ɵngcc0.ɵɵlistener("change", function TableRadio_ibm_radio_0_Template_ibm_radio_change_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.change.emit(); });
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵpipe(2, "i18nReplace");
    ɵngcc0.ɵɵpipe(3, "async");
    ɵngcc0.ɵɵpipe(4, "i18nReplace");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ariaLabel", ɵngcc0.ɵɵpipeBind1(3, 8, ɵngcc0.ɵɵpipeBind2(4, 10, ctx_r0.getLabel(), ctx_r0.getSelectionLabelValue(ctx_r0.row))))("checked", ctx_r0.selected);
    ɵngcc0.ɵɵattribute("aria-label", ɵngcc0.ɵɵpipeBind1(1, 3, ɵngcc0.ɵɵpipeBind2(2, 5, ctx_r0.getLabel(), ctx_r0.getSelectionLabelValue(ctx_r0.row))));
} }
const _c26 = ["ibmTableExpandButton", ""];
function TableExpandButton_button_0_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 1);
    ɵngcc0.ɵɵlistener("click", function TableExpandButton_button_0_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.expandRow.emit(); });
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(2, "svg", 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("aria-label", ɵngcc0.ɵɵpipeBind1(1, 1, ctx_r0.getAriaLabel()));
} }
class TableHeaderItem {
    /**
     * Creates an instance of TableHeaderItem.
     */
    constructor(rawData) {
        /**
         * Defines if column under this TableHeaderItem should be displayed.
         *
         */
        this.visible = true;
        /**
         * Disables sorting by default.
         *
         */
        this.sorted = false;
        /**
         * Enables sorting on click by default.
         * If false then this column won't show a sorting arrow at all.
         *
         */
        this.sortable = true;
        /**
         * Number of applied filters.
         *
         * `filter()` should set it to appropriate number.
         *
         */
        this.filterCount = 0;
        /**
         * The number of rows to span
         * **NOTE:** not supported by the default carbon table
         */
        this.rowSpan = 1;
        /**
         * The number of columns to span
         */
        this.colSpan = 1;
        /**
         * Style for the column, applied to every element in the column.
         *
         * ngStyle-like format
         *
         */
        this.style = {};
        /**
         * used in `ascending`
         *
         * @protected
         */
        this._ascending = true;
        // defaults so we dont leave things empty
        const defaults = {
            data: "",
            visible: this.visible,
            style: this.style,
            filterCount: this.filterCount,
            filterData: { data: "" }
        };
        // fill our object with provided props, and fallback to defaults
        const data = Object.assign({}, defaults, rawData);
        for (let property of Object.getOwnPropertyNames(data)) {
            if (data.hasOwnProperty(property)) {
                this[property] = data[property];
            }
        }
    }
    /**
     * If true, sort is set to ascending, if false descending will be true.
     *
     */
    set ascending(asc) {
        this._ascending = asc;
    }
    get ascending() {
        return this._ascending;
    }
    /**
     * If true, sort is set to descending, if false ascending will be true.
     *
     */
    set descending(desc) {
        this._ascending = !desc;
    }
    get descending() {
        return !this._ascending;
    }
    /**
     * Used for sorting rows of the table.
     *
     * Override to enable different sorting.
     *
     * < 0 if `one` should go before `two`
     * > 0 if `one` should go after `two`
     * 0 if it doesn't matter (they are the same)
     */
    compare(one, two) {
        if (!one || !two) {
            return 0;
        }
        if (typeof one.data === "string") {
            return one.data.localeCompare(two.data);
        }
        if (one.data < two.data) {
            return -1;
        }
        else if (one.data > two.data) {
            return 1;
        }
        else {
            return 0;
        }
    }
    /**
     * Used to filter rows in the table.
     *
     * Override to make a custom filter.
     *
     * Even though there is just one filter function, there can be multiple filters.
     * When implementing filter, set `filterCount` before returning.
     *
     * `true` to hide the row
     * `false` to show the row
     */
    filter(item) {
        this.filterCount = 0;
        return false;
    }
}

class TableItem {
    /**
     * Creates an instance of TableItem.
     */
    constructor(rawData) {
        /**
         * The number of rows to span
         */
        this.rowSpan = 1;
        /**
         * The number of columns to span
         */
        this.colSpan = 1;
        // defaults so we dont leave things empty
        const defaults = {
            data: ""
        };
        // fill our object with provided props, and fallback to defaults
        const data = Object.assign({}, defaults, rawData);
        for (const property of Object.getOwnPropertyNames(data)) {
            if (data.hasOwnProperty(property)) {
                this[property] = data[property];
            }
        }
    }
    get title() {
        if (this._title) {
            return this._title;
        }
        if (!this.data) {
            return "";
        }
        if (typeof this.data === "string") {
            return this.data;
        }
        if (this.data.toString &&
            this.data.constructor !== ({}).constructor) {
            return this.data.toString();
        }
        // data can’t be reasonably converted to an end user readable string
        return "";
    }
    set title(title) {
        this._title = title;
    }
}

/**
 * TableModel represents a data model for two-dimensional data. It's used for all things table
 * (table component, table toolbar, pagination, etc)
 *
 * TableModel manages its internal data integrity very well if you use the provided helper
 * functions for modifying rows and columns and assigning header and data in that order.
 *
 * It also provides direct access to the data so you can read and modify it.
 * If you change the structure of the data (by directly pushing into the arrays or otherwise),
 * keep in mind to keep the data structure intact.
 *
 * Header length and length of every line in the data should be equal.
 *
 * If they are not consistent, unexpected things will happen.
 *
 * Use the provided functions when in doubt.
 */
class TableModel {
    constructor() {
        this.dataChange = new EventEmitter();
        this.rowsSelectedChange = new EventEmitter();
        this.rowsExpandedChange = new EventEmitter();
        /**
         * Gets emitted when `selectAll` is called. Emits false if all rows are deselected and true if
         * all rows are selected.
         */
        this.selectAllChange = new Subject();
        /**
         * Contains information about selection state of rows in the table.
         */
        this.rowsSelected = [];
        /**
         * Contains information about expanded state of rows in the table.
         */
        this.rowsExpanded = [];
        /**
         * Contains information about the context of the row.
         *
         * It affects styling of the row to reflect the context.
         *
         * string can be one of `"success" | "warning" | "info" | "error" | ""` and it's
         * empty or undefined by default
         */
        this.rowsContext = [];
        /**
         * Contains class name(s) of the row.
         *
         * It affects styling of the row to reflect the appended class name(s).
         *
         * It's empty or undefined by default
         */
        this.rowsClass = [];
        /**
         * Contains information about the header cells of the table.
         */
        this.header = [];
        /**
         * Tracks the current page.
         */
        this.currentPage = 1;
        /**
         * Length of page.
         */
        this.pageLength = 10;
        /**
         * Set to true when there is no more data to load in the table
         */
        this.isEnd = false;
        /**
         * Set to true when lazy loading to show loading indicator
         */
        this.isLoading = false;
        /**
         * Used in `data`
         */
        this._data = [[]];
        /**
         * The number of models instantiated, this is to make sure each table has a different
         * model count for unique id generation.
         */
        this.tableModelCount = 0;
        this.tableModelCount = TableModel.COUNT++;
    }
    /**
     * Sets data of the table.
     *
     * Make sure all rows are the same length to keep the column count accurate.
     */
    set data(newData) {
        if (!newData || (Array.isArray(newData) && newData.length === 0)) {
            newData = [[]];
        }
        this._data = newData;
        // init rowsSelected
        this.rowsSelected = new Array(this._data.length).fill(false);
        this.rowsExpanded = new Array(this._data.length).fill(false);
        // init rowsContext
        this.rowsContext = new Array(this._data.length);
        // init rowsClass
        this.rowsClass = new Array(this._data.length);
        // only create a fresh header if necessary (header doesn't exist or differs in length)
        if (this.header == null || (this.header.length !== this._data[0].length && this._data[0].length > 0)) {
            let header = new Array();
            for (let i = 0; i < this._data[0].length; i++) {
                header.push(new TableHeaderItem());
            }
            this.header = header;
        }
        this.dataChange.emit();
    }
    /**
     * Gets the full data.
     *
     * You can use it to alter individual `TableItem`s but if you need to change
     * table structure, use `addRow()` and/or `addColumn()`
     */
    get data() {
        return this._data;
    }
    /**
     * Manually set data length in case the data in the table doesn't
     * correctly reflect all the data that table is to display.
     *
     * Example: if you have multiple pages of data that table will display
     * but you're loading one at a time.
     *
     * Set to `null` to reset to default behavior.
     */
    set totalDataLength(length) {
        // if this function is called without a parameter we need to set to null to avoid having undefined != null
        this._totalDataLength = length || null;
    }
    /**
     * Total length of data that table has access to, or the amount manually set
     */
    get totalDataLength() {
        // if manually set data length
        if (this._totalDataLength !== null && this._totalDataLength >= 0) {
            return this._totalDataLength;
        }
        // if empty dataset
        if (this.data && this.data.length === 1 && this.data[0].length === 0) {
            return 0;
        }
        return this.data.length;
    }
    /**
     * Returns an id for the given column
     *
     * @param column the column to generate an id for
     * @param row the row of the header to generate an id for
     */
    getId(column, row = 0) {
        return `table-header-${row}-${column}-${this.tableModelCount}`;
    }
    /**
     * Returns the id of the header. Used to link the cells with headers (or headers with headers)
     *
     * @param column the column to start getting headers for
     * @param colSpan the number of columns to get headers for (defaults to 1)
     */
    getHeaderId(column, colSpan = 1) {
        if (column === "select" || column === "expand") {
            return this.getId(column);
        }
        let ids = [];
        for (let i = column; i >= 0; i--) {
            if (this.header[i]) {
                for (let j = 0; j < colSpan; j++) {
                    ids.push(this.getId(i + j));
                }
                break;
            }
        }
        return ids.join(" ");
    }
    /**
     * Finds closest header by trying the `column` and then working its way to the left
     *
     * @param column the target column
     */
    getHeader(column) {
        if (!this.header) {
            return null;
        }
        for (let i = column; i >= 0; i--) {
            const headerCell = this.header[i];
            if (headerCell) {
                return headerCell;
            }
        }
        return null;
    }
    /**
     * Returns how many rows is currently selected
     */
    selectedRowsCount() {
        let count = 0;
        if (this.rowsSelected) {
            this.rowsSelected.forEach(rowSelected => {
                if (rowSelected) {
                    count++;
                }
            });
        }
        return count;
    }
    /**
     * Returns how many rows is currently expanded
     */
    expandedRowsCount() {
        let count = 0;
        if (this.rowsExpanded) {
            this.rowsExpanded.forEach(rowExpanded => {
                if (rowExpanded) {
                    count++;
                }
            });
        }
        return count;
    }
    /**
     * Returns `index`th row of the table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    row(index) {
        return this.data[this.realRowIndex(index)];
    }
    /**
     * Adds a row to the `index`th row or appends to table if index not provided.
     *
     * If row is shorter than other rows or not provided, it will be padded with
     * empty `TableItem` elements.
     *
     * If row is longer than other rows, others will be extended to match so no data is lost.
     *
     * If called on an empty table with no parameters, it creates a 1x1 table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param [row]
     * @param [index]
     */
    addRow(row, index) {
        // if table empty create table with row
        if (!this.data || this.data.length === 0 || this.data[0].length === 0) {
            let newData = new Array();
            newData.push(row ? row : [new TableItem()]); // row or one empty one column row
            this.data = newData;
            return;
        }
        let realRow = row;
        const columnCount = this.data[0].length;
        if (row == null) {
            realRow = new Array();
            for (let i = 0; i < columnCount; i++) {
                realRow.push(new TableItem());
            }
        }
        if (realRow.length < columnCount) {
            // extend the length of realRow
            const difference = columnCount - realRow.length;
            for (let i = 0; i < difference; i++) {
                realRow.push(new TableItem());
            }
        }
        else if (realRow.length > columnCount) {
            // extend the length of header
            let difference = realRow.length - this.header.length;
            for (let j = 0; j < difference; j++) {
                this.header.push(new TableHeaderItem());
            }
            // extend the length of every other row
            for (let i = 0; i < this.data.length; i++) {
                let currentRow = this.data[i];
                difference = realRow.length - currentRow.length;
                for (let j = 0; j < difference; j++) {
                    currentRow.push(new TableItem());
                }
            }
        }
        if (index == null) {
            this.data.push(realRow);
            // update rowsSelected property for length
            this.rowsSelected.push(false);
            // update rowsExpanded property for length
            this.rowsExpanded.push(false);
            // update rowsContext property for length
            this.rowsContext.push(undefined);
            // update rowsClass property for length
            this.rowsClass.push(undefined);
        }
        else {
            const ri = this.realRowIndex(index);
            this.data.splice(ri, 0, realRow);
            // update rowsSelected property for length
            this.rowsSelected.splice(ri, 0, false);
            // update rowsExpanded property for length
            this.rowsExpanded.splice(ri, 0, false);
            // update rowsContext property for length
            this.rowsContext.splice(ri, 0, undefined);
            // update rowsClass property for length
            this.rowsClass.splice(ri, 0, undefined);
        }
        this.dataChange.emit();
    }
    /**
     * Deletes `index`th row.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    deleteRow(index) {
        const rri = this.realRowIndex(index);
        this.data.splice(rri, 1);
        this.rowsSelected.splice(rri, 1);
        this.rowsExpanded.splice(rri, 1);
        this.rowsContext.splice(rri, 1);
        this.rowsClass.splice(rri, 1);
        this.dataChange.emit();
    }
    hasExpandableRows() {
        return this.data.some(data => data.some(d => d && d.expandedData)); // checking for some in 2D array
    }
    isRowExpandable(index) {
        return this.data[index].some(d => d && d.expandedData);
    }
    isRowExpanded(index) {
        return this.rowsExpanded[index];
    }
    getRowContext(index) {
        return this.rowsContext[index];
    }
    /**
     * Returns `index`th column of the table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    column(index) {
        let column = new Array();
        const ri = this.realColumnIndex(index);
        const rc = this.data.length;
        for (let i = 0; i < rc; i++) {
            const row = this.data[i];
            column.push(row[ri]);
        }
        return column;
    }
    /**
     * Adds a column to the `index`th column or appends to table if index not provided.
     *
     * If column is shorter than other columns or not provided, it will be padded with
     * empty `TableItem` elements.
     *
     * If column is longer than other columns, others will be extended to match so no data is lost.
     *
     * If called on an empty table with no parameters, it creates a 1x1 table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param [column]
     * @param [index]
     */
    addColumn(column, index) {
        // if table empty create table with row
        if (!this.data || this.data.length === 0 || this.data[0].length === 0) {
            let newData = new Array();
            if (column == null) {
                newData.push([new TableItem()]);
            }
            else {
                for (let i = 0; i < column.length; i++) {
                    let item = column[i];
                    newData.push([item]);
                }
            }
            this.data = newData;
            return;
        }
        let rc = this.data.length; // row count
        let ci = this.realColumnIndex(index);
        // append missing rows
        for (let i = 0; column != null && i < column.length - rc; i++) {
            this.addRow();
        }
        rc = this.data.length;
        if (index == null) {
            // append to end
            for (let i = 0; i < rc; i++) {
                let row = this.data[i];
                row.push(column == null || column[i] == null ? new TableItem() : column[i]);
            }
            // update header if not already set by user
            if (this.header.length < this.data[0].length) {
                this.header.push(new TableHeaderItem());
            }
        }
        else {
            if (index >= this.data[0].length) {
                // if trying to append
                ci++;
            }
            // insert
            for (let i = 0; i < rc; i++) {
                let row = this.data[i];
                row.splice(ci, 0, column == null || column[i] == null ? new TableItem() : column[i]);
            }
            // update header if not already set by user
            if (this.header.length < this.data[0].length) {
                this.header.splice(ci, 0, new TableHeaderItem());
            }
        }
        this.dataChange.emit();
    }
    /**
     * Deletes `index`th column.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    deleteColumn(index) {
        const rci = this.realColumnIndex(index);
        const rowCount = this.data.length;
        for (let i = 0; i < rowCount; i++) {
            this.data[i].splice(rci, 1);
        }
        // update header if not already set by user
        if (this.header.length > this.data[0].length) {
            this.header.splice(rci, 1);
        }
        this.dataChange.emit();
    }
    moveColumn(indexFrom, indexTo) {
        const headerFrom = this.header[indexFrom];
        this.addColumn(this.column(indexFrom), indexTo);
        this.deleteColumn(indexFrom + (indexTo < indexFrom ? 1 : 0));
        this.header[indexTo + (indexTo > indexFrom ? -1 : 0)] = headerFrom;
    }
    /**
     * Sorts the data currently present in the model based on `compare()`
     *
     * Direction is set by `ascending` and `descending` properties of `TableHeaderItem`
     * in `index`th column.
     *
     * @param index The column based on which it's sorting
     */
    sort(index) {
        this.pushRowStateToModelData();
        this.data.sort((a, b) => (this.header[index].descending ? -1 : 1) * this.header[index].compare(a[index], b[index]));
        this.popRowStateFromModelData();
        this.header.forEach(column => column.sorted = false);
        this.header[index].sorted = true;
    }
    /**
     * Appends `rowsSelected` and `rowsExpanded` info to model data.
     *
     * When sorting rows, do this first so information about row selection
     * gets sorted with the other row info.
     *
     * Call `popRowSelectionFromModelData()` after sorting to make everything
     * right with the world again.
     */
    pushRowStateToModelData() {
        for (let i = 0; i < this.data.length; i++) {
            const rowSelectedMark = new TableItem();
            rowSelectedMark.data = this.rowsSelected[i];
            this.data[i].push(rowSelectedMark);
            const rowExpandedMark = new TableItem();
            rowExpandedMark.data = this.rowsExpanded[i];
            this.data[i].push(rowExpandedMark);
            const rowContext = new TableItem();
            rowContext.data = this.rowsContext[i];
            this.data[i].push(rowContext);
            const rowClass = new TableItem();
            rowClass.data = this.rowsClass[i];
            this.data[i].push(rowClass);
        }
    }
    /**
     * Restores `rowsSelected` from data pushed by `pushRowSelectionToModelData()`
     *
     * Call after sorting data (if you previously pushed to maintain selection order)
     * to make everything right with the world again.
     */
    popRowStateFromModelData() {
        for (let i = 0; i < this.data.length; i++) {
            this.rowsClass[i] = this.data[i].pop().data;
            this.rowsContext[i] = this.data[i].pop().data;
            this.rowsExpanded[i] = !!this.data[i].pop().data;
            this.rowsSelected[i] = !!this.data[i].pop().data;
        }
    }
    /**
     * Checks if row is filtered out.
     *
     * @param index
     * @returns true if any of the filters in header filters out the `index`th row
     */
    isRowFiltered(index) {
        const realIndex = this.realRowIndex(index);
        return this.header.some((item, i) => item && item.filter(this.row(realIndex)[i]));
    }
    /**
     * Select/deselect `index`th row based on value
     *
     * @param index index of the row to select
     * @param value state to set the row to. Defaults to `true`
     */
    selectRow(index, value = true) {
        if (this.isRowDisabled(index)) {
            return;
        }
        this.rowsSelected[index] = value;
        this.rowsSelectedChange.emit(index);
    }
    /**
     * Selects or deselects all rows in the model
     *
     * @param value state to set all rows to. Defaults to `true`
     */
    selectAll(value = true) {
        if (this.data.length >= 1) {
            for (let i = 0; i < this.rowsSelected.length; i++) {
                this.selectRow(i, value);
            }
        }
        this.selectAllChange.next(value);
    }
    isRowSelected(index) {
        return this.rowsSelected[index];
    }
    /**
     * Checks if row is disabled or not.
     */
    isRowDisabled(index) {
        const row = this.data[index];
        return !!row.disabled;
    }
    /**
     * Expands/Collapses `index`th row based on value
     *
     * @param index index of the row to expand or collapse
     * @param value expanded state of the row. `true` is expanded and `false` is collapsed
     */
    expandRow(index, value = true) {
        this.rowsExpanded[index] = value;
        this.rowsExpandedChange.emit(index);
    }
    /**
     * Gets the true index of a row based on it's relative position.
     * Like in Python, positive numbers start from the top and
     * negative numbers start from the bottom.
     *
     * @param index
     */
    realRowIndex(index) {
        return this.realIndex(index, this.data.length);
    }
    /**
     * Gets the true index of a column based on it's relative position.
     * Like in Python, positive numbers start from the top and
     * negative numbers start from the bottom.
     *
     * @param index
     */
    realColumnIndex(index) {
        return this.realIndex(index, this.data[0].length);
    }
    /**
     * Generic function to calculate the real index of something.
     * Used by `realRowIndex()` and `realColumnIndex()`
     *
     * @param index
     * @param length
     */
    realIndex(index, length) {
        if (index == null) {
            return length - 1;
        }
        else if (index >= 0) {
            return index >= length ? length - 1 : index;
        }
        else {
            return -index >= length ? 0 : length + index;
        }
    }
}
/**
 * The number of models instantiated, used for (among other things) unique id generation
 */
TableModel.COUNT = 0;

/**
 * The table toolbar is reserved for global table actions such as table settings, complex filter, export, or editing table data.
 *
 * ## Basic usage
 *
 * ```html
 * <ibm-table-toolbar [model]="model">
 *		<ibm-table-toolbar-actions>
 *			<button ibmButton="primary">
 *				Delete
 *				<svg ibmIcon="delete" size="16" class="bx--btn__icon"></svg>
 *			</button>
 *			<button ibmButton="primary">
 *				Save
 *				<svg ibmIcon="save" size="16" class="bx--btn__icon"></svg>
 *			</button>
 *			<button ibmButton="primary">
 *				Download
 *				<svg ibmIcon="download" size="16" class="bx--btn__icon"></svg>
 *			</button>
 *		</ibm-table-toolbar-actions>
 *			<ibm-table-toolbar-content>
 *			<ibm-table-toolbar-search [expandable]="true"></ibm-table-toolbar-search>
 *			<button ibmButton="toolbar-action">
 *				<svg ibmIcon="settings" size="16" class="bx--toolbar-action__icon"></ibm-icon-settings>
 *			</button>
 *			<button ibmButton="primary" size="sm">
 *				Primary Button
 *				<svg ibmIcon="add" size="20" class="bx--btn__icon"></svg>
 *			</button>
 *		</ibm-table-toolbar-content>
 *	</ibm-table-toolbar>
 * ```
 *
 */
class TableToolbar {
    constructor(i18n) {
        this.i18n = i18n;
        this.size = "md";
        this.cancel = new EventEmitter();
        this.actionBarLabel = this.i18n.getOverridable("TABLE_TOOLBAR.ACTION_BAR");
        this._cancelText = this.i18n.getOverridable("TABLE_TOOLBAR.CANCEL");
        this._batchTextLegacy = this.i18n.getOverridable("TABLE_TOOLBAR.BATCH_TEXT");
        this._batchTextSingle = this.i18n.getOverridable("TABLE_TOOLBAR.BATCH_TEXT_SINGLE");
        this._batchTextMultiple = this.i18n.getOverridable("TABLE_TOOLBAR.BATCH_TEXT_MULTIPLE");
    }
    set batchText(value) {
        if (typeof value === "object") {
            this._batchTextSingle.override(value.SINGLE);
            this._batchTextMultiple.override(value.MULTIPLE);
        }
        else {
            // For compatibility with old code
            this._batchTextLegacy.override(value);
        }
    }
    set ariaLabel(value) {
        this.actionBarLabel.override(value.ACTION_BAR);
    }
    set cancelText(value) {
        this._cancelText.override(value.CANCEL);
    }
    get cancelText() {
        return { CANCEL: this._cancelText.value };
    }
    get count() {
        return this.model.totalDataLength > 0 ? this.model.rowsSelected.reduce((previous, current) => previous + (current ? 1 : 0), 0) : 0;
    }
    get selected() {
        return this.model.totalDataLength > 0 ? this.model.rowsSelected.some(item => item) : false;
    }
    onCancel() {
        this.model.selectAll(false);
        this.cancel.emit();
    }
}
TableToolbar.ɵfac = function TableToolbar_Factory(t) { return new (t || TableToolbar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n)); };
TableToolbar.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TableToolbar, selectors: [["ibm-table-toolbar"]], inputs: { size: "size", batchText: "batchText", ariaLabel: "ariaLabel", cancelText: "cancelText", model: "model" }, outputs: { cancel: "cancel" }, ngContentSelectors: _c4, decls: 3, vars: 4, consts: [[1, "bx--table-toolbar", 3, "ngClass"], ["class", "bx--batch-actions", 3, "ngClass", 4, "ngIf"], [1, "bx--batch-actions", 3, "ngClass"], [1, "bx--action-list"], ["ibmButton", "primary", 1, "bx--batch-summary__cancel", 3, "tabindex", "click"], [1, "bx--batch-summary"], ["class", "bx--batch-summary__para", 4, "ngIf"], [1, "bx--batch-summary__para"], [4, "ngIf", "ngIfElse"], ["batchTextBlock", ""], [4, "ngIf"]], template: function TableToolbar_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c2);
        ɵngcc0.ɵɵelementStart(0, "section", 0);
        ɵngcc0.ɵɵtemplate(1, TableToolbar_div_1_Template, 9, 11, "div", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(2, _c3, ctx.size === "sm"));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.model);
    } }, directives: [ɵngcc2.NgClass, ɵngcc2.NgIf, ɵngcc3.Button], pipes: [ɵngcc2.AsyncPipe, ɵngcc1.ReplacePipe], encapsulation: 2 });
/** @nocollapse */
TableToolbar.ctorParameters = () => [
    { type: I18n }
];
TableToolbar.propDecorators = {
    model: [{ type: Input }],
    batchText: [{ type: Input }],
    ariaLabel: [{ type: Input }],
    cancelText: [{ type: Input }],
    size: [{ type: Input }],
    cancel: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableToolbar, [{
        type: Component,
        args: [{
                selector: "ibm-table-toolbar",
                template: `
	<section
		class="bx--table-toolbar"
		[ngClass]="{'bx--table-toolbar--small' : size === 'sm'}">
		<div
			*ngIf="model"
			class="bx--batch-actions"
			[ngClass]="{
				'bx--batch-actions--active': selected
			}"
			[attr.aria-label]="actionBarLabel.subject | async">
			<div class="bx--action-list">
				<ng-content select="ibm-table-toolbar-actions"></ng-content>
				<button
					ibmButton="primary"
					class="bx--batch-summary__cancel"
					[tabindex]="selected ? 0 : -1"
					(click)="onCancel()">
					{{_cancelText.subject | async}}
				</button>
			</div>
			<div class="bx--batch-summary">
				<p class="bx--batch-summary__para" *ngIf="count as n">
					<ng-container *ngIf="_batchTextLegacy.subject | async as legacyText; else batchTextBlock">
						<span>{{n}}</span> {{legacyText}}
					</ng-container>
					<ng-template #batchTextBlock>
						<span *ngIf="n === 1">{{_batchTextSingle.subject | async}}</span>
						<span *ngIf="n !== 1">{{_batchTextMultiple.subject | i18nReplace: {count: n} | async}}</span>
					</ng-template>
				</p>
			</div>
		</div>
		<ng-content></ng-content>
	</section>
	`
            }]
    }], function () { return [{ type: ɵngcc1.I18n }]; }, { size: [{
            type: Input
        }], cancel: [{
            type: Output
        }], batchText: [{
            type: Input
        }], ariaLabel: [{
            type: Input
        }], cancelText: [{
            type: Input
        }], model: [{
            type: Input
        }] }); })();

class TableToolbarActions {
}
TableToolbarActions.ɵfac = function TableToolbarActions_Factory(t) { return new (t || TableToolbarActions)(); };
TableToolbarActions.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TableToolbarActions, selectors: [["ibm-table-toolbar-actions"]], ngContentSelectors: _c5, decls: 1, vars: 0, template: function TableToolbarActions_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableToolbarActions, [{
        type: Component,
        args: [{
                selector: "ibm-table-toolbar-actions",
                template: `<ng-content></ng-content>`
            }]
    }], null, null); })();

class TableToolbarSearch extends Search {
    constructor() {
        super(...arguments);
        this.tableSearch = true;
        this.expandable = false;
    }
    get persistentClass() { return !this.expandable; }
    get activeClass() {
        return this.active && (this.value !== null || this.value !== "");
    }
    ngOnInit() {
        this.size = "sm";
        if (this.expandable) {
            this.toolbar = true;
        }
    }
    ngAfterViewInit() {
        setTimeout(() => {
            if (this.value) {
                this.openSearch();
            }
        });
    }
}
TableToolbarSearch.ɵfac = function TableToolbarSearch_Factory(t) { return ɵTableToolbarSearch_BaseFactory(t || TableToolbarSearch); };
TableToolbarSearch.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TableToolbarSearch, selectors: [["ibm-table-toolbar-search"]], hostVars: 6, hostBindings: function TableToolbarSearch_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--toolbar-search-container-expandable", ctx.expandable)("bx--toolbar-search-container-persistent", ctx.persistentClass)("bx--toolbar-search-container-active", ctx.activeClass);
    } }, inputs: { expandable: "expandable" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: TableToolbarSearch,
                multi: true
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 7, vars: 15, consts: [["role", "search", "tabindex", "0", 1, "bx--search", 3, "ngClass", "click"], [1, "bx--label", 3, "for"], ["class", "bx--search-input", 4, "ngIf", "ngIfElse"], ["enableInput", ""], ["class", "bx--search-close", 3, "ngClass", "title", "click", 4, "ngIf"], [1, "bx--search-input"], [1, "bx--search-input", 3, "type", "id", "value", "autocomplete", "placeholder", "disabled", "required", "input", "keyup.enter"], ["input", ""], ["class", "bx--toolbar-search__btn", "aria-label", "Open search", 3, "click", 4, "ngIf"], ["ibmIcon", "search", "class", "bx--search-magnifier", "size", "16", 4, "ngIf"], ["aria-label", "Open search", 1, "bx--toolbar-search__btn", 3, "click"], ["ibmIcon", "search", "size", "16", 1, "bx--search-magnifier"], [1, "bx--search-close", 3, "ngClass", "title", "click"], [1, "bx--visually-hidden"], ["ibmIcon", "close", "size", "16"]], template: function TableToolbarSearch_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("click", function TableToolbarSearch_Template_div_click_0_listener() { return ctx.openSearch(); });
        ɵngcc0.ɵɵelementStart(1, "label", 1);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, TableToolbarSearch_div_3_Template, 1, 0, "div", 2);
        ɵngcc0.ɵɵtemplate(4, TableToolbarSearch_ng_template_4_Template, 4, 9, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, TableToolbarSearch_button_6_Template, 4, 5, "button", 4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(5);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction7(7, _c7, ctx.size === "sm", ctx.size === "md", ctx.size === "xl", ctx.theme === "light", ctx.skeleton, ctx.toolbar, ctx.toolbar && ctx.active));
        ɵngcc0.ɵɵattribute("aria-label", ctx.ariaLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("for", ctx.id);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.label);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.skeleton)("ngIfElse", _r1);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.tableSearch || !ctx.toolbar);
    } }, directives: [ɵngcc2.NgClass, ɵngcc2.NgIf, ɵngcc4.IconDirective], encapsulation: 2 });
TableToolbarSearch.propDecorators = {
    expandable: [{ type: HostBinding, args: ["class.bx--toolbar-search-container-expandable",] }, { type: Input }],
    persistentClass: [{ type: HostBinding, args: ["class.bx--toolbar-search-container-persistent",] }],
    activeClass: [{ type: HostBinding, args: ["class.bx--toolbar-search-container-active",] }]
};
const ɵTableToolbarSearch_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(TableToolbarSearch);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableToolbarSearch, [{
        type: Component,
        args: [{
                selector: "ibm-table-toolbar-search",
                template: "<div\n\tclass=\"bx--search\"\n\t[ngClass]=\"{\n\t\t'bx--search--sm': size === 'sm',\n\t\t'bx--search--lg': size === 'md',\n\t\t'bx--search--xl': size === 'xl',\n\t\t'bx--search--light': theme === 'light',\n\t\t'bx--skeleton': skeleton,\n\t\t'bx--toolbar-search': toolbar,\n\t\t'bx--toolbar-search--active': toolbar && active\n\t}\"\n\trole=\"search\"\n\t[attr.aria-label]=\"ariaLabel\"\n\ttabindex=\"0\"\n\t(click)=\"openSearch()\">\n\t<label class=\"bx--label\" [for]=\"id\">{{label}}</label>\n\n\t<div *ngIf=\"skeleton; else enableInput\" class=\"bx--search-input\"></div>\n\t<ng-template #enableInput>\n\t\t<input\n\t\t\t#input\n\t\t\tclass=\"bx--search-input\"\n\t\t\t[type]=\"tableSearch || !toolbar ? 'text' : 'search'\"\n\t\t\t[id]=\"id\"\n\t\t\t[value]=\"value\"\n\t\t\t[autocomplete]=\"autocomplete\"\n\t\t\t[placeholder]=\"placeholder\"\n\t\t\t[disabled]=\"disabled\"\n\t\t\t[required]=\"required\"\n\t\t\t(input)=\"onSearch($event.target.value)\"\n\t\t\t(keyup.enter)=\"onEnter()\"/>\n\t\t<button\n\t\t\t*ngIf=\"!tableSearch && toolbar\"\n\t\t\tclass=\"bx--toolbar-search__btn\"\n\t\t\t(click)=\"openSearch()\"\n\t\t\taria-label=\"Open search\">\n\t\t\t<svg ibmIcon=\"search\" size=\"16\" class=\"bx--search-magnifier\"></svg>\n\t\t</button>\n\t\t<svg\n\t\t\tibmIcon=\"search\"\n\t\t\t*ngIf=\"tableSearch || !toolbar\"\n\t\t\tclass=\"bx--search-magnifier\"\n\t\t\tsize=\"16\">\n\t\t</svg>\n\t</ng-template>\n\n\t<button\n\t\t*ngIf=\"tableSearch || !toolbar\"\n\t\tclass=\"bx--search-close\"\n\t\t[ngClass]=\"{\n\t\t\t'bx--search-close--hidden': !value || value.length === 0\n\t\t}\"\n\t\t[title]=\"clearButtonTitle\"\n\t\t(click)=\"clearSearch()\">\n\t\t<span class=\"bx--visually-hidden\">{{ clearButtonTitle }}</span>\n\t\t<svg ibmIcon=\"close\" size=\"16\"></svg>\n\t</button>\n</div>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: TableToolbarSearch,
                        multi: true
                    }
                ]
            }]
    }], null, { expandable: [{
            type: HostBinding,
            args: ["class.bx--toolbar-search-container-expandable"]
        }, {
            type: Input
        }], persistentClass: [{
            type: HostBinding,
            args: ["class.bx--toolbar-search-container-persistent"]
        }], activeClass: [{
            type: HostBinding,
            args: ["class.bx--toolbar-search-container-active"]
        }] }); })();

class TableToolbarContent {
    constructor() {
        this.class = true;
    }
}
TableToolbarContent.ɵfac = function TableToolbarContent_Factory(t) { return new (t || TableToolbarContent)(); };
TableToolbarContent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TableToolbarContent, selectors: [["ibm-table-toolbar-content"]], hostVars: 2, hostBindings: function TableToolbarContent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--toolbar-content", ctx.class);
    } }, ngContentSelectors: _c5, decls: 1, vars: 0, template: function TableToolbarContent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
TableToolbarContent.propDecorators = {
    class: [{ type: HostBinding, args: ["class.bx--toolbar-content",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableToolbarContent, [{
        type: Component,
        args: [{
                selector: "ibm-table-toolbar-content",
                template: `<ng-content></ng-content>`
            }]
    }], function () { return []; }, { class: [{
            type: HostBinding,
            args: ["class.bx--toolbar-content"]
        }] }); })();

class TableContainer {
    constructor() {
        this.containerClass = true;
    }
}
TableContainer.ɵfac = function TableContainer_Factory(t) { return new (t || TableContainer)(); };
TableContainer.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TableContainer, selectors: [["ibm-table-container"]], hostVars: 2, hostBindings: function TableContainer_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--data-table-container", ctx.containerClass);
    } }, ngContentSelectors: _c5, decls: 1, vars: 0, template: function TableContainer_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%] { display: block }"] });
TableContainer.propDecorators = {
    containerClass: [{ type: HostBinding, args: ["class.bx--data-table-container",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableContainer, [{
        type: Component,
        args: [{
                selector: "ibm-table-container",
                template: `<ng-content></ng-content>`,
                styles: [`
		:host { display: block }
	`]
            }]
    }], function () { return []; }, { containerClass: [{
            type: HostBinding,
            args: ["class.bx--data-table-container"]
        }] }); })();

class TableHeader {
    constructor() {
        this.headerClass = true;
        this.displayStyle = "block";
    }
}
TableHeader.ɵfac = function TableHeader_Factory(t) { return new (t || TableHeader)(); };
TableHeader.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TableHeader, selectors: [["ibm-table-header"]], hostVars: 4, hostBindings: function TableHeader_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("display", ctx.displayStyle);
        ɵngcc0.ɵɵclassProp("bx--data-table-header", ctx.headerClass);
    } }, ngContentSelectors: _c5, decls: 1, vars: 0, template: function TableHeader_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
TableHeader.propDecorators = {
    headerClass: [{ type: HostBinding, args: ["class.bx--data-table-header",] }],
    displayStyle: [{ type: HostBinding, args: ["style.display",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableHeader, [{
        type: Component,
        args: [{
                selector: "ibm-table-header",
                template: `
		<ng-content></ng-content>
	`
            }]
    }], function () { return []; }, { headerClass: [{
            type: HostBinding,
            args: ["class.bx--data-table-header"]
        }], displayStyle: [{
            type: HostBinding,
            args: ["style.display"]
        }] }); })();

class TableHeaderTitle {
    constructor() {
        this.titleClass = true;
    }
}
TableHeaderTitle.ɵfac = function TableHeaderTitle_Factory(t) { return new (t || TableHeaderTitle)(); };
TableHeaderTitle.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TableHeaderTitle, selectors: [["", "ibmTableHeaderTitle", ""]], hostVars: 2, hostBindings: function TableHeaderTitle_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--data-table-header__title", ctx.titleClass);
    } } });
TableHeaderTitle.propDecorators = {
    titleClass: [{ type: HostBinding, args: ["class.bx--data-table-header__title",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableHeaderTitle, [{
        type: Directive,
        args: [{
                selector: "[ibmTableHeaderTitle]"
            }]
    }], function () { return []; }, { titleClass: [{
            type: HostBinding,
            args: ["class.bx--data-table-header__title"]
        }] }); })();

class TableHeadCellLabel {
    constructor() {
        this.baseClass = true;
    }
}
TableHeadCellLabel.ɵfac = function TableHeadCellLabel_Factory(t) { return new (t || TableHeadCellLabel)(); };
TableHeadCellLabel.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TableHeadCellLabel, selectors: [["", "ibmTableHeadCellLabel", ""]], hostVars: 2, hostBindings: function TableHeadCellLabel_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--table-header-label", ctx.baseClass);
    } } });
TableHeadCellLabel.propDecorators = {
    baseClass: [{ type: HostBinding, args: ["class.bx--table-header-label",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableHeadCellLabel, [{
        type: Directive,
        args: [{
                selector: "[ibmTableHeadCellLabel]"
            }]
    }], function () { return []; }, { baseClass: [{
            type: HostBinding,
            args: ["class.bx--table-header-label"]
        }] }); })();

class TableHeaderDescription {
    constructor() {
        this.descriptionClass = true;
    }
}
TableHeaderDescription.ɵfac = function TableHeaderDescription_Factory(t) { return new (t || TableHeaderDescription)(); };
TableHeaderDescription.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TableHeaderDescription, selectors: [["", "ibmTableHeaderDescription", ""]], hostVars: 2, hostBindings: function TableHeaderDescription_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--data-table-header__description", ctx.descriptionClass);
    } } });
TableHeaderDescription.propDecorators = {
    descriptionClass: [{ type: HostBinding, args: ["class.bx--data-table-header__description",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableHeaderDescription, [{
        type: Directive,
        args: [{
                selector: "[ibmTableHeaderDescription]"
            }]
    }], function () { return []; }, { descriptionClass: [{
            type: HostBinding,
            args: ["class.bx--data-table-header__description"]
        }] }); })();

class ExpandedRowHover {
    addHoverClass(event) {
        event.target.previousElementSibling.classList.add("bx--expandable-row--hover");
    }
    removeHoverClass(event) {
        event.target.previousElementSibling.classList.remove("bx--expandable-row--hover");
    }
}
ExpandedRowHover.ɵfac = function ExpandedRowHover_Factory(t) { return new (t || ExpandedRowHover)(); };
ExpandedRowHover.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ExpandedRowHover, selectors: [["", "ibmExpandedRowHover", ""]], hostBindings: function ExpandedRowHover_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseenter", function ExpandedRowHover_mouseenter_HostBindingHandler($event) { return ctx.addHoverClass($event); })("mouseleave", function ExpandedRowHover_mouseleave_HostBindingHandler($event) { return ctx.removeHoverClass($event); });
    } } });
ExpandedRowHover.propDecorators = {
    addHoverClass: [{ type: HostListener, args: ["mouseenter", ["$event"],] }],
    removeHoverClass: [{ type: HostListener, args: ["mouseleave", ["$event"],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExpandedRowHover, [{
        type: Directive,
        args: [{
                selector: "[ibmExpandedRowHover]"
            }]
    }], null, { addHoverClass: [{
            type: HostListener,
            args: ["mouseenter", ["$event"]]
        }], removeHoverClass: [{
            type: HostListener,
            args: ["mouseleave", ["$event"]]
        }] }); })();

/**
 * `DataGridInteractionModel` provides centralized control over arbitrary 2d grids, following the w3 specs.
 *
 * Refs:
 *  - https://www.w3.org/TR/wai-aria-practices/examples/grid/dataGrids.html
 *  - https://www.w3.org/TR/wai-aria-practices/#grid
 *
 * Example usage (taken from `table.component`):
```typescript
// a standard HTML table
const table = this.elementRef.nativeElement.querySelector("table") as HTMLTableElement;

// `TableDomAdapter` implements `TableAdapter` and provides a consistent interface to query rows and columns in a table
const tableAdapter = new TableDomAdapter(table);

// the keydown events that we'll use for keyboard navigation of the table
const keydownEventStream = fromEvent<KeyboardEvent>(table, "keydown");

// the click events we'll use to ensure focus is updated correctly on click
const clickEventStream = fromEvent<MouseEvent>(table, "click");

// the `DataGridInteractionModel` instance!
this.interactionModel = new DataGridInteractionModel(keydownEventStream, clickEventStream, tableAdapter);

// subscribe to the combined position updates
this.interactionModel.position.subscribe(event => {
    const [currentRow, currentColumn] = event.current;
    const [previousRow, previousColumn] = event.previous;

    // query the TableAdapter for the cell at the current row and column ...
    const currentElement = tableAdapter.getCell(currentRow, currentColumn);
    // ... and make it focusable it
    Table.setTabIndex(currentElement, 0);

    // if the model has just initialized don't focus or reset anything
    if (previousRow === -1 || previousColumn === -1) { return; }

    // query the TableAdapter for the cell at the previous row and column ...
    const previousElement = tableAdapter.getCell(previousRow, previousColumn);
    // ... and make it unfocusable (now there is only a single focusable cell)
    Table.setTabIndex(previousElement, -1);

    // finally, focus the current cell (skipped during initilzation)
    Table.focus(currentElement);
});
```
 */
class DataGridInteractionModel {
    /**
     * `DataGridInteractionModel` requires knowledge of events, and a representation of your table/grid to be useful.
     *
     * @param keyboardEventStream an Observable of KeyboardEvents. Should be scoped to the table container.
     * @param clickEventStream an Observable of ClickEvents. should only include clicks that take action on items known by the TableAdapter
     * @param tableAdapter an instance of a concrete class that implements TableAdapter. The standard carbon table uses TableDomAdapter
     */
    constructor(keyboardEventStream, clickEventStream, tableAdapter) {
        this.keyboardEventStream = keyboardEventStream;
        this.clickEventStream = clickEventStream;
        this.tableAdapter = tableAdapter;
        /**
         * Internal subject to handle changes in row
         */
        this.rowSubject = new BehaviorSubject({ current: 0, previous: -1 });
        /**
         * Internal subject to handle changes in column
         */
        this.columnSubject = new BehaviorSubject({ current: 0, previous: -1 });
        this.rowIndex = this.rowSubject.asObservable();
        this.columnIndex = this.columnSubject.asObservable();
        this.position = combineLatest(this.rowIndex, this.columnIndex).pipe(map(positions => {
            const [row, column] = positions;
            return {
                current: [row.current, column.current],
                previous: [row.previous, column.previous]
            };
        }));
        this.keyboardEventStream.subscribe(this.handleKeyboardEvent.bind(this));
        this.clickEventStream.subscribe(this.handleClickEvent.bind(this));
    }
    /**
     * The latest value emitted by the rowSubject
     */
    get currentRow() {
        return this.rowSubject.getValue().current;
    }
    /**
     * The latest value emitted by the columnSubject
     */
    get currentColumn() {
        return this.columnSubject.getValue().current;
    }
    /**
     * The last column as reported by the adapter
     */
    get lastColumn() {
        return this.tableAdapter.lastColumnIndex;
    }
    /**
     * The last row as reported by the adapter
     */
    get lastRow() {
        return this.tableAdapter.lastRowIndex;
    }
    /**
     * Handles moving the position according to the w3 datagrid navigation specs
     *
     * Refs:
     *  - https://www.w3.org/TR/wai-aria-practices/examples/grid/dataGrids.html
     *  - https://www.w3.org/TR/wai-aria-practices/#grid
     *
     * @param event the KeyboardEvent to handle
     */
    handleKeyboardEvent(event) {
        const currentCell = this.tableAdapter.getCell(this.currentRow, this.currentColumn);
        let currentColumn = this.tableAdapter.findColumnIndex(currentCell);
        let currentRow = this.tableAdapter.findRowIndex(currentCell);
        switch (event.key) {
            case "Right": // IE specific value
            case "ArrowRight":
                event.preventDefault();
                // add the colspan since findColumnIndex will return the
                // first column containing the cell (of N columns it may span)
                // and we want to navigate to the next "real" column
                this.goToColumn(currentColumn + currentCell.colSpan);
                break;
            case "Left": // IE specific value
            case "ArrowLeft":
                event.preventDefault();
                // we only ever need to subtract 1 from the column, since findColumnIndex returns the
                // first of N columns containing the cell
                this.goToColumn(currentColumn - 1);
                break;
            case "Down": // IE specific value
            case "ArrowDown":
                event.preventDefault();
                this.goToRow(currentRow + currentCell.rowSpan);
                break;
            case "Up": // IE specific value
            case "ArrowUp":
                event.preventDefault();
                this.goToRow(currentRow - 1);
                break;
            case "Home":
                event.preventDefault();
                if (event.ctrlKey) {
                    this.goTo({ row: 0, column: 0 });
                }
                else {
                    this.goToColumn(0);
                }
                break;
            case "End":
                event.preventDefault();
                if (event.ctrlKey) {
                    this.goTo({ row: this.lastRow, column: this.lastColumn });
                }
                else {
                    this.goToColumn(this.lastColumn);
                }
                break;
        }
    }
    /**
     * Handles moving the position to the clicked cell
     *
     * @param event the MouseEvent to handle
     */
    handleClickEvent(event) {
        const cell = event.target.closest("td, th");
        const [rowIndex, cellIndex] = this.tableAdapter.findIndex(cell);
        this.goTo({ row: rowIndex, column: cellIndex });
    }
    /**
     * Jump to a specific column without changing the row
     *
     * @param index column to jump to
     */
    goToColumn(index) {
        if (index > this.lastColumn || index < 0) {
            return;
        }
        this.goTo({ row: this.currentRow, column: index });
    }
    /**
     * Jump to a specific row without changing the column
     *
     * @param index row to jump to
     */
    goToRow(index) {
        if (index > this.lastRow || index < 0) {
            return;
        }
        this.goTo({ row: index, column: this.currentColumn });
    }
    /**
     * Jump to the specified row and column
     *
     * @param param0 an object that contains `row` and `column` properties
     */
    goTo({ row, column }) {
        this.rowSubject.next({ current: row, previous: this.currentRow });
        this.columnSubject.next({ current: column, previous: this.currentColumn });
    }
    /**
     * Convenience method to reset the tab indexes on a standard carbon table.
     * For custom tables you may want to reset the indexes manually and simply call `.reset()`
     */
    resetTabIndexes(newTabIndex = -1) {
        for (let i = 0; i < this.tableAdapter.lastRowIndex; i++) {
            const row = this.tableAdapter.getRow(i);
            for (const cell of Array.from(row.cells)) {
                const tabbableElements = getFocusElementList(cell, tabbableSelectorIgnoreTabIndex);
                tabbableElements.forEach((node) => node.tabIndex = newTabIndex);
                cell.tabIndex = newTabIndex;
            }
        }
        this.reset();
    }
    /**
     * Resets the models focus position
     */
    reset() {
        this.rowSubject.next({ current: 0, previous: -1 });
        this.columnSubject.next({ current: 0, previous: -1 });
    }
}

/**
 * An abstract class that represents a cell in a table
 */
class TableCellAdapter {
}
/**
 * An abstract class that represents a row in a table
 */
class TableRowAdapter {
}
/**
 * An abstract representation of a table that provides
 * a standard interface to query 2d tables for cell and row information.
 */
class TableAdapter {
    /**
     * The last accessible column in the table
     */
    get lastColumnIndex() { return; }
    /**
     * The last accessible row in the table
     */
    get lastRowIndex() { return; }
    /**
     * Returns a cell from the table
     *
     * @param row index of the row
     * @param column index of the column
     */
    getCell(row, column) { return; }
    /**
     * Returns a row from the table
     *
     * @param column index of the column
     */
    getColumn(column) { return; }
    /**
     * Returns a row from the table
     *
     * @param row index of the row
     */
    getRow(row) { return; }
    /**
     * Finds the column index of a given cell
     *
     * @param cell the cell to search for
     */
    findColumnIndex(cell) { return; }
    /**
     * Finds the row index of a given cell
     *
     * @param cell the cell to search for
     */
    findRowIndex(cell) { return; }
    /**
     * Finds the row and column index of a given cell
     *
     * @param cell the cell to search for
     * @returns a tuple that follows the `[row, column]` convention
     */
    findIndex(cell) { return; }
}
var TableDomSpanDirection;
(function (TableDomSpanDirection) {
    TableDomSpanDirection["colSpan"] = "colSpan";
    TableDomSpanDirection["rowSpan"] = "rowSpan";
})(TableDomSpanDirection || (TableDomSpanDirection = {}));
/**
 * A concrete implementation of `TableAdapter`
 *
 * Provides standard and consistent access to table cells and rows
 */
class TableDomAdapter {
    /**
     * `TableDomAdapter` works on a normal HTML table structure.
     * Custom tables that don't follow the standard structure should use a custom implementation of `TableAdapter`.
     *
     * The standard structure allows us to directly query rows for cells and indexes - though we do have to handle colspans specially.
     *
     * @param tableElement the root HTML table element.
     */
    constructor(tableElement) {
        this.tableElement = tableElement;
    }
    /**
     * The last accessible column in the table
     */
    get lastColumnIndex() {
        return this.getRealRowLength(this.tableElement.rows[0]);
    }
    /**
     * The last accessible row in the table
     */
    get lastRowIndex() {
        return this.tableElement.rows.length - 1;
    }
    /**
     * Returns a cell from the table taking colspans in to account.
     *
     * @param row index of the row
     * @param column index of the column
     */
    getCell(row, column) {
        const col = this.getColumn(column);
        return this.findCellInColumn(col, row).cell;
    }
    /**
     * Returns a column from the table, using the `id` and `headers` attributes
     *
     * See here for more detail these attributes: https://www.w3.org/TR/WCAG20-TECHS/H43.html
     *
     * @param column the index of the column
     */
    getColumn(column) {
        const firstHeader = Array.from(this.tableElement.rows[0].cells);
        const { cell: header, realIndex: realColumnIndex } = this.findCellInRow(firstHeader, column);
        const linkedCells = [];
        for (let i = 1; i < this.tableElement.rows.length; i++) {
            const row = this.tableElement.rows[i];
            // query for any cells that are linked to the given header id
            // `~=` matches values in space separated lists - so `[headers~='foo']` would match `headers="foo bar"` and `headers="foo"`
            // but not `headers="bar"` or `headers="bar baz"`
            const linkedRowCells = row.querySelectorAll(`[headers~='${header.id}']`);
            // if we have more than one cell, get the one that is closest to the column
            if (linkedRowCells.length > 1) {
                const { cell } = this.findCellInRow(Array.from(linkedRowCells), column - realColumnIndex);
                linkedCells.push(cell);
            }
            else if (linkedRowCells[0]) {
                linkedCells.push(linkedRowCells[0]);
            }
        }
        // return an empty array if we can't find any linked cells
        // returning anything else would be a lie
        if (!linkedCells) {
            return [];
        }
        return [header, ...linkedCells];
    }
    /**
     * Returns a row from the table
     *
     * @param row index of the row
     */
    getRow(row) {
        return this.tableElement.rows[row];
    }
    /**
     * Finds the column index of a given cell
     *
     * @param cell the cell to search for
     */
    findColumnIndex(cell) {
        const row = this.getRow(this.findRowIndex(cell));
        if (!row) {
            return;
        }
        // if the cell has linked headers we can do a more accurate lookup
        if (cell && cell.headers) {
            const ids = cell.headers.split(" ");
            const headerRows = Array.from(this.tableElement.tHead.rows);
            const indexes = [];
            // start from the last row and work up
            for (const headerRow of headerRows.reverse()) {
                const headerCells = Array.from(headerRow.cells);
                const header = headerCells.find(headerCell => ids.includes(headerCell.id));
                // if we have a matching header, find it's index (adjusting for colspans)
                if (header) {
                    // this is borrowed from below
                    let cellIndex = 0;
                    for (const c of headerCells) {
                        if (c === header) {
                            break;
                        }
                        cellIndex += c.colSpan;
                    }
                    indexes.push(cellIndex);
                }
            }
            // sort the indexes largest to smallest to find the closest matching header index
            const firstIndex = indexes.sort((a, b) => b - a)[0];
            // search the row for cells that share the header
            let similarCells = [];
            for (const id of ids) {
                // there's no selector that will match two space separated lists,
                // so we have to iterate through the ids and query the row for each
                const rowCells = Array.from(row.querySelectorAll(`[headers~='${id}']`));
                for (const rowCell of rowCells) {
                    // only keep one set of cells
                    if (!similarCells.includes(rowCell)) {
                        similarCells.push(rowCell);
                    }
                }
            }
            // DOM order is not preserved, so we have to sort the row
            similarCells = similarCells.sort((a, b) => a.cellIndex - b.cellIndex);
            // return the header index plus any adjustment within that headers column
            return firstIndex + similarCells.indexOf(cell);
        }
        // fallback if the cell isn't linked to any headers
        let cellIndex = 0;
        for (const c of Array.from(row.cells)) {
            if (c === cell) {
                break;
            }
            cellIndex += c.colSpan;
        }
        return cellIndex;
    }
    /**
     * Finds the row index of a given cell
     *
     * @param cell the cell to search for
     */
    findRowIndex(cell) {
        for (const row of Array.from(this.tableElement.rows)) {
            if (row.contains(cell)) {
                return row.rowIndex;
            }
        }
    }
    /**
     * Finds the row and column index of a given cell
     *
     * @param cell the cell to search for
     * @returns a tuple that follows the `[row, column]` convention
     */
    findIndex(cell) {
        return [this.findRowIndex(cell), this.findColumnIndex(cell)];
    }
    /**
     * Helper function that returns the "real" length of a row.
     * Only accurate with regard to colspans (though that's sufficient for it's uses here)
     *
     * TODO: Take rowSpan into account
     *
     * @param row the row to get the length of
     */
    getRealRowLength(row) {
        // start at -1 since the colspans will sum to 1 index greater than the total
        return Array.from(row.cells).reduce((count, cell) => count + cell.colSpan, -1);
    }
    /**
     * Finds a cell and it's real index given an array of cells, a target index, and the spanning direction
     *
     * @param cells An array of cells to search
     * @param targetIndex The index we think the cell is located at
     * @param spanDirection The direction of the cell spans. Should be `"colSpan"` for a row and `"rowSpan"` for a column
     */
    findCell(cells, targetIndex, spanDirection) {
        // rows/cols can have fewer total cells than the actual table
        // the model pretends all rows/cols behave the same (with col/row spans > 1 being N cells long)
        // this maps that view to the HTML view (col/row spans > 1 are one element, so the array is shorter)
        let realIndex = 0;
        // i is only used for iterating the cells
        for (let i = 0; i < targetIndex;) {
            // skip the next N cells
            i += cells[realIndex][spanDirection];
            // don't bump realIndex if i now exceeds the cell we're shooting for
            if (i > targetIndex) {
                break;
            }
            // finally, increment realIndex (to keep it generally in step with i)
            realIndex++;
        }
        return {
            cell: cells[realIndex],
            realIndex
        };
    }
    /**
     * Helper method around `findCell`, searches based on a row of cells
     *
     * @param row the row of elements to search
     * @param index the index of the element
     */
    findCellInRow(row, index) {
        return this.findCell(row, index, TableDomSpanDirection.colSpan);
    }
    /**
     * Helper method around `findCell`, searches based on a column of cells
     *
     * @param col the column of elements to search
     * @param index the index of the element
     */
    findCellInColumn(col, index) {
        return this.findCell(col, index, TableDomSpanDirection.rowSpan);
    }
}

/**
 * Build your table with this component by extending things that differ from default.
 *
 * [See demo](../../?path=/story/table--basic)
 *
 * Instead of the usual write-your-own-html approach you had with `<table>`,
 * carbon table uses model-view-controller approach.
 *
 * Here, you create a view (with built-in controller) and provide it a model.
 * Changes you make to the model are reflected in the view. Provide same model you use
 * in the table to the `<ibm-pagination>` components.
 * They provide a different view over the same data.
 *
 * ## Basic usage
 *
 * ```html
 * <ibm-table [model]="model"></ibm-table>
 * ```
 *
 * ```typescript
 * public model = new TableModel();
 *
 * this.model.data = [
 * 	[new TableItem({data: "asdf"}), new TableItem({data: "qwer"})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "zwer"})],
 * 	[new TableItem({data: "bsdf"}), new TableItem({data: "swer"})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "twer"})]
 * ];
 * ```
 *
 * ## Customization
 *
 * If you have custom data in your table, you need a way to display it. You can do that
 * by providing a template to `TableItem`.
 *
 * ```html
 * <ng-template #customTableItemTemplate let-data="data">
 * 	<a [routerLink]="data.link">{{data.name}} {{data.surname}}</a>
 * </ng-template>
 * ```
 *
 * ```typescript
 * customTableItemTemplate: TemplateRef<any>;
 *
 * this.customModel.data = [
 * 	[new TableItem({data: "asdf"}), new TableItem({data: {name: "Lessy", link: "/table"}, template: this.customTableItemTemplate})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "swer"})],
 * 	[new TableItem({data: "bsdf"}), new TableItem({data: {name: "Alice", surname: "Bob"}, template: this.customTableItemTemplate})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "twer"})],
 * ];
 * ```
 *
 * ### Sorting and filtering
 *
 * In case you need custom sorting and/or filtering you should subclass `TableHeaderItem`
 * and override needed functions.
 *
 * ```typescript
 * class FilterableHeaderItem extends TableHeaderItem {
 * 	// custom filter function
 * 	filter(item: TableItem): boolean {
 * 		if (typeof item.data === "string" && item.data.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0 ||
 * 		item.data.name && item.data.name.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0 ||
 * 		item.data.surname && item.data.surname.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0) {
 * 			return false;
 * 		}
 * 		return true;
 * 	}
 *
 * 	set filterCount(n) {}
 * 	get filterCount() {
 * 		return (this.filterData && this.filterData.data && this.filterData.data.length > 0) ? 1 : 0;
 * 	}
 *
 * 	// used for custom sorting
 * 	compare(one: TableItem, two: TableItem) {
 * 		const stringOne = (one.data.name || one.data.surname || one.data).toLowerCase();
 * 		const stringTwo = (two.data.name || two.data.surname || two.data).toLowerCase();
 *
 * 		if (stringOne > stringTwo) {
 * 			return 1;
 * 		} else if (stringOne < stringTwo) {
 * 			return -1;
 * 		} else {
 * 			return 0;
 * 		}
 * 	}
 * }
 * ```
 *
 * If you want to do your sorting on the backend or query for sorted data as a result of user
 * clicking the table header, check table [`sort`](#sort) output documentation
 *
 * See `TableHeaderItem` class for more information.
 *
 * ## No data template
 *
 * When table has no data to show, it can show a message you provide it instead.
 *
 * ```html
 * <ibm-table [model]="model">No data.</ibm-table>
 * ```
 *
 * ... will show `No data.` message, but you can get creative and provide any template you want
 * to replace table's default `tbody`.
 *
 * ## Use pagination as table footer
 *
 * ```html
 * <ibm-pagination [model]="model" (selectPage)="selectPage($event)"></ibm-pagination>
 * ```
 *
 * `selectPage()` function should fetch the data from backend, create new `data`, apply it to `model.data`,
 * and update `model.currentPage`.
 *
 * If the data your server returns is a two dimensional array of objects, it would look something like this:
 *
 * ```typescript
 * selectPage(page) {
 * 	this.getPage(page).then((data: Array<Array<any>>) => {
 * 		// set the data and update page
 * 		this.model.data = this.prepareData(data);
 * 		this.model.currentPage = page;
 * 	});
 * }
 *
 * protected prepareData(data: Array<Array<any>>) {
 * 	// create new data from the service data
 * 	let newData = [];
 * 	data.forEach(dataRow => {
 * 		let row = [];
 * 		dataRow.forEach(dataElement => {
 * 			row.push(new TableItem({
 * 				data: dataElement,
 * 				template: typeof dataElement === "string" ? undefined : this.paginationTableItemTemplate
 * 				// your template can handle all the data types so you don't have to conditionally set it
 * 				// you can also set different templates for different columns based on index
 * 			}));
 * 		});
 * 		newData.push(row);
 * 	});
 * 	return newData;
 * }
 * ```
 *
 * <example-url>../../iframe.html?id=table--basic</example-url>
 */
class Table {
    /**
     * Creates an instance of Table.
     */
    constructor(elementRef, applicationRef, i18n) {
        this.elementRef = elementRef;
        this.applicationRef = applicationRef;
        this.i18n = i18n;
        /**
         * Size of the table rows.
         */
        this.size = "md";
        /**
         * Set to `true` for a loading table.
         */
        this.skeleton = false;
        /**
         * Setting sortable to false will disable all headers including headers which are sortable. Is is
         * possible to set the sortable state on the header item to disable/enable sorting for only some headers.
         */
        this.sortable = true;
        this.noBorder = true;
        /**
         * Controls whether to show the selection checkboxes column or not.
         */
        this.showSelectionColumn = true;
        /**
         * Controls whether to enable multiple or single row selection.
         */
        this.enableSingleSelect = false;
        /**
         * Distance (in px) from the bottom that view has to reach before
         * `scrollLoad` event is emitted.
         */
        this.scrollLoadDistance = 0;
        /**
         * Set to `true` to enable users to resize columns.
         *
         * Works for columns with width set in pixels.
         *
         */
        this.columnsResizable = false;
        /**
         * Set to `true` to enable users to drag and drop columns.
         *
         * Changing the column order in table changes table model. Be aware of it when you add additional data
         * to the model.
         *
         */
        this.columnsDraggable = false;
        /**
         * Set to `false` to remove table rows (zebra) stripes.
         */
        this.striped = true;
        /**
         * Set to `true` to stick the header to the top of the table
         */
        this.stickyHeader = false;
        /**
         * Emits an index of the column that wants to be sorted.
         *
         * If no observers are provided (default), table will attempt to do a simple sort of the data loaded
         * into the model.
         *
         * If an observer is provided, table will not attempt any sorting of its own and it is up to the observer
         * to sort the table. This is what you typically want if you're using a backend query to get the sorted
         * data or want to sort data across multiple pages.
         *
         * Usage:
         *
         * ```typescript
         * @Component({
         * 	selector: "app-table",
         * 	template: `
         * 		<ibm-table
         * 			[model]="model"
         * 			(sort)="simpleSort($event)">
         * 			No data.
         * 		</ibm-table>
         * 	`
         * })
         * export class TableApp implements OnInit, OnChanges {
         * 	@Input() model = new TableModel();
         *
         * 	ngOnInit() {
         * 		this.model.header = [
         * 			new TableHeaderItem({ data: "Name" }),
         * 			new TableHeaderItem({ data: "hwer" })
         * 		];
         *
         * 		this.model.data = [
         * 			[new TableItem({ data: "Name 1" }), new TableItem({ data: "qwer" })],
         * 			[new TableItem({ data: "Name 3" }), new TableItem({ data: "zwer" })],
         * 			[new TableItem({ data: "Name 2" }), new TableItem({ data: "swer" })],
         * 			[new TableItem({ data: "Name 4" }), new TableItem({data: "twer"})],
         * 			[new TableItem({ data: "Name 5" }), new TableItem({data: "twer"})],
         * 			[new TableItem({ data: "Name 6" }), new TableItem({data: "twer"})]
         * 		];
         * 	}
         *
         * 	simpleSort(index: number) {
         * 		// this function does a simple sort, which is the default for the table and if that's
         * 		// all you want, you don't need to do this.
         *
         * 		// here you can query your backend and update the model.data based on the result
         * 		if (this.model.header[index].sorted) {
         * 			// if already sorted flip sorting direction
         * 			this.model.header[index].ascending = this.model.header[index].descending;
         * 		}
         * 		this.model.sort(index);
         * 	}
         * }
         * ```
         */
        this.sort = new EventEmitter();
        /**
         * Emits if all rows are selected.
         *
         * @param model
         */
        this.selectAll = new EventEmitter();
        /**
         * Emits if all rows are deselected.
         *
         * @param model
         */
        this.deselectAll = new EventEmitter();
        /**
         * Emits if a single row is selected.
         *
         * @param ({model: this.model, selectedRowIndex: index})
         */
        this.selectRow = new EventEmitter();
        /**
         * Emits if a single row is deselected.
         *
         * @param ({model: this.model, deselectedRowIndex: index})
         */
        this.deselectRow = new EventEmitter();
        /**
         * Emits if a row item excluding expandButtons, checkboxes, or radios is clicked.
         */
        this.rowClick = new EventEmitter();
        /**
         * Emits when table requires more data to be loaded.
         */
        this.scrollLoad = new EventEmitter();
        /**
         * Controls if all checkboxes are viewed as selected.
         */
        this.selectAllCheckbox = false;
        /**
         * Controls the indeterminate state of the header checkbox.
         */
        this.selectAllCheckboxSomeSelected = false;
        this.isColumnDragging = false;
        this.columnDraggedHoverIndex = -1;
        this.columnDraggedPosition = "";
        this._isDataGrid = false;
        // flag to prevent getters/setters from querying the view before it's fully instantiated
        this.isViewReady = false;
        this.subscriptions = new Subscription();
        this._expandButtonAriaLabel = this.i18n.getOverridable("TABLE.EXPAND_BUTTON");
        this._sortDescendingLabel = this.i18n.getOverridable("TABLE.SORT_DESCENDING");
        this._sortAscendingLabel = this.i18n.getOverridable("TABLE.SORT_ASCENDING");
        this._checkboxHeaderLabel = this.i18n.getOverridable("TABLE.CHECKBOX_HEADER");
        this._checkboxRowLabel = this.i18n.getOverridable("TABLE.CHECKBOX_ROW");
        this._endOfDataText = this.i18n.getOverridable("TABLE.END_OF_DATA");
        this._scrollTopText = this.i18n.getOverridable("TABLE.SCROLL_TOP");
        this._filterTitle = this.i18n.getOverridable("TABLE.FILTER");
    }
    /**
     * Creates a skeleton model with a row and column count specified by the user
     *
     * Example:
     *
     * ```typescript
     * this.model = Table.skeletonModel(5, 5);
     * ```
     */
    static skeletonModel(rowCount, columnCount) {
        const model = new TableModel();
        let header = new Array();
        let data = new Array();
        let row = new Array();
        for (let i = 0; i < columnCount; i++) {
            header.push(new TableHeaderItem());
            row.push(new TableItem());
        }
        for (let i = 0; i < rowCount - 1; i++) {
            data.push(row);
        }
        model.header = header;
        model.data = data;
        return model;
    }
    static setTabIndex(element, index) {
        const focusElementList = getFocusElementList(element, tabbableSelectorIgnoreTabIndex);
        if (element.firstElementChild && element.firstElementChild.classList.contains("bx--table-sort")) {
            focusElementList[1].tabIndex = index;
        }
        else if (focusElementList.length > 0) {
            focusElementList[0].tabIndex = index;
        }
        else {
            element.tabIndex = index;
        }
    }
    static focus(element) {
        const focusElementList = getFocusElementList(element, tabbableSelectorIgnoreTabIndex);
        if (element.firstElementChild && element.firstElementChild.classList.contains("bx--table-sort") && focusElementList.length > 1) {
            focusElementList[1].focus();
        }
        else if (focusElementList.length > 0) {
            focusElementList[0].focus();
        }
        else {
            element.focus();
        }
    }
    /**
     * `TableModel` with data the table is to display.
     */
    set model(m) {
        if (this._model) {
            this.subscriptions.unsubscribe();
            // Need to create a new subscription instance here because unsubscribing prevents any new subscriptions
            // from being added for some reason. When a new model is set, none of the subscriptions would exist.
            this.subscriptions = new Subscription();
        }
        this._model = m;
        const rowsChange = this._model.rowsSelectedChange.subscribe(() => this.updateSelectAllCheckbox());
        const dataChange = this._model.dataChange.subscribe(() => {
            if (this.isDataGrid) {
                this.resetTabIndex();
            }
            this.updateSelectAllCheckbox();
        });
        this.subscriptions.add(rowsChange);
        this.subscriptions.add(dataChange);
        if (this.isDataGrid) {
            const expandedChange = this._model.rowsExpandedChange.subscribe(() => {
                // Allows the expanded row to have a focus state when it exists in the DOM
                setTimeout(() => {
                    const expandedRows = this.elementRef.nativeElement.querySelectorAll(".bx--expandable-row:not(.bx--parent-row)");
                    Array.from(expandedRows).forEach(row => {
                        if (row.firstElementChild.tabIndex === undefined || row.firstElementChild.tabIndex !== -1) {
                            row.firstElementChild.tabIndex = -1;
                        }
                    });
                });
            });
            this.subscriptions.add(expandedChange);
        }
    }
    get model() {
        return this._model;
    }
    /**
     * Set to `true` for a data grid with keyboard interactions.
     */
    set isDataGrid(value) {
        this._isDataGrid = value;
        if (this.isViewReady) {
            if (value) {
                this.enableDataGridInteractions();
            }
            else {
                this.disableDataGridInteractions();
            }
        }
    }
    get isDataGrid() {
        return this._isDataGrid;
    }
    set expandButtonAriaLabel(value) {
        this._expandButtonAriaLabel.override(value);
    }
    get expandButtonAriaLabel() {
        return this._expandButtonAriaLabel.value;
    }
    set sortDescendingLabel(value) {
        this._sortDescendingLabel.override(value);
    }
    get sortDescendingLabel() {
        return this._sortDescendingLabel.value;
    }
    set sortAscendingLabel(value) {
        this._sortAscendingLabel.override(value);
    }
    get sortAscendingLabel() {
        return this._sortAscendingLabel.value;
    }
    /**
     * Expects an object that contains some or all of:
     * ```
     * {
     *		"FILTER": "Filter",
     *		"END_OF_DATA": "You've reached the end of your content",
     *		"SCROLL_TOP": "Scroll to top",
     *		"CHECKBOX_HEADER": "Select all rows",
     *		"CHECKBOX_ROW": "Select row"
     * }
     * ```
     */
    set translations(value) {
        const valueWithDefaults = merge(this.i18n.getMultiple("TABLE"), value);
        this._filterTitle.override(valueWithDefaults.FILTER);
        this._endOfDataText.override(valueWithDefaults.END_OF_DATA);
        this._scrollTopText.override(valueWithDefaults.SCROLL_TOP);
        this._checkboxHeaderLabel.override(valueWithDefaults.CHECKBOX_HEADER);
        this._checkboxRowLabel.override(valueWithDefaults.CHECKBOX_ROW);
    }
    get noData() {
        return !this.model.data ||
            this.model.data.length === 0 ||
            this.model.data.length === 1 && this.model.data[0].length === 0;
    }
    ngAfterViewInit() {
        this.isViewReady = true;
        if (this.isDataGrid) {
            this.enableDataGridInteractions();
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
        if (this.positionSubscription) {
            this.positionSubscription.unsubscribe();
        }
    }
    enableDataGridInteractions() {
        // if we have an `interactioModel` we've already enabled datagrid
        if (this.interactionModel) {
            return;
        }
        const table = this.elementRef.nativeElement.querySelector("table");
        const tableAdapter = new TableDomAdapter(table);
        const keydownEventStream = fromEvent(table, "keydown");
        const clickEventStream = fromEvent(table, "click");
        this.interactionModel = new DataGridInteractionModel(keydownEventStream, clickEventStream, tableAdapter);
        this.positionSubscription = this.interactionModel.position.subscribe(event => {
            const [currentRow, currentColumn] = event.current;
            const [previousRow, previousColumn] = event.previous;
            const currentElement = tableAdapter.getCell(currentRow, currentColumn);
            Table.setTabIndex(currentElement, 0);
            // if the model has just initialized don't focus or reset anything
            if (previousRow === -1 || previousColumn === -1) {
                return;
            }
            // Make the previous cell unfocusable (if it's not the current)
            if (previousRow !== currentRow || previousColumn !== currentColumn) {
                const previousElement = tableAdapter.getCell(previousRow, previousColumn);
                Table.setTabIndex(previousElement, -1);
            }
            Table.focus(currentElement);
        });
        // call this after assigning `this.interactionModel` since it depends on it
        this.resetTabIndex();
    }
    disableDataGridInteractions() {
        // unsubscribe first so we don't cause the focus to fly around
        if (this.positionSubscription) {
            this.positionSubscription.unsubscribe();
        }
        // undo tab indexing (also resets the model)
        this.resetTabIndex(0);
        // null out the model ref
        this.interactionModel = null;
    }
    onSelectAll() {
        this.model.selectAll(true);
        this.selectAll.emit(this.model);
    }
    onDeselectAll() {
        this.model.selectAll(false);
        this.deselectAll.emit(this.model);
    }
    onSelectRow(event) {
        // check for the existence of the selectedRowIndex property
        if (Object.keys(event).includes("selectedRowIndex")) {
            if (this.enableSingleSelect) {
                this.model.selectAll(false);
            }
            this.model.selectRow(event.selectedRowIndex, true);
            this.selectRow.emit(event);
        }
        else {
            this.model.selectRow(event.deselectedRowIndex, false);
            this.deselectRow.emit(event);
        }
    }
    onRowClick(index) {
        this.rowClick.emit(index);
    }
    updateSelectAllCheckbox() {
        const selectedRowsCount = this.model.selectedRowsCount();
        if (selectedRowsCount <= 0) {
            // reset select all checkbox if nothing selected
            this.selectAllCheckbox = false;
            this.selectAllCheckboxSomeSelected = false;
        }
        else if (selectedRowsCount < this.model.data.length) {
            this.selectAllCheckbox = true;
            this.selectAllCheckboxSomeSelected = true;
        }
        else {
            this.selectAllCheckbox = true;
            this.selectAllCheckboxSomeSelected = false;
        }
    }
    resetTabIndex(newTabIndex = -1) {
        // ensure the view is ready for the reset before we preform the actual reset
        setTimeout(() => {
            // reset all the tabIndexes we can find
            const focusElementList = getFocusElementList(this.elementRef.nativeElement, tabbableSelectorIgnoreTabIndex);
            if (focusElementList) {
                focusElementList.forEach(tabbable => {
                    tabbable.tabIndex = newTabIndex;
                });
            }
            // reset interaction model positions and tabIndexes
            if (this.interactionModel) {
                this.interactionModel.resetTabIndexes(newTabIndex);
            }
        });
    }
    columnResizeStart(event, column) {
        this.columnResizeWidth = parseInt(column.style.width, 10);
        this.columnResizeMouseX = event.clientX;
        event.preventDefault();
        this.mouseMoveSubscription = fromEvent(document.body, "mousemove").subscribe(event => {
            this.columnResizeProgress(event, column);
        });
        this.mouseUpSubscription = fromEvent(document.body, "mouseup").subscribe(event => {
            this.columnResizeEnd(event, column);
        });
    }
    columnResizeProgress(event, column) {
        const move = event.clientX - this.columnResizeMouseX;
        column.style.width = `${this.columnResizeWidth + move}px`;
    }
    columnResizeEnd(event, column) {
        this.mouseMoveSubscription.unsubscribe();
        this.mouseUpSubscription.unsubscribe();
    }
    /**
     * Triggered when the user scrolls on the `<tbody>` element.
     * Emits the `scrollLoad` event.
     */
    onScroll(event) {
        const distanceFromBottom = event.target.scrollHeight - event.target.clientHeight - event.target.scrollTop;
        if (distanceFromBottom <= this.scrollLoadDistance) {
            this.scrollLoad.emit(this.model);
        }
        else {
            this.model.isEnd = false;
        }
    }
    columnDragStart(event, columnIndex) {
        this.isColumnDragging = true;
        this.columnDraggedHoverIndex = columnIndex;
        event.dataTransfer.setData("columnIndex", JSON.stringify(columnIndex));
    }
    columnDragEnd(event, columnIndex) {
        this.isColumnDragging = false;
        this.columnDraggedHoverIndex = -1;
    }
    columnDragEnter(event, position, columnIndex) {
        this.columnDraggedPosition = position;
        this.columnDraggedHoverIndex = columnIndex;
    }
    columnDragLeave(event, position, columnIndex) {
        this.columnDraggedPosition = "";
    }
    columnDragover(event, position, columnIndex) {
        this.columnDraggedHoverIndex = columnIndex;
        this.columnDraggedPosition = position;
        // needed to tell browser to allow dropping
        event.preventDefault();
    }
    columnDrop(event, position, columnIndex) {
        this.isColumnDragging = false;
        this.columnDraggedHoverIndex = -1;
        this.columnDraggedPosition = "";
        this.model.moveColumn(parseInt(event.dataTransfer.getData("columnIndex"), 10), columnIndex + (position === "right" ? 1 : 0));
    }
    doSort(index) {
        if (this.sort.observers.length === 0) {
            // no sort provided so do the simple sort
            if (this.model.header[index].sorted) {
                // if already sorted flip sorting direction
                this.model.header[index].ascending = this.model.header[index].descending;
            }
            this.model.sort(index);
        }
        this.sort.emit(index);
    }
    /**
     * Triggered when the user scrolls on the `<tbody>` element.
     * Emits the `scrollLoad` event.
     */
    scrollToTop(event) {
        event.target.parentElement.parentElement.parentElement.parentElement.children[1].scrollTop = 0;
        this.model.isEnd = false;
    }
    getSelectionLabelValue(row) {
        if (!this.selectionLabelColumn) {
            return { value: this.i18n.get().TABLE.ROW };
        }
        return { value: row[this.selectionLabelColumn].data };
    }
    getExpandButtonAriaLabel() {
        return this._expandButtonAriaLabel.subject;
    }
    getSortDescendingLabel() {
        return this._sortDescendingLabel.subject;
    }
    getSortAscendingLabel() {
        return this._sortAscendingLabel.subject;
    }
    getCheckboxHeaderLabel() {
        return this._checkboxHeaderLabel.subject;
    }
    getCheckboxRowLabel() {
        return this._checkboxRowLabel.subject;
    }
    getEndOfDataText() {
        return this._endOfDataText.subject;
    }
    getScrollTopText() {
        return this._scrollTopText.subject;
    }
    getFilterTitle() {
        return this._filterTitle.subject;
    }
}
Table.ɵfac = function Table_Factory(t) { return new (t || Table)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n)); };
Table.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: Table, selectors: [["ibm-table"]], hostVars: 2, hostBindings: function Table_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--data-table_inner-container", ctx.stickyHeader);
    } }, inputs: { size: "size", skeleton: "skeleton", sortable: "sortable", noBorder: "noBorder", showSelectionColumn: "showSelectionColumn", enableSingleSelect: "enableSingleSelect", scrollLoadDistance: "scrollLoadDistance", columnsResizable: "columnsResizable", columnsDraggable: "columnsDraggable", striped: "striped", stickyHeader: "stickyHeader", model: "model", isDataGrid: "isDataGrid", expandButtonAriaLabel: "expandButtonAriaLabel", sortDescendingLabel: "sortDescendingLabel", sortAscendingLabel: "sortAscendingLabel", translations: "translations", footerTemplate: "footerTemplate", selectionLabelColumn: "selectionLabelColumn" }, outputs: { sort: "sort", selectAll: "selectAll", deselectAll: "deselectAll", selectRow: "selectRow", deselectRow: "deselectRow", rowClick: "rowClick", scrollLoad: "scrollLoad" }, ngContentSelectors: _c5, decls: 9, vars: 26, consts: [["ibmTable", "", 3, "sortable", "noBorder", "ngClass", "size", "striped", "skeleton"], ["ibmTableHead", "", 3, "sortable", "checkboxHeaderLabel", "filterTitle", "model", "size", "selectAllCheckbox", "selectAllCheckboxSomeSelected", "showSelectionColumn", "enableSingleSelect", "skeleton", "sortAscendingLabel", "sortDescendingLabel", "stickyHeader", "deselectAll", "selectAll", "sort"], ["ibmTableBody", "", 3, "checkboxRowLabel", "enableSingleSelect", "expandButtonAriaLabel", "model", "size", "ngStyle", "selectionLabelColumn", "showSelectionColumn", "skeleton", "deselectRow", "scroll", "selectRow", "rowClick", 4, "ngIf", "ngIfElse"], ["noDataTemplate", ""], [3, "ngTemplateOutlet"], [4, "ngIf"], ["ibmTableBody", "", 3, "checkboxRowLabel", "enableSingleSelect", "expandButtonAriaLabel", "model", "size", "ngStyle", "selectionLabelColumn", "showSelectionColumn", "skeleton", "deselectRow", "scroll", "selectRow", "rowClick"], [1, "table_loading-indicator"], [1, "bx--loading", "bx--loading--small"], ["viewBox", "-75 -75 150 150", 1, "bx--loading__svg"], ["cx", "0", "cy", "0", "r", "37.5", 1, "bx--loading__stroke"], [1, "table_end-indicator"], [1, "btn--secondary-sm", 3, "click"]], template: function Table_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "table", 0);
        ɵngcc0.ɵɵelementStart(1, "thead", 1);
        ɵngcc0.ɵɵlistener("deselectAll", function Table_Template_thead_deselectAll_1_listener() { return ctx.onDeselectAll(); })("selectAll", function Table_Template_thead_selectAll_1_listener() { return ctx.onSelectAll(); })("sort", function Table_Template_thead_sort_1_listener($event) { return ctx.doSort($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, Table_tbody_2_Template, 1, 10, "tbody", 2);
        ɵngcc0.ɵɵtemplate(3, Table_ng_template_3_Template, 1, 0, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementStart(5, "tfoot");
        ɵngcc0.ɵɵtemplate(6, Table_ng_template_6_Template, 0, 0, "ng-template", 4);
        ɵngcc0.ɵɵtemplate(7, Table_tr_7_Template, 5, 0, "tr", 5);
        ɵngcc0.ɵɵtemplate(8, Table_tr_8_Template, 8, 6, "tr", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(4);
        ɵngcc0.ɵɵproperty("sortable", ctx.sortable)("noBorder", ctx.noBorder)("ngClass", ɵngcc0.ɵɵpureFunction1(24, _c9, ctx.stickyHeader))("size", ctx.size)("striped", ctx.striped)("skeleton", ctx.skeleton);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("sortable", ctx.sortable)("checkboxHeaderLabel", ctx.getCheckboxHeaderLabel())("filterTitle", ctx.getFilterTitle())("model", ctx.model)("size", ctx.size)("selectAllCheckbox", ctx.selectAllCheckbox)("selectAllCheckboxSomeSelected", ctx.selectAllCheckboxSomeSelected)("showSelectionColumn", ctx.showSelectionColumn)("enableSingleSelect", ctx.enableSingleSelect)("skeleton", ctx.skeleton)("sortAscendingLabel", ctx.sortAscendingLabel)("sortDescendingLabel", ctx.sortDescendingLabel)("stickyHeader", ctx.stickyHeader);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.noData)("ngIfElse", _r1);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.footerTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.model.isLoading);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.model.isEnd);
    } }, directives: function () { return [TableDirective, ɵngcc2.NgClass, TableHead, ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, TableBody, ɵngcc2.NgStyle]; }, pipes: function () { return [ɵngcc2.AsyncPipe]; }, encapsulation: 2 });
/** @nocollapse */
Table.ctorParameters = () => [
    { type: ElementRef },
    { type: ApplicationRef },
    { type: I18n }
];
Table.propDecorators = {
    model: [{ type: Input }],
    size: [{ type: Input }],
    skeleton: [{ type: Input }],
    isDataGrid: [{ type: Input }],
    sortable: [{ type: Input }],
    noBorder: [{ type: Input }],
    showSelectionColumn: [{ type: Input }],
    enableSingleSelect: [{ type: Input }],
    scrollLoadDistance: [{ type: Input }],
    columnsResizable: [{ type: Input }],
    columnsDraggable: [{ type: Input }],
    expandButtonAriaLabel: [{ type: Input }],
    sortDescendingLabel: [{ type: Input }],
    sortAscendingLabel: [{ type: Input }],
    translations: [{ type: Input }],
    striped: [{ type: Input }],
    stickyHeader: [{ type: HostBinding, args: ["class.bx--data-table_inner-container",] }, { type: Input }],
    footerTemplate: [{ type: Input }],
    selectionLabelColumn: [{ type: Input }],
    sort: [{ type: Output }],
    selectAll: [{ type: Output }],
    deselectAll: [{ type: Output }],
    selectRow: [{ type: Output }],
    deselectRow: [{ type: Output }],
    rowClick: [{ type: Output }],
    scrollLoad: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Table, [{
        type: Component,
        args: [{
                selector: "ibm-table",
                template: `
	<table
		ibmTable
		[sortable]="sortable"
		[noBorder]="noBorder"
		[ngClass]="{'bx--data-table--sticky-header': stickyHeader}"
		[size]="size"
		[striped]="striped"
		[skeleton]="skeleton">
		<thead
			ibmTableHead
			[sortable]="sortable"
			(deselectAll)="onDeselectAll()"
			(selectAll)="onSelectAll()"
			(sort)="doSort($event)"
			[checkboxHeaderLabel]="getCheckboxHeaderLabel()"
			[filterTitle]="getFilterTitle()"
			[model]="model"
			[size]="size"
			[selectAllCheckbox]="selectAllCheckbox"
			[selectAllCheckboxSomeSelected]="selectAllCheckboxSomeSelected"
			[showSelectionColumn]="showSelectionColumn"
			[enableSingleSelect]="enableSingleSelect"
			[skeleton]="skeleton"
			[sortAscendingLabel]="sortAscendingLabel"
			[sortDescendingLabel]="sortDescendingLabel"
			[stickyHeader]="stickyHeader">
		</thead>
		<tbody
			ibmTableBody
			(deselectRow)="onSelectRow($event)"
			(scroll)="onScroll($event)"
			(selectRow)="onSelectRow($event)"
			[checkboxRowLabel]="getCheckboxRowLabel()"
			[enableSingleSelect]="enableSingleSelect"
			(rowClick)="onRowClick($event)"
			[expandButtonAriaLabel]="expandButtonAriaLabel"
			[model]="model"
			[size]="size"
			[ngStyle]="{'overflow-y': 'scroll'}"
			[selectionLabelColumn]="selectionLabelColumn"
			[showSelectionColumn]="showSelectionColumn"
			[skeleton]="skeleton"
			*ngIf="!noData; else noDataTemplate">
		</tbody>
		<ng-template #noDataTemplate><ng-content></ng-content></ng-template>
		<tfoot>
			<ng-template
				[ngTemplateOutlet]="footerTemplate">
			</ng-template>
			<tr *ngIf="this.model.isLoading">
				<td class="table_loading-indicator">
					<div class="bx--loading bx--loading--small">
						<svg class="bx--loading__svg" viewBox="-75 -75 150 150">
							<circle class="bx--loading__stroke" cx="0" cy="0" r="37.5" />
						</svg>
					</div>
				</td>
			</tr>
			<tr *ngIf="this.model.isEnd">
				<td class="table_end-indicator">
					<h5>{{getEndOfDataText() | async}}</h5>
					<button (click)="scrollToTop($event)" class="btn--secondary-sm">
						{{getScrollTopText() | async}}
					</button>
				</td>
			</tr>
		</tfoot>
	</table>
	`
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ApplicationRef }, { type: ɵngcc1.I18n }]; }, { size: [{
            type: Input
        }], skeleton: [{
            type: Input
        }], sortable: [{
            type: Input
        }], noBorder: [{
            type: Input
        }], showSelectionColumn: [{
            type: Input
        }], enableSingleSelect: [{
            type: Input
        }], scrollLoadDistance: [{
            type: Input
        }], columnsResizable: [{
            type: Input
        }], columnsDraggable: [{
            type: Input
        }], striped: [{
            type: Input
        }], stickyHeader: [{
            type: HostBinding,
            args: ["class.bx--data-table_inner-container"]
        }, {
            type: Input
        }], sort: [{
            type: Output
        }], selectAll: [{
            type: Output
        }], deselectAll: [{
            type: Output
        }], selectRow: [{
            type: Output
        }], deselectRow: [{
            type: Output
        }], rowClick: [{
            type: Output
        }], scrollLoad: [{
            type: Output
        }], model: [{
            type: Input
        }], isDataGrid: [{
            type: Input
        }], expandButtonAriaLabel: [{
            type: Input
        }], sortDescendingLabel: [{
            type: Input
        }], sortAscendingLabel: [{
            type: Input
        }], translations: [{
            type: Input
        }], footerTemplate: [{
            type: Input
        }], selectionLabelColumn: [{
            type: Input
        }] }); })();

class TableDirective {
    constructor() {
        this.sortable = true;
        this.noBorder = true;
        this.striped = false;
        this.skeleton = false;
        /**
         * Size of the table rows.
         */
        this.size = "md";
        this.tableClass = true;
    }
    get compactClass() {
        return this.size === "sm";
    }
    get tallClass() {
        return this.size === "lg";
    }
    get shortClass() {
        return this.size === "sh";
    }
}
TableDirective.ɵfac = function TableDirective_Factory(t) { return new (t || TableDirective)(); };
TableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TableDirective, selectors: [["", "ibmTable", ""]], hostVars: 16, hostBindings: function TableDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--data-table--sort", ctx.sortable)("bx--data-table--no-border", ctx.noBorder)("bx--data-table--zebra", ctx.striped)("bx--skeleton", ctx.skeleton)("bx--data-table", ctx.tableClass)("bx--data-table--compact", ctx.compactClass)("bx--data-table--tall", ctx.tallClass)("bx--data-table--short", ctx.shortClass);
    } }, inputs: { sortable: "sortable", noBorder: "noBorder", striped: "striped", skeleton: "skeleton", size: "size" } });
TableDirective.propDecorators = {
    sortable: [{ type: Input }, { type: HostBinding, args: ["class.bx--data-table--sort",] }],
    noBorder: [{ type: Input }, { type: HostBinding, args: ["class.bx--data-table--no-border",] }],
    striped: [{ type: Input }, { type: HostBinding, args: ["class.bx--data-table--zebra",] }],
    skeleton: [{ type: Input }, { type: HostBinding, args: ["class.bx--skeleton",] }],
    size: [{ type: Input }],
    tableClass: [{ type: HostBinding, args: ["class.bx--data-table",] }],
    compactClass: [{ type: HostBinding, args: ["class.bx--data-table--compact",] }],
    tallClass: [{ type: HostBinding, args: ["class.bx--data-table--tall",] }],
    shortClass: [{ type: HostBinding, args: ["class.bx--data-table--short",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableDirective, [{
        type: Directive,
        args: [{
                selector: "[ibmTable]"
            }]
    }], function () { return []; }, { sortable: [{
            type: Input
        }, {
            type: HostBinding,
            args: ["class.bx--data-table--sort"]
        }], noBorder: [{
            type: Input
        }, {
            type: HostBinding,
            args: ["class.bx--data-table--no-border"]
        }], striped: [{
            type: Input
        }, {
            type: HostBinding,
            args: ["class.bx--data-table--zebra"]
        }], skeleton: [{
            type: Input
        }, {
            type: HostBinding,
            args: ["class.bx--skeleton"]
        }], size: [{
            type: Input
        }], tableClass: [{
            type: HostBinding,
            args: ["class.bx--data-table"]
        }], compactClass: [{
            type: HostBinding,
            args: ["class.bx--data-table--compact"]
        }], tallClass: [{
            type: HostBinding,
            args: ["class.bx--data-table--tall"]
        }], shortClass: [{
            type: HostBinding,
            args: ["class.bx--data-table--short"]
        }] }); })();

/**
 * A subcomponent that creates the thead of the table
 *
 * ## Basic usage
 *
 * ```html
 * 	<thead ibmTableHead [model]="model"></thead>
 * ```
 */
class TableHead {
    constructor(i18n) {
        this.i18n = i18n;
        this.showSelectionColumn = true;
        this.enableSingleSelect = false;
        this.selectAllCheckboxSomeSelected = false;
        this.selectAllCheckbox = false;
        this.skeleton = false;
        this.stickyHeader = false;
        /**
         * Setting sortable to false will disable all headers including headers which are sortable. Is is
         * possible to set the sortable state on the header item to disable/enable sorting for only some headers.
         */
        this.sortable = true;
        /**
         * Size of the table rows.
         */
        this.size = "md";
        /**
         * Emits an index of the column that wants to be sorted.
         */
        this.sort = new EventEmitter();
        /**
         * Emits if all rows are selected.
         *
         * @param model
         */
        this.selectAll = new EventEmitter();
        /**
         * Emits if all rows are deselected.
         *
         * @param model
         */
        this.deselectAll = new EventEmitter();
        this.scrollbarWidth = 0;
        this._checkboxHeaderLabel = this.i18n.getOverridable("TABLE.CHECKBOX_HEADER");
        this._sortDescendingLabel = this.i18n.getOverridable("TABLE.SORT_DESCENDING");
        this._sortAscendingLabel = this.i18n.getOverridable("TABLE.SORT_ASCENDING");
        this._filterTitle = this.i18n.getOverridable("TABLE.FILTER");
    }
    set checkboxHeaderLabel(value) {
        this._checkboxHeaderLabel.override(value);
    }
    get checkboxHeaderLabel() {
        return this._checkboxHeaderLabel.value;
    }
    set sortDescendingLabel(value) {
        this._sortDescendingLabel.override(value);
    }
    get sortDescendingLabel() {
        return this._sortDescendingLabel.value;
    }
    set sortAscendingLabel(value) {
        this._sortAscendingLabel.override(value);
    }
    get sortAscendingLabel() {
        return this._sortAscendingLabel.value;
    }
    set filterTitle(value) {
        this._filterTitle.override(value);
    }
    get filterTitle() {
        return this._filterTitle.value;
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.scrollbarWidth = getScrollbarWidth();
        });
    }
    onSelectAllCheckboxChange() {
        if (!this.selectAllCheckbox && !this.selectAllCheckboxSomeSelected) {
            this.selectAll.emit(this.model);
        }
        else {
            this.deselectAll.emit(this.model);
        }
    }
    getCheckboxHeaderLabel() {
        return this._checkboxHeaderLabel.subject;
    }
    getSortDescendingLabel() {
        return this._sortDescendingLabel.subject;
    }
    getSortAscendingLabel() {
        return this._sortAscendingLabel.subject;
    }
    getFilterTitle() {
        return this._filterTitle.subject;
    }
}
TableHead.ɵfac = function TableHead_Factory(t) { return new (t || TableHead)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n)); };
TableHead.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TableHead, selectors: [["", "ibmTableHead", ""]], inputs: { showSelectionColumn: "showSelectionColumn", enableSingleSelect: "enableSingleSelect", selectAllCheckboxSomeSelected: "selectAllCheckboxSomeSelected", selectAllCheckbox: "selectAllCheckbox", skeleton: "skeleton", stickyHeader: "stickyHeader", sortable: "sortable", size: "size", checkboxHeaderLabel: "checkboxHeaderLabel", sortDescendingLabel: "sortDescendingLabel", sortAscendingLabel: "sortAscendingLabel", filterTitle: "filterTitle", model: "model" }, outputs: { sort: "sort", selectAll: "selectAll", deselectAll: "deselectAll" }, attrs: _c10, ngContentSelectors: _c5, decls: 2, vars: 1, consts: [[4, "ngIf"], ["ibmTableHeadExpand", "", "scope", "col", 3, "ngClass", "id", 4, "ngIf"], ["scope", "col", "style", "width: 0;", 3, "id", 4, "ngIf"], ["ibmTableHeadCheckbox", "", "scope", "col", 3, "checked", "indeterminate", "ariaLabel", "size", "skeleton", "name", "id", "change", 4, "ngIf"], [4, "ngFor", "ngForOf"], ["scope", "col", 3, "ngStyle", 4, "ngIf"], ["ibmTableHeadExpand", "", "scope", "col", 3, "ngClass", "id"], ["scope", "col", 2, "width", "0", 3, "id"], ["ibmTableHeadCheckbox", "", "scope", "col", 3, "checked", "indeterminate", "ariaLabel", "size", "skeleton", "name", "id", "change"], ["ibmTableHeadCell", "", "scope", "col", 3, "ngStyle", "class", "sortable", "skeleton", "id", "column", "filterTitle", "sort", 4, "ngIf"], ["ibmTableHeadCell", "", "scope", "col", 3, "ngStyle", "sortable", "skeleton", "id", "column", "filterTitle", "sort"], ["scope", "col", 3, "ngStyle"]], template: function TableHead_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, TableHead_ng_container_0_Template, 7, 5, "ng-container", 0);
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.model);
    } }, directives: function () { return [ɵngcc2.NgIf, ɵngcc2.NgForOf, TableHeadExpand, ɵngcc2.NgClass, TableHeadCheckbox, TableHeadCell, ɵngcc2.NgStyle]; }, styles: [".bx--table-expand-v2[_ngcontent-%COMP%] {\n\t\t\tpadding-left: 2.5rem;\n\t\t}"] });
/** @nocollapse */
TableHead.ctorParameters = () => [
    { type: I18n }
];
TableHead.propDecorators = {
    model: [{ type: Input }],
    showSelectionColumn: [{ type: Input }],
    enableSingleSelect: [{ type: Input }],
    selectAllCheckboxSomeSelected: [{ type: Input }],
    selectAllCheckbox: [{ type: Input }],
    skeleton: [{ type: Input }],
    stickyHeader: [{ type: Input }],
    sortable: [{ type: Input }],
    size: [{ type: Input }],
    checkboxHeaderLabel: [{ type: Input }],
    sortDescendingLabel: [{ type: Input }],
    sortAscendingLabel: [{ type: Input }],
    filterTitle: [{ type: Input }],
    sort: [{ type: Output }],
    selectAll: [{ type: Output }],
    deselectAll: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableHead, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: "[ibmTableHead]",
                template: `
	<ng-container *ngIf="model">
		<tr>
			<th
				ibmTableHeadExpand
				*ngIf="model.hasExpandableRows()"
				scope="col"
				[ngClass]="{'bx--table-expand-v2': stickyHeader}"
				[id]="model.getId('expand')">
			</th>
			<th
				*ngIf="!skeleton && showSelectionColumn && enableSingleSelect"
				scope="col"
				style="width: 0;"
				[id]="model.getId('select')">
				<!-- add width 0; since the carbon styles don't seem to constrain this headers width -->
			</th>
			<th
				ibmTableHeadCheckbox
				*ngIf="!skeleton && showSelectionColumn && !enableSingleSelect"
				scope="col"
				[checked]="selectAllCheckbox"
				[indeterminate]="selectAllCheckboxSomeSelected"
				[ariaLabel]="getCheckboxHeaderLabel()"
				[size]="size"
				[skeleton]="skeleton"
				[name]="model.getHeaderId('select')"
				(change)="onSelectAllCheckboxChange()"
				[id]="model.getId('select')">
			</th>
			<ng-container *ngFor="let column of model.header; let i = index">
				<th
					*ngIf="column && column.visible"
					[ngStyle]="column.style"
					ibmTableHeadCell
					scope="col"
					[class]="column.className"
					[sortable]="sortable"
					[skeleton]="skeleton"
					[id]="model.getId(i)"
					[column]="column"
					[skeleton]="skeleton"
					[filterTitle]="getFilterTitle()"
					[attr.colspan]="column.colSpan"
					[attr.rowspan]="column.rowSpan"
					(sort)="sort.emit(i)">
				</th>
			</ng-container>
			<th *ngIf="!skeleton && stickyHeader && scrollbarWidth"
				scope="col"
				[ngStyle]="{'width': scrollbarWidth + 'px', 'padding': 0, 'border': 0}">
				<!--
					Scrollbar pushes body to the left so this header column is added to push
					the title bar the same amount and keep the header and body columns aligned.
				-->
			</th>
		</tr>
	</ng-container>
	<ng-content></ng-content>
	`,
                styles: [`
		.bx--table-expand-v2 {
			padding-left: 2.5rem;
		}
	`]
            }]
    }], function () { return [{ type: ɵngcc1.I18n }]; }, { showSelectionColumn: [{
            type: Input
        }], enableSingleSelect: [{
            type: Input
        }], selectAllCheckboxSomeSelected: [{
            type: Input
        }], selectAllCheckbox: [{
            type: Input
        }], skeleton: [{
            type: Input
        }], stickyHeader: [{
            type: Input
        }], sortable: [{
            type: Input
        }], size: [{
            type: Input
        }], sort: [{
            type: Output
        }], selectAll: [{
            type: Output
        }], deselectAll: [{
            type: Output
        }], checkboxHeaderLabel: [{
            type: Input
        }], sortDescendingLabel: [{
            type: Input
        }], sortAscendingLabel: [{
            type: Input
        }], filterTitle: [{
            type: Input
        }], model: [{
            type: Input
        }] }); })();

class TableHeadCell {
    constructor(i18n) {
        this.i18n = i18n;
        this.skeleton = false;
        this.sortable = true;
        /**
         * Notifies that the column should be sorted
         */
        this.sort = new EventEmitter();
        this.theadAction = false;
        this._sortDescendingLabel = this.i18n.getOverridable("TABLE.SORT_DESCENDING");
        this._sortAscendingLabel = this.i18n.getOverridable("TABLE.SORT_ASCENDING");
        this._filterTitle = this.i18n.getOverridable("TABLE.FILTER");
    }
    set sortDescendingLabel(value) {
        this._sortDescendingLabel.override(value);
    }
    get sortDescendingLabel() {
        return this._sortDescendingLabel.value;
    }
    set sortAscendingLabel(value) {
        this._sortAscendingLabel.override(value);
    }
    get sortAscendingLabel() {
        return this._sortAscendingLabel.value;
    }
    set filterTitle(value) {
        this._filterTitle.override(value);
    }
    get filterTitle() {
        return this._filterTitle.value;
    }
    ngOnChanges() {
        // Since it's not an input, and it touches the view, we're using `ngOnChanges`
        // `get`ters have caused issues in the past with the view updating outside of change detection
        this.theadAction = !!this.column.filterTemplate || this.sort.observers.length > 0;
    }
    getSortDescendingLabel() {
        return this._sortDescendingLabel.subject.pipe(this.sortLabelMap());
    }
    getSortAscendingLabel() {
        return this._sortAscendingLabel.subject.pipe(this.sortLabelMap());
    }
    getFilterTitle() {
        return this._filterTitle.subject;
    }
    onClick() {
        if (!this.skeleton) {
            this.sort.emit();
        }
    }
    sortLabelMap() {
        return map((str) => {
            if (this.column.ariaSortLabel) {
                return this.column.ariaSortLabel;
            }
            if (this.column.formatSortLabel) {
                return this.column.formatSortLabel(str, this.column.ariaSortLabel);
            }
            return `${this.column.data} - ${str}`;
        });
    }
}
TableHeadCell.ɵfac = function TableHeadCell_Factory(t) { return new (t || TableHeadCell)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n)); };
TableHeadCell.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TableHeadCell, selectors: [["", "ibmTableHeadCell", ""]], hostVars: 2, hostBindings: function TableHeadCell_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("thead_action", ctx.theadAction);
    } }, inputs: { skeleton: "skeleton", sortable: "sortable", sortDescendingLabel: "sortDescendingLabel", sortAscendingLabel: "sortAscendingLabel", filterTitle: "filterTitle", column: "column" }, outputs: { sort: "sort" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c13, decls: 3, vars: 3, consts: [["class", "bx--table-sort", "aria-live", "polite", 3, "ngClass", "click", 4, "ngIf"], ["class", "bx--table-header-label", 4, "ngIf"], ["type", "button", "aria-expanded", "false", "aria-haspopup", "true", "trigger", "click", "placement", "bottom,top", 3, "ngClass", "ibmTooltip", "title", "data", 4, "ngIf"], ["aria-live", "polite", 1, "bx--table-sort", 3, "ngClass", "click"], ["tabindex", "-1", 1, "bx--table-sort__flex", 3, "title"], ["ibmTableHeadCellLabel", "", 4, "ngIf"], [4, "ngIf"], ["focusable", "false", "preserveAspectRatio", "xMidYMid meet", "style", "will-change: transform;", "xmlns", "http://www.w3.org/2000/svg", "class", "bx--table-sort__icon", "width", "16", "height", "16", "viewBox", "0 0 16 16", "aria-hidden", "true", 4, "ngIf"], ["focusable", "false", "preserveAspectRatio", "xMidYMid meet", "style", "will-change: transform;", "xmlns", "http://www.w3.org/2000/svg", "class", "bx--table-sort__icon-unsorted", "width", "16", "height", "16", "viewBox", "0 0 16 16", "aria-hidden", "true", 4, "ngIf"], ["ibmTableHeadCellLabel", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["focusable", "false", "preserveAspectRatio", "xMidYMid meet", "xmlns", "http://www.w3.org/2000/svg", "width", "16", "height", "16", "viewBox", "0 0 16 16", "aria-hidden", "true", 1, "bx--table-sort__icon", 2, "will-change", "transform"], ["d", "M12.3 9.3l-3.8 3.8V1h-1v12.1L3.7 9.3 3 10l5 5 5-5z"], ["focusable", "false", "preserveAspectRatio", "xMidYMid meet", "xmlns", "http://www.w3.org/2000/svg", "width", "16", "height", "16", "viewBox", "0 0 16 16", "aria-hidden", "true", 1, "bx--table-sort__icon-unsorted", 2, "will-change", "transform"], ["d", "M13.8 10.3L12 12.1V2h-1v10.1l-1.8-1.8-.7.7 3 3 3-3zM4.5 2l-3 3 .7.7L4 3.9V14h1V3.9l1.8 1.8.7-.7z"], [1, "bx--table-header-label"], [3, "title", 4, "ngIf"], [3, "title"], ["type", "button", "aria-expanded", "false", "aria-haspopup", "true", "trigger", "click", "placement", "bottom,top", 3, "ngClass", "ibmTooltip", "title", "data"], ["xmlns", "http://www.w3.org/2000/svg", "width", "16", "height", "16", "viewBox", "0 0 16 16", 1, "icon--sm"], ["d", "M0 0v3l6 8v5h4v-5l6-8V0H0zm9 10.7V15H7v-4.3L1.3 3h13.5L9 10.7z"]], template: function TableHeadCell_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TableHeadCell_button_0_Template, 7, 12, "button", 0);
        ɵngcc0.ɵɵtemplate(1, TableHeadCell_div_1_Template, 3, 5, "div", 1);
        ɵngcc0.ɵɵtemplate(2, TableHeadCell_button_2_Template, 5, 9, "button", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.sortable && ctx.sort.observers.length > 0 && ctx.column.sortable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.skeleton && ctx.sort.observers.length === 0 || ctx.sort.observers.length > 0 && !ctx.column.sortable || !ctx.sortable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.column.filterTemplate);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgClass, TableHeadCellLabel, ɵngcc2.NgTemplateOutlet, ɵngcc5.TooltipDirective], pipes: [ɵngcc2.AsyncPipe], encapsulation: 2 });
/** @nocollapse */
TableHeadCell.ctorParameters = () => [
    { type: I18n }
];
TableHeadCell.propDecorators = {
    column: [{ type: Input }],
    skeleton: [{ type: Input }],
    sortable: [{ type: Input }],
    sortDescendingLabel: [{ type: Input }],
    sortAscendingLabel: [{ type: Input }],
    filterTitle: [{ type: Input }],
    sort: [{ type: Output }],
    theadAction: [{ type: HostBinding, args: ["class.thead_action",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableHeadCell, [{
        type: Component,
        args: [{
                // tslint:disable-next-line: component-selector
                selector: "[ibmTableHeadCell]",
                template: `
		<button
			class="bx--table-sort"
			*ngIf="sortable && this.sort.observers.length > 0 && column.sortable"
			[attr.aria-label]="(column.sorted && column.ascending ? getSortDescendingLabel() : getSortAscendingLabel()) | async"
			aria-live="polite"
			[ngClass]="{
				'bx--table-sort--active': column.sorted,
				'bx--table-sort--ascending': column.ascending
			}"
			(click)="onClick()">
			<span
				class="bx--table-sort__flex"
				[title]="column.data"
				tabindex="-1">
				<div *ngIf="!skeleton && !column.template" ibmTableHeadCellLabel>
					{{column.data}}
				</div>
				<ng-template
					*ngIf="!skeleton && column.template"
					[ngTemplateOutlet]="column.template"
					[ngTemplateOutletContext]="{data: column.data}">
				</ng-template>
				<svg
					*ngIf="!skeleton"
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					style="will-change: transform;"
					xmlns="http://www.w3.org/2000/svg"
					class="bx--table-sort__icon"
					width="16"
					height="16"
					viewBox="0 0 16 16"
					aria-hidden="true">
					<path d="M12.3 9.3l-3.8 3.8V1h-1v12.1L3.7 9.3 3 10l5 5 5-5z"></path>
				</svg>
				<svg
					*ngIf="!skeleton"
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					style="will-change: transform;"
					xmlns="http://www.w3.org/2000/svg"
					class="bx--table-sort__icon-unsorted"
					width="16"
					height="16"
					viewBox="0 0 16 16"
					aria-hidden="true">
					<path d="M13.8 10.3L12 12.1V2h-1v10.1l-1.8-1.8-.7.7 3 3 3-3zM4.5 2l-3 3 .7.7L4 3.9V14h1V3.9l1.8 1.8.7-.7z"></path>
				</svg>
			</span>
		</button>
		<div
			class="bx--table-header-label"
			*ngIf="!skeleton && this.sort.observers.length === 0 || (this.sort.observers.length > 0 && !column.sortable) || !sortable">
			<span *ngIf="!column.template" [title]="column.data">{{column.data}}</span>
			<ng-template
				[ngTemplateOutlet]="column.template" [ngTemplateOutletContext]="{data: column.data}">
			</ng-template>
		</div>
		<button
			[ngClass]="{'active': column.filterCount > 0}"
			*ngIf="column.filterTemplate"
			type="button"
			aria-expanded="false"
			aria-haspopup="true"
			[ibmTooltip]="column.filterTemplate"
			trigger="click"
			[title]="getFilterTitle() | async"
			placement="bottom,top"
			[data]="column.filterData">
			<svg
				xmlns="http://www.w3.org/2000/svg"
				class="icon--sm"
				width="16"
				height="16"
				viewBox="0 0 16 16">
				<path d="M0 0v3l6 8v5h4v-5l6-8V0H0zm9 10.7V15H7v-4.3L1.3 3h13.5L9 10.7z"/>
			</svg>
			<span *ngIf="column.filterCount > 0">
				{{column.filterCount}}
			</span>
		</button>
	`
            }]
    }], function () { return [{ type: ɵngcc1.I18n }]; }, { skeleton: [{
            type: Input
        }], sortable: [{
            type: Input
        }], sort: [{
            type: Output
        }], theadAction: [{
            type: HostBinding,
            args: ["class.thead_action"]
        }], sortDescendingLabel: [{
            type: Input
        }], sortAscendingLabel: [{
            type: Input
        }], filterTitle: [{
            type: Input
        }], column: [{
            type: Input
        }] }); })();

class TableHeadCheckbox {
    constructor(i18n) {
        this.i18n = i18n;
        /**
         * Size of the table rows.
         */
        this.size = "md";
        this.checked = false;
        this.indeterminate = false;
        this.skeleton = false;
        this.name = `select-all-${TableHeadCheckbox.tableSelectAllCount++}`;
        this.change = new EventEmitter();
        this.hostClass = true;
        this._ariaLabel = this.i18n.getOverridable("TABLE.CHECKBOX_HEADER");
    }
    set ariaLabel(value) {
        this._ariaLabel.override(value);
    }
    get ariaLabel() {
        return this._ariaLabel.value;
    }
    getAriaLabel() {
        return this._ariaLabel.subject;
    }
}
TableHeadCheckbox.ɵfac = function TableHeadCheckbox_Factory(t) { return new (t || TableHeadCheckbox)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n)); };
TableHeadCheckbox.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TableHeadCheckbox, selectors: [["", "ibmTableHeadCheckbox", ""]], hostVars: 2, hostBindings: function TableHeadCheckbox_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--table-column-checkbox", ctx.hostClass);
    } }, inputs: { size: "size", checked: "checked", indeterminate: "indeterminate", skeleton: "skeleton", name: "name", ariaLabel: "ariaLabel" }, outputs: { change: "change" }, attrs: _c17, decls: 1, vars: 1, consts: [["inline", "true", 3, "size", "name", "checked", "indeterminate", "aria-label", "checkedChange", 4, "ngIf"], ["inline", "true", 3, "size", "name", "checked", "indeterminate", "aria-label", "checkedChange"]], template: function TableHeadCheckbox_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TableHeadCheckbox_ibm_checkbox_0_Template, 2, 7, "ibm-checkbox", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.skeleton);
    } }, directives: [ɵngcc2.NgIf, ɵngcc6.Checkbox], pipes: [ɵngcc2.AsyncPipe], styles: ["[_nghost-%COMP%] { width: 10px; }"] });
TableHeadCheckbox.tableSelectAllCount = 0;
/** @nocollapse */
TableHeadCheckbox.ctorParameters = () => [
    { type: I18n }
];
TableHeadCheckbox.propDecorators = {
    size: [{ type: Input }],
    checked: [{ type: Input }],
    indeterminate: [{ type: Input }],
    skeleton: [{ type: Input }],
    name: [{ type: Input }],
    ariaLabel: [{ type: Input }],
    change: [{ type: Output }],
    hostClass: [{ type: HostBinding, args: ["class.bx--table-column-checkbox",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableHeadCheckbox, [{
        type: Component,
        args: [{
                // tslint:disable-next-line: component-selector
                selector: "[ibmTableHeadCheckbox]",
                template: `
		<ibm-checkbox
			*ngIf="!skeleton"
			inline="true"
			[size]="(size !== 'sm' ? 'md' : 'sm')"
			[name]="name"
			[checked]="checked"
			[indeterminate]="indeterminate"
			(checkedChange)="change.emit()"
			[aria-label]="getAriaLabel() | async">
		</ibm-checkbox>
	`,
                styles: [`
        :host { width: 10px; }
    `]
            }]
    }], function () { return [{ type: ɵngcc1.I18n }]; }, { size: [{
            type: Input
        }], checked: [{
            type: Input
        }], indeterminate: [{
            type: Input
        }], skeleton: [{
            type: Input
        }], name: [{
            type: Input
        }], change: [{
            type: Output
        }], hostClass: [{
            type: HostBinding,
            args: ["class.bx--table-column-checkbox"]
        }], ariaLabel: [{
            type: Input
        }] }); })();

class TableHeadExpand {
    constructor() {
        this.hostClass = true;
    }
}
TableHeadExpand.ɵfac = function TableHeadExpand_Factory(t) { return new (t || TableHeadExpand)(); };
TableHeadExpand.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TableHeadExpand, selectors: [["", "ibmTableHeadExpand", ""]], hostVars: 2, hostBindings: function TableHeadExpand_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--table-expand", ctx.hostClass);
    } }, attrs: _c18, ngContentSelectors: _c5, decls: 1, vars: 0, template: function TableHeadExpand_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
TableHeadExpand.propDecorators = {
    hostClass: [{ type: HostBinding, args: ["class.bx--table-expand",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableHeadExpand, [{
        type: Component,
        args: [{
                // tslint:disable-next-line: component-selector
                selector: "[ibmTableHeadExpand]",
                template: `
		<ng-content></ng-content>
	`
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ["class.bx--table-expand"]
        }] }); })();

class TableBody {
    constructor(i18n) {
        this.i18n = i18n;
        /**
         * Controls whether to enable multiple or single row selection.
         */
        this.enableSingleSelect = false;
        /**
         * Controls whether to show the selection checkboxes column or not.
         */
        this.showSelectionColumn = true;
        /**
         * Size of the table rows.
         */
        this.size = "md";
        this.skeleton = false;
        /**
         * Emits if a single row is selected.
         *
         * @param ({model: this.model, selectedRowIndex: index})
         */
        this.selectRow = new EventEmitter();
        /**
         * Emits if a single row is deselected.
         *
         * @param ({model: this.model, deselectedRowIndex: index})
         */
        this.deselectRow = new EventEmitter();
        /**
         * Emits if a row item excluding expandButtons, checkboxes, or radios is clicked.
         */
        this.rowClick = new EventEmitter();
        this._checkboxRowLabel = this.i18n.getOverridable("TABLE.CHECKBOX_ROW");
        this._expandButtonAriaLabel = this.i18n.getOverridable("TABLE.EXPAND_BUTTON");
    }
    set expandButtonAriaLabel(value) {
        this._expandButtonAriaLabel.override(value);
    }
    get expandButtonAriaLabel() {
        return this._expandButtonAriaLabel.value;
    }
    set checkboxRowLabel(value) {
        this._checkboxRowLabel.override(value);
    }
    get checkboxRowLabel() {
        return this._checkboxRowLabel.value;
    }
    /**
     * Triggered when a single row is clicked.
     * Updates the header checkbox state.
     * Emits the `selectRow` or `deselectRow` event.
     */
    onRowCheckboxChange(index) {
        if (this.model.isRowSelected(index)) {
            this.deselectRow.emit({ model: this.model, deselectedRowIndex: index });
        }
        else {
            this.selectRow.emit({ model: this.model, selectedRowIndex: index });
        }
    }
    onRowClick(index) {
        this.rowClick.emit(index);
    }
    getCheckboxRowLabel() {
        return this._checkboxRowLabel.subject;
    }
    getExpandButtonAriaLabel() {
        return this._expandButtonAriaLabel.subject;
    }
    firstExpandedDataInRow(row) {
        const found = row.find(d => d.expandedData);
        if (found) {
            return found.expandedData;
        }
        return found;
    }
    shouldExpandAsTable(row) {
        return row.some(d => d.expandAsTable);
    }
}
TableBody.ɵfac = function TableBody_Factory(t) { return new (t || TableBody)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n)); };
TableBody.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TableBody, selectors: [["", "ibmTableBody", ""]], inputs: { enableSingleSelect: "enableSingleSelect", showSelectionColumn: "showSelectionColumn", size: "size", skeleton: "skeleton", expandButtonAriaLabel: "expandButtonAriaLabel", checkboxRowLabel: "checkboxRowLabel", model: "model", selectionLabelColumn: "selectionLabelColumn" }, outputs: { selectRow: "selectRow", deselectRow: "deselectRow", rowClick: "rowClick" }, attrs: _c19, ngContentSelectors: _c5, decls: 2, vars: 1, consts: [[4, "ngIf"], [4, "ngFor", "ngForOf"], ["ibmTableRow", "", 3, "model", "row", "size", "selected", "expandable", "expanded", "checkboxLabel", "expandButtonAriaLabel", "showSelectionColumn", "enableSingleSelect", "skeleton", "class", "ngClass", "selectRow", "deselectRow", "expandRow", "rowClick", 4, "ngIf"], ["ibmTableRow", "", 3, "model", "row", "size", "selected", "expandable", "expanded", "checkboxLabel", "expandButtonAriaLabel", "showSelectionColumn", "enableSingleSelect", "skeleton", "ngClass", "selectRow", "deselectRow", "expandRow", "rowClick"], ["ibmTableExpandedRow", "", "ibmExpandedRowHover", "", 3, "row", "expanded", "skeleton", 4, "ngIf", "ngIfElse"], ["expandAsTableTemplate", ""], ["ibmTableExpandedRow", "", "ibmExpandedRowHover", "", 3, "row", "expanded", "skeleton"], ["ibmTableRow", "", 3, "model", "showSelectionColumnCheckbox", "showSelectionColumn", "row", "size", "skeleton", 4, "ngFor", "ngForOf"], ["ibmTableRow", "", 3, "model", "showSelectionColumnCheckbox", "showSelectionColumn", "row", "size", "skeleton"]], template: function TableBody_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, TableBody_ng_container_0_Template, 2, 1, "ng-container", 0);
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.model);
    } }, directives: function () { return [ɵngcc2.NgIf, ɵngcc2.NgForOf, TableRowComponent, ɵngcc2.NgClass, TableExpandedRow, ExpandedRowHover]; }, encapsulation: 2 });
/** @nocollapse */
TableBody.ctorParameters = () => [
    { type: I18n }
];
TableBody.propDecorators = {
    model: [{ type: Input }],
    enableSingleSelect: [{ type: Input }],
    expandButtonAriaLabel: [{ type: Input }],
    checkboxRowLabel: [{ type: Input }],
    showSelectionColumn: [{ type: Input }],
    size: [{ type: Input }],
    selectionLabelColumn: [{ type: Input }],
    skeleton: [{ type: Input }],
    selectRow: [{ type: Output }],
    deselectRow: [{ type: Output }],
    rowClick: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableBody, [{
        type: Component,
        args: [{
                // tslint:disable-next-line: component-selector
                selector: "[ibmTableBody]",
                template: `
		<ng-container *ngIf="model">
			<ng-container *ngFor="let row of model.data; let i = index">
				<tr
					ibmTableRow
					[model]="model"
					[row]="row"
					[size]="size"
					[selected]="model.isRowSelected(i)"
					[expandable]="model.isRowExpandable(i)"
					[expanded]="model.isRowExpanded(i)"
					[checkboxLabel]="getCheckboxRowLabel()"
					[expandButtonAriaLabel]="getExpandButtonAriaLabel()"
					[showSelectionColumn]="showSelectionColumn"
					[enableSingleSelect]="enableSingleSelect"
					[skeleton]="skeleton"
					(selectRow)="onRowCheckboxChange(i)"
					(deselectRow)="onRowCheckboxChange(i)"
					(expandRow)="model.expandRow(i, !model.isRowExpanded(i))"
					(rowClick)="onRowClick(i)"
					*ngIf="!model.isRowFiltered(i)"
					[class]="(model.rowsClass[i] ? model.rowsClass[i] : null)"
					[ngClass]="{
						'tbody_row--success': !model.isRowSelected(i) && model.getRowContext(i) === 'success',
						'tbody_row--warning': !model.isRowSelected(i) && model.getRowContext(i) === 'warning',
						'tbody_row--info': !model.isRowSelected(i) && model.getRowContext(i) === 'info',
						'tbody_row--error': !model.isRowSelected(i) && model.getRowContext(i) === 'error'
					}">
				</tr>
				<ng-container *ngIf="model.isRowExpanded(i) && !model.isRowFiltered(i)">
					<tr
						*ngIf="!shouldExpandAsTable(row); else expandAsTableTemplate"
						ibmTableExpandedRow
						ibmExpandedRowHover
						[row]="row"
						[expanded]="model.isRowExpanded(i)"
						[skeleton]="skeleton">
					</tr>
					<ng-template #expandAsTableTemplate>
						<tr
							*ngFor="let expandedDataRow of firstExpandedDataInRow(row)"
							ibmTableRow
							[model]="model"
							[showSelectionColumnCheckbox]="false"
							[showSelectionColumn]="showSelectionColumn"
							[row]="expandedDataRow"
							[size]="size"
							[skeleton]="skeleton">
						</tr>
					</ng-template>
				</ng-container>
			</ng-container>
		</ng-container>
		<ng-content></ng-content>
	`
            }]
    }], function () { return [{ type: ɵngcc1.I18n }]; }, { enableSingleSelect: [{
            type: Input
        }], showSelectionColumn: [{
            type: Input
        }], size: [{
            type: Input
        }], skeleton: [{
            type: Input
        }], selectRow: [{
            type: Output
        }], deselectRow: [{
            type: Output
        }], rowClick: [{
            type: Output
        }], expandButtonAriaLabel: [{
            type: Input
        }], checkboxRowLabel: [{
            type: Input
        }], model: [{
            type: Input
        }], selectionLabelColumn: [{
            type: Input
        }] }); })();

class TableRowComponent {
    constructor(i18n) {
        this.i18n = i18n;
        this.expanded = false;
        this.expandable = false;
        this.selected = false;
        /**
         * Size of the table rows.
         */
        this.size = "md";
        /**
         * Controls whether to enable multiple or single row selection.
         */
        this.enableSingleSelect = false;
        /**
         * Controls whether to show the selection checkboxes column or not.
         */
        this.showSelectionColumn = true;
        /**
         * Shows or hide the checkbox in the selection column when `showSelectionColumn`
         * is set to true
         */
        this.showSelectionColumnCheckbox = true;
        this.skeleton = false;
        /**
         * Emits when the row is selected.
         */
        this.selectRow = new EventEmitter();
        /**
         * Emits when the row is deselected.
         */
        this.deselectRow = new EventEmitter();
        /**
         * Emits when the row is expanded
         */
        this.expandRow = new EventEmitter();
        /**
         * Emits when a row is clicked regardless of `enableSingleSelect` or `showSelectionColumn`.
         * Should only get emitted when a row item is selected excluding expand buttons,
         * checkboxes, or radios.
         */
        this.rowClick = new EventEmitter();
        this._checkboxLabel = this.i18n.getOverridable("TABLE.CHECKBOX_ROW");
        this._expandButtonAriaLabel = this.i18n.getOverridable("TABLE.EXPAND_BUTTON");
    }
    set expandButtonAriaLabel(value) {
        this._expandButtonAriaLabel.override(value);
    }
    get expandButtonAriaLabel() {
        return this._expandButtonAriaLabel.value;
    }
    set checkboxLabel(value) {
        this._checkboxLabel.override(value);
    }
    get checkboxLabel() {
        return this._checkboxLabel.value;
    }
    get selectedClass() {
        return this.selected;
    }
    get parentRowClass() {
        return this.expandable;
    }
    get expandableRowClass() {
        return this.expanded;
    }
    get selectableClass() {
        return false; // this.singleSelect
    }
    get isParentRow() {
        return this.expandable ? true : null;
    }
    get isAccessible() {
        return this.enableSingleSelect && !this.showSelectionColumn ? 0 : null;
    }
    onHostClick() {
        if (this.enableSingleSelect && !this.showSelectionColumn) {
            this.onSelectionChange();
        }
    }
    onRowClick() {
        this.rowClick.emit();
    }
    onSelectionChange() {
        if (this.selected) {
            this.deselectRow.emit();
        }
        else {
            this.selectRow.emit();
        }
    }
    getCheckboxLabel() {
        return this._checkboxLabel.subject;
    }
    getExpandButtonAriaLabel() {
        return this._expandButtonAriaLabel.subject;
    }
}
TableRowComponent.ɵfac = function TableRowComponent_Factory(t) { return new (t || TableRowComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n)); };
TableRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TableRowComponent, selectors: [["", "ibmTableRow", ""]], hostVars: 10, hostBindings: function TableRowComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function TableRowComponent_click_HostBindingHandler() { return ctx.onHostClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-parent-row", ctx.isParentRow)("tabindex", ctx.isAccessible);
        ɵngcc0.ɵɵclassProp("bx--data-table--selected", ctx.selectedClass)("bx--parent-row", ctx.parentRowClass)("bx--expandable-row", ctx.expandableRowClass)("tbody_row--selectable", ctx.selectableClass);
    } }, inputs: { expanded: "expanded", expandable: "expandable", selected: "selected", size: "size", enableSingleSelect: "enableSingleSelect", showSelectionColumn: "showSelectionColumn", showSelectionColumnCheckbox: "showSelectionColumnCheckbox", skeleton: "skeleton", expandButtonAriaLabel: "expandButtonAriaLabel", checkboxLabel: "checkboxLabel", model: "model", row: "row", selectionLabelColumn: "selectionLabelColumn" }, outputs: { selectRow: "selectRow", deselectRow: "deselectRow", expandRow: "expandRow", rowClick: "rowClick" }, attrs: _c21, ngContentSelectors: _c5, decls: 2, vars: 1, consts: [[4, "ngIf"], ["ibmTableExpandButton", "", "class", "bx--table-expand-v2", 3, "expanded", "expandable", "skeleton", "ariaLabel", "headers", "expandRow", 4, "ngIf"], ["ibmTableRadio", "", 3, "selected", "label", "row", "skeleton", "headers", "change", 4, "ngIf"], [4, "ngFor", "ngForOf"], ["ibmTableExpandButton", "", 1, "bx--table-expand-v2", 3, "expanded", "expandable", "skeleton", "ariaLabel", "headers", "expandRow"], [4, "ngIf", "ngIfElse"], ["tableCheckboxTemplate", ""], ["ibmTableCheckbox", "", 1, "bx--table-column-checkbox", 3, "size", "selected", "label", "row", "skeleton", "headers", "change"], ["ibmTableRadio", "", 3, "selected", "label", "row", "skeleton", "headers", "change"], ["ibmTableData", "", 3, "headers", "item", "title", "class", "ngStyle", "skeleton", "click", "keydown.enter", 4, "ngIf"], ["ibmTableData", "", 3, "headers", "item", "title", "skeleton", "click", "keydown.enter", 4, "ngIf"], ["ibmTableData", "", 3, "headers", "item", "title", "ngStyle", "skeleton", "click", "keydown.enter"], ["ibmTableData", "", 3, "headers", "item", "title", "skeleton", "click", "keydown.enter"]], template: function TableRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, TableRowComponent_ng_container_0_Template, 5, 4, "ng-container", 0);
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.model);
    } }, directives: function () { return [ɵngcc2.NgIf, ɵngcc2.NgForOf, TableExpandButton, TableCheckbox, TableRadio, TableData, ɵngcc2.NgStyle]; }, encapsulation: 2 });
/** @nocollapse */
TableRowComponent.ctorParameters = () => [
    { type: I18n }
];
TableRowComponent.propDecorators = {
    model: [{ type: Input }],
    row: [{ type: Input }],
    expanded: [{ type: Input }],
    expandable: [{ type: Input }],
    selected: [{ type: Input }],
    size: [{ type: Input }],
    enableSingleSelect: [{ type: Input }],
    expandButtonAriaLabel: [{ type: Input }],
    checkboxLabel: [{ type: Input }],
    showSelectionColumn: [{ type: Input }],
    showSelectionColumnCheckbox: [{ type: Input }],
    selectionLabelColumn: [{ type: Input }],
    skeleton: [{ type: Input }],
    selectRow: [{ type: Output }],
    deselectRow: [{ type: Output }],
    expandRow: [{ type: Output }],
    rowClick: [{ type: Output }],
    selectedClass: [{ type: HostBinding, args: ["class.bx--data-table--selected",] }],
    parentRowClass: [{ type: HostBinding, args: ["class.bx--parent-row",] }],
    expandableRowClass: [{ type: HostBinding, args: ["class.bx--expandable-row",] }],
    selectableClass: [{ type: HostBinding, args: ["class.tbody_row--selectable",] }],
    isParentRow: [{ type: HostBinding, args: ["attr.data-parent-row",] }],
    isAccessible: [{ type: HostBinding, args: ["attr.tabindex",] }],
    onHostClick: [{ type: HostListener, args: ["click",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableRowComponent, [{
        type: Component,
        args: [{
                // tslint:disable-next-line: component-selector
                selector: "[ibmTableRow]",
                template: `
		<ng-container *ngIf="model">
			<td
				*ngIf="model.hasExpandableRows()"
				ibmTableExpandButton
				class="bx--table-expand-v2"
				[expanded]="expanded"
				[expandable]="expandable"
				[skeleton]="skeleton"
				[ariaLabel]="getExpandButtonAriaLabel()"
				[headers]="model.getHeaderId('expand')"
				(expandRow)="expandRow.emit()">
			</td>
			<ng-container *ngIf="!skeleton && showSelectionColumn && !enableSingleSelect">
				<td
					*ngIf="!showSelectionColumnCheckbox; else tableCheckboxTemplate">
				</td>
				<ng-template #tableCheckboxTemplate>
					<td
						ibmTableCheckbox
						class="bx--table-column-checkbox"
						[size]="size"
						[selected]="selected"
						[label]="getCheckboxLabel()"
						[row]="row"
						[skeleton]="skeleton"
						[headers]="model.getHeaderId('select')"
						(change)="onSelectionChange()">
					</td>
				</ng-template>
			</ng-container>
			<td
				*ngIf="!skeleton && showSelectionColumn && enableSingleSelect"
				ibmTableRadio
				[selected]="selected"
				[label]="getCheckboxLabel()"
				[row]="row"
				[skeleton]="skeleton"
				[headers]="model.getHeaderId('select')"
				(change)="onSelectionChange()">
			</td>
			<ng-container *ngFor="let item of row; let j = index">
				<td
					*ngIf="item && model.getHeader(j) && model.getHeader(j).visible"
					ibmTableData
					[headers]="model.getHeaderId(j, item.colSpan)"
					[item]="item"
					[title]="item.title"
					[class]="model.getHeader(j).className"
					[ngStyle]="model.getHeader(j).style"
					[skeleton]="skeleton"
					[attr.colspan]="item.colSpan"
					[attr.rowspan]="item.rowSpan"
					(click)="onRowClick()"
					(keydown.enter)="onRowClick()">
				</td>
				<td
					*ngIf="item && model.getHeader(j) == null"
					ibmTableData
					[headers]="model.getHeaderId(j, item.colSpan)"
					[item]="item"
					[title]="item.title"
					[skeleton]="skeleton"
					[attr.colspan]="item.colSpan"
					[attr.rowspan]="item.rowSpan"
					(click)="onRowClick()"
					(keydown.enter)="onRowClick()">
				</td>
			</ng-container>
		</ng-container>
		<ng-content></ng-content>
	`
            }]
    }], function () { return [{ type: ɵngcc1.I18n }]; }, { expanded: [{
            type: Input
        }], expandable: [{
            type: Input
        }], selected: [{
            type: Input
        }], size: [{
            type: Input
        }], enableSingleSelect: [{
            type: Input
        }], showSelectionColumn: [{
            type: Input
        }], showSelectionColumnCheckbox: [{
            type: Input
        }], skeleton: [{
            type: Input
        }], selectRow: [{
            type: Output
        }], deselectRow: [{
            type: Output
        }], expandRow: [{
            type: Output
        }], rowClick: [{
            type: Output
        }], expandButtonAriaLabel: [{
            type: Input
        }], checkboxLabel: [{
            type: Input
        }], selectedClass: [{
            type: HostBinding,
            args: ["class.bx--data-table--selected"]
        }], parentRowClass: [{
            type: HostBinding,
            args: ["class.bx--parent-row"]
        }], expandableRowClass: [{
            type: HostBinding,
            args: ["class.bx--expandable-row"]
        }], selectableClass: [{
            type: HostBinding,
            args: ["class.tbody_row--selectable"]
        }], isParentRow: [{
            type: HostBinding,
            args: ["attr.data-parent-row"]
        }], isAccessible: [{
            type: HostBinding,
            args: ["attr.tabindex"]
        }], onHostClick: [{
            type: HostListener,
            args: ["click"]
        }], model: [{
            type: Input
        }], row: [{
            type: Input
        }], selectionLabelColumn: [{
            type: Input
        }] }); })();

class TableExpandedRow {
    constructor() {
        this.skeleton = false;
        this.expandableRowClass = true;
        this.expanded = false;
    }
    firstExpandedTemplateInRow(row) {
        const found = row.find(d => d.expandedTemplate);
        if (found) {
            return found.expandedTemplate;
        }
        return found;
    }
    firstExpandedDataInRow(row) {
        const found = row.find(d => d.expandedData);
        if (found) {
            return found.expandedData;
        }
        return found;
    }
}
TableExpandedRow.ɵfac = function TableExpandedRow_Factory(t) { return new (t || TableExpandedRow)(); };
TableExpandedRow.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TableExpandedRow, selectors: [["", "ibmTableExpandedRow", ""]], hostVars: 3, hostBindings: function TableExpandedRow_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-child-row", ctx.expanded);
        ɵngcc0.ɵɵclassProp("bx--expandable-row", ctx.expandableRowClass);
    } }, inputs: { skeleton: "skeleton", expanded: "expanded", row: "row" }, attrs: _c22, decls: 3, vars: 6, consts: [[4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function TableExpandedRow_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "td");
        ɵngcc0.ɵɵtemplate(1, TableExpandedRow_ng_container_1_Template, 2, 1, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(2, TableExpandedRow_ng_template_2_Template, 0, 0, "ng-template", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("colspan", ctx.row.length + 2);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.firstExpandedTemplateInRow(ctx.row));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.firstExpandedTemplateInRow(ctx.row))("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(4, _c14, ctx.firstExpandedDataInRow(ctx.row)));
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet], encapsulation: 2 });
TableExpandedRow.propDecorators = {
    row: [{ type: Input }],
    skeleton: [{ type: Input }],
    expandableRowClass: [{ type: HostBinding, args: ["class.bx--expandable-row",] }],
    expanded: [{ type: HostBinding, args: ["attr.data-child-row",] }, { type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableExpandedRow, [{
        type: Component,
        args: [{
                // tslint:disable-next-line: component-selector
                selector: "[ibmTableExpandedRow]",
                template: `
		<td [attr.colspan]="row.length + 2">
			<ng-container *ngIf="!firstExpandedTemplateInRow(row)">
				{{firstExpandedDataInRow(row)}}
			</ng-container>
			<ng-template
				[ngTemplateOutlet]="firstExpandedTemplateInRow(row)"
				[ngTemplateOutletContext]="{data: firstExpandedDataInRow(row)}">
			</ng-template>
		</td>
	`
            }]
    }], function () { return []; }, { skeleton: [{
            type: Input
        }], expandableRowClass: [{
            type: HostBinding,
            args: ["class.bx--expandable-row"]
        }], expanded: [{
            type: HostBinding,
            args: ["attr.data-child-row"]
        }, {
            type: Input
        }], row: [{
            type: Input
        }] }); })();

class TableData {
    constructor() {
        this.skeleton = false;
    }
}
TableData.ɵfac = function TableData_Factory(t) { return new (t || TableData)(); };
TableData.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TableData, selectors: [["", "ibmTableData", ""]], inputs: { skeleton: "skeleton", item: "item" }, attrs: _c23, decls: 2, vars: 2, consts: [[4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function TableData_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TableData_ng_container_0_Template, 2, 1, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, TableData_1_Template, 1, 4, undefined, 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.skeleton && !ctx.item.template);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.skeleton);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet], encapsulation: 2 });
TableData.propDecorators = {
    item: [{ type: Input }],
    skeleton: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableData, [{
        type: Component,
        args: [{
                // tslint:disable-next-line: component-selector
                selector: "[ibmTableData]",
                template: `
		<ng-container *ngIf="!skeleton && !item.template">{{item.data}}</ng-container>
		<ng-template
			*ngIf="!skeleton"
			[ngTemplateOutlet]="item.template"
			[ngTemplateOutletContext]="{data: item.data}">
		</ng-template>
	`
            }]
    }], function () { return []; }, { skeleton: [{
            type: Input
        }], item: [{
            type: Input
        }] }); })();

class TableCheckbox {
    constructor(i18n) {
        this.i18n = i18n;
        this.selected = false;
        this.name = "";
        /**
         * Size of the table rows.
         */
        this.size = "md";
        this.skeleton = false;
        /**
         * Emits if a single row is selected.
         */
        this.change = new EventEmitter();
        this._label = this.i18n.getOverridable("TABLE.CHECKBOX_ROW");
    }
    get disabled() {
        return this.row ? !!this.row.disabled : false;
    }
    set label(value) {
        this._label.override(value);
    }
    get label() {
        return this._label.value;
    }
    getSelectionLabelValue(row) {
        if (!this.selectionLabelColumn) {
            return { value: this.i18n.get().TABLE.ROW };
        }
        return { value: row[this.selectionLabelColumn].data };
    }
    getLabel() {
        return this._label.subject;
    }
}
TableCheckbox.ɵfac = function TableCheckbox_Factory(t) { return new (t || TableCheckbox)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n)); };
TableCheckbox.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TableCheckbox, selectors: [["", "ibmTableCheckbox", ""]], inputs: { selected: "selected", name: "name", size: "size", skeleton: "skeleton", label: "label", row: "row", selectionLabelColumn: "selectionLabelColumn" }, outputs: { change: "change" }, attrs: _c24, decls: 1, vars: 1, consts: [["inline", "true", 3, "name", "aria-label", "size", "checked", "disabled", "change", 4, "ngIf"], ["inline", "true", 3, "name", "aria-label", "size", "checked", "disabled", "change"]], template: function TableCheckbox_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TableCheckbox_ibm_checkbox_0_Template, 3, 10, "ibm-checkbox", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.skeleton);
    } }, directives: [ɵngcc2.NgIf, ɵngcc6.Checkbox], pipes: [ɵngcc2.AsyncPipe, ɵngcc1.ReplacePipe], encapsulation: 2 });
/** @nocollapse */
TableCheckbox.ctorParameters = () => [
    { type: I18n }
];
TableCheckbox.propDecorators = {
    row: [{ type: Input }],
    selected: [{ type: Input }],
    name: [{ type: Input }],
    size: [{ type: Input }],
    label: [{ type: Input }],
    selectionLabelColumn: [{ type: Input }],
    skeleton: [{ type: Input }],
    change: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableCheckbox, [{
        type: Component,
        args: [{
                // tslint:disable-next-line: component-selector
                selector: "[ibmTableCheckbox]",
                template: `
		<ibm-checkbox
			*ngIf="!skeleton"
			inline="true"
			[name]="name"
			[aria-label]="getLabel() | i18nReplace:getSelectionLabelValue(row) | async"
			[size]="(size !== 'sm' ? 'md' : 'sm')"
			[checked]="selected"
			[disabled]="disabled"
			(change)="change.emit()">
		</ibm-checkbox>
	`
            }]
    }], function () { return [{ type: ɵngcc1.I18n }]; }, { selected: [{
            type: Input
        }], name: [{
            type: Input
        }], size: [{
            type: Input
        }], skeleton: [{
            type: Input
        }], change: [{
            type: Output
        }], label: [{
            type: Input
        }], row: [{
            type: Input
        }], selectionLabelColumn: [{
            type: Input
        }] }); })();

class TableRadio {
    constructor(i18n) {
        this.i18n = i18n;
        this.selected = false;
        this.skeleton = false;
        /**
         * Emits if a single row is selected.
         */
        this.change = new EventEmitter();
        this._label = this.i18n.getOverridable("TABLE.CHECKBOX_ROW");
    }
    set label(value) {
        this._label.override(value);
    }
    get label() {
        return this._label.value;
    }
    getSelectionLabelValue(row) {
        if (!this.selectionLabelColumn) {
            return { value: this.i18n.get().TABLE.ROW };
        }
        return { value: row[this.selectionLabelColumn].data };
    }
    getLabel() {
        return this._label.subject;
    }
}
TableRadio.ɵfac = function TableRadio_Factory(t) { return new (t || TableRadio)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n)); };
TableRadio.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TableRadio, selectors: [["", "ibmTableRadio", ""]], inputs: { selected: "selected", skeleton: "skeleton", label: "label", row: "row", selectionLabelColumn: "selectionLabelColumn" }, outputs: { change: "change" }, attrs: _c25, decls: 1, vars: 1, consts: [[3, "ariaLabel", "checked", "change", 4, "ngIf"], [3, "ariaLabel", "checked", "change"]], template: function TableRadio_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TableRadio_ibm_radio_0_Template, 5, 13, "ibm-radio", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.skeleton);
    } }, directives: [ɵngcc2.NgIf, ɵngcc7.Radio], pipes: [ɵngcc2.AsyncPipe, ɵngcc1.ReplacePipe], encapsulation: 2 });
/** @nocollapse */
TableRadio.ctorParameters = () => [
    { type: I18n }
];
TableRadio.propDecorators = {
    row: [{ type: Input }],
    selected: [{ type: Input }],
    label: [{ type: Input }],
    selectionLabelColumn: [{ type: Input }],
    skeleton: [{ type: Input }],
    change: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableRadio, [{
        type: Component,
        args: [{
                // tslint:disable-next-line: component-selector
                selector: "[ibmTableRadio]",
                template: `
		<ibm-radio
			*ngIf="!skeleton"
			[attr.aria-label]="getLabel() | i18nReplace:getSelectionLabelValue(row) | async"
			[ariaLabel]="getLabel() | i18nReplace:getSelectionLabelValue(row) | async"
			[checked]="selected"
			(change)="change.emit()">
		</ibm-radio>
	`
            }]
    }], function () { return [{ type: ɵngcc1.I18n }]; }, { selected: [{
            type: Input
        }], skeleton: [{
            type: Input
        }], change: [{
            type: Output
        }], label: [{
            type: Input
        }], row: [{
            type: Input
        }], selectionLabelColumn: [{
            type: Input
        }] }); })();

class TableExpandButton {
    constructor(i18n) {
        this.i18n = i18n;
        /**
         * Set to true to indicate the row has expanded
         */
        this.expanded = false;
        /**
         * Set to true to indicate the row can be expanded.
         * Defaults to false to allow for correct column alignment
         */
        this.expandable = false;
        this.skeleton = false;
        this.expandClass = true;
        this.expandRow = new EventEmitter();
        this._ariaLabel = this.i18n.getOverridable("TABLE.EXPAND_BUTTON");
    }
    set ariaLabel(value) {
        this._ariaLabel.override(value);
    }
    get ariaLabel() {
        return this._ariaLabel.value;
    }
    get previousValue() {
        return this.expanded ? "collapsed" : null;
    }
    getAriaLabel() {
        return this._ariaLabel.subject;
    }
}
TableExpandButton.ɵfac = function TableExpandButton_Factory(t) { return new (t || TableExpandButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n)); };
TableExpandButton.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TableExpandButton, selectors: [["", "ibmTableExpandButton", ""]], hostVars: 3, hostBindings: function TableExpandButton_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-previous-value", ctx.previousValue);
        ɵngcc0.ɵɵclassProp("bx--table-expand", ctx.expandClass);
    } }, inputs: { expanded: "expanded", expandable: "expandable", skeleton: "skeleton", ariaLabel: "ariaLabel" }, outputs: { expandRow: "expandRow" }, attrs: _c26, decls: 1, vars: 1, consts: [["class", "bx--table-expand__button", 3, "click", 4, "ngIf"], [1, "bx--table-expand__button", 3, "click"], ["ibmIcon", "chevron--right", "size", "16", 1, "bx--table-expand__svg"]], template: function TableExpandButton_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TableExpandButton_button_0_Template, 3, 3, "button", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.expandable);
    } }, directives: [ɵngcc2.NgIf, ɵngcc4.IconDirective], pipes: [ɵngcc2.AsyncPipe], encapsulation: 2 });
/** @nocollapse */
TableExpandButton.ctorParameters = () => [
    { type: I18n }
];
TableExpandButton.propDecorators = {
    expanded: [{ type: Input }],
    expandable: [{ type: Input }],
    ariaLabel: [{ type: Input }],
    skeleton: [{ type: Input }],
    expandClass: [{ type: HostBinding, args: ["class.bx--table-expand",] }],
    previousValue: [{ type: HostBinding, args: ["attr.data-previous-value",] }],
    expandRow: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableExpandButton, [{
        type: Component,
        args: [{
                // tslint:disable-next-line: component-selector
                selector: "[ibmTableExpandButton]",
                template: `
		<button
			*ngIf="expandable"
			class="bx--table-expand__button"
			[attr.aria-label]="getAriaLabel() | async"
			(click)="expandRow.emit()">
			<svg ibmIcon="chevron--right" size="16" class="bx--table-expand__svg"></svg>
		</button>
	`
            }]
    }], function () { return [{ type: ɵngcc1.I18n }]; }, { expanded: [{
            type: Input
        }], expandable: [{
            type: Input
        }], skeleton: [{
            type: Input
        }], expandClass: [{
            type: HostBinding,
            args: ["class.bx--table-expand"]
        }], expandRow: [{
            type: Output
        }], ariaLabel: [{
            type: Input
        }], previousValue: [{
            type: HostBinding,
            args: ["attr.data-previous-value"]
        }] }); })();

/**
 * Represents a table row, which is essentially an array of TableItem.
 */
class TableRow extends Array {
    constructor() {
        super(...arguments);
        /**
         * Whether row is disabled or not.
         */
        this.disabled = false;
    }
}

// modules
class TableModule {
}
TableModule.ɵfac = function TableModule_Factory(t) { return new (t || TableModule)(); };
TableModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TableModule });
TableModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            NFormsModule,
            FormsModule,
            DialogModule,
            ButtonModule,
            SearchModule,
            I18nModule,
            IconModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TableModule, { declarations: function () { return [TableToolbar, TableContainer, TableHeader, TableHeaderTitle, TableHeaderDescription, TableHeadCellLabel, TableToolbarActions, TableToolbarSearch, TableToolbarContent, ExpandedRowHover, Table, TableDirective, TableHead, TableHeadCell, TableHeadCheckbox, TableHeadExpand, TableBody, TableRowComponent, TableExpandedRow, TableData, TableCheckbox, TableRadio, TableExpandButton]; }, imports: function () { return [CommonModule,
        NFormsModule,
        FormsModule,
        DialogModule,
        ButtonModule,
        SearchModule,
        I18nModule,
        IconModule]; }, exports: function () { return [TableToolbar, TableContainer, TableHeader, TableHeaderTitle, TableHeaderDescription, TableHeadCellLabel, TableToolbarActions, TableToolbarSearch, TableToolbarContent, ExpandedRowHover, Table, TableDirective, TableHead, TableHeadCell, TableHeadCheckbox, TableHeadExpand, TableBody, TableRowComponent, TableExpandedRow, TableData, TableCheckbox, TableRadio, TableExpandButton]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    // toolbar and utility components
                    TableToolbar,
                    TableContainer,
                    TableHeader,
                    TableHeaderTitle,
                    TableHeaderDescription,
                    TableHeadCellLabel,
                    TableToolbarActions,
                    TableToolbarSearch,
                    TableToolbarContent,
                    ExpandedRowHover,
                    // core table components
                    Table,
                    TableDirective,
                    TableHead,
                    TableHeadCell,
                    TableHeadCheckbox,
                    TableHeadExpand,
                    TableBody,
                    TableRowComponent,
                    TableExpandedRow,
                    TableData,
                    TableCheckbox,
                    TableRadio,
                    TableExpandButton
                ],
                exports: [
                    // toolbar and utility components
                    TableToolbar,
                    TableContainer,
                    TableHeader,
                    TableHeaderTitle,
                    TableHeaderDescription,
                    TableHeadCellLabel,
                    TableToolbarActions,
                    TableToolbarSearch,
                    TableToolbarContent,
                    ExpandedRowHover,
                    // core table components
                    Table,
                    TableDirective,
                    TableHead,
                    TableHeadCell,
                    TableHeadCheckbox,
                    TableHeadExpand,
                    TableBody,
                    TableRowComponent,
                    TableExpandedRow,
                    TableData,
                    TableCheckbox,
                    TableRadio,
                    TableExpandButton
                ],
                imports: [
                    CommonModule,
                    NFormsModule,
                    FormsModule,
                    DialogModule,
                    ButtonModule,
                    SearchModule,
                    I18nModule,
                    IconModule
                ]
            }]
    }], null, null); })();

// table utilities/toolbar imports

/**
 * Generated bundle index. Do not edit.
 */

export { TableToolbar, TableToolbarActions, TableToolbarSearch, TableToolbarContent, TableContainer, TableHeader, TableHeaderTitle, TableHeadCellLabel, TableHeaderDescription, ExpandedRowHover, Table, TableDirective, TableHead, TableHeadCell, TableHeadCheckbox, TableHeadExpand, TableBody, TableRowComponent, TableExpandedRow, TableData, TableCheckbox, TableRadio, TableExpandButton, TableModel, TableItem, TableHeaderItem, TableCellAdapter, TableRowAdapter, TableAdapter, TableDomAdapter, DataGridInteractionModel, TableModule, TableRow };

//# sourceMappingURL=carbon-components-angular-table.js.map