/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-placeholder.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Injectable, Component, ViewContainerRef, ViewChild, Input, NgModule, SkipSelf, Optional } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * Singleton service used to register the container for out-of-flow components to insert into.
 * Also used to insert/remove components from that view.
 */
import * as ɵngcc0 from '@angular/core';

const _c0 = ["placeholder"];
class PlaceholderService {
    constructor() {
        /**
         * Main `ViewContainerRef` to insert components into
         */
        this.viewContainerRef = null;
        /**
         * Map of id's to secondary `ViewContainerRef`s
         */
        this.viewContainerMap = new Map();
    }
    /**
     * Used by `Placeholder` to register view-container reference.
     */
    registerViewContainerRef(vcRef, id) {
        if (id) {
            this.viewContainerMap.set(id, vcRef);
        }
        else {
            this.viewContainerRef = vcRef;
        }
    }
    /**
     * Creates and returns component in the view.
     */
    createComponent(componentFactory, injector, id) {
        if (id) {
            if (!this.viewContainerMap.has(id)) {
                console.error(`No view container with id ${id} found`);
                return;
            }
            return this.viewContainerMap.get(id).createComponent(componentFactory, null, injector);
        }
        if (!this.viewContainerRef) {
            console.error("No view container defined! Likely due to a missing `ibm-placeholder`");
            return;
        }
        return this.viewContainerRef.createComponent(componentFactory, null, injector);
    }
    destroyComponent(component) {
        component.destroy();
    }
    hasComponentRef(component, id) {
        if (id) {
            return !(this.viewContainerMap.get(id).indexOf(component.hostView) < 0);
        }
        return !(this.viewContainerRef.indexOf(component.hostView) < 0);
    }
    hasPlaceholderRef(id) {
        if (id) {
            return this.viewContainerMap.has(id);
        }
        return !!this.viewContainerRef;
    }
    appendElement(element, id) {
        if (id) {
            return this.viewContainerMap.get(id).element.nativeElement.appendChild(element);
        }
        return this.viewContainerRef.element.nativeElement.appendChild(element);
    }
    removeElement(element, id) {
        if (id) {
            return this.viewContainerMap.get(id).element.nativeElement.removeChild(element);
        }
        return this.viewContainerRef.element.nativeElement.removeChild(element);
    }
    hasElement(element, id) {
        if (id) {
            return this.viewContainerMap.get(id).element.nativeElement.contains(element);
        }
        return this.viewContainerRef.element.nativeElement.contains(element);
    }
}
PlaceholderService.ɵfac = function PlaceholderService_Factory(t) { return new (t || PlaceholderService)(); };
PlaceholderService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PlaceholderService, factory: PlaceholderService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PlaceholderService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * Using a modal, dialog (Tooltip, OverflowMenu), or any other component that draws out of the normal page flow
 * in your application *requires* this component (`ibm-placeholder`).
 * It would generally be placed near the end of your root app component template
 * (app.component.ts or app.component.html) as:
 *
 * ```
 * <ibm-placeholder></ibm-placeholder>
 * ```
 */
class Placeholder {
    /**
     * Creates an instance of `Placeholder`.
     */
    constructor(placeholderService) {
        this.placeholderService = placeholderService;
    }
    /**
     * Registers the components view with `PlaceholderService`
     */
    ngOnInit() {
        // TODO use `id` to register with the placeholderService
        this.placeholderService.registerViewContainerRef(this.viewContainerRef);
    }
}
Placeholder.ɵfac = function Placeholder_Factory(t) { return new (t || Placeholder)(ɵngcc0.ɵɵdirectiveInject(PlaceholderService)); };
Placeholder.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: Placeholder, selectors: [["ibm-placeholder"]], viewQuery: function Placeholder_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 3, ViewContainerRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewContainerRef = _t.first);
    } }, inputs: { id: "id" }, decls: 2, vars: 0, consts: [["placeholder", ""]], template: function Placeholder_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", null, 0);
    } }, encapsulation: 2 });
/** @nocollapse */
Placeholder.ctorParameters = () => [
    { type: PlaceholderService }
];
Placeholder.propDecorators = {
    id: [{ type: Input }],
    viewContainerRef: [{ type: ViewChild, args: ["placeholder", { read: ViewContainerRef, static: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Placeholder, [{
        type: Component,
        args: [{
                selector: "ibm-placeholder",
                template: `<div #placeholder></div>`
            }]
    }], function () { return [{ type: PlaceholderService }]; }, { id: [{
            type: Input
        }], viewContainerRef: [{
            type: ViewChild,
            args: ["placeholder", { read: ViewContainerRef, static: true }]
        }] }); })();

// modules
// either provides a new instance of PlaceholderService, or returns the parent
function PLACEHOLDER_SERVICE_PROVIDER_FACTORY(parentService) {
    return parentService || new PlaceholderService();
}
// placeholder service *must* be a singleton to ensure the placeholder viewRef is accessible globally
const PLACEHOLDER_SERVICE_PROVIDER = {
    provide: PlaceholderService,
    deps: [[new Optional(), new SkipSelf(), PlaceholderService]],
    useFactory: PLACEHOLDER_SERVICE_PROVIDER_FACTORY
};
class PlaceholderModule {
}
PlaceholderModule.ɵfac = function PlaceholderModule_Factory(t) { return new (t || PlaceholderModule)(); };
PlaceholderModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PlaceholderModule });
PlaceholderModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [PLACEHOLDER_SERVICE_PROVIDER], imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PlaceholderModule, { declarations: function () { return [Placeholder]; }, imports: function () { return [CommonModule]; }, exports: function () { return [Placeholder]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PlaceholderModule, [{
        type: NgModule,
        args: [{
                declarations: [Placeholder],
                exports: [Placeholder],
                providers: [PLACEHOLDER_SERVICE_PROVIDER],
                imports: [CommonModule]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { Placeholder, PLACEHOLDER_SERVICE_PROVIDER_FACTORY, PLACEHOLDER_SERVICE_PROVIDER, PlaceholderModule, PlaceholderService };

//# sourceMappingURL=carbon-components-angular-placeholder.js.map