/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-toggle.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Checkbox } from 'carbon-components-angular/checkbox';
import { ChangeDetectorRef, Component, Input, Output, EventEmitter, TemplateRef, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { I18n, I18nModule } from 'carbon-components-angular/i18n';

/**
 * Defines the set of states for a toggle component.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from 'carbon-components-angular/i18n';
import * as ɵngcc2 from '@angular/common';

function Toggle_label_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.label);
} }
function Toggle_label_0_2_ng_template_0_Template(rf, ctx) { }
function Toggle_label_0_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, Toggle_label_0_2_ng_template_0_Template, 0, 0, "ng-template", 8);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r2.label);
} }
function Toggle_label_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 6);
    ɵngcc0.ɵɵtemplate(1, Toggle_label_0_ng_container_1_Template, 2, 1, "ng-container", 7);
    ɵngcc0.ɵɵtemplate(2, Toggle_label_0_2_Template, 1, 1, undefined, 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r0.ariaLabelledby);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.label));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.label));
} }
const _c0 = function (a0, a1) { return { "bx--toggle-input--small": a0, "bx--skeleton": a1 }; };
const _c1 = function (a0) { return { "bx--skeleton": a0 }; };
var ToggleState;
(function (ToggleState) {
    ToggleState[ToggleState["Init"] = 0] = "Init";
    ToggleState[ToggleState["Indeterminate"] = 1] = "Indeterminate";
    ToggleState[ToggleState["Checked"] = 2] = "Checked";
    ToggleState[ToggleState["Unchecked"] = 3] = "Unchecked";
})(ToggleState || (ToggleState = {}));
/**
 * Used to emit changes performed on toggle components.
 *
 * @deprecated since v4
 */
class ToggleChange {
}
/**
 * [See demo](../../?path=/story/toggle--basic)
 *
 * ```html
 * <ibm-toggle [(ngModel)]="toggleState">Toggle</ibm-toggle>
 * ```
 *
 * <example-url>../../iframe.html?id=toggle--basic</example-url>
 */
class Toggle extends Checkbox {
    /**
     * Creates an instance of Toggle.
     */
    constructor(changeDetectorRef, i18n) {
        super(changeDetectorRef);
        this.changeDetectorRef = changeDetectorRef;
        this.i18n = i18n;
        /**
         * Size of the toggle component.
         */
        this.size = "md";
        /**
         * Set to `true` for a loading toggle.
         */
        this.skeleton = false;
        /**
         * The unique id allocated to the `Toggle`.
         */
        this.id = "toggle-" + Toggle.toggleCount;
        /**
         * Emits event notifying other classes when a change in state occurs on a toggle after a
         * click.
         *
         * @deprecated since v4
         */
        this.change = new EventEmitter();
        this._offValues = this.i18n.getOverridable("TOGGLE.OFF");
        this._onValues = this.i18n.getOverridable("TOGGLE.ON");
        Toggle.toggleCount++;
    }
    /**
     * Text that is set on the left side of the toggle.
     */
    set offText(value) {
        this._offValues.override(value);
    }
    get offText() {
        return this._offValues.value;
    }
    /**
     * Text that is set on the right side of the toggle.
     */
    set onText(value) {
        this._onValues.override(value);
    }
    get onText() {
        return this._onValues.value;
    }
    getOffText() {
        return this._offValues.subject;
    }
    getOnText() {
        return this._onValues.subject;
    }
    /**
     * Creates instance of `ToggleChange` used to propagate the change event.
     */
    emitChangeEvent() {
        /* begin deprecation */
        let event = new ToggleChange();
        event.source = this;
        event.checked = this.checked;
        this.change.emit(event);
        /* end deprecation */
        this.checkedChange.emit(this.checked);
        this.propagateChange(this.checked);
    }
    isTemplate(value) {
        return value instanceof TemplateRef;
    }
}
Toggle.ɵfac = function Toggle_Factory(t) { return new (t || Toggle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n)); };
Toggle.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: Toggle, selectors: [["ibm-toggle"]], inputs: { size: "size", skeleton: "skeleton", offText: "offText", onText: "onText", label: "label" }, outputs: { change: "change" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: Toggle,
                multi: true
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 10, vars: 23, consts: [["class", "bx--label", 3, "id", 4, "ngIf"], ["type", "checkbox", 1, "bx--toggle-input", 3, "ngClass", "id", "value", "name", "required", "checked", "disabled", "change", "click"], [1, "bx--toggle-input__label", 3, "for", "ngClass"], [1, "bx--toggle__switch"], [1, "bx--toggle__text--off"], [1, "bx--toggle__text--on"], [1, "bx--label", 3, "id"], [4, "ngIf"], [3, "ngTemplateOutlet"]], template: function Toggle_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, Toggle_label_0_Template, 3, 3, "label", 0);
        ɵngcc0.ɵɵelementStart(1, "input", 1);
        ɵngcc0.ɵɵlistener("change", function Toggle_Template_input_change_1_listener($event) { return ctx.onChange($event); })("click", function Toggle_Template_input_click_1_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "label", 2);
        ɵngcc0.ɵɵelementStart(3, "span", 3);
        ɵngcc0.ɵɵelementStart(4, "span", 4);
        ɵngcc0.ɵɵtext(5);
        ɵngcc0.ɵɵpipe(6, "async");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(7, "span", 5);
        ɵngcc0.ɵɵtext(8);
        ɵngcc0.ɵɵpipe(9, "async");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.label);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(18, _c0, ctx.size === "sm", ctx.skeleton))("id", ctx.id)("value", ctx.value)("name", ctx.name)("required", ctx.required)("checked", ctx.checked)("disabled", ctx.disabled);
        ɵngcc0.ɵɵattribute("aria-labelledby", ctx.ariaLabelledby)("aria-checked", ctx.checked);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("for", ctx.id)("ngClass", ɵngcc0.ɵɵpureFunction1(21, _c1, ctx.skeleton));
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind1(6, 14, !ctx.skeleton ? ctx.getOffText() : null));
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind1(9, 16, !ctx.skeleton ? ctx.getOnText() : null));
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgClass, ɵngcc2.NgTemplateOutlet], pipes: [ɵngcc2.AsyncPipe], encapsulation: 2 });
/**
 * Variable used for creating unique ids for toggle components.
 */
Toggle.toggleCount = 0;
/** @nocollapse */
Toggle.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: I18n }
];
Toggle.propDecorators = {
    offText: [{ type: Input }],
    onText: [{ type: Input }],
    label: [{ type: Input }],
    size: [{ type: Input }],
    skeleton: [{ type: Input }],
    change: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Toggle, [{
        type: Component,
        args: [{
                selector: "ibm-toggle",
                template: `
		<label *ngIf="label" [id]="ariaLabelledby" class="bx--label">
			<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
			<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
		</label>
		<input
			class="bx--toggle-input"
			type="checkbox"
			[ngClass]="{
				'bx--toggle-input--small': size === 'sm',
				'bx--skeleton': skeleton
			}"
			[id]="id"
			[value]="value"
			[name]="name"
			[required]="required"
			[checked]="checked"
			[disabled]="disabled"
			[attr.aria-labelledby]="ariaLabelledby"
			[attr.aria-checked]="checked"
			(change)="onChange($event)"
			(click)="onClick($event)">
		<label
			class="bx--toggle-input__label"
			[for]="id"
			[ngClass]="{
				'bx--skeleton': skeleton
			}">
			<span class="bx--toggle__switch">
				<span class="bx--toggle__text--off">{{(!skeleton ? getOffText() : null) | async }}</span>
				<span class="bx--toggle__text--on">{{(!skeleton ? getOnText() : null) | async}}</span>
			</span>
		</label>
	`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: Toggle,
                        multi: true
                    }
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc1.I18n }]; }, { size: [{
            type: Input
        }], skeleton: [{
            type: Input
        }], change: [{
            type: Output
        }], offText: [{
            type: Input
        }], onText: [{
            type: Input
        }], label: [{
            type: Input
        }] }); })();

// modules
class ToggleModule {
}
ToggleModule.ɵfac = function ToggleModule_Factory(t) { return new (t || ToggleModule)(); };
ToggleModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ToggleModule });
ToggleModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            FormsModule,
            I18nModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ToggleModule, { declarations: function () { return [Toggle]; }, imports: function () { return [CommonModule,
        FormsModule,
        I18nModule]; }, exports: function () { return [Toggle]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ToggleModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    Toggle
                ],
                exports: [
                    Toggle
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    I18nModule
                ]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { ToggleState, ToggleChange, Toggle, ToggleModule };

//# sourceMappingURL=carbon-components-angular-toggle.js.map