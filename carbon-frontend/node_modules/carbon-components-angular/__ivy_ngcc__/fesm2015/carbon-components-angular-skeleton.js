/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-skeleton.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Component, Input, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

function SkeletonText_p_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "p", 1);
} if (rf & 2) {
    const width_r1 = ctx.$implicit;
    ɵngcc0.ɵɵstyleProp("width", width_r1);
} }
class SkeletonPlaceholder {
}
SkeletonPlaceholder.ɵfac = function SkeletonPlaceholder_Factory(t) { return new (t || SkeletonPlaceholder)(); };
SkeletonPlaceholder.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SkeletonPlaceholder, selectors: [["ibm-skeleton-placeholder"]], decls: 1, vars: 0, consts: [[1, "bx--skeleton__placeholder"]], template: function SkeletonPlaceholder_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0);
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SkeletonPlaceholder, [{
        type: Component,
        args: [{
                selector: "ibm-skeleton-placeholder",
                template: `
		<div class="bx--skeleton__placeholder"></div>`
            }]
    }], null, null); })();

class SkeletonText {
    constructor() {
        this.lines = 5;
        this.minLineWidth = 100;
        this.maxLineWidth = 300;
    }
    /**
     * Returns a random width in pixels based off a min width, and a max width.
     */
    getRandomInt(min, max) {
        return `${Math.floor(Math.random() * (max - min + 1) + min) + "px"}`;
    }
    ngOnChanges() {
        // Creates an array of length defined by input lines with content from
        // 0 to lines - 1, maps each value to a random width in pixels.
        this.lineWidths =
            Array.from(Array(this.lines).keys())
                .map(num => this.getRandomInt(this.minLineWidth, this.maxLineWidth));
    }
}
SkeletonText.ɵfac = function SkeletonText_Factory(t) { return new (t || SkeletonText)(); };
SkeletonText.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SkeletonText, selectors: [["ibm-skeleton-text"]], inputs: { lines: "lines", minLineWidth: "minLineWidth", maxLineWidth: "maxLineWidth" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 1, consts: [["class", "bx--skeleton__text", 3, "width", 4, "ngFor", "ngForOf"], [1, "bx--skeleton__text"]], template: function SkeletonText_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, SkeletonText_p_0_Template, 1, 2, "p", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.lineWidths);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2 });
SkeletonText.propDecorators = {
    lines: [{ type: Input }],
    minLineWidth: [{ type: Input }],
    maxLineWidth: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SkeletonText, [{
        type: Component,
        args: [{
                selector: "ibm-skeleton-text",
                template: `
		<p
			*ngFor="let width of lineWidths"
			class="bx--skeleton__text"
			[style.width]="width">
		</p>
	`
            }]
    }], function () { return []; }, { lines: [{
            type: Input
        }], minLineWidth: [{
            type: Input
        }], maxLineWidth: [{
            type: Input
        }] }); })();

class SkeletonModule {
}
SkeletonModule.ɵfac = function SkeletonModule_Factory(t) { return new (t || SkeletonModule)(); };
SkeletonModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SkeletonModule });
SkeletonModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SkeletonModule, { declarations: function () { return [SkeletonPlaceholder, SkeletonText]; }, imports: function () { return [CommonModule]; }, exports: function () { return [SkeletonPlaceholder, SkeletonText]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SkeletonModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    SkeletonPlaceholder,
                    SkeletonText
                ],
                exports: [
                    SkeletonPlaceholder,
                    SkeletonText
                ],
                imports: [
                    CommonModule
                ]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { SkeletonPlaceholder, SkeletonText, SkeletonModule };

//# sourceMappingURL=carbon-components-angular-skeleton.js.map