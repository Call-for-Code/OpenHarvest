/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-inline-loading.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Component, Input, Output, EventEmitter, HostBinding, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { IconModule } from 'carbon-components-angular/icon';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from 'carbon-components-angular/icon';

const _c0 = function (a0) { return { "bx--loading--stop": a0 }; };
function InlineLoading_div_0_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(1, "svg", 7);
    ɵngcc0.ɵɵelement(2, "circle", 8);
    ɵngcc0.ɵɵelement(3, "circle", 9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(1, _c0, ctx_r4.state === ctx_r4.InlineLoadingState.Inactive));
} }
function InlineLoading_div_0__svg_svg_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 10);
} }
function InlineLoading_div_0__svg_svg_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 11);
} }
function InlineLoading_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵtemplate(1, InlineLoading_div_0_div_1_Template, 4, 3, "div", 3);
    ɵngcc0.ɵɵtemplate(2, InlineLoading_div_0__svg_svg_2_Template, 1, 0, "svg", 4);
    ɵngcc0.ɵɵtemplate(3, InlineLoading_div_0__svg_svg_3_Template, 1, 0, "svg", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.state === ctx_r0.InlineLoadingState.Inactive || ctx_r0.state === ctx_r0.InlineLoadingState.Active);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.state === ctx_r0.InlineLoadingState.Finished);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.state === ctx_r0.InlineLoadingState.Error);
} }
function InlineLoading_p_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "p", 12);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.loadingText);
} }
function InlineLoading_p_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "p", 12);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.successText);
} }
function InlineLoading_p_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "p", 12);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.errorText);
} }
var InlineLoadingState;
(function (InlineLoadingState) {
    /** It hides the whole component. */
    InlineLoadingState["Hidden"] = "hidden";
    /** It shows the `loadingText` but no loading animation. */
    InlineLoadingState["Inactive"] = "inactive";
    /** It shows the `loadingText` with loading animation. */
    InlineLoadingState["Active"] = "active";
    /** It shows the `successText` with a success state. */
    InlineLoadingState["Finished"] = "finished";
    /** It shows the `errorText` with an error state. */
    InlineLoadingState["Error"] = "error";
})(InlineLoadingState || (InlineLoadingState = {}));
/**
 * [See demo](../../?path=/story/inline-loading--basic)
 *
 * <example-url>../../iframe.html?id=inline-loading--basic</example-url>
 */
class InlineLoading {
    constructor() {
        this.InlineLoadingState = InlineLoadingState;
        /**
         * Specify the text description for the loading state.
         */
        this.state = InlineLoadingState.Active;
        /**
         * Provide a delay for the `setTimeout` for success.
         */
        this.successDelay = 1500;
        /**
         * Emits event after the success state is active
         */
        this.onSuccess = new EventEmitter();
        this.loadingClass = true;
    }
    /**
     * set to `false` to stop the loading animation
     */
    get isActive() {
        return this.state === InlineLoadingState.Active;
    }
    set isActive(active) {
        this.state = active ? InlineLoadingState.Active : InlineLoadingState.Inactive;
    }
    /**
     * Returns value `true` if the component is in the success state.
     */
    get success() {
        return this.state === InlineLoadingState.Finished;
    }
    /**
     * Set the component's state to match the parameter and emits onSuccess if it exits.
     */
    set success(success) {
        this.state = success ? InlineLoadingState.Finished : InlineLoadingState.Error;
        if (this.state === InlineLoadingState.Finished) {
            setTimeout(() => {
                this.onSuccess.emit();
            }, this.successDelay);
        }
    }
}
InlineLoading.ɵfac = function InlineLoading_Factory(t) { return new (t || InlineLoading)(); };
InlineLoading.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: InlineLoading, selectors: [["ibm-inline-loading"]], hostVars: 2, hostBindings: function InlineLoading_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--inline-loading", ctx.loadingClass);
    } }, inputs: { state: "state", successDelay: "successDelay", isActive: "isActive", success: "success", loadingText: "loadingText", successText: "successText", errorText: "errorText" }, outputs: { onSuccess: "onSuccess" }, decls: 4, vars: 4, consts: [["class", "bx--inline-loading__animation", 4, "ngIf"], ["class", "bx--inline-loading__text", 4, "ngIf"], [1, "bx--inline-loading__animation"], ["class", "bx--loading bx--loading--small", 3, "ngClass", 4, "ngIf"], ["ibmIcon", "checkmark--filled", "size", "16", "class", "bx--inline-loading__checkmark-container", 4, "ngIf"], ["ibmIcon", "error--filled", "size", "16", "class", "bx--inline-loading--error", 4, "ngIf"], [1, "bx--loading", "bx--loading--small", 3, "ngClass"], ["viewBox", "-75 -75 150 150", 1, "bx--loading__svg"], ["cx", "0", "cy", "0", "r", "30", 1, "bx--loading__background"], ["cx", "0", "cy", "0", "r", "30", 1, "bx--loading__stroke"], ["ibmIcon", "checkmark--filled", "size", "16", 1, "bx--inline-loading__checkmark-container"], ["ibmIcon", "error--filled", "size", "16", 1, "bx--inline-loading--error"], [1, "bx--inline-loading__text"]], template: function InlineLoading_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, InlineLoading_div_0_Template, 4, 3, "div", 0);
        ɵngcc0.ɵɵtemplate(1, InlineLoading_p_1_Template, 2, 1, "p", 1);
        ɵngcc0.ɵɵtemplate(2, InlineLoading_p_2_Template, 2, 1, "p", 1);
        ɵngcc0.ɵɵtemplate(3, InlineLoading_p_3_Template, 2, 1, "p", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.state !== ctx.InlineLoadingState.Hidden);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.state === ctx.InlineLoadingState.Inactive || ctx.state === ctx.InlineLoadingState.Active);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.state === ctx.InlineLoadingState.Finished);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.state === ctx.InlineLoadingState.Error);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass, ɵngcc2.IconDirective], encapsulation: 2 });
InlineLoading.propDecorators = {
    state: [{ type: Input }],
    loadingText: [{ type: Input }],
    successText: [{ type: Input }],
    successDelay: [{ type: Input }],
    errorText: [{ type: Input }],
    isActive: [{ type: Input }],
    success: [{ type: Input }],
    onSuccess: [{ type: Output }],
    loadingClass: [{ type: HostBinding, args: ["class.bx--inline-loading",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(InlineLoading, [{
        type: Component,
        args: [{
                selector: "ibm-inline-loading",
                template: `
		<div *ngIf="state !== InlineLoadingState.Hidden"
			class="bx--inline-loading__animation">
			<div
				*ngIf="state === InlineLoadingState.Inactive || state === InlineLoadingState.Active"
				class="bx--loading bx--loading--small"
				[ngClass]="{
					'bx--loading--stop': state === InlineLoadingState.Inactive
				}">
				<svg class="bx--loading__svg" viewBox="-75 -75 150 150">
					<circle class="bx--loading__background" cx="0" cy="0" r="30" />
					<circle class="bx--loading__stroke" cx="0" cy="0" r="30" />
				</svg>
			</div>
			<svg
				*ngIf="state === InlineLoadingState.Finished"
				ibmIcon="checkmark--filled"
				size="16"
				class="bx--inline-loading__checkmark-container">
			</svg>
			<svg
				*ngIf="state === InlineLoadingState.Error"
				ibmIcon="error--filled"
				size="16"
				class="bx--inline-loading--error">
			</svg>
		</div>
		<p
			*ngIf="state === InlineLoadingState.Inactive || state === InlineLoadingState.Active"
			class="bx--inline-loading__text">{{loadingText}}</p>
		<p *ngIf="state === InlineLoadingState.Finished" class="bx--inline-loading__text">{{successText}}</p>
		<p *ngIf="state === InlineLoadingState.Error" class="bx--inline-loading__text">{{errorText}}</p>
	`
            }]
    }], function () { return []; }, { state: [{
            type: Input
        }], successDelay: [{
            type: Input
        }], onSuccess: [{
            type: Output
        }], loadingClass: [{
            type: HostBinding,
            args: ["class.bx--inline-loading"]
        }], isActive: [{
            type: Input
        }], success: [{
            type: Input
        }], loadingText: [{
            type: Input
        }], successText: [{
            type: Input
        }], errorText: [{
            type: Input
        }] }); })();

class InlineLoadingModule {
}
InlineLoadingModule.ɵfac = function InlineLoadingModule_Factory(t) { return new (t || InlineLoadingModule)(); };
InlineLoadingModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: InlineLoadingModule });
InlineLoadingModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, IconModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(InlineLoadingModule, { declarations: function () { return [InlineLoading]; }, imports: function () { return [CommonModule, IconModule]; }, exports: function () { return [InlineLoading]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(InlineLoadingModule, [{
        type: NgModule,
        args: [{
                declarations: [InlineLoading],
                exports: [InlineLoading],
                imports: [CommonModule, IconModule]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { InlineLoading, InlineLoadingState, InlineLoadingModule };

//# sourceMappingURL=carbon-components-angular-inline-loading.js.map