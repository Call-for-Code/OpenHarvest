/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-timepicker.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { Component, Input, Output, EventEmitter, TemplateRef, HostListener, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { TimePickerSelectModule } from 'carbon-components-angular/timepicker-select';

/**
 * [See demo](../../?path=/story/time-picker--simple)
 *
 * <example-url>../../iframe.html?id=time-picker--simple</example-url>
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

function TimePicker_label_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.label);
} }
function TimePicker_label_0_2_ng_template_0_Template(rf, ctx) { }
function TimePicker_label_0_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TimePicker_label_0_2_ng_template_0_Template, 0, 0, "ng-template", 7);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r3.label);
} }
function TimePicker_label_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 5);
    ɵngcc0.ɵɵtemplate(1, TimePicker_label_0_ng_container_1_Template, 2, 1, "ng-container", 6);
    ɵngcc0.ɵɵtemplate(2, TimePicker_label_0_2_Template, 1, 1, undefined, 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("for", ctx_r0.id);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.label));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.label));
} }
function TimePicker_div_5_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r5.invalidText);
} }
function TimePicker_div_5_2_ng_template_0_Template(rf, ctx) { }
function TimePicker_div_5_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TimePicker_div_5_2_ng_template_0_Template, 0, 0, "ng-template", 7);
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r6.invalidText);
} }
function TimePicker_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵtemplate(1, TimePicker_div_5_ng_container_1_Template, 2, 1, "ng-container", 6);
    ɵngcc0.ɵɵtemplate(2, TimePicker_div_5_2_Template, 1, 1, undefined, 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.isTemplate(ctx_r1.invalidText));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.isTemplate(ctx_r1.invalidText));
} }
const _c0 = function (a0) { return { "bx--time-picker--invalid": a0 }; };
const _c1 = function (a0, a1) { return { "bx--text-input--light": a0, "bx--skeleton": a1 }; };
const _c2 = ["*"];
class TimePicker {
    constructor() {
        this.invalid = false;
        this.placeholder = "hh:mm";
        this.pattern = "(1[012]|[0-9]):[0-5][0-9]";
        this.id = `timepicker-${TimePicker.timePickerCount++}`;
        this.disabled = false;
        /**
         * Set to true for a loading select.
         */
        this.skeleton = false;
        /**
         * `light` or `dark` select theme
         */
        this.theme = "dark";
        this.valueChange = new EventEmitter();
        this.onChangeHandler = (_) => { };
        this.onTouchedHandler = () => { };
    }
    writeValue(value) {
        this.value = value;
    }
    registerOnChange(callback) {
        this.onChangeHandler = callback;
    }
    registerOnTouched(callback) {
        this.onTouchedHandler = callback;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    onChange(event) {
        this.onChangeHandler(event.target.value);
        this.valueChange.emit(event.target.value);
    }
    focusOut() {
        this.onTouchedHandler();
    }
    isTemplate(value) {
        return value instanceof TemplateRef;
    }
}
TimePicker.ɵfac = function TimePicker_Factory(t) { return new (t || TimePicker)(); };
TimePicker.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TimePicker, selectors: [["ibm-timepicker"]], hostBindings: function TimePicker_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focusout", function TimePicker_focusout_HostBindingHandler() { return ctx.focusOut(); });
    } }, inputs: { invalid: "invalid", placeholder: "placeholder", pattern: "pattern", id: "id", disabled: "disabled", skeleton: "skeleton", theme: "theme", value: "value", invalidText: "invalidText", label: "label" }, outputs: { valueChange: "valueChange" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: TimePicker,
                multi: true
            }
        ])], ngContentSelectors: _c2, decls: 6, vars: 15, consts: [["class", "bx--label", 3, "for", 4, "ngIf"], [1, "bx--time-picker", 3, "ngClass"], [1, "bx--time-picker__input"], ["maxlength", "5", "type", "text", 1, "bx--time-picker__input-field", "bx--text-input", 3, "ngClass", "value", "placeholder", "pattern", "disabled", "change"], ["class", "bx--form-requirement", 4, "ngIf"], [1, "bx--label", 3, "for"], [4, "ngIf"], [3, "ngTemplateOutlet"], [1, "bx--form-requirement"]], template: function TimePicker_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, TimePicker_label_0_Template, 3, 3, "label", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "input", 3);
        ɵngcc0.ɵɵlistener("change", function TimePicker_Template_input_change_3_listener($event) { return ctx.onChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, TimePicker_div_5_Template, 3, 2, "div", 4);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.skeleton && ctx.label);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(10, _c0, ctx.invalid));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(12, _c1, ctx.theme === "light", ctx.skeleton))("value", ctx.value)("placeholder", ctx.placeholder)("pattern", ctx.pattern)("disabled", ctx.disabled);
        ɵngcc0.ɵɵattribute("data-invalid", ctx.invalid ? true : undefined)("id", ctx.id);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.invalid);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass, ɵngcc1.NgTemplateOutlet], encapsulation: 2 });
/**
 * Tracks the total number of selects instantiated. Used to generate unique IDs
 */
TimePicker.timePickerCount = 0;
TimePicker.propDecorators = {
    invalid: [{ type: Input }],
    invalidText: [{ type: Input }],
    label: [{ type: Input }],
    placeholder: [{ type: Input }],
    pattern: [{ type: Input }],
    id: [{ type: Input }],
    disabled: [{ type: Input }],
    value: [{ type: Input }],
    skeleton: [{ type: Input }],
    theme: [{ type: Input }],
    valueChange: [{ type: Output }],
    focusOut: [{ type: HostListener, args: ["focusout",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TimePicker, [{
        type: Component,
        args: [{
                selector: "ibm-timepicker",
                template: `
		<label *ngIf="!skeleton && label" [for]="id" class="bx--label">
			<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
			<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
		</label>
		<div
			class="bx--time-picker"
			[ngClass]="{'bx--time-picker--invalid' : invalid}">
			<div class="bx--time-picker__input">
				<input
					[ngClass]="{
						'bx--text-input--light': theme === 'light',
						'bx--skeleton': skeleton
					}"
					[value]="value"
					[placeholder]="placeholder"
					[attr.data-invalid]="invalid ? true : undefined"
					[pattern]="pattern"
					[attr.id]="id"
					[disabled]="disabled"
					maxlength="5"
					(change)="onChange($event)"
					type="text"
					class="bx--time-picker__input-field bx--text-input">
			</div>
			<ng-content></ng-content>
		</div>
		<div *ngIf="invalid" class="bx--form-requirement">
			<ng-container *ngIf="!isTemplate(invalidText)">{{invalidText}}</ng-container>
			<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
		</div>
	`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: TimePicker,
                        multi: true
                    }
                ]
            }]
    }], function () { return []; }, { invalid: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], pattern: [{
            type: Input
        }], id: [{
            type: Input
        }], disabled: [{
            type: Input
        }], skeleton: [{
            type: Input
        }], theme: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], value: [{
            type: Input
        }], focusOut: [{
            type: HostListener,
            args: ["focusout"]
        }], invalidText: [{
            type: Input
        }], label: [{
            type: Input
        }] }); })();

class TimePickerModule {
}
TimePickerModule.ɵfac = function TimePickerModule_Factory(t) { return new (t || TimePickerModule)(); };
TimePickerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TimePickerModule });
TimePickerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            TimePickerSelectModule,
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TimePickerModule, { declarations: function () { return [TimePicker]; }, imports: function () { return [TimePickerSelectModule,
        CommonModule]; }, exports: function () { return [TimePicker]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TimePickerModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    TimePicker
                ],
                exports: [
                    TimePicker
                ],
                imports: [
                    TimePickerSelectModule,
                    CommonModule
                ]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { TimePicker, TimePickerModule };

//# sourceMappingURL=carbon-components-angular-timepicker.js.map