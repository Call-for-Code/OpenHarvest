/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-structured-list.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { Component, HostBinding, Input, ContentChildren, HostListener, ViewChild, EventEmitter, Output, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { IconModule } from 'carbon-components-angular/icon';

/**
 * `ListColumn` represents a single column in a `StructuredList`.
 *
 * `ListColumn`s can be used in a `ListHeader` to specify the column headers, or in `ListRow`s to specify the column data.
 *
 * Example:
 * ```html
 * <ibm-list-column nowrap="true">Column 1</ibm-list-column>
 * ```
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from 'carbon-components-angular/icon';

function ListColumn_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span");
} }
const _c0 = ["*"];
function ListHeader_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 2);
} }
const _c1 = ["input"];
function ListRow_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "input", 1, 2);
    ɵngcc0.ɵɵlistener("change", function ListRow_ng_container_1_Template_input_change_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onChange($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "div", 3);
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(4, "svg", 4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", ctx_r0.value)("name", ctx_r0.name)("title", ctx_r0.label)("checked", ctx_r0.selected);
} }
const _c2 = [[["ibm-list-header"]], "*"];
const _c3 = function (a0, a1, a2, a3, a4) { return { "bx--structured-list--border": a0, "bx--structured-list--selection": a1, "bx--structured-list--condensed": a2, "bx--structured-list-content--nowrap": a3, "bx--skeleton": a4 }; };
const _c4 = ["ibm-list-header", "*"];
class ListColumn {
    constructor() {
        this.skeleton = false;
        this.isHeaderColumn = true;
        this.isBodyColumn = true;
        /**
         * Applies `white-space: nowrap` to the content of this `ListColumn`
         */
        this.nowrap = false;
    }
}
ListColumn.ɵfac = function ListColumn_Factory(t) { return new (t || ListColumn)(); };
ListColumn.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ListColumn, selectors: [["ibm-list-column"]], hostVars: 6, hostBindings: function ListColumn_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--structured-list-th", ctx.isHeaderColumn)("bx--structured-list-td", ctx.isBodyColumn)("bx--structured-list-content--nowrap", ctx.nowrap);
    } }, inputs: { skeleton: "skeleton", nowrap: "nowrap" }, ngContentSelectors: _c0, decls: 2, vars: 1, consts: [[4, "ngIf"]], template: function ListColumn_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, ListColumn_span_0_Template, 1, 0, "span", 0);
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.skeleton);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2 });
ListColumn.propDecorators = {
    skeleton: [{ type: Input }],
    isHeaderColumn: [{ type: HostBinding, args: ["class.bx--structured-list-th",] }],
    isBodyColumn: [{ type: HostBinding, args: ["class.bx--structured-list-td",] }],
    nowrap: [{ type: HostBinding, args: ["class.bx--structured-list-content--nowrap",] }, { type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ListColumn, [{
        type: Component,
        args: [{
                selector: "ibm-list-column",
                template: `
		<span *ngIf="skeleton"></span>
		<ng-content></ng-content>
	`
            }]
    }], function () { return []; }, { skeleton: [{
            type: Input
        }], isHeaderColumn: [{
            type: HostBinding,
            args: ["class.bx--structured-list-th"]
        }], isBodyColumn: [{
            type: HostBinding,
            args: ["class.bx--structured-list-td"]
        }], nowrap: [{
            type: HostBinding,
            args: ["class.bx--structured-list-content--nowrap"]
        }, {
            type: Input
        }] }); })();

/**
 * `ListHeader` provides a container for the `ListColumn`s that make up the header of a structured list.
 *
 * Example:
 * ```html
 * 	<ibm-list-header>
 *		<ibm-list-column nowrap="true">Column 1</ibm-list-column>
 *		<ibm-list-column nowrap="true">Column 2</ibm-list-column>
 *		<ibm-list-column>Column 3</ibm-list-column>
 *	</ibm-list-header>
 * ```
 */
class ListHeader {
    constructor() {
        this.wrapper = true;
        /**
         * Set by the containing `StructuredList`. Adds a dummy header for the selection column when set to true.
         */
        this.selection = false;
        this._skeleton = false;
    }
    set skeleton(value) {
        this._skeleton = value;
        this.updateChildren();
    }
    get skeleton() {
        return this._skeleton;
    }
    ngAfterContentInit() {
        this.columns.forEach(column => {
            column.isBodyColumn = false;
            column.isHeaderColumn = true;
        });
        this.updateChildren();
    }
    updateChildren() {
        if (this.columns) {
            this.columns.toArray().forEach(child => child.skeleton = this.skeleton);
        }
    }
}
ListHeader.ɵfac = function ListHeader_Factory(t) { return new (t || ListHeader)(); };
ListHeader.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ListHeader, selectors: [["ibm-list-header"]], contentQueries: function ListHeader_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ListColumn, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columns = _t);
    } }, hostVars: 2, hostBindings: function ListHeader_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--structured-list-thead", ctx.wrapper);
    } }, inputs: { skeleton: "skeleton" }, ngContentSelectors: _c0, decls: 3, vars: 1, consts: [[1, "bx--structured-list-row", "bx--structured-list-row--header-row"], ["class", "bx--structured-list-th", 4, "ngIf"], [1, "bx--structured-list-th"]], template: function ListHeader_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵtemplate(2, ListHeader_div_2_Template, 1, 0, "div", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.selection);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2 });
ListHeader.propDecorators = {
    wrapper: [{ type: HostBinding, args: ["class.bx--structured-list-thead",] }],
    skeleton: [{ type: Input }],
    columns: [{ type: ContentChildren, args: [ListColumn,] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ListHeader, [{
        type: Component,
        args: [{
                selector: "ibm-list-header",
                template: `
		<div class="bx--structured-list-row bx--structured-list-row--header-row">
			<ng-content></ng-content>
			<div *ngIf="selection" class="bx--structured-list-th"></div>
		</div>
	`
            }]
    }], function () { return []; }, { wrapper: [{
            type: HostBinding,
            args: ["class.bx--structured-list-thead"]
        }], skeleton: [{
            type: Input
        }], columns: [{
            type: ContentChildren,
            args: [ListColumn]
        }] }); })();

/**
 * `ListRow` provides a container for the `ListColumn`s that make up the body of a structured list.
 *
 * Example:
 * ```html
 * 	<ibm-list-row>
 *		<ibm-list-column>Row 1</ibm-list-column>
 *		<ibm-list-column nowrap="true">Row One</ibm-list-column>
 *		<ibm-list-column>
 *			Lorem ipsum dolor sit amet,
 *			consectetur adipiscing elit. Nunc dui magna,
 *			finibus id tortor sed, aliquet bibendum augue.
 *			Aenean posuere sem vel euismod dignissim. Nulla ut cursus dolor.
 *			Pellentesque vulputate nisl a porttitor interdum.
 *		</ibm-list-column>
 *	</ibm-list-row>
 * ```
 */
class ListRow {
    constructor() {
        this.selected = false;
        /**
         * Internal event used to notify the containing `StructuredList` of changes.
         */
        this.change = new EventEmitter();
        /**
         * Set by the containing `StructuredList`. Enables or disables row level selection features.
         */
        this.selection = false;
        /**
         * Set by the containing `StructuredList`. When `selection = true`, used for the `name` property on the radio input.
         */
        this.name = "list";
        this.wrapper = true;
        this.tabindex = this.selection ? "0" : null;
    }
    ngAfterContentInit() {
        this.columns.forEach(column => {
            column.isBodyColumn = true;
            column.isHeaderColumn = false;
        });
    }
    onclick() {
        if (this.selection) {
            this.input.nativeElement.click();
        }
    }
    onChange(event) {
        this.change.emit(event);
    }
}
ListRow.ɵfac = function ListRow_Factory(t) { return new (t || ListRow)(); };
ListRow.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ListRow, selectors: [["ibm-list-row"]], contentQueries: function ListRow_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ListColumn, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columns = _t);
    } }, viewQuery: function ListRow_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c1, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 6, hostBindings: function ListRow_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function ListRow_click_HostBindingHandler() { return ctx.onclick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex)("aria-label", ctx.label);
        ɵngcc0.ɵɵclassProp("bx--structured-list-row--selected", ctx.selected)("bx--structured-list-row", ctx.wrapper);
    } }, inputs: { selected: "selected", label: "label", value: "value" }, outputs: { change: "change" }, ngContentSelectors: _c0, decls: 2, vars: 1, consts: [[4, "ngIf"], ["tabindex", "-1", "type", "radio", 1, "bx--structured-list-input", 3, "value", "name", "title", "checked", "change"], ["input", ""], [1, "bx--structured-list-td"], ["ibmIcon", "checkmark--filled", "size", "16", 1, "bx--structured-list-svg"]], template: function ListRow_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, ListRow_ng_container_1_Template, 5, 4, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.selection);
    } }, directives: [ɵngcc1.NgIf, ɵngcc2.IconDirective], encapsulation: 2 });
ListRow.propDecorators = {
    selected: [{ type: Input }, { type: HostBinding, args: ["class.bx--structured-list-row--selected",] }],
    label: [{ type: Input }, { type: HostBinding, args: ["attr.aria-label",] }],
    value: [{ type: Input }],
    change: [{ type: Output }],
    wrapper: [{ type: HostBinding, args: ["class.bx--structured-list-row",] }],
    tabindex: [{ type: HostBinding, args: ["attr.tabindex",] }],
    columns: [{ type: ContentChildren, args: [ListColumn,] }],
    input: [{ type: ViewChild, args: ["input", { static: false },] }],
    onclick: [{ type: HostListener, args: ["click",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ListRow, [{
        type: Component,
        args: [{
                selector: "ibm-list-row",
                template: `
		<ng-content></ng-content>
		<ng-container *ngIf="selection">
			<input
				#input
				tabindex="-1"
				class="bx--structured-list-input"
				type="radio"
				[value]="value"
				[name]="name"
				[title]="label"
				(change)="onChange($event)"
				[checked]="selected"/>
			<div class="bx--structured-list-td">
				<svg ibmIcon="checkmark--filled" size="16" class="bx--structured-list-svg"></svg>
			</div>
		</ng-container>
	`
            }]
    }], function () { return []; }, { selected: [{
            type: Input
        }, {
            type: HostBinding,
            args: ["class.bx--structured-list-row--selected"]
        }], change: [{
            type: Output
        }], wrapper: [{
            type: HostBinding,
            args: ["class.bx--structured-list-row"]
        }], tabindex: [{
            type: HostBinding,
            args: ["attr.tabindex"]
        }], onclick: [{
            type: HostListener,
            args: ["click"]
        }], label: [{
            type: Input
        }, {
            type: HostBinding,
            args: ["attr.aria-label"]
        }], value: [{
            type: Input
        }], columns: [{
            type: ContentChildren,
            args: [ListColumn]
        }], input: [{
            type: ViewChild,
            args: ["input", { static: false }]
        }] }); })();

/**
 * Structured Lists represent related tabular data. For larger datasets consider a full `Table`.
 *
 * [See demo](../../?path=/story/structured-list--basic)
 *
 * See [structured-list/usage](https://www.carbondesignsystem.com/components/structured-list/usage) for usage guidance.
 *
 * A basic structued list looks something like:
 * ```html
 *	<ibm-structured-list>
 *		<ibm-list-header>
 *			<ibm-list-column nowrap="true">Column 1</ibm-list-column>
 *			<ibm-list-column nowrap="true">Column 2</ibm-list-column>
 *			<ibm-list-column>Column 3</ibm-list-column>
 *		</ibm-list-header>
 *		<ibm-list-row>
 *			<ibm-list-column>Row 1</ibm-list-column>
 *			<ibm-list-column nowrap="true">Row One</ibm-list-column>
 *			<ibm-list-column>
 *				Lorem ipsum dolor sit amet,
 *				consectetur adipiscing elit. Nunc dui magna,
 *				finibus id tortor sed, aliquet bibendum augue.
 *				Aenean posuere sem vel euismod dignissim. Nulla ut cursus dolor.
 *				Pellentesque vulputate nisl a porttitor interdum.
 *			</ibm-list-column>
 *		</ibm-list-row>
 *		<ibm-list-row>
 *			<ibm-list-column>Row 2</ibm-list-column>
 *			<ibm-list-column nowrap="true">Row Two</ibm-list-column>
 *			<ibm-list-column>
 *				Lorem ipsum dolor sit amet,
 *				consectetur adipiscing elit. Nunc dui magna,
 *				finibus id tortor sed, aliquet bibendum augue.
 *				Aenean posuere sem vel euismod dignissim. Nulla ut cursus dolor.
 *				Pellentesque vulputate nisl a porttitor interdum.
 *			</ibm-list-column>
 *		</ibm-list-row>
 *	</ibm-structured-list>
 * ```
 *
 * <example-url>../../iframe.html?id=structured-list--basic</example-url>
 */
class StructuredList {
    constructor() {
        /**
         * Set to `true` to enable radio like selection of the rows.
         */
        this.selection = false;
        /**
         * Set to `true` to apply a border and white background.
         */
        this.border = false;
        /**
         * Set to `true` to apply a condensed style to the headers and rows.
         */
        this.condensed = false;
        /**
         * Set to `true` to apply `white-space: nowrap` on _all_ conent.
         */
        this.nowrap = false;
        /**
         * Used when `selection = true` as the row radio group `name`
         */
        this.name = `structured-list-${StructuredList.listCount++}`;
        /**
         * Emits an event when the row selection changes.
         *
         * Emits an object that looks like:
         * ```javascript
         * {
         * 	value: "something",
         * 	selected: true,
         * 	name: "structured-list-1"
         * }
         * ```
         */
        this.selected = new EventEmitter();
        this._skeleton = false;
        this.onChange = (_) => { };
        this.onTouched = () => { };
    }
    /**
     * Sets the skeleton value for all `ListHeader` to the skeleton value of `StructuredList`.
     */
    set skeleton(value) {
        this._skeleton = value;
        this.updateChildren();
    }
    /**
     * Returns the skeleton value in the `StructuredList` if there is one.
     */
    get skeleton() {
        return this._skeleton;
    }
    ngAfterContentInit() {
        const setSelection = (rowOrHeader) => {
            rowOrHeader.selection = this.selection;
        };
        this.headers.forEach(setSelection);
        this.rows.forEach(row => {
            setSelection(row);
            row.name = this.name;
            row.tabindex = this.selection ? "0" : "null";
            row.change.subscribe(() => {
                this.selected.emit({
                    value: row.value,
                    selected: row.selected,
                    name: this.name
                });
                this.onChange(row.value);
            });
        });
        this.updateChildren();
    }
    writeValue(value) {
        if (!this.rows) {
            return;
        }
        this.rows.forEach(row => {
            if (row.value === value) {
                row.selected = true;
            }
            else {
                row.selected = false;
            }
        });
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    updateChildren() {
        if (this.headers) {
            this.headers.toArray().forEach(child => child.skeleton = this.skeleton);
        }
    }
}
StructuredList.ɵfac = function StructuredList_Factory(t) { return new (t || StructuredList)(); };
StructuredList.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: StructuredList, selectors: [["ibm-structured-list"]], contentQueries: function StructuredList_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ListRow, 0);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ListHeader, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rows = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headers = _t);
    } }, inputs: { selection: "selection", border: "border", condensed: "condensed", nowrap: "nowrap", name: "name", skeleton: "skeleton" }, outputs: { selected: "selected" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: StructuredList,
                multi: true
            }
        ])], ngContentSelectors: _c4, decls: 4, vars: 7, consts: [[1, "bx--structured-list", 3, "ngClass"], [1, "bx--structured-list-tbody"]], template: function StructuredList_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c2);
        ɵngcc0.ɵɵelementStart(0, "section", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵprojection(3, 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction5(1, _c3, ctx.border, ctx.selection, ctx.condensed, ctx.nowrap, ctx.skeleton));
    } }, directives: [ɵngcc1.NgClass], encapsulation: 2 });
/**
 * A counter to provide unique default values.
 */
StructuredList.listCount = 0;
StructuredList.propDecorators = {
    selection: [{ type: Input }],
    border: [{ type: Input }],
    condensed: [{ type: Input }],
    nowrap: [{ type: Input }],
    name: [{ type: Input }],
    skeleton: [{ type: Input }],
    selected: [{ type: Output }],
    rows: [{ type: ContentChildren, args: [ListRow,] }],
    headers: [{ type: ContentChildren, args: [ListHeader,] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StructuredList, [{
        type: Component,
        args: [{
                selector: "ibm-structured-list",
                template: `
		<section
			class="bx--structured-list"
			[ngClass]="{
				'bx--structured-list--border': border,
				'bx--structured-list--selection': selection,
				'bx--structured-list--condensed': condensed,
				'bx--structured-list-content--nowrap': nowrap,
				'bx--skeleton': skeleton
			}">
			<ng-content select="ibm-list-header"></ng-content>
			<div class="bx--structured-list-tbody">
				<ng-content></ng-content>
			</div>
		</section>
	`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: StructuredList,
                        multi: true
                    }
                ]
            }]
    }], function () { return []; }, { selection: [{
            type: Input
        }], border: [{
            type: Input
        }], condensed: [{
            type: Input
        }], nowrap: [{
            type: Input
        }], name: [{
            type: Input
        }], selected: [{
            type: Output
        }], skeleton: [{
            type: Input
        }], rows: [{
            type: ContentChildren,
            args: [ListRow]
        }], headers: [{
            type: ContentChildren,
            args: [ListHeader]
        }] }); })();

class StructuredListModule {
}
StructuredListModule.ɵfac = function StructuredListModule_Factory(t) { return new (t || StructuredListModule)(); };
StructuredListModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: StructuredListModule });
StructuredListModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            IconModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(StructuredListModule, { declarations: function () { return [StructuredList, ListRow, ListHeader, ListColumn]; }, imports: function () { return [CommonModule,
        IconModule]; }, exports: function () { return [StructuredList, ListRow, ListHeader, ListColumn]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StructuredListModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    StructuredList,
                    ListRow,
                    ListHeader,
                    ListColumn
                ],
                exports: [
                    StructuredList,
                    ListRow,
                    ListHeader,
                    ListColumn
                ],
                imports: [
                    CommonModule,
                    IconModule
                ]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { ListColumn, ListHeader, ListRow, StructuredList, StructuredListModule };

//# sourceMappingURL=carbon-components-angular-structured-list.js.map