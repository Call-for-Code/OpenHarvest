/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-loading.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Component, Input, HostBinding, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { I18n, I18nModule } from 'carbon-components-angular/i18n';

/**
 * [See demo](../../?path=/story/loading--basic)
 *
 * <example-url>../../iframe.html?id=loading--basic</example-url>
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from 'carbon-components-angular/i18n';
import * as ɵngcc2 from '@angular/common';

const _c0 = function (a0, a1, a2) { return { "bx--loading--small": a0, "bx--loading--stop": a1, "bx--loading-overlay--stop": a2 }; };
class Loading {
    constructor(i18n) {
        this.i18n = i18n;
        /**
         * Accessible title for the loading circle.
         * Defaults to the `LOADING.TITLE` value from the i18n service.
         */
        this.title = this.i18n.get().LOADING.TITLE;
        /**
         * set to `false` to stop the loading animation
         */
        this.isActive = true;
        /**
         * Specify the size of the button
         */
        this.size = "normal";
        /**
         * Set to `true` to make loader with an overlay.
         */
        this.overlay = false;
    }
}
Loading.ɵfac = function Loading_Factory(t) { return new (t || Loading)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n)); };
Loading.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: Loading, selectors: [["ibm-loading"]], hostVars: 2, hostBindings: function Loading_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--loading-overlay", ctx.overlay);
    } }, inputs: { title: "title", isActive: "isActive", size: "size", overlay: "overlay" }, decls: 5, vars: 6, consts: [[1, "bx--loading", 3, "ngClass"], ["viewBox", "-75 -75 150 150", 1, "bx--loading__svg"], ["cx", "0", "cy", "0", "r", "37.5", 1, "bx--loading__stroke"]], template: function Loading_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "svg", 1);
        ɵngcc0.ɵɵelementStart(2, "title");
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(4, "circle", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction3(2, _c0, ctx.size === "sm", !ctx.isActive && !ctx.overlay, !ctx.isActive && ctx.overlay));
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.title);
    } }, directives: [ɵngcc2.NgClass], encapsulation: 2 });
/** @nocollapse */
Loading.ctorParameters = () => [
    { type: I18n }
];
Loading.propDecorators = {
    title: [{ type: Input }],
    isActive: [{ type: Input }],
    size: [{ type: Input }],
    overlay: [{ type: Input }, { type: HostBinding, args: ["class.bx--loading-overlay",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Loading, [{
        type: Component,
        args: [{
                selector: "ibm-loading",
                template: `
		<div
			[ngClass]="{
				'bx--loading--small': size === 'sm',
				'bx--loading--stop': !isActive && !overlay,
				'bx--loading-overlay--stop': !isActive && overlay
			}"
			class="bx--loading">
			<svg class="bx--loading__svg" viewBox="-75 -75 150 150">
				<title>{{title}}</title>
				<circle class="bx--loading__stroke" cx="0" cy="0" r="37.5" />
			</svg>
		</div>
	`
            }]
    }], function () { return [{ type: ɵngcc1.I18n }]; }, { title: [{
            type: Input
        }], isActive: [{
            type: Input
        }], size: [{
            type: Input
        }], overlay: [{
            type: Input
        }, {
            type: HostBinding,
            args: ["class.bx--loading-overlay"]
        }] }); })();

class LoadingModule {
}
LoadingModule.ɵfac = function LoadingModule_Factory(t) { return new (t || LoadingModule)(); };
LoadingModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: LoadingModule });
LoadingModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, I18nModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LoadingModule, { declarations: function () { return [Loading]; }, imports: function () { return [CommonModule, I18nModule]; }, exports: function () { return [Loading]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LoadingModule, [{
        type: NgModule,
        args: [{
                declarations: [Loading],
                exports: [Loading],
                imports: [CommonModule, I18nModule]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { Loading, LoadingModule };

//# sourceMappingURL=carbon-components-angular-loading.js.map