/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-tiles.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Router } from '@angular/router';
import { merge } from 'carbon-components-angular/utils';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { Component, Input, Output, EventEmitter, Optional, ElementRef, ViewChild, HostListener, HostBinding, ContentChildren, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { I18n, I18nModule } from 'carbon-components-angular/i18n';
import { LinkModule } from 'carbon-components-angular/link';

/**
 * Build application's clickable tiles using this component.
 *
 * ## Basic usage
 *
 * ```html
 * <ibm-clickable-tile>
 * 		tile content
 * </ibm-clickable-tile>
 * ```
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/router';
import * as ɵngcc2 from 'carbon-components-angular/link';
import * as ɵngcc3 from 'carbon-components-angular/i18n';
import * as ɵngcc4 from '@angular/common';

const _c0 = ["*"];
function ExpandableTile__svg_svg_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "svg", 4);
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵelementStart(2, "title");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵpipe(4, "async");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(5, "path", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("title", ɵngcc0.ɵɵpipeBind1(1, 2, ctx_r0.expand.subject));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind1(4, 4, ctx_r0.expand.subject));
} }
function ExpandableTile__svg_svg_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "svg", 4);
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵelementStart(2, "title");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵpipe(4, "async");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(5, "path", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("title", ɵngcc0.ɵɵpipeBind1(1, 2, ctx_r1.collapse.subject));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind1(4, 4, ctx_r1.collapse.subject));
} }
const _c1 = [[["", 8, "bx--tile-content__above-the-fold"]], [["", 8, "bx--tile-content__below-the-fold"]]];
const _c2 = function (a0) { return { "bx--tile--is-expanded": a0 }; };
const _c3 = function (a0) { return { "max-height": a0 }; };
const _c4 = [".bx--tile-content__above-the-fold", ".bx--tile-content__below-the-fold"];
const _c5 = ["input"];
const _c6 = function (a0) { return { "bx--tile--is-selected": a0 }; };
const _c7 = [[["ibm-selection-tile"]]];
const _c8 = ["ibm-selection-tile"];
class ClickableTile {
    constructor(router) {
        this.router = router;
        /**
         * Sets the `href` attribute on the `ibm-clickable-tile` element.
         */
        this.href = "#";
        /**
         * Set to `true` to disable the clickable tile.
         */
        this.disabled = false;
        /**
         * Emits the navigation status promise when the link is activated
         */
        this.navigation = new EventEmitter();
    }
    navigate(event) {
        if (this.router && this.route) {
            event.preventDefault();
            const status = this.router.navigate(this.route, this.routeExtras);
            this.navigation.emit(status);
        }
    }
}
ClickableTile.ɵfac = function ClickableTile_Factory(t) { return new (t || ClickableTile)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Router, 8)); };
ClickableTile.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClickableTile, selectors: [["ibm-clickable-tile"]], inputs: { href: "href", disabled: "disabled", target: "target", route: "route", routeExtras: "routeExtras" }, outputs: { navigation: "navigation" }, ngContentSelectors: _c0, decls: 2, vars: 3, consts: [["ibmLink", "", "tabindex", "0", 1, "bx--tile", "bx--tile--clickable", 3, "href", "click"]], template: function ClickableTile_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "a", 0);
        ɵngcc0.ɵɵlistener("click", function ClickableTile_Template_a_click_0_listener($event) { return ctx.navigate($event); });
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("href", ctx.href, ɵngcc0.ɵɵsanitizeUrl);
        ɵngcc0.ɵɵattribute("target", ctx.target)("aria-disabled", ctx.disabled);
    } }, directives: [ɵngcc2.Link], encapsulation: 2 });
/** @nocollapse */
ClickableTile.ctorParameters = () => [
    { type: Router, decorators: [{ type: Optional }] }
];
ClickableTile.propDecorators = {
    href: [{ type: Input }],
    target: [{ type: Input }],
    disabled: [{ type: Input }],
    route: [{ type: Input }],
    routeExtras: [{ type: Input }],
    navigation: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ClickableTile, [{
        type: Component,
        args: [{
                selector: "ibm-clickable-tile",
                template: `
	<a
		ibmLink
		class="bx--tile bx--tile--clickable"
		tabindex="0"
		(click)="navigate($event)"
		[href]="href"
		[attr.target]="target"
		[attr.aria-disabled]="disabled">
		<ng-content></ng-content>
	</a>`
            }]
    }], function () { return [{ type: ɵngcc1.Router, decorators: [{
                type: Optional
            }] }]; }, { href: [{
            type: Input
        }], disabled: [{
            type: Input
        }], navigation: [{
            type: Output
        }], target: [{
            type: Input
        }], route: [{
            type: Input
        }], routeExtras: [{
            type: Input
        }] }); })();

class ExpandableTile {
    constructor(i18n, elementRef) {
        this.i18n = i18n;
        this.elementRef = elementRef;
        this.expanded = false;
        this.tileMaxHeight = 0;
        this.currentExpandedHeight = 0;
        this.element = this.elementRef.nativeElement;
        this.expand = this.i18n.getOverridable("TILES.EXPAND");
        this.collapse = this.i18n.getOverridable("TILES.COLLAPSE");
    }
    /**
     * Expects an object that contains some or all of:
     * ```
     * {
     *		"EXPAND": "Expand",
     *		"COLLAPSE": "Collapse",
     * }
     * ```
     */
    set translations(value) {
        const valueWithDefaults = merge(this.i18n.getMultiple("TILES"), value);
        this.expand.override(valueWithDefaults.EXPAND);
        this.collapse.override(valueWithDefaults.COLLAPSE);
    }
    ngAfterContentInit() {
        this.updateMaxHeight();
    }
    get expandedHeight() {
        const tile = this.element.querySelector(".bx--tile");
        const tilePadding = parseInt(getComputedStyle(tile).paddingBottom, 10) + parseInt(getComputedStyle(tile).paddingTop, 10);
        const expandedHeight = this.tileMaxHeight + tilePadding;
        if (!isNaN(expandedHeight)) {
            this.currentExpandedHeight = expandedHeight;
        }
        return this.currentExpandedHeight;
    }
    updateMaxHeight() {
        if (this.expanded) {
            this.tileMaxHeight = this.element.querySelector(".bx--tile-content").getBoundingClientRect().height;
        }
        else {
            this.tileMaxHeight = this.element.querySelector(".bx--tile-content__above-the-fold").getBoundingClientRect().height;
        }
    }
    onClick() {
        this.expanded = !this.expanded;
        this.updateMaxHeight();
    }
}
ExpandableTile.ɵfac = function ExpandableTile_Factory(t) { return new (t || ExpandableTile)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.I18n), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ExpandableTile.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ExpandableTile, selectors: [["ibm-expandable-tile"]], inputs: { expanded: "expanded", translations: "translations" }, ngContentSelectors: _c4, decls: 7, vars: 8, consts: [["type", "button", 1, "bx--tile", "bx--tile--expandable", 3, "ngClass", "ngStyle", "click"], [1, "bx--tile__chevron"], ["width", "12", "height", "7", "viewBox", "0 0 12 7", "role", "img", 4, "ngIf"], [1, "bx--tile-content"], ["width", "12", "height", "7", "viewBox", "0 0 12 7", "role", "img"], ["fill-rule", "nonzero", "d", "M6.002 5.55L11.27 0l.726.685L6.003 7 0 .685.726 0z"]], template: function ExpandableTile_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c1);
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function ExpandableTile_Template_button_click_0_listener() { return ctx.onClick(); });
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵtemplate(2, ExpandableTile__svg_svg_2_Template, 6, 6, "svg", 2);
        ɵngcc0.ɵɵtemplate(3, ExpandableTile__svg_svg_3_Template, 6, 6, "svg", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div", 3);
        ɵngcc0.ɵɵprojection(5);
        ɵngcc0.ɵɵprojection(6, 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(4, _c2, ctx.expanded))("ngStyle", ɵngcc0.ɵɵpureFunction1(6, _c3, ctx.expandedHeight + "px"));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.expanded);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.expanded);
    } }, directives: [ɵngcc4.NgClass, ɵngcc4.NgStyle, ɵngcc4.NgIf], pipes: [ɵngcc4.AsyncPipe], encapsulation: 2 });
/** @nocollapse */
ExpandableTile.ctorParameters = () => [
    { type: I18n },
    { type: ElementRef }
];
ExpandableTile.propDecorators = {
    expanded: [{ type: Input }],
    translations: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExpandableTile, [{
        type: Component,
        args: [{
                selector: "ibm-expandable-tile",
                template: `
		<button
			class="bx--tile bx--tile--expandable"
			[ngClass]="{'bx--tile--is-expanded' : expanded}"
			[ngStyle]="{'max-height': expandedHeight + 'px'}"
			type="button"
			(click)="onClick()">
			<div class="bx--tile__chevron">
				<svg *ngIf="!expanded" width="12" height="7" viewBox="0 0 12 7" [attr.title]="expand.subject | async" role="img">
					<title>{{expand.subject | async}}</title>
					<path fill-rule="nonzero" d="M6.002 5.55L11.27 0l.726.685L6.003 7 0 .685.726 0z"/>
				</svg>
				<svg *ngIf="expanded" width="12" height="7" viewBox="0 0 12 7" [attr.title]="collapse.subject | async" role="img">
					<title>{{collapse.subject | async}}</title>
					<path fill-rule="nonzero" d="M6.002 5.55L11.27 0l.726.685L6.003 7 0 .685.726 0z"/>
				</svg>
			</div>
			<div class="bx--tile-content">
				<ng-content select=".bx--tile-content__above-the-fold"></ng-content>
				<ng-content select=".bx--tile-content__below-the-fold"></ng-content>
			</div>
		</button>
	`
            }]
    }], function () { return [{ type: ɵngcc3.I18n }, { type: ɵngcc0.ElementRef }]; }, { expanded: [{
            type: Input
        }], translations: [{
            type: Input
        }] }); })();

class SelectionTile {
    constructor(i18n) {
        this.i18n = i18n;
        /**
         * The unique id for the input.
         */
        this.id = `tile-${SelectionTile.tileCount}`;
        /**
         * Internal event used to notify the containing `TileGroup` of changes.
         */
        this.change = new EventEmitter();
        /**
         * Set by the containing `TileGroup`. Used for the `name` property on the input.
         */
        this.name = "tile-group-unbound";
        /**
         * Defines whether or not the `SelectionTile` supports selecting multiple tiles as opposed to single
         * tile selection.
         */
        this.multiple = true; // Set to true because of the way tile group sets it up.
        // If an initial selected value is set before input exists, we save
        // the value and check again when input exists in `AfterViewInit`.
        this._selected = null;
        SelectionTile.tileCount++;
    }
    /**
     * Updating the state of the input to match the state of the parameter passed in.
     * Set to `true` if this tile should be selected.
     */
    set selected(value) {
        // If an initial selected value is set before input exists, we save
        // the value and check again when input exists in `AfterViewInit`.
        this._selected = value ? true : null;
        if (this.input) {
            this.input.nativeElement.checked = this._selected;
        }
    }
    get selected() {
        return this.input ? this.input.nativeElement.checked : false;
    }
    ngAfterViewInit() {
        if (this.input) {
            setTimeout(() => {
                this.input.nativeElement.checked = this._selected;
            });
        }
    }
    keyboardInput(event) {
        if (event.key === "Enter" || event.key === "Spacebar" || event.key === " ") {
            this.selected = !this.selected;
            this.change.emit(event);
        }
    }
    onChange(event) {
        this.change.emit(event);
    }
}
SelectionTile.ɵfac = function SelectionTile_Factory(t) { return new (t || SelectionTile)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.I18n)); };
SelectionTile.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SelectionTile, selectors: [["ibm-selection-tile"]], viewQuery: function SelectionTile_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c5, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostBindings: function SelectionTile_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function SelectionTile_keydown_HostBindingHandler($event) { return ctx.keyboardInput($event); });
    } }, inputs: { id: "id", selected: "selected", value: "value" }, outputs: { change: "change" }, ngContentSelectors: _c0, decls: 9, vars: 11, consts: [["tabindex", "0", 1, "bx--tile", "bx--tile--selectable", 3, "for", "ngClass"], ["tabindex", "-1", 1, "bx--tile-input", 3, "id", "type", "value", "name", "change"], ["input", ""], [1, "bx--tile__checkmark"], ["width", "16", "height", "16", "viewBox", "0 0 16 16"], ["d", "M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16zm3.646-10.854L6.75 10.043 4.354 7.646l-.708.708 3.104 3.103 5.604-5.603-.708-.708z", "fill-rule", "evenodd"], [1, "bx--tile-content"]], template: function SelectionTile_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵpipe(1, "async");
        ɵngcc0.ɵɵelementStart(2, "input", 1, 2);
        ɵngcc0.ɵɵlistener("change", function SelectionTile_Template_input_change_2_listener($event) { return ctx.onChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div", 3);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(5, "svg", 4);
        ɵngcc0.ɵɵelement(6, "path", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelementStart(7, "div", 6);
        ɵngcc0.ɵɵprojection(8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("for", ctx.id)("ngClass", ɵngcc0.ɵɵpureFunction1(9, _c6, ctx.selected));
        ɵngcc0.ɵɵattribute("aria-label", ɵngcc0.ɵɵpipeBind1(1, 7, ctx.i18n.get("TILES.TILE")));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("id", ctx.id)("type", ctx.multiple ? "checkbox" : "radio")("value", ctx.value)("name", ctx.name);
    } }, directives: [ɵngcc4.NgClass], pipes: [ɵngcc4.AsyncPipe], encapsulation: 2 });
SelectionTile.tileCount = 0;
/** @nocollapse */
SelectionTile.ctorParameters = () => [
    { type: I18n }
];
SelectionTile.propDecorators = {
    id: [{ type: Input }],
    selected: [{ type: Input }],
    value: [{ type: Input }],
    change: [{ type: Output }],
    input: [{ type: ViewChild, args: ["input", { static: true },] }],
    keyboardInput: [{ type: HostListener, args: ["keydown", ["$event"],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SelectionTile, [{
        type: Component,
        args: [{
                selector: "ibm-selection-tile",
                template: `
		<label
			class="bx--tile bx--tile--selectable"
			tabindex="0"
			[for]="id"
			[ngClass]="{'bx--tile--is-selected' : selected}"
			[attr.aria-label]="i18n.get('TILES.TILE') | async">
			<input
				#input
				tabindex="-1"
				class="bx--tile-input"
				[id]="id"
				[type]="(multiple ? 'checkbox': 'radio')"
				[value]="value"
				[name]="name"
				(change)="onChange($event)"/>
			<div class="bx--tile__checkmark">
				<svg width="16" height="16" viewBox="0 0 16 16">
					<path d="M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16zm3.646-10.854L6.75 10.043 4.354 7.646l-.708.708 3.104 3.103 5.604-5.603-.708-.708z"
						fill-rule="evenodd"/>
				</svg>
			</div>
			<div class="bx--tile-content">
				<ng-content></ng-content>
			</div>
		</label>
	`
            }]
    }], function () { return [{ type: ɵngcc3.I18n }]; }, { id: [{
            type: Input
        }], change: [{
            type: Output
        }], selected: [{
            type: Input
        }], keyboardInput: [{
            type: HostListener,
            args: ["keydown", ["$event"]]
        }], value: [{
            type: Input
        }], input: [{
            type: ViewChild,
            args: ["input", { static: true }]
        }] }); })();

class TileGroup {
    constructor() {
        /**
         * The tile group `name`
         */
        this.name = `tile-group-${TileGroup.tileGroupCount}`;
        /**
         * Set to `true` to support multiple tile selection
         */
        this.multiple = false;
        /**
         * Emits an event when the tile selection changes.
         *
         * Emits an object that looks like:
         * ```javascript
         * {
         * 	value: "something",
         * 	selected: true,
         * 	name: "tile-group-1"
         * }
         * ```
         */
        this.selected = new EventEmitter();
        this.tileGroupClass = true;
        this.unsubscribe$ = new Subject();
        this.unsubscribeTiles$ = new Subject();
        this.onChange = (_) => { };
        this.onTouched = () => { };
        TileGroup.tileGroupCount++;
    }
    ngAfterContentInit() {
        const updateTiles = () => {
            // remove old subscriptions
            this.unsubscribeTiles$.next();
            // react to changes
            // setTimeout to avoid ExpressionChangedAfterItHasBeenCheckedError
            setTimeout(() => {
                this.selectionTiles.forEach(tile => {
                    tile.name = this.name;
                    tile.change
                        .pipe(takeUntil(this.unsubscribeTiles$))
                        .subscribe(() => {
                        this.selected.emit({
                            value: tile.value,
                            selected: tile.selected,
                            name: this.name
                        });
                        this.onChange(tile.value);
                    });
                    tile.multiple = this.multiple;
                });
            });
        };
        updateTiles();
        this.selectionTiles.changes
            .pipe(takeUntil(this.unsubscribe$))
            .subscribe(_ => updateTiles());
    }
    ngOnDestroy() {
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
        // takes care of tile subscriptions when tile-group dies
        this.unsubscribeTiles$.next();
        this.unsubscribeTiles$.complete();
    }
    writeValue(value) {
        if (!this.selectionTiles) {
            return;
        }
        this.selectionTiles.forEach(tile => {
            if (tile.value === value) {
                tile.selected = true;
            }
            else {
                tile.selected = false;
            }
        });
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
}
TileGroup.ɵfac = function TileGroup_Factory(t) { return new (t || TileGroup)(); };
TileGroup.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TileGroup, selectors: [["ibm-tile-group"]], contentQueries: function TileGroup_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, SelectionTile, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.selectionTiles = _t);
    } }, hostVars: 2, hostBindings: function TileGroup_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--tile-group", ctx.tileGroupClass);
    } }, inputs: { name: "name", multiple: "multiple" }, outputs: { selected: "selected" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: TileGroup,
                multi: true
            }
        ])], ngContentSelectors: _c8, decls: 1, vars: 0, template: function TileGroup_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c7);
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
TileGroup.tileGroupCount = 0;
/** @nocollapse */
TileGroup.ctorParameters = () => [];
TileGroup.propDecorators = {
    name: [{ type: Input }],
    multiple: [{ type: Input }],
    selected: [{ type: Output }],
    tileGroupClass: [{ type: HostBinding, args: ["class.bx--tile-group",] }],
    selectionTiles: [{ type: ContentChildren, args: [SelectionTile,] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TileGroup, [{
        type: Component,
        args: [{
                selector: "ibm-tile-group",
                template: `<ng-content select="ibm-selection-tile"></ng-content>`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: TileGroup,
                        multi: true
                    }
                ]
            }]
    }], function () { return []; }, { name: [{
            type: Input
        }], multiple: [{
            type: Input
        }], selected: [{
            type: Output
        }], tileGroupClass: [{
            type: HostBinding,
            args: ["class.bx--tile-group"]
        }], selectionTiles: [{
            type: ContentChildren,
            args: [SelectionTile]
        }] }); })();

/**
 * Build application's tiles using this component.
 *
 * [See demo](../../?path=/story/tiles--basic)
 *
 * ## Basic usage
 *
 * ```html
 * <ibm-tile>
 * 		tile content
 * </ibm-tile>
 * ```
 *
 * <example-url>../../iframe.html?id=tiles--basic</example-url>
 */
class Tile {
    constructor() {
        this.tileClass = true;
        this.theme = "dark";
    }
    get lightThemeEnabled() {
        return this.theme === "light";
    }
}
Tile.ɵfac = function Tile_Factory(t) { return new (t || Tile)(); };
Tile.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: Tile, selectors: [["ibm-tile"]], hostVars: 4, hostBindings: function Tile_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("bx--tile", ctx.tileClass)("bx--tile--light", ctx.lightThemeEnabled);
    } }, inputs: { theme: "theme" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Tile_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
Tile.propDecorators = {
    tileClass: [{ type: HostBinding, args: ["class.bx--tile",] }],
    lightThemeEnabled: [{ type: HostBinding, args: ["class.bx--tile--light",] }],
    theme: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Tile, [{
        type: Component,
        args: [{
                selector: "ibm-tile",
                template: `<ng-content></ng-content>`
            }]
    }], function () { return []; }, { tileClass: [{
            type: HostBinding,
            args: ["class.bx--tile"]
        }], theme: [{
            type: Input
        }], lightThemeEnabled: [{
            type: HostBinding,
            args: ["class.bx--tile--light"]
        }] }); })();

class TilesModule {
}
TilesModule.ɵfac = function TilesModule_Factory(t) { return new (t || TilesModule)(); };
TilesModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TilesModule });
TilesModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            I18nModule,
            LinkModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TilesModule, { declarations: function () { return [Tile, ClickableTile, ExpandableTile, SelectionTile, TileGroup]; }, imports: function () { return [CommonModule,
        I18nModule,
        LinkModule]; }, exports: function () { return [Tile, ClickableTile, ExpandableTile, SelectionTile, TileGroup]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TilesModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    Tile,
                    ClickableTile,
                    ExpandableTile,
                    SelectionTile,
                    TileGroup
                ],
                exports: [
                    Tile,
                    ClickableTile,
                    ExpandableTile,
                    SelectionTile,
                    TileGroup
                ],
                imports: [
                    CommonModule,
                    I18nModule,
                    LinkModule
                ]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { ClickableTile, ExpandableTile, SelectionTile, TileGroup, Tile, TilesModule };

//# sourceMappingURL=carbon-components-angular-tiles.js.map