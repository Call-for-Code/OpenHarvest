/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-tabs.umd.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs'), require('@angular/core'), require('@angular/common'), require('carbon-components-angular/utils')) :
    typeof define === 'function' && define.amd ? define('carbon-components-angular/tabs', ['exports', 'rxjs', '@angular/core', '@angular/common', 'carbon-components-angular/utils'], factory) :
    (factory((global['carbon-components-angular'] = global['carbon-components-angular'] || {}, global['carbon-components-angular'].tabs = {}),global.rxjs,global.ng.core,global.ng.common,global['carbon-components-angular'].utils));
}(this, (function (exports,rxjs,core,common,utils) { 'use strict';

    var TabHeader = /** @class */ (function () {
        function TabHeader() {
            /**
             * Indicates whether the `Tab` is active/selected.
             * Determines whether it's `TabPanel` is rendered.
             */
            this.active = false;
            /**
             * Indicates whether or not the `Tab` item is disabled.
             */
            this.disabled = false;
            /**
             * Value 'selected' to be emitted after a new `Tab` is selected.
             */
            this.selected = new core.EventEmitter();
            this._cacheActive = false;
        }
        Object.defineProperty(TabHeader.prototype, "cacheActive", {
            get: function () {
                return this._cacheActive;
            },
            /**
             * Set to 'true' to have pane reference cached and not reloaded on tab switching.
             */
            set: function (shouldCache) {
                this._cacheActive = shouldCache;
                // Updates the pane references associated with the tab header when cache active is changed.
                if (this.paneReference) {
                    this.paneReference.cacheActive = this.cacheActive;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabHeader.prototype, "paneTabIndex", {
            set: function (tabIndex) {
                if (this.paneReference) {
                    this.paneReference.tabIndex = tabIndex;
                }
            },
            enumerable: true,
            configurable: true
        });
        TabHeader.prototype.ngAfterViewInit = function () {
            var _this = this;
            setTimeout(function () {
                _this.title = _this.title ? _this.title : _this.tabItem.nativeElement.textContent;
            });
        };
        TabHeader.prototype.selectTab = function () {
            this.tabItem.nativeElement.focus();
            if (!this.disabled) {
                this.selected.emit();
                this.active = true;
                if (this.paneReference) {
                    this.paneReference.active = true;
                }
            }
        };
        TabHeader.decorators = [
            { type: core.Component, args: [{
                        selector: "ibm-tab-header",
                        template: "\n\t\t<li\n\t\t\t[ngClass]=\"{\n\t\t\t\t'bx--tabs__nav-item--selected bx--tabs--scrollable__nav-item--selected': active,\n\t\t\t\t'bx--tabs__nav-item--disabled bx--tabs--scrollable__nav-item--disabled': disabled\n\t\t\t}\"\n\t\t\tclass=\"bx--tabs--scrollable__nav-item\"\n\t\t\trole=\"presentation\"\n\t\t\t(click)=\"selectTab()\">\n\t\t\t<button\n\t\t\t\t#tabItem\n\t\t\t\t[attr.aria-selected]=\"active\"\n\t\t\t\tdraggable=\"false\"\n\t\t\t\tclass=\"bx--tabs--scrollable__nav-link\"\n\t\t\t\thref=\"javascript:void(0)\"\n\t\t\t\t[title]=\"title\"\n\t\t\t\t[attr.tabindex]=\"(active? 0 : -1)\"\n\t\t\t\trole=\"tab\">\n\t\t\t\t<ng-content></ng-content>\n\t\t\t</button>\n\t\t</li>\n\t"
                    }] }
        ];
        TabHeader.propDecorators = {
            active: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            paneReference: [{ type: core.Input }],
            title: [{ type: core.Input }],
            cacheActive: [{ type: core.Input }],
            paneTabIndex: [{ type: core.Input }],
            selected: [{ type: core.Output }],
            tabItem: [{ type: core.ViewChild, args: ["tabItem", { static: true },] }]
        };
        return TabHeader;
    }());

    var TabHeaderGroup = /** @class */ (function () {
        function TabHeaderGroup(elementRef, changeDetectorRef, eventService) {
            this.elementRef = elementRef;
            this.changeDetectorRef = changeDetectorRef;
            this.eventService = eventService;
            /**
             * Set to `true` to put tabs in a loading state.
             */
            this.skeleton = false;
            /**
             * Set to 'true' to have all pane references associated with each tab header
             * in the tab header group cached and not reloaded on tab switching.
             */
            this.cacheActive = false;
            this.isNavigation = false;
            this.type = "default";
            /**
             * Keeps track of all the subscriptions to the tab header selection events.
             */
            this.selectedSubscriptionTracker = new rxjs.Subscription();
            /**
             * Controls the manual focusing done by tabbing through headings.
             */
            this.currentSelectedIndex = 0;
            // width of the overflow buttons
            this.OVERFLOW_BUTTON_OFFSET = 40;
            this._cacheActive = false;
        }
        Object.defineProperty(TabHeaderGroup.prototype, "hasHorizontalOverflow", {
            get: function () {
                var tabList = this.headerContainer.nativeElement;
                return tabList.scrollWidth > tabList.clientWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabHeaderGroup.prototype, "leftOverflowNavButtonHidden", {
            get: function () {
                var tabList = this.headerContainer.nativeElement;
                return !this.hasHorizontalOverflow || !tabList.scrollLeft;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabHeaderGroup.prototype, "rightOverflowNavButtonHidden", {
            get: function () {
                var tabList = this.headerContainer.nativeElement;
                return !this.hasHorizontalOverflow ||
                    (tabList.scrollLeft + tabList.clientWidth) === tabList.scrollWidth;
            },
            enumerable: true,
            configurable: true
        });
        // keyboard accessibility
        /**
         * Controls the keydown events used for tabbing through the headings.
         */
        TabHeaderGroup.prototype.keyboardInput = function (event) {
            var tabHeadersArray = Array.from(this.tabHeaderQuery);
            if (event.key === "Right" || event.key === "ArrowRight") {
                if (this.currentSelectedIndex < tabHeadersArray.length - 1) {
                    event.preventDefault();
                    if (this.followFocus && !tabHeadersArray[this.currentSelectedIndex + 1].disabled) {
                        tabHeadersArray[this.currentSelectedIndex + 1].selectTab();
                    }
                    else {
                        tabHeadersArray[this.currentSelectedIndex + 1].tabItem.nativeElement.focus();
                        this.currentSelectedIndex++;
                    }
                }
                else {
                    event.preventDefault();
                    if (this.followFocus && !tabHeadersArray[0].disabled) {
                        tabHeadersArray[0].selectTab();
                    }
                    else {
                        tabHeadersArray[0].tabItem.nativeElement.focus();
                        this.currentSelectedIndex = 0;
                    }
                }
            }
            if (event.key === "Left" || event.key === "ArrowLeft") {
                if (this.currentSelectedIndex > 0) {
                    event.preventDefault();
                    if (this.followFocus && !tabHeadersArray[this.currentSelectedIndex - 1].disabled) {
                        tabHeadersArray[this.currentSelectedIndex - 1].selectTab();
                    }
                    else {
                        tabHeadersArray[this.currentSelectedIndex - 1].tabItem.nativeElement.focus();
                        this.currentSelectedIndex--;
                    }
                }
                else {
                    event.preventDefault();
                    if (this.followFocus && !tabHeadersArray[tabHeadersArray.length - 1].disabled) {
                        tabHeadersArray[tabHeadersArray.length - 1].selectTab();
                    }
                    else {
                        tabHeadersArray[tabHeadersArray.length - 1].tabItem.nativeElement.focus();
                        this.currentSelectedIndex = tabHeadersArray.length - 1;
                    }
                }
            }
            if (event.key === "Home") {
                event.preventDefault();
                if (this.followFocus && !tabHeadersArray[0].disabled) {
                    tabHeadersArray[0].selectTab();
                }
                else {
                    tabHeadersArray[0].tabItem.nativeElement.focus();
                    this.currentSelectedIndex = 0;
                }
            }
            if (event.key === "End") {
                event.preventDefault();
                if (this.followFocus && !tabHeadersArray[tabHeadersArray.length - 1].disabled) {
                    tabHeadersArray[tabHeadersArray.length - 1].selectTab();
                }
                else {
                    tabHeadersArray[tabHeadersArray.length - 1].tabItem.nativeElement.focus();
                    this.currentSelectedIndex = tabHeadersArray.length - 1;
                }
            }
            // `"Spacebar"` is IE11 specific value
            if ((event.key === " " || event.key === "Spacebar") && !this.followFocus) {
                tabHeadersArray[this.currentSelectedIndex].selectTab();
            }
        };
        TabHeaderGroup.prototype.ngOnInit = function () {
            var _this = this;
            this.eventService.on(window, "resize", function () { return _this.handleScroll(); });
        };
        TabHeaderGroup.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.selectedSubscriptionTracker.unsubscribe();
            if (this.tabHeaderQuery) {
                this.tabHeaderQuery.toArray()
                    .forEach(function (tabHeader) {
                    tabHeader.cacheActive = _this.cacheActive;
                    tabHeader.paneTabIndex = _this.isNavigation ? null : 0;
                });
            }
            var selectedSubscriptions = this.tabHeaderQuery.toArray().forEach(function (tabHeader) {
                tabHeader.selected.subscribe(function () {
                    _this.currentSelectedIndex = _this.tabHeaderQuery.toArray().indexOf(tabHeader);
                    // The Filter takes the current selected tab out, then all other headers are
                    // deactivated and their associated pane references are also deactivated.
                    _this.tabHeaderQuery.toArray().filter(function (header) { return header !== tabHeader; })
                        .forEach(function (filteredHeader) {
                        filteredHeader.active = false;
                        if (filteredHeader.paneReference) {
                            filteredHeader.paneReference.active = false;
                        }
                    });
                });
            });
            this.selectedSubscriptionTracker.add(selectedSubscriptions);
            setTimeout(function () { return _this.tabHeaderQuery.toArray()[_this.currentSelectedIndex].selectTab(); });
        };
        TabHeaderGroup.prototype.ngOnChanges = function (changes) {
            var _this = this;
            if (this.tabHeaderQuery) {
                if (changes.cacheActive) {
                    this.tabHeaderQuery.toArray().forEach(function (tabHeader) { return tabHeader.cacheActive = _this.cacheActive; });
                }
                if (changes.isNavigation) {
                    this.tabHeaderQuery.toArray()
                        .forEach(function (tabHeader) { return tabHeader.paneTabIndex = _this.isNavigation ? null : 0; });
                }
            }
        };
        TabHeaderGroup.prototype.getSelectedTab = function () {
            var selected = this.tabHeaderQuery.toArray()[this.currentSelectedIndex];
            if (selected) {
                return selected;
            }
            return {
                headingIsTemplate: false,
                heading: ""
            };
        };
        TabHeaderGroup.prototype.handleScroll = function () {
            this.changeDetectorRef.markForCheck();
        };
        TabHeaderGroup.prototype.handleOverflowNavClick = function (direction, multiplier) {
            if (multiplier === void 0) {
                multiplier = 15;
            }
            var tabList = this.headerContainer.nativeElement;
            var clientWidth = tabList.clientWidth, scrollLeft = tabList.scrollLeft, scrollWidth = tabList.scrollWidth;
            if (direction === 1 && !scrollLeft) {
                tabList.scrollLeft += this.OVERFLOW_BUTTON_OFFSET;
            }
            tabList.scrollLeft += direction * multiplier;
            var leftEdgeReached = direction === -1 && scrollLeft < this.OVERFLOW_BUTTON_OFFSET;
            var rightEdgeReached = direction === 1 &&
                scrollLeft + clientWidth >= scrollWidth - this.OVERFLOW_BUTTON_OFFSET;
            if (leftEdgeReached) {
                this.rightOverflowNavButton.nativeElement.focus();
            }
            if (rightEdgeReached) {
                this.leftOverflowNavButton.nativeElement.focus();
            }
        };
        TabHeaderGroup.prototype.handleOverflowNavMouseDown = function (direction) {
            var _this = this;
            var tabList = this.headerContainer.nativeElement;
            this.overflowNavInterval = setInterval(function () {
                var clientWidth = tabList.clientWidth, scrollLeft = tabList.scrollLeft, scrollWidth = tabList.scrollWidth;
                // clear interval if scroll reaches left or right edge
                var leftEdgeReached = direction === -1 && scrollLeft < _this.OVERFLOW_BUTTON_OFFSET;
                var rightEdgeReached = direction === 1 &&
                    scrollLeft + clientWidth >= scrollWidth - _this.OVERFLOW_BUTTON_OFFSET;
                if (leftEdgeReached || rightEdgeReached) {
                    clearInterval(_this.overflowNavInterval);
                }
                // account for overflow button appearing and causing tablist width change
                _this.handleOverflowNavClick(direction);
            });
        };
        TabHeaderGroup.prototype.handleOverflowNavMouseUp = function () {
            clearInterval(this.overflowNavInterval);
        };
        TabHeaderGroup.decorators = [
            { type: core.Component, args: [{
                        selector: "ibm-tab-header-group",
                        template: "\n\t<nav\n\t\tclass=\"bx--tabs bx--tabs--scrollable\"\n\t\t[ngClass]=\"{\n\t\t\t'bx--skeleton': skeleton,\n\t\t\t'bx--tabs--container bx--tabs--scrollable--container': type === 'container'\n\t\t}\"\n\t\trole=\"navigation\"\n\t\t[attr.aria-label]=\"ariaLabel\"\n\t\t[attr.aria-labelledby]=\"ariaLabelledby\">\n\t\t<button\n\t\t\t#leftOverflowNavButton\n\t\t\ttype=\"button\"\n\t\t\t[ngClass]=\"{\n\t\t\t\t'bx--tab--overflow-nav-button': hasHorizontalOverflow,\n\t\t\t\t'bx--tab--overflow-nav-button--hidden': leftOverflowNavButtonHidden\n\t\t\t}\"\n\t\t\t(click)=\"handleOverflowNavClick(-1)\"\n\t\t\t(mousedown)=\"handleOverflowNavMouseDown(-1)\"\n\t\t\t(mouseup)=\"handleOverflowNavMouseUp()\">\n\t\t\t<svg\n\t\t\t\tfocusable=\"false\"\n\t\t\t\tpreserveAspectRatio=\"xMidYMid meet\"\n\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\t\tfill=\"currentColor\"\n\t\t\t\twidth=\"16\"\n\t\t\t\theight=\"16\"\n\t\t\t\tviewBox=\"0 0 16 16\"\n\t\t\t\taria-hidden=\"true\">\n\t\t\t\t<path d=\"M5 8L10 3 10.7 3.7 6.4 8 10.7 12.3 10 13z\"></path>\n\t\t\t</svg>\n\t\t</button>\n\t\t<div *ngIf=\"!leftOverflowNavButtonHidden\" class=\"bx--tabs__overflow-indicator--left\"></div>\n\t\t<ul\n\t\t\t#tabList\n\t\t\tclass=\"bx--tabs--scrollable__nav\"\n\t\t\trole=\"tablist\"\n\t\t\t(scroll)=\"handleScroll()\">\n\t\t\t<li role=\"presentation\">\n\t\t\t\t<ng-container *ngIf=\"contentBefore\" [ngTemplateOutlet]=\"contentBefore\"></ng-container>\n\t\t\t</li>\n\t\t\t<ng-content></ng-content>\n\t\t\t<li role=\"presentation\">\n\t\t\t\t<ng-container *ngIf=\"contentAfter\" [ngTemplateOutlet]=\"contentAfter\"></ng-container>\n\t\t\t</li>\n\t\t</ul>\n\t\t<div *ngIf=\"!rightOverflowNavButtonHidden\" class=\"bx--tabs__overflow-indicator--right\"></div>\n\t\t<button\n\t\t\t#rightOverflowNavButton\n\t\t\ttype=\"button\"\n\t\t\t[ngClass]=\"{\n\t\t\t\t'bx--tab--overflow-nav-button': hasHorizontalOverflow,\n\t\t\t\t'bx--tab--overflow-nav-button--hidden': rightOverflowNavButtonHidden\n\t\t\t}\"\n\t\t\t(click)=\"handleOverflowNavClick(1)\"\n\t\t\t(mousedown)=\"handleOverflowNavMouseDown(1)\"\n\t\t\t(mouseup)=\"handleOverflowNavMouseUp()\">\n\t\t\t<svg\n\t\t\t\tfocusable=\"false\"\n\t\t\t\tpreserveAspectRatio=\"xMidYMid meet\"\n\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\t\tfill=\"currentColor\"\n\t\t\t\twidth=\"16\"\n\t\t\t\theight=\"16\"\n\t\t\t\tviewBox=\"0 0 16 16\"\n\t\t\t\taria-hidden=\"true\">\n\t\t\t\t<path d=\"M11 8L6 13 5.3 12.3 9.6 8 5.3 3.7 6 3z\"></path>\n\t\t\t</svg>\n\t\t</button>\n\t</nav>\n\t"
                    }] }
        ];
        /** @nocollapse */
        TabHeaderGroup.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.ChangeDetectorRef },
                { type: utils.EventService }
            ];
        };
        TabHeaderGroup.propDecorators = {
            followFocus: [{ type: core.Input }],
            skeleton: [{ type: core.Input }],
            ariaLabel: [{ type: core.Input }],
            ariaLabelledby: [{ type: core.Input }],
            contentAfter: [{ type: core.Input }],
            contentBefore: [{ type: core.Input }],
            cacheActive: [{ type: core.Input }],
            isNavigation: [{ type: core.Input }],
            type: [{ type: core.Input }],
            tabHeaderQuery: [{ type: core.ContentChildren, args: [TabHeader,] }],
            headerContainer: [{ type: core.ViewChild, args: ["tabList", { static: true },] }],
            rightOverflowNavButton: [{ type: core.ViewChild, args: ["rightOverflowNavButton", { static: true },] }],
            leftOverflowNavButton: [{ type: core.ViewChild, args: ["leftOverflowNavButton", { static: true },] }],
            keyboardInput: [{ type: core.HostListener, args: ["keydown", ["$event"],] }]
        };
        return TabHeaderGroup;
    }());

    var nextId = 0;
    /**
    * The `Tab` component is a child of the `Tabs` component.
    * It represents one `Tab` item and its content within a panel of other `Tab` items.
    *
    *
    * `Tab` takes a string or `TemplateRef` for the header, and any content for the body of the tab.
    * Disabled states should be handled by the application (ie. switch to the tab, but display some
    * indication as to _why_ the tab is disabled).
    *
    * When the tab is selected the `select` output will be triggered.
    * The `select` output will also be triggered for the active tab when the tabs are loaded or updated.
    *
    *
    * Tab with string header:
    *
    * ```html
    * <ibm-tab heading='tab1'>
    * 	tab 1 content
    * </ibm-tab>
    * ```
    *
    * Tab with custom header:
    *
    * ```html
    * <ng-template #tabHeading>
    * 	<svg ibmIcon="facebook"
    * 		size="sm"
    * 		style="margin-right: 7px;">
    * 	</svg>
    * 	Hello Tab 1
    * </ng-template>
    * <ibm-tabs>
    * 	<ibm-tab [heading]="tabHeading">
    * 		Tab 1 content <svg ibmIcon="alert" size="lg"></svg>
    * 	</ibm-tab>
    * 	<ibm-tab heading='Tab2'>
    * 		Tab 2 content
    * 	</ibm-tab>
    * 	<ibm-tab heading='Tab3'>
    * 		Tab 3 content
    * 	</ibm-tab>
    * </ibm-tabs>
    * ```
    */
    var Tab = /** @class */ (function () {
        function Tab() {
            /**
             * Boolean value reflects if the `Tab` is using a custom template for the heading.
             * Default value is false.
             */
            this.headingIsTemplate = false;
            /**
             * Indicates whether the `Tab` is active/selected.
             * Determines whether it's `TabPanel` is rendered.
             */
            this.active = false;
            /**
             * Indicates whether or not the `Tab` item is disabled.
             */
            this.disabled = false;
            this.tabIndex = 0;
            // do we need id's?
            /**
             * Sets the id of the `Tab`. Will be uniquely generated if not provided.
             */
            this.id = "n-tab-" + nextId++;
            /**
             * Value 'selected' to be emitted after a new `Tab` is selected.
             */
            this.selected = new core.EventEmitter();
            /**
             * Used to set the id property on the element.
             */
            this.attrClass = this.id;
            this._cacheActive = false;
        }
        Object.defineProperty(Tab.prototype, "cacheActive", {
            get: function () {
                return this._cacheActive;
            },
            /**
             * Set to true to have Tab items cached and not reloaded on tab switching.
             */
            set: function (shouldCache) {
                this._cacheActive = shouldCache;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Checks for custom heading template on initialization and updates the value
         * of the boolean 'headingIsTemplate'.
         */
        Tab.prototype.ngOnInit = function () {
            if (this.heading instanceof core.TemplateRef) {
                this.headingIsTemplate = true;
            }
        };
        /**
         * Emit the status of the `Tab`, specifically 'select' and 'selected' properties.
         */
        Tab.prototype.doSelect = function () {
            this.selected.emit();
        };
        /**
        * Returns value indicating whether this `Tab` should be rendered in a `TabPanel`.
        */
        Tab.prototype.shouldRender = function () {
            return this.active || this.cacheActive;
        };
        Tab.decorators = [
            { type: core.Component, args: [{
                        selector: "ibm-tab",
                        template: "\n\t\t<div\n\t\t\t[attr.tabindex]=\"tabIndex\"\n\t\t\trole=\"tabpanel\"\n\t\t\t*ngIf=\"shouldRender()\"\n\t\t\tclass=\"bx--tab-content\"\n\t\t\t[ngStyle]=\"{'display': active ? null : 'none'}\"\n\t\t\t[attr.aria-labelledby]=\"id + '-header'\"\n\t\t\taria-live=\"polite\">\n\t\t\t<ng-content></ng-content>\n\t\t</div>\n\t"
                    }] }
        ];
        Tab.propDecorators = {
            heading: [{ type: core.Input }],
            title: [{ type: core.Input }],
            context: [{ type: core.Input }],
            active: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            tabIndex: [{ type: core.Input }],
            id: [{ type: core.Input }],
            cacheActive: [{ type: core.Input }],
            selected: [{ type: core.Output }],
            attrClass: [{ type: core.HostBinding, args: ["attr.id",] }]
        };
        return Tab;
    }());

    /**
     * The `TabHeaders` component contains the `Tab` items and controls scroll functionality
     * if content has overflow.
     */
    var TabHeaders = /** @class */ (function () {
        function TabHeaders(elementRef, changeDetectorRef, eventService) {
            this.elementRef = elementRef;
            this.changeDetectorRef = changeDetectorRef;
            this.eventService = eventService;
            /**
             * Set to 'true' to have `Tab` items cached and not reloaded on tab switching.
             * Duplicate from `n-tabs` to support standalone headers
             */
            this.cacheActive = false;
            /**
             * Set to `true` to put tabs in a loading state.
             */
            this.skeleton = false;
            this.type = "default";
            /**
             * The index of the first visible tab.
             */
            this.firstVisibleTab = 0;
            // width of the overflow buttons
            this.OVERFLOW_BUTTON_OFFSET = 40;
        }
        Object.defineProperty(TabHeaders.prototype, "hasHorizontalOverflow", {
            get: function () {
                var tabList = this.headerContainer.nativeElement;
                return tabList.scrollWidth > tabList.clientWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabHeaders.prototype, "leftOverflowNavButtonHidden", {
            get: function () {
                var tabList = this.headerContainer.nativeElement;
                return !this.hasHorizontalOverflow || !tabList.scrollLeft;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabHeaders.prototype, "rightOverflowNavButtonHidden", {
            get: function () {
                var tabList = this.headerContainer.nativeElement;
                return !this.hasHorizontalOverflow ||
                    (tabList.scrollLeft + tabList.clientWidth) === tabList.scrollWidth;
            },
            enumerable: true,
            configurable: true
        });
        // keyboard accessibility
        /**
         * Controls the keydown events used for tabbing through the headings.
         */
        TabHeaders.prototype.keyboardInput = function (event) {
            var tabsArray = Array.from(this.tabs);
            // "Right" is an ie11 specific value
            if (event.key === "Right" || event.key === "ArrowRight") {
                if (this.currentSelectedTab < this.allTabHeaders.length - 1) {
                    event.preventDefault();
                    if (this.followFocus) {
                        this.selectTab(event.target, tabsArray[this.currentSelectedTab + 1], this.currentSelectedTab);
                    }
                    this.allTabHeaders.toArray()[this.currentSelectedTab + 1].nativeElement.focus();
                }
                else {
                    event.preventDefault();
                    if (this.followFocus) {
                        this.selectTab(event.target, tabsArray[0], 0);
                    }
                    this.allTabHeaders.first.nativeElement.focus();
                }
            }
            // "Left" is an ie11 specific value
            if (event.key === "Left" || event.key === "ArrowLeft") {
                if (this.currentSelectedTab > 0) {
                    event.preventDefault();
                    if (this.followFocus) {
                        this.selectTab(event.target, tabsArray[this.currentSelectedTab - 1], this.currentSelectedTab);
                    }
                    this.allTabHeaders.toArray()[this.currentSelectedTab - 1].nativeElement.focus();
                }
                else {
                    event.preventDefault();
                    if (this.followFocus) {
                        this.selectTab(event.target, tabsArray[this.allTabHeaders.length - 1], this.allTabHeaders.length);
                    }
                    this.allTabHeaders.toArray()[this.allTabHeaders.length - 1].nativeElement.focus();
                }
            }
            if (event.key === "Home") {
                event.preventDefault();
                if (this.followFocus) {
                    this.selectTab(event.target, tabsArray[0], 0);
                }
                this.allTabHeaders.toArray()[0].nativeElement.focus();
            }
            if (event.key === "End") {
                event.preventDefault();
                if (this.followFocus) {
                    this.selectTab(event.target, tabsArray[this.allTabHeaders.length - 1], this.allTabHeaders.length);
                }
                this.allTabHeaders.toArray()[this.allTabHeaders.length - 1].nativeElement.focus();
            }
            // `"Spacebar"` is IE11 specific value
            if ((event.key === " " || event.key === "Spacebar") && !this.followFocus) {
                this.selectTab(event.target, tabsArray[this.currentSelectedTab], this.currentSelectedTab);
            }
        };
        TabHeaders.prototype.ngOnInit = function () {
            var _this = this;
            this.eventService.on(window, "resize", function () { return _this.handleScroll(); });
        };
        TabHeaders.prototype.ngAfterContentInit = function () {
            var _this = this;
            if (!this.tabInput) {
                this.tabs = this.tabQuery;
            }
            else {
                this.tabs = this.tabInput;
            }
            this.tabs.forEach(function (tab) { return tab.cacheActive = _this.cacheActive; });
            this.tabs.changes.subscribe(function () {
                _this.setFirstTab();
            });
            this.setFirstTab();
        };
        TabHeaders.prototype.ngOnChanges = function (changes) {
            var _this = this;
            if (this.tabs && changes.cacheActive) {
                this.tabs.forEach(function (tab) { return tab.cacheActive = _this.cacheActive; });
            }
        };
        /**
         * Controls manually focusing tabs.
         */
        TabHeaders.prototype.onTabFocus = function (ref, index) {
            this.currentSelectedTab = index;
            // reset scroll left because we're already handling it
            this.headerContainer.nativeElement.parentElement.scrollLeft = 0;
        };
        TabHeaders.prototype.getSelectedTab = function () {
            var selected = this.tabs.find(function (tab) { return tab.active; });
            if (selected) {
                return selected;
            }
            return { headingIsTemplate: false, heading: "" };
        };
        /**
         * Selects `Tab` 'tab' and moves it into view on the view DOM if it is not already.
         */
        TabHeaders.prototype.selectTab = function (ref, tab, tabIndex) {
            if (tab.disabled) {
                return;
            }
            this.currentSelectedTab = tabIndex;
            this.tabs.forEach(function (_tab) { return _tab.active = false; });
            tab.active = true;
            tab.doSelect();
        };
        TabHeaders.prototype.handleScroll = function () {
            this.changeDetectorRef.markForCheck();
        };
        TabHeaders.prototype.handleOverflowNavClick = function (direction, multiplier) {
            if (multiplier === void 0) {
                multiplier = 15;
            }
            var tabList = this.headerContainer.nativeElement;
            var clientWidth = tabList.clientWidth, scrollLeft = tabList.scrollLeft, scrollWidth = tabList.scrollWidth;
            if (direction === 1 && !scrollLeft) {
                tabList.scrollLeft += this.OVERFLOW_BUTTON_OFFSET;
            }
            tabList.scrollLeft += direction * multiplier;
            var leftEdgeReached = direction === -1 && scrollLeft < this.OVERFLOW_BUTTON_OFFSET;
            var rightEdgeReached = direction === 1 &&
                scrollLeft + clientWidth >= scrollWidth - this.OVERFLOW_BUTTON_OFFSET;
            if (leftEdgeReached) {
                this.rightOverflowNavButton.nativeElement.focus();
            }
            if (rightEdgeReached) {
                this.leftOverflowNavButton.nativeElement.focus();
            }
        };
        TabHeaders.prototype.handleOverflowNavMouseDown = function (direction) {
            var _this = this;
            var tabList = this.headerContainer.nativeElement;
            this.overflowNavInterval = setInterval(function () {
                var clientWidth = tabList.clientWidth, scrollLeft = tabList.scrollLeft, scrollWidth = tabList.scrollWidth;
                // clear interval if scroll reaches left or right edge
                var leftEdgeReached = direction === -1 && scrollLeft < _this.OVERFLOW_BUTTON_OFFSET;
                var rightEdgeReached = direction === 1 &&
                    scrollLeft + clientWidth >= scrollWidth - _this.OVERFLOW_BUTTON_OFFSET;
                if (leftEdgeReached || rightEdgeReached) {
                    clearInterval(_this.overflowNavInterval);
                }
                // account for overflow button appearing and causing tablist width change
                _this.handleOverflowNavClick(direction);
            });
        };
        TabHeaders.prototype.handleOverflowNavMouseUp = function () {
            clearInterval(this.overflowNavInterval);
        };
        /**
         * Determines which `Tab` is initially selected.
         */
        TabHeaders.prototype.setFirstTab = function () {
            var _this = this;
            setTimeout(function () {
                var firstTab = _this.tabs.find(function (tab) { return tab.active; });
                if (!firstTab && _this.tabs.first) {
                    firstTab = _this.tabs.first;
                    firstTab.active = true;
                }
                if (firstTab) {
                    firstTab.doSelect();
                }
            });
        };
        TabHeaders.decorators = [
            { type: core.Component, args: [{
                        selector: "ibm-tab-headers",
                        template: "\n\t\t<nav\n\t\t\tclass=\"bx--tabs--scrollable\"\n\t\t\t[ngClass]=\"{\n\t\t\t\t'bx--skeleton': skeleton,\n\t\t\t\t'bx--tabs--container bx--tabs--scrollable--container': type === 'container'\n\t\t\t}\"\n\t\t\trole=\"navigation\"\n\t\t\t[attr.aria-label]=\"ariaLabel\"\n\t\t\t[attr.aria-labelledby]=\"ariaLabelledby\">\n\t\t\t<button\n\t\t\t\t#leftOverflowNavButton\n\t\t\t\ttype=\"button\"\n\t\t\t\t[ngClass]=\"{\n\t\t\t\t\t'bx--tab--overflow-nav-button': hasHorizontalOverflow,\n\t\t\t\t\t'bx--tab--overflow-nav-button--hidden': leftOverflowNavButtonHidden\n\t\t\t\t}\"\n\t\t\t\t(click)=\"handleOverflowNavClick(-1)\"\n\t\t\t\t(mousedown)=\"handleOverflowNavMouseDown(-1)\"\n\t\t\t\t(mouseup)=\"handleOverflowNavMouseUp()\">\n\t\t\t\t<svg\n\t\t\t\t\tfocusable=\"false\"\n\t\t\t\t\tpreserveAspectRatio=\"xMidYMid meet\"\n\t\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\t\t\tfill=\"currentColor\"\n\t\t\t\t\twidth=\"16\"\n\t\t\t\t\theight=\"16\"\n\t\t\t\t\tviewBox=\"0 0 16 16\"\n\t\t\t\t\taria-hidden=\"true\">\n\t\t\t\t\t<path d=\"M5 8L10 3 10.7 3.7 6.4 8 10.7 12.3 10 13z\"></path>\n\t\t\t\t</svg>\n\t\t\t</button>\n\t\t\t<div *ngIf=\"!leftOverflowNavButtonHidden\" class=\"bx--tabs__overflow-indicator--left\"></div>\n\t\t\t<ul\n\t\t\t\t#tabList\n\t\t\t\tclass=\"bx--tabs--scrollable__nav\"\n\t\t\t\trole=\"tablist\"\n\t\t\t\t(scroll)=\"handleScroll()\">\n\t\t\t\t<li role=\"presentation\">\n\t\t\t\t\t<ng-container *ngIf=\"contentBefore\" [ngTemplateOutlet]=\"contentBefore\"></ng-container>\n\t\t\t\t</li>\n\t\t\t\t<li\n\t\t\t\t\t*ngFor=\"let tab of tabs; let i = index;\"\n\t\t\t\t\t[ngClass]=\"{\n\t\t\t\t\t\t'bx--tabs__nav-item--selected bx--tabs--scrollable__nav-item--selected': tab.active,\n\t\t\t\t\t\t'bx--tabs__nav-item--disabled bx--tabs--scrollable__nav-item--disabled': tab.disabled\n\t\t\t\t\t}\"\n\t\t\t\t\tclass=\"bx--tabs--scrollable__nav-item\"\n\t\t\t\t\trole=\"presentation\"\n\t\t\t\t\t(click)=\"selectTab(tabItem, tab, i)\">\n\t\t\t\t\t<button\n\t\t\t\t\t\t#tabItem\n\t\t\t\t\t\t[attr.aria-selected]=\"tab.active\"\n\t\t\t\t\t\t[attr.tabindex]=\"(tab.active?0:-1)\"\n\t\t\t\t\t\t[attr.aria-controls]=\"tab.id\"\n\t\t\t\t\t\t[attr.aria-disabled]=\"tab.disabled\"\n\t\t\t\t\t\t(focus)=\"onTabFocus(tabItem, i)\"\n\t\t\t\t\t\t(click)=\"$event.preventDefault()\"\n\t\t\t\t\t\tdraggable=\"false\"\n\t\t\t\t\t\tid=\"{{tab.id}}-header\"\n\t\t\t\t\t\tclass=\"bx--tabs--scrollable__nav-link\"\n\t\t\t\t\t\t[title]=\"tab.title ? tab.title : tab.heading\"\n\t\t\t\t\t\thref=\"#\"\n\t\t\t\t\t\trole=\"tab\">\n\t\t\t\t\t\t<ng-container *ngIf=\"!tab.headingIsTemplate\">\n\t\t\t\t\t\t\t{{ tab.heading }}\n\t\t\t\t\t\t</ng-container>\n\t\t\t\t\t\t<ng-template\n\t\t\t\t\t\t\t*ngIf=\"tab.headingIsTemplate\"\n\t\t\t\t\t\t\t[ngTemplateOutlet]=\"tab.heading\"\n\t\t\t\t\t\t\t[ngTemplateOutletContext]=\"{$implicit: tab.context}\">\n\t\t\t\t\t\t</ng-template>\n\t\t\t\t\t</button>\n\t\t\t\t</li>\n\t\t\t\t<li role=\"presentation\">\n\t\t\t\t\t<ng-container *ngIf=\"contentAfter\" [ngTemplateOutlet]=\"contentAfter\"></ng-container>\n\t\t\t\t</li>\n\t\t\t</ul>\n\t\t\t<div *ngIf=\"!rightOverflowNavButtonHidden\" class=\"bx--tabs__overflow-indicator--right\"></div>\n\t\t\t<button\n\t\t\t\t#rightOverflowNavButton\n\t\t\t\ttype=\"button\"\n\t\t\t\t[ngClass]=\"{\n\t\t\t\t\t'bx--tab--overflow-nav-button': hasHorizontalOverflow,\n\t\t\t\t\t'bx--tab--overflow-nav-button--hidden': rightOverflowNavButtonHidden\n\t\t\t\t}\"\n\t\t\t\t(click)=\"handleOverflowNavClick(1)\"\n\t\t\t\t(mousedown)=\"handleOverflowNavMouseDown(1)\"\n\t\t\t\t(mouseup)=\"handleOverflowNavMouseUp()\">\n\t\t\t\t<svg\n\t\t\t\t\tfocusable=\"false\"\n\t\t\t\t\tpreserveAspectRatio=\"xMidYMid meet\"\n\t\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\t\t\tfill=\"currentColor\"\n\t\t\t\t\twidth=\"16\"\n\t\t\t\t\theight=\"16\"\n\t\t\t\t\tviewBox=\"0 0 16 16\"\n\t\t\t\t\taria-hidden=\"true\">\n\t\t\t\t\t<path d=\"M11 8L6 13 5.3 12.3 9.6 8 5.3 3.7 6 3z\"></path>\n\t\t\t\t</svg>\n\t\t\t</button>\n\t\t</nav>\n\t"
                    }] }
        ];
        /** @nocollapse */
        TabHeaders.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.ChangeDetectorRef },
                { type: utils.EventService }
            ];
        };
        TabHeaders.propDecorators = {
            tabInput: [{ type: core.Input, args: ["tabs",] }],
            cacheActive: [{ type: core.Input }],
            followFocus: [{ type: core.Input }],
            skeleton: [{ type: core.Input }],
            ariaLabel: [{ type: core.Input }],
            ariaLabelledby: [{ type: core.Input }],
            contentBefore: [{ type: core.Input }],
            contentAfter: [{ type: core.Input }],
            type: [{ type: core.Input }],
            headerContainer: [{ type: core.ViewChild, args: ["tabList", { static: true },] }],
            rightOverflowNavButton: [{ type: core.ViewChild, args: ["rightOverflowNavButton", { static: true },] }],
            leftOverflowNavButton: [{ type: core.ViewChild, args: ["leftOverflowNavButton", { static: true },] }],
            tabQuery: [{ type: core.ContentChildren, args: [Tab,] }],
            allTabHeaders: [{ type: core.ViewChildren, args: ["tabItem",] }],
            keyboardInput: [{ type: core.HostListener, args: ["keydown", ["$event"],] }]
        };
        return TabHeaders;
    }());

    /**
     * Build out your application's tabs using this component.
     * This is the parent of the `Tab` and `TabHeader` components.
     *
     * [See demo](../../?path=/story/tabs--basic)
     *
     * `Tabs` expects a set of `n-tab` elements
     *
     * ```html
     * <ibm-tabs>
     * 	<ibm-tab heading='tab1'>
     * 		tab 1 content
     * 	</ibm-tab>
     * 	<ibm-tab heading='tab1'>
     * 		tab 2 content
     * 	</ibm-tab>
     * 	<!-- ... -->
     * 	<ibm-tab heading='tab1'>
     * 		tab n content
     * 	</ibm-tab>
     * </ibm-tabs>
     * ```
     *
     * <example-url>../../iframe.html?id=tabs--basic</example-url>
     */
    var Tabs = /** @class */ (function () {
        function Tabs() {
            /**
             * Takes either the string value 'top' or 'bottom' to place TabHeader
             * relative to the `TabPanel`s.
             */
            this.position = "top";
            /**
             * Set to 'true' to have `Tab` items cached and not reloaded on tab switching.
             */
            this.cacheActive = false;
            /**
             * Set to 'true' to have tabs automatically activated and have their content displayed when they receive focus.
             */
            this.followFocus = true;
            /**
             * Set to `true` to put tabs in a loading state.
             */
            this.skeleton = false;
            /**
             * Set to `true` to have the tabIndex of the all tabpanels be -1.
             */
            this.isNavigation = false;
            /**
             * Sets the type of the `TabHeader`s
             */
            this.type = "default";
        }
        /**
         * After content is initialized update `Tab`s to cache (if turned on) and set the initial
         * selected Tab item.
         */
        Tabs.prototype.ngAfterContentInit = function () {
            var _this = this;
            if (this.tabHeaders) {
                this.tabHeaders.cacheActive = this.cacheActive;
            }
            this.tabs.forEach(function (tab) {
                tab.tabIndex = _this.isNavigation ? null : 0;
            });
        };
        Tabs.prototype.ngOnChanges = function (changes) {
            var _this = this;
            if (this.tabHeaders && changes.cacheActive) {
                this.tabHeaders.cacheActive = this.cacheActive;
            }
            if (this.tabs && changes.isNavigation) {
                this.tabs.forEach(function (tab) {
                    tab.tabIndex = _this.isNavigation ? null : 0;
                });
            }
        };
        /**
         * true if the n-tab's are passed directly to the component as children
         */
        Tabs.prototype.hasTabHeaders = function () {
            return this.tabs.length > 0;
        };
        Tabs.decorators = [
            { type: core.Component, args: [{
                        selector: "ibm-tabs",
                        template: "\n\t\t\t<ibm-tab-headers\n\t\t\t\t*ngIf=\"hasTabHeaders() && position === 'top'\"\n\t\t\t\t[skeleton]=\"skeleton\"\n\t\t\t\t[tabs]=\"tabs\"\n\t\t\t\t[followFocus]=\"followFocus\"\n\t\t\t\t[cacheActive]=\"cacheActive\"\n\t\t\t\t[contentBefore]=\"before\"\n\t\t\t\t[contentAfter]=\"after\"\n\t\t\t\t[ariaLabel]=\"ariaLabel\"\n\t\t\t\t[ariaLabelledby]=\"ariaLabelledby\"\n\t\t\t\t[type]=\"type\">\n\t\t\t</ibm-tab-headers>\n\t\t\t<ng-content></ng-content>\n\t\t\t<ng-template #before>\n\t\t\t\t<ng-content select=\"[before]\"></ng-content>\n\t\t\t</ng-template>\n\t\t\t<ng-template #after>\n\t\t\t\t<ng-content select=\"[after]\"></ng-content>\n\t\t\t</ng-template>\n\t\t\t<ibm-tab-headers\n\t\t\t\t*ngIf=\"hasTabHeaders() && position === 'bottom'\"\n\t\t\t\t[skeleton]=\"skeleton\"\n\t\t\t\t[tabs]=\"tabs\"\n\t\t\t\t[cacheActive]=\"cacheActive\"\n\t\t\t\t[type]=\"type\">\n\t\t\t</ibm-tab-headers>\n\t"
                    }] }
        ];
        Tabs.propDecorators = {
            position: [{ type: core.Input }],
            cacheActive: [{ type: core.Input }],
            followFocus: [{ type: core.Input }],
            skeleton: [{ type: core.Input }],
            isNavigation: [{ type: core.Input }],
            ariaLabel: [{ type: core.Input }],
            ariaLabelledby: [{ type: core.Input }],
            type: [{ type: core.Input }],
            tabs: [{ type: core.ContentChildren, args: [Tab, { descendants: false },] }],
            tabHeaders: [{ type: core.ContentChild, args: [TabHeaders, { static: false },] }]
        };
        return Tabs;
    }());

    var TabsModule = /** @class */ (function () {
        function TabsModule() {
        }
        TabsModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            Tabs,
                            Tab,
                            TabHeaders,
                            TabHeader,
                            TabHeaderGroup
                        ],
                        exports: [
                            Tabs,
                            Tab,
                            TabHeaders,
                            TabHeader,
                            TabHeaderGroup
                        ],
                        imports: [
                            common.CommonModule,
                            utils.UtilsModule
                        ]
                    },] }
        ];
        return TabsModule;
    }());

    /**
     * Generated bundle index. Do not edit.
     */

    exports.TabHeaderGroup = TabHeaderGroup;
    exports.TabHeader = TabHeader;
    exports.TabHeaders = TabHeaders;
    exports.Tab = Tab;
    exports.Tabs = Tabs;
    exports.TabsModule = TabsModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=carbon-components-angular-tabs.umd.js.map