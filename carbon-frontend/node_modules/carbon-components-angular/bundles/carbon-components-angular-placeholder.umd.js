/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-placeholder.umd.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('carbon-components-angular/placeholder', ['exports', '@angular/core', '@angular/common'], factory) :
    (factory((global['carbon-components-angular'] = global['carbon-components-angular'] || {}, global['carbon-components-angular'].placeholder = {}),global.ng.core,global.ng.common));
}(this, (function (exports,core,common) { 'use strict';

    /**
     * Singleton service used to register the container for out-of-flow components to insert into.
     * Also used to insert/remove components from that view.
     */
    var PlaceholderService = /** @class */ (function () {
        function PlaceholderService() {
            /**
             * Main `ViewContainerRef` to insert components into
             */
            this.viewContainerRef = null;
            /**
             * Map of id's to secondary `ViewContainerRef`s
             */
            this.viewContainerMap = new Map();
        }
        /**
         * Used by `Placeholder` to register view-container reference.
         */
        PlaceholderService.prototype.registerViewContainerRef = function (vcRef, id) {
            if (id) {
                this.viewContainerMap.set(id, vcRef);
            }
            else {
                this.viewContainerRef = vcRef;
            }
        };
        /**
         * Creates and returns component in the view.
         */
        PlaceholderService.prototype.createComponent = function (componentFactory, injector, id) {
            if (id) {
                if (!this.viewContainerMap.has(id)) {
                    console.error("No view container with id " + id + " found");
                    return;
                }
                return this.viewContainerMap.get(id).createComponent(componentFactory, null, injector);
            }
            if (!this.viewContainerRef) {
                console.error("No view container defined! Likely due to a missing `ibm-placeholder`");
                return;
            }
            return this.viewContainerRef.createComponent(componentFactory, null, injector);
        };
        PlaceholderService.prototype.destroyComponent = function (component) {
            component.destroy();
        };
        PlaceholderService.prototype.hasComponentRef = function (component, id) {
            if (id) {
                return !(this.viewContainerMap.get(id).indexOf(component.hostView) < 0);
            }
            return !(this.viewContainerRef.indexOf(component.hostView) < 0);
        };
        PlaceholderService.prototype.hasPlaceholderRef = function (id) {
            if (id) {
                return this.viewContainerMap.has(id);
            }
            return !!this.viewContainerRef;
        };
        PlaceholderService.prototype.appendElement = function (element, id) {
            if (id) {
                return this.viewContainerMap.get(id).element.nativeElement.appendChild(element);
            }
            return this.viewContainerRef.element.nativeElement.appendChild(element);
        };
        PlaceholderService.prototype.removeElement = function (element, id) {
            if (id) {
                return this.viewContainerMap.get(id).element.nativeElement.removeChild(element);
            }
            return this.viewContainerRef.element.nativeElement.removeChild(element);
        };
        PlaceholderService.prototype.hasElement = function (element, id) {
            if (id) {
                return this.viewContainerMap.get(id).element.nativeElement.contains(element);
            }
            return this.viewContainerRef.element.nativeElement.contains(element);
        };
        PlaceholderService.decorators = [
            { type: core.Injectable }
        ];
        return PlaceholderService;
    }());

    /**
     * Using a modal, dialog (Tooltip, OverflowMenu), or any other component that draws out of the normal page flow
     * in your application *requires* this component (`ibm-placeholder`).
     * It would generally be placed near the end of your root app component template
     * (app.component.ts or app.component.html) as:
     *
     * ```
     * <ibm-placeholder></ibm-placeholder>
     * ```
     */
    var Placeholder = /** @class */ (function () {
        /**
         * Creates an instance of `Placeholder`.
         */
        function Placeholder(placeholderService) {
            this.placeholderService = placeholderService;
        }
        /**
         * Registers the components view with `PlaceholderService`
         */
        Placeholder.prototype.ngOnInit = function () {
            // TODO use `id` to register with the placeholderService
            this.placeholderService.registerViewContainerRef(this.viewContainerRef);
        };
        Placeholder.decorators = [
            { type: core.Component, args: [{
                        selector: "ibm-placeholder",
                        template: "<div #placeholder></div>"
                    }] }
        ];
        /** @nocollapse */
        Placeholder.ctorParameters = function () {
            return [
                { type: PlaceholderService }
            ];
        };
        Placeholder.propDecorators = {
            id: [{ type: core.Input }],
            viewContainerRef: [{ type: core.ViewChild, args: ["placeholder", { read: core.ViewContainerRef, static: true },] }]
        };
        return Placeholder;
    }());

    // modules
    // either provides a new instance of PlaceholderService, or returns the parent
    function PLACEHOLDER_SERVICE_PROVIDER_FACTORY(parentService) {
        return parentService || new PlaceholderService();
    }
    // placeholder service *must* be a singleton to ensure the placeholder viewRef is accessible globally
    var PLACEHOLDER_SERVICE_PROVIDER = {
        provide: PlaceholderService,
        deps: [[new core.Optional(), new core.SkipSelf(), PlaceholderService]],
        useFactory: PLACEHOLDER_SERVICE_PROVIDER_FACTORY
    };
    var PlaceholderModule = /** @class */ (function () {
        function PlaceholderModule() {
        }
        PlaceholderModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [Placeholder],
                        exports: [Placeholder],
                        providers: [PLACEHOLDER_SERVICE_PROVIDER],
                        imports: [common.CommonModule]
                    },] }
        ];
        return PlaceholderModule;
    }());

    /**
     * Generated bundle index. Do not edit.
     */

    exports.Placeholder = Placeholder;
    exports.PLACEHOLDER_SERVICE_PROVIDER_FACTORY = PLACEHOLDER_SERVICE_PROVIDER_FACTORY;
    exports.PLACEHOLDER_SERVICE_PROVIDER = PLACEHOLDER_SERVICE_PROVIDER;
    exports.PlaceholderModule = PlaceholderModule;
    exports.PlaceholderService = PlaceholderService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=carbon-components-angular-placeholder.umd.js.map