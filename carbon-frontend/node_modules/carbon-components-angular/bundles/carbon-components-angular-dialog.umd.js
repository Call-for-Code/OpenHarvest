/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-dialog.umd.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs'), require('carbon-components-angular/common'), require('@carbon/utils-position'), require('@angular/core'), require('@angular/common'), require('carbon-components-angular/i18n'), require('carbon-components-angular/placeholder'), require('carbon-components-angular/experimental'), require('carbon-components-angular/utils'), require('carbon-components-angular/icon')) :
    typeof define === 'function' && define.amd ? define('carbon-components-angular/dialog', ['exports', 'rxjs', 'carbon-components-angular/common', '@carbon/utils-position', '@angular/core', '@angular/common', 'carbon-components-angular/i18n', 'carbon-components-angular/placeholder', 'carbon-components-angular/experimental', 'carbon-components-angular/utils', 'carbon-components-angular/icon'], factory) :
    (factory((global['carbon-components-angular'] = global['carbon-components-angular'] || {}, global['carbon-components-angular'].dialog = {}),global.rxjs,global['carbon-components-angular'].common,global.Position,global.ng.core,global.ng.common,global['carbon-components-angular'].i18n,global['carbon-components-angular'].placeholder,global['carbon-components-angular'].experimental,global['carbon-components-angular'].utils,global['carbon-components-angular'].icon));
}(this, (function (exports,rxjs,common,Position,core,common$1,i18n,placeholder,experimental,utils,icon) { 'use strict';

    var Position__default = 'default' in Position ? Position['default'] : Position;

    /**
     * An enum of the various reasons a dialog may close. For use with `CloseMeta` and `shouldClose`
     *
     * It's expected that `interaction` will be a common closure reason.
     */
    (function (CloseReasons) {
        /**
         * For when the component is closed by being destroyed
         */
        CloseReasons[CloseReasons["destroyed"] = 0] = "destroyed";
        /**
         * For use in cases where the dialog closes for programmatic reasons other than destruction
         */
        CloseReasons[CloseReasons["programmatic"] = 1] = "programmatic";
        /**
         * interaction reasons will also provide a target for the interaction
         */
        CloseReasons[CloseReasons["interaction"] = 2] = "interaction";
        /**
         * For use in cases where the dialog closes due to being hidden
         */
        CloseReasons[CloseReasons["hidden"] = 3] = "hidden";
    })(exports.CloseReasons || (exports.CloseReasons = {}));

    /**
     * `Dialog` object to be injected into other components.
     */
    var DialogService = /** @class */ (function () {
        /**
         * Creates an instance of `DialogService`.
         */
        function DialogService(componentFactoryResolver, injector, placeholderService) {
            this.componentFactoryResolver = componentFactoryResolver;
            this.injector = injector;
            this.placeholderService = placeholderService;
        }
        /**
         * Closes all known `Dialog`s. Does not focus any previous elements, since we can't know which would be correct
         */
        DialogService.closeAll = function () {
            DialogService.dialogRefs.forEach(function (ref) {
                return ref.instance.doClose({
                    reason: exports.CloseReasons.programmatic
                });
            });
            DialogService.dialogRefs.clear();
        };
        /**
         * Set the context for the service. For example, the `component` property can be used to set the
         * default component that should be created by the service, for a given instance of the service.
         * @param options `{ component: any }` where `component` is a component that extends `dialog.component`
         */
        DialogService.prototype.setContext = function (options) {
            this.componentFactory = this.componentFactoryResolver.resolveComponentFactory(options.component);
        };
        /**
         * If `dialogRef` is defined, the Dialog is already open. If
         * `dialogRef` is undefined, we create the `Dialog` component and reference to it.
         * A subscription is created to track if the `Dialog` should close.
         *
         * @param viewContainer a `ViewContainerRef` to instantiate the component against.
         * May be `null` if an `ibm-placeholder` exists and `dialogConfig.appendInline` is false
         * @param dialogConfig the `DialogConfig` for the component
         */
        DialogService.prototype.open = function (viewContainer, dialogConfig, component) {
            var componentFactory = this.componentFactory;
            if (component) {
                componentFactory = this.componentFactoryResolver.resolveComponentFactory(component);
            }
            var dialogRef;
            if (dialogConfig.appendInline) {
                // add our component to the view
                dialogRef = viewContainer.createComponent(componentFactory, 0, this.injector);
            }
            else if (!this.placeholderService.hasPlaceholderRef()) {
                dialogRef = viewContainer.createComponent(componentFactory, 0, this.injector);
                if (dialogRef) {
                    setTimeout(function () {
                        window.document.querySelector("body").appendChild(dialogRef.location.nativeElement);
                    });
                }
            }
            else {
                dialogRef = this.placeholderService.createComponent(componentFactory, this.injector);
            }
            // keep track of all initialized dialogs
            DialogService.dialogRefs.add(dialogRef);
            // initialize some extra options
            dialogConfig["previouslyFocusedElement"] = document.activeElement;
            dialogRef.instance.dialogConfig = dialogConfig;
            dialogRef.instance.elementRef.nativeElement.focus();
            return dialogRef;
        };
        /**
         * On close of `Dialog` item, sets focus back to previous item, unsets
         * the current `dialogRef` item. Unsubscribes to the event of `Dialog` close.
         *
         * @param dialogRef the dialogRef to close
         */
        DialogService.prototype.close = function (dialogRef) {
            // to handle the case where we have a null `this.dialogRef`
            if (!dialogRef) {
                return;
            }
            var elementToFocus = dialogRef.instance.dialogConfig["previouslyFocusedElement"];
            dialogRef.destroy();
            // update the globally tracked dialogRefs
            if (DialogService.dialogRefs.has(dialogRef)) {
                DialogService.dialogRefs.delete(dialogRef);
            }
            // Keeps the focus on the dialog trigger if there are no focusable elements. Change focus to previously focused element
            // if there are focusable elements in the dialog.
            if (!dialogRef.location.nativeElement.querySelectorAll(common.tabbableSelector)) {
                elementToFocus.focus();
            }
        };
        /**
         * Closes all known `Dialog`s. Does not focus any previous elements, since we can't know which would be correct
         *
         * @deprecated since v4. Use the static `DialogService.closeAll` instead
         */
        DialogService.prototype.closeAll = function () {
            DialogService.closeAll();
        };
        /**
         * Fix for safari hijacking clicks.
         *
         * Runs on `ngOnInit` of every dialog. Ensures we don't have multiple listeners
         * because having many of them could degrade performance in certain cases (and is
         * not necessary for our use case)
         *
         * This is an internally used function, can change at any point (even get removed)
         * and changes to it won't be considered a breaking change. Use at your own risk.
         */
        DialogService.prototype.singletonClickListen = function () {
            if (!DialogService.listeningForBodyClicks) {
                document.body.firstElementChild.addEventListener("click", function () { return null; }, true);
                DialogService.listeningForBodyClicks = true;
            }
        };
        /**
         * Used in `singletonClickListen`, don't count on its existence and values.
         */
        DialogService.listeningForBodyClicks = false;
        /**
         * A set of all known dialog components
         */
        DialogService.dialogRefs = new Set();
        DialogService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        DialogService.ctorParameters = function () {
            return [
                { type: core.ComponentFactoryResolver },
                { type: core.Injector },
                { type: placeholder.PlaceholderService }
            ];
        };
        return DialogService;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    /**
     * Implements a `Dialog` that can be positioned anywhere on the page.
     * Used to implement a popover or tooltip.
     */
    var Dialog = /** @class */ (function () {
        /**
         * Creates an instance of `Dialog`.
         * @param elementRef
         * @param elementService
         */
        function Dialog(elementRef, elementService, animationFrameService) {
            if (animationFrameService === void 0) {
                animationFrameService = null;
            }
            var _this = this;
            this.elementRef = elementRef;
            this.elementService = elementService;
            this.animationFrameService = animationFrameService;
            /**
             * Emits event that handles the closing of a `Dialog` object.
             */
            this.close = new core.EventEmitter();
            /**
             * Stores the data received from `dialogConfig`.
             */
            this.data = {};
            this.visibilitySubscription = new rxjs.Subscription();
            this.animationFrameSubscription = new rxjs.Subscription();
            /**
             * Handles offsetting the `Dialog` item based on the defined position
             * to not obscure the content beneath.
             */
            this.addGap = {
                "left": function (pos) { return Position.position.addOffset(pos, 0, -_this.dialogConfig.gap); },
                "right": function (pos) { return Position.position.addOffset(pos, 0, _this.dialogConfig.gap); },
                "top": function (pos) { return Position.position.addOffset(pos, -_this.dialogConfig.gap); },
                "bottom": function (pos) { return Position.position.addOffset(pos, _this.dialogConfig.gap); },
                "left-bottom": function (pos) { return Position.position.addOffset(pos, 0, -_this.dialogConfig.gap); },
                "right-bottom": function (pos) { return Position.position.addOffset(pos, 0, _this.dialogConfig.gap); }
            };
            /**
             * Extra placements. Child classes can add to this for use in `placeDialog`.
             */
            this.placements = {};
        }
        /**
         * Initialize the `Dialog`, set the placement and gap, and add a `Subscription` to resize events.
         */
        Dialog.prototype.ngOnInit = function () {
            this.placement = this.dialogConfig.placement.split(",")[0];
            this.data = this.dialogConfig.data;
            // run any additional initialization code that consuming classes may have
            this.onDialogInit();
        };
        /**
         * After the DOM is ready, focus is set and dialog is placed
         * in respect to the parent element.
         */
        Dialog.prototype.ngAfterViewInit = function () {
            var _this = this;
            var e_1, _a;
            var dialogElement = this.dialog.nativeElement;
            // split the wrapper class list and apply separately to avoid IE
            // 1. throwing an error due to assigning a readonly property (classList)
            // 2. throwing a SyntaxError due to passing an empty string to `add`
            if (this.dialogConfig.wrapperClass) {
                try {
                    for (var _b = __values(this.dialogConfig.wrapperClass.split(" ")), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var extraClass = _c.value;
                        dialogElement.classList.add(extraClass);
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
            }
            // only focus the dialog if there are focusable elements within the dialog
            if (common.getFocusElementList(this.dialog.nativeElement).length > 0) {
                dialogElement.focus();
            }
            var parentElement = this.dialogConfig.parentRef.nativeElement;
            if (this.animationFrameService) {
                this.animationFrameSubscription = this.animationFrameService.tick.subscribe(function () {
                    _this.placeDialog();
                });
            }
            if (this.dialogConfig.closeWhenHidden) {
                this.visibilitySubscription = this.elementService
                    .visibility(parentElement, parentElement)
                    .subscribe(function (value) {
                    _this.placeDialog();
                    if (!value.visible) {
                        _this.doClose({
                            reason: exports.CloseReasons.hidden
                        });
                    }
                });
            }
            this.placeDialog();
            // run afterDialogViewInit on the next tick
            setTimeout(function () { return _this.afterDialogViewInit(); });
        };
        /**
         * Empty method to be overridden by consuming classes to run any additional initialization code.
         */
        Dialog.prototype.onDialogInit = function () { };
        /**
         * Empty method to be overridden by consuming classes to run any additional initialization code after the view is available.
         * NOTE: this does _not_ guarantee the dialog will be positioned, simply that it will exist in the DOM
         */
        Dialog.prototype.afterDialogViewInit = function () { };
        /**
         * Uses the position service to position the `Dialog` in screen space
         */
        Dialog.prototype.placeDialog = function () {
            var _this = this;
            var positionService = new Position__default(this.placements);
            // helper to find the position based on the current/given environment
            var findPosition = function (reference, target, placement) {
                var pos;
                if (_this.dialogConfig.appendInline) {
                    pos = _this.addGap[placement](positionService.findRelative(reference, target, placement));
                }
                else {
                    pos = _this.addGap[placement](positionService.findAbsolute(reference, target, placement));
                }
                if (_this.dialogConfig.offset) {
                    // Apply vertical and horizontal offsets given through the dialogConfig
                    pos.top = pos.top + _this.dialogConfig.offset.y;
                    pos.left = pos.left + _this.dialogConfig.offset.x;
                }
                return pos;
            };
            var parentEl = this.dialogConfig.parentRef.nativeElement;
            var el = this.dialog.nativeElement;
            var dialogPlacement = this.placement;
            // split always returns an array, so we can just use the auto position logic
            // for single positions too
            var placements = this.dialogConfig.placement.split(",");
            // find the best placement
            dialogPlacement = positionService.findBestPlacement(parentEl, el, placements);
            // calculate the final position
            var pos = findPosition(parentEl, el, dialogPlacement);
            // update the element
            positionService.setElement(el, pos);
            setTimeout(function () { _this.placement = dialogPlacement; });
        };
        /**
         * Sets up a KeyboardEvent to close `Dialog` with Escape key.
         * @param event
         */
        Dialog.prototype.escapeClose = function (event) {
            switch (event.key) {
                case "Esc": // IE specific value
                case "Escape": {
                    event.stopImmediatePropagation();
                    this.doClose({
                        reason: exports.CloseReasons.interaction,
                        target: event.target
                    });
                    break;
                }
                case "Tab": {
                    common.cycleTabs(event, this.elementRef.nativeElement);
                    break;
                }
            }
        };
        /**
         * Sets up a event Listener to close `Dialog` if click event occurs outside
         * `Dialog` object.
         * @param event
         */
        Dialog.prototype.clickClose = function (event) {
            if (!this.elementRef.nativeElement.contains(event.target)
                && !this.dialogConfig.parentRef.nativeElement.contains(event.target)) {
                this.doClose({
                    reason: exports.CloseReasons.interaction,
                    target: event.target
                });
            }
        };
        /**
         * Closes `Dialog` object by emitting the close event upwards to parents.
         */
        Dialog.prototype.doClose = function (meta) {
            if (meta === void 0) {
                meta = { reason: exports.CloseReasons.interaction };
            }
            this.close.emit(meta);
        };
        /**
         * At destruction of component, `Dialog` unsubscribes from all the subscriptions.
         */
        Dialog.prototype.ngOnDestroy = function () {
            this.visibilitySubscription.unsubscribe();
            if (this.animationFrameSubscription) {
                this.animationFrameSubscription.unsubscribe();
            }
        };
        Dialog.decorators = [
            { type: core.Component, args: [{
                        selector: "ibm-dialog",
                        template: ""
                    }] }
        ];
        /** @nocollapse */
        Dialog.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: utils.ElementService },
                { type: utils.AnimationFrameService, decorators: [{ type: core.Optional }] }
            ];
        };
        Dialog.propDecorators = {
            close: [{ type: core.Output }],
            dialogConfig: [{ type: core.Input }],
            dialog: [{ type: core.ViewChild, args: ["dialog", { static: false },] }],
            escapeClose: [{ type: core.HostListener, args: ["keydown", ["$event"],] }],
            clickClose: [{ type: core.HostListener, args: ["document:click", ["$event"],] }]
        };
        return Dialog;
    }());

    /**
     * A generic directive that can be inherited from to create dialogs (for example, a tooltip or popover)
     *
     * This class contains the relevant initialization code, specific templates, options, and additional inputs
     * should be specified in the derived class.
     *
     * NOTE: All child classes should add `DialogService` as a provider, otherwise they will lose context that
     * the service relies on.
     */
    var DialogDirective = /** @class */ (function () {
        /**
         * Creates an instance of DialogDirective.
         * @param elementRef
         * @param viewContainerRef
         * @param dialogService
         * @param eventService
         */
        function DialogDirective(elementRef, viewContainerRef, dialogService, eventService) {
            this.elementRef = elementRef;
            this.viewContainerRef = viewContainerRef;
            this.dialogService = dialogService;
            this.eventService = eventService;
            /**
             * Title for the dialog
             */
            this.title = "";
            /**
             * Defines how the Dialog is triggered.(Hover and click behave the same on mobile - both respond to a single tap).
             * Do not add focusable elements if trigger is `hover` or `mouseenter`.
             */
            this.trigger = "click";
            /**
             * Defines how the Dialog close event is triggered.
             *
             * [See here](https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseleave_event)
             * for more on the difference between `mouseleave` and `mouseout`.
             *
             * Defaults to `click` when `trigger` is set to `click`.
             */
            this.closeTrigger = "mouseleave";
            /**
             * Placement of the dialog, usually relative to the element the directive is on.
             */
            this.placement = "left";
            /**
             * Spacing between the dialog and it's triggering element
             */
            this.gap = 0;
            /**
             * Set to `true` to open the dialog next to the triggering component
             */
            this.appendInline = false;
            /**
             * Optional data for templates
             */
            this.data = {};
            this.isOpen = false;
            /**
             * This prevents the dialog from being toggled
             */
            this.disabled = false;
            /**
             * Emits an event when the dialog is closed
             */
            this.onClose = new core.EventEmitter();
            /**
             * Emits an event when the dialog is opened
             */
            this.onOpen = new core.EventEmitter();
            /**
             * Emits an event when the state of `isOpen` changes. Allows `isOpen` to be double bound
             */
            this.isOpenChange = new core.EventEmitter();
            this.role = "button";
            this.hasPopup = true;
        }
        Object.defineProperty(DialogDirective.prototype, "ariaOwns", {
            get: function () {
                return this.isOpen ? this.dialogConfig.compID : null;
            },
            enumerable: true,
            configurable: true
        });
        DialogDirective.prototype.ngOnChanges = function (changes) {
            // set the config object (this can [and should!] be added to in child classes depending on what they need)
            this.dialogConfig = {
                title: this.title,
                content: this.ibmDialog,
                placement: this.placement,
                parentRef: this.elementRef,
                gap: this.gap,
                trigger: this.trigger,
                closeTrigger: this.closeTrigger,
                shouldClose: this.shouldClose || (function () { return true; }),
                appendInline: this.appendInline,
                wrapperClass: this.wrapperClass,
                data: this.data,
                offset: this.offset,
                disabled: this.disabled
            };
            if (changes.isOpen) {
                if (changes.isOpen.currentValue) {
                    this.open();
                }
                else {
                    this.close({
                        reason: exports.CloseReasons.programmatic
                    });
                }
            }
            // Run any code a child class may need.
            this.onDialogChanges(changes);
            this.updateConfig();
        };
        /**
         * Sets the config object and binds events for hovering or clicking before
         * running code from child class.
         */
        DialogDirective.prototype.ngOnInit = function () {
            var _this = this;
            // fix for safari hijacking clicks
            this.dialogService.singletonClickListen();
            var element = this.elementRef.nativeElement;
            this.eventService.on(element, "keydown", function (event) {
                // "Esc" is an IE specific value
                if (event.target === _this.dialogConfig.parentRef.nativeElement &&
                    (event.key === "Tab" || event.key === "Tab" && event.shiftKey) ||
                    event.key === "Escape" || event.key === "Esc") {
                    _this.close({
                        reason: exports.CloseReasons.interaction,
                        target: event.target
                    });
                }
            });
            // bind events for hovering or clicking the host
            if (this.trigger === "hover" || this.trigger === "mouseenter") {
                this.eventService.on(element, "mouseenter", this.open.bind(this));
                this.eventService.on(element, this.closeTrigger, function (event) {
                    _this.close({
                        reason: exports.CloseReasons.interaction,
                        target: event.target
                    });
                });
                this.eventService.on(element, "focus", this.open.bind(this));
                this.eventService.on(element, "blur", function (event) {
                    _this.close({
                        reason: exports.CloseReasons.interaction,
                        target: event.target
                    });
                });
            }
            else {
                this.eventService.on(element, "click", function (event) {
                    _this.toggle({
                        reason: exports.CloseReasons.interaction,
                        target: event.target
                    });
                });
                this.eventService.on(element, "keydown", function (event) {
                    // "Spacebar" is an IE specific value
                    if (event.key === "Enter" || event.key === " " || event.key === "Spacebar") {
                        setTimeout(function () {
                            _this.open();
                        });
                    }
                });
            }
            DialogDirective.dialogCounter++;
            this.dialogConfig.compID = "dialog-" + DialogDirective.dialogCounter;
            // run any code a child class may need
            this.onDialogInit();
            this.updateConfig();
        };
        /**
         * When the host dies, kill the popover.
         * - Useful for use in a modal or similar.
         */
        DialogDirective.prototype.ngOnDestroy = function () {
            this.close({
                reason: exports.CloseReasons.destroyed
            });
        };
        /**
         * Helper method to call dialogService 'open'.
         * - Enforce accessibility by updating an aria attr for nativeElement.
         */
        DialogDirective.prototype.open = function () {
            var _this = this;
            // don't allow dialogs to be opened if they're already open
            if (this.dialogRef || this.disabled) {
                return;
            }
            // actually open the dialog, emit events, and set the open state
            this.dialogRef = this.dialogService.open(this.viewContainerRef, this.dialogConfig);
            this.isOpen = true;
            this.onOpen.emit();
            this.isOpenChange.emit(true);
            // Handles emitting all the close events to clean everything up
            // Also enforce accessibility on close by updating an aria attr on the nativeElement.
            this.dialogRef.instance.close.subscribe(function (meta) {
                if (!_this.dialogRef) {
                    return;
                }
                if (_this.dialogConfig.shouldClose && _this.dialogConfig.shouldClose(meta)) {
                    // close the dialog, emit events, and clear out the open states
                    _this.dialogService.close(_this.dialogRef);
                    _this.dialogRef = null;
                    _this.isOpen = false;
                    _this.onClose.emit();
                    _this.isOpenChange.emit(false);
                }
            });
            return this.dialogRef;
        };
        /**
         * Helper method to toggle the open state of the dialog
         */
        DialogDirective.prototype.toggle = function (meta) {
            if (meta === void 0) {
                meta = { reason: exports.CloseReasons.interaction };
            }
            if (!this.isOpen) {
                this.open();
            }
            else {
                this.close(meta);
            }
        };
        /**
         * Helper method to close the dialogRef.
         */
        DialogDirective.prototype.close = function (meta) {
            var _this = this;
            if (meta === void 0) {
                meta = { reason: exports.CloseReasons.interaction };
            }
            if (this.dialogRef) {
                setTimeout(function () {
                    _this.dialogRef.instance.doClose(meta);
                });
            }
        };
        /**
         * Empty method for child classes to override and specify additional init steps.
         * Run after DialogDirective completes it's ngOnInit.
         */
        DialogDirective.prototype.onDialogInit = function () { };
        /**
         * Empty method for child to override and specify additional on changes steps.
         * run after DialogDirective completes it's ngOnChanges.
         */
        DialogDirective.prototype.onDialogChanges = function (_changes) { };
        DialogDirective.prototype.updateConfig = function () { };
        DialogDirective.dialogCounter = 0;
        DialogDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: "[ibmDialog]",
                        exportAs: "ibmDialog",
                        providers: [
                            DialogService
                        ]
                    },] }
        ];
        /** @nocollapse */
        DialogDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.ViewContainerRef },
                { type: DialogService },
                { type: utils.EventService }
            ];
        };
        DialogDirective.propDecorators = {
            title: [{ type: core.Input }],
            ibmDialog: [{ type: core.Input }],
            trigger: [{ type: core.Input }],
            closeTrigger: [{ type: core.Input }],
            placement: [{ type: core.Input }],
            offset: [{ type: core.Input }],
            wrapperClass: [{ type: core.Input }],
            gap: [{ type: core.Input }],
            appendInline: [{ type: core.Input }],
            data: [{ type: core.Input }],
            isOpen: [{ type: core.Input }, { type: core.HostBinding, args: ["attr.aria-expanded",] }],
            disabled: [{ type: core.Input }],
            shouldClose: [{ type: core.Input }],
            onClose: [{ type: core.Output }],
            onOpen: [{ type: core.Output }],
            isOpenChange: [{ type: core.Output }],
            role: [{ type: core.HostBinding, args: ["attr.role",] }],
            hasPopup: [{ type: core.HostBinding, args: ["attr.aria-haspopup",] }],
            ariaOwns: [{ type: core.HostBinding, args: ["attr.aria-owns",] }]
        };
        return DialogDirective;
    }());

    /**
     * Extend the `Dialog` component to create a tooltip for exposing content.
     */
    var Tooltip = /** @class */ (function (_super) {
        __extends(Tooltip, _super);
        function Tooltip(elementRef, elementService, animationFrameService) {
            if (animationFrameService === void 0) {
                animationFrameService = null;
            }
            var _this = _super.call(this, elementRef, elementService, animationFrameService) || this;
            _this.elementRef = elementRef;
            _this.elementService = elementService;
            _this.animationFrameService = animationFrameService;
            _this.style = "inline-block";
            /**
             * Value is set to `true` if the `Tooltip` is to display a `TemplateRef` instead of a string.
             */
            _this.hasContentTemplate = false;
            /**
             * Sets the role of the tooltip. If there's no focusable content we leave it as a `tooltip`,
             * if there _is_ focusable content we switch to the interactive `dialog` role.
             */
            _this.role = "tooltip";
            return _this;
        }
        /**
         * Check whether there is a template for the `Tooltip` content.
         */
        Tooltip.prototype.onDialogInit = function () {
            var _this = this;
            this.addGap["bottom"] = function (pos) {
                var adjustedOffset = _this.getAdjustOffset();
                return Position.position.addOffset(pos, 3 + adjustedOffset.top, 0 + adjustedOffset.left);
            };
            this.addGap["top"] = function (pos) {
                var adjustedOffset = _this.getAdjustOffset();
                return Position.position.addOffset(pos, -10 + adjustedOffset.top, 0 + adjustedOffset.left);
            };
            this.addGap["left"] = function (pos) {
                var adjustedOffset = _this.getAdjustOffset();
                return Position.position.addOffset(pos, -3 + adjustedOffset.top, -6 + adjustedOffset.left);
            };
            this.addGap["right"] = function (pos) {
                var adjustedOffset = _this.getAdjustOffset();
                return Position.position.addOffset(pos, -3 + adjustedOffset.top, 6 + adjustedOffset.left);
            };
            this.hasContentTemplate = this.dialogConfig.content instanceof core.TemplateRef;
        };
        Tooltip.prototype.getAdjustOffset = function () {
            var closestWithPos = utils.closestAttr("position", ["relative", "fixed", "absolute"], this.elementRef.nativeElement.parentElement);
            var topPos = closestWithPos ? closestWithPos.getBoundingClientRect().top * -1 : 0;
            var leftPos = closestWithPos ? closestWithPos.getBoundingClientRect().left * -1 : 0;
            return { top: topPos, left: leftPos };
        };
        Tooltip.prototype.afterDialogViewInit = function () {
            var focusableElements = common.getFocusElementList(this.dialog.nativeElement);
            if (focusableElements.length > 0) {
                this.role = "dialog";
                focusableElements[0].focus();
            }
        };
        Tooltip.decorators = [
            { type: core.Component, args: [{
                        selector: "ibm-tooltip",
                        template: "\n\t\t<div\n\t\t\t#dialog\n\t\t\t[id]=\"dialogConfig.compID\"\n\t\t\t[attr.role]=\"role\"\n\t\t\t[attr.data-floating-menu-direction]=\"placement\"\n\t\t\tclass=\"bx--tooltip bx--tooltip--shown\">\n\t\t\t<span class=\"bx--tooltip__caret\" aria-hidden=\"true\"></span>\n\t\t\t<ng-template\n\t\t\t\t\t*ngIf=\"hasContentTemplate\"\n\t\t\t\t\t[ngTemplateOutlet]=\"dialogConfig.content\"\n\t\t\t\t\t[ngTemplateOutletContext]=\"{tooltip: this}\">\n\t\t\t</ng-template>\n\t\t\t<p\n\t\t\t\t*ngIf=\"!hasContentTemplate\">\n\t\t\t\t{{dialogConfig.content}}\n\t\t\t</p>\n\t\t</div>\n\t\t"
                    }] }
        ];
        /** @nocollapse */
        Tooltip.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: utils.ElementService },
                { type: utils.AnimationFrameService, decorators: [{ type: core.Optional }] }
            ];
        };
        Tooltip.propDecorators = {
            style: [{ type: core.HostBinding, args: ["style.display",] }]
        };
        return Tooltip;
    }(Dialog));

    var TooltipDefinition = /** @class */ (function () {
        function TooltipDefinition() {
            this.id = "definition-tooltip-" + TooltipDefinition.tooltipItemCount++;
            /**
             * The placement in which the `TooltipDefinition` appears.
             * Set to `"top"` to have it positioned above the trigger text
             */
            this.placement = "bottom";
            this.alignment = "start";
            this.className = true;
            this.accessibility = true;
        }
        TooltipDefinition.tooltipItemCount = 0;
        TooltipDefinition.decorators = [
            { type: core.Component, args: [{
                        selector: "ibm-tooltip-definition",
                        template: "\n\t\t<button\n\t\t\ttype=\"button\"\n\t\t\t[ngClass]=\"{\n\t\t\t\t'bx--tooltip--bottom' : placement === 'bottom',\n\t\t\t\t'bx--tooltip--top' : placement === 'top',\n\t\t\t\t'bx--tooltip--align-start' : alignment === 'start',\n\t\t\t\t'bx--tooltip--align-center' : alignment === 'center',\n\t\t\t\t'bx--tooltip--align-end' : alignment === 'end'\n\t\t\t}\"\n\t\t\tclass=\"bx--tooltip__trigger bx--tooltip--a11y bx--tooltip__trigger--definition\"\n\t\t\t[attr.aria-describedby]=\"id\">\n\t\t\t<ng-content></ng-content>\n\t\t</button>\n\t\t<div class=\"bx--assistive-text\" [id]=\"id\" role=\"tooltip\">{{content}}</div>\n\t"
                    }] }
        ];
        TooltipDefinition.propDecorators = {
            id: [{ type: core.Input }],
            content: [{ type: core.Input }],
            placement: [{ type: core.Input }],
            alignment: [{ type: core.Input }],
            className: [{ type: core.HostBinding, args: ["class.bx--tooltip--definition",] }],
            accessibility: [{ type: core.HostBinding, args: ["class.bx--tooltip--a11y",] }]
        };
        return TooltipDefinition;
    }());

    var TooltipIcon = /** @class */ (function () {
        function TooltipIcon() {
            /**
             * The placement in which the `TooltipIcon` appears.
             * Set to `"top"` to have it positioned above the icon
             */
            this.placement = "bottom";
            this.alignment = "start";
            this.className = true;
        }
        TooltipIcon.decorators = [
            { type: core.Component, args: [{
                        selector: "ibm-tooltip-icon",
                        template: "\n\t\t<button\n\t\t\ttype=\"button\"\n\t\t\tclass=\"bx--tooltip__trigger bx--tooltip--a11y\"\n\t\t\t[ngClass]=\"{\n\t\t\t\t'bx--tooltip--bottom' : placement === 'bottom',\n\t\t\t\t'bx--tooltip--top' : placement === 'top',\n\t\t\t\t'bx--tooltip--left' : placement === 'left',\n\t\t\t\t'bx--tooltip--right' : placement === 'right',\n\t\t\t\t'bx--tooltip--align-start' : alignment === 'start',\n\t\t\t\t'bx--tooltip--align-center' : alignment === 'center',\n\t\t\t\t'bx--tooltip--align-end' : alignment === 'end'\n\t\t\t}\">\n\t\t\t<span class=\"bx--assistive-text\">{{content}}</span>\n\t\t\t<ng-content></ng-content>\n\t\t</button>\n\t"
                    }] }
        ];
        TooltipIcon.propDecorators = {
            content: [{ type: core.Input }],
            placement: [{ type: core.Input }],
            alignment: [{ type: core.Input }],
            className: [{ type: core.HostBinding, args: ["class.bx--tooltip-icon",] }]
        };
        return TooltipIcon;
    }());

    /**
     * Directive for extending `Dialog` to create tooltips.
     *
     * [See demo](../../?path=/story/tooltip--basic)
     *
     * class: TooltipDirective (extends PopoverDirective)
     *
     *
     * selector: `nTooltip`
     *
     *
     * ```html
     * <button nTooltip="I am a tooltip" placement="right" trigger="mouseenter" type="danger">Tooltip Right</button>
     * <button nTooltip="I am a tooltip" type="warning">Tooltip Top warning on click</button>
     * ```
     *
     * <example-url>../../iframe.html?id=tooltip--basic</example-url>
     */
    var TooltipDirective = /** @class */ (function (_super) {
        __extends(TooltipDirective, _super);
        /**
         * Creates an instance of `TooltipDirective`.
         */
        function TooltipDirective(elementRef, viewContainerRef, dialogService, eventService) {
            var _this = _super.call(this, elementRef, viewContainerRef, dialogService, eventService) || this;
            _this.elementRef = elementRef;
            _this.viewContainerRef = viewContainerRef;
            _this.dialogService = dialogService;
            _this.eventService = eventService;
            /**
             * Set tooltip type to reflect 'warning' or 'error' styles.
             */
            // tslint:disable-next-line:no-input-rename
            _this.tooltipType = "";
            _this.tabIndex = 0;
            _this.className = true;
            dialogService.setContext({ component: Tooltip });
            return _this;
        }
        Object.defineProperty(TooltipDirective.prototype, "descriptorId", {
            get: function () {
                return this.isOpen ? this.dialogConfig.compID : null;
            },
            enumerable: true,
            configurable: true
        });
        TooltipDirective.prototype.updateConfig = function () {
            this.dialogConfig.content = this.ibmTooltip;
            this.dialogConfig.type = this.tooltipType;
            this.dialogConfig.offset = this.offset;
        };
        TooltipDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: "[ibmTooltip]",
                        exportAs: "ibmTooltip",
                        providers: [
                            DialogService
                        ]
                    },] }
        ];
        /** @nocollapse */
        TooltipDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.ViewContainerRef },
                { type: DialogService },
                { type: utils.EventService }
            ];
        };
        TooltipDirective.propDecorators = {
            ibmTooltip: [{ type: core.Input }],
            tooltipType: [{ type: core.Input, args: ["tooltip-type",] }],
            tabIndex: [{ type: core.HostBinding, args: ["tabindex",] }],
            className: [{ type: core.HostBinding, args: ["class.bx--tooltip__trigger",] }],
            descriptorId: [{ type: core.HostBinding, args: ["attr.aria-describedby",] }]
        };
        return TooltipDirective;
    }(DialogDirective));

    /**
     * A directive that creates a tooltip `Dialog` for exposing truncated text.
     *
     * class: EllipsisTooltip (extends PopoverDirective)
     *
     * selector: `nEllipsisTooltip`
     *
     * ```html
     * <div class="ellipsis" nEllipsisTooltip>Tooltip for ellipsis because I can and I am really really long</div>
     * ```
     */
    var EllipsisTooltip = /** @class */ (function (_super) {
        __extends(EllipsisTooltip, _super);
        function EllipsisTooltip() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * If text is truncated, this appends the text to the dialog as content.
         * @returns null
         * @memberof EllipsisTooltip
         */
        EllipsisTooltip.prototype.updateTooltipContent = function () {
            if (this.elementRef.nativeElement.scrollWidth <= this.elementRef.nativeElement.offsetWidth) {
                this.disabled = true;
                return;
            }
            this.disabled = false;
            this.dialogConfig.content = this.elementRef.nativeElement.innerText;
        };
        EllipsisTooltip.prototype.onClick = function () {
            if (this.trigger === "click") {
                this.updateTooltipContent();
            }
        };
        EllipsisTooltip.prototype.onHover = function () {
            if (this.trigger === "hover" || this.trigger === "mouseenter") {
                this.updateTooltipContent();
            }
        };
        EllipsisTooltip.prototype.onFocus = function () {
            this.updateTooltipContent();
        };
        EllipsisTooltip.decorators = [
            { type: core.Directive, args: [{
                        selector: "[ibmEllipsisTooltip]",
                        providers: [
                            DialogService
                        ]
                    },] }
        ];
        EllipsisTooltip.propDecorators = {
            onClick: [{ type: core.HostListener, args: ["click",] }],
            onHover: [{ type: core.HostListener, args: ["mouseenter",] }],
            onFocus: [{ type: core.HostListener, args: ["focus",] }]
        };
        return EllipsisTooltip;
    }(TooltipDirective));

    /**
     * Extend the `Dialog` component to create an overflow menu.
     *
     * Not used directly. See overflow-menu.component and overflow-menu.directive for more
     */
    var OverflowMenuPane = /** @class */ (function (_super) {
        __extends(OverflowMenuPane, _super);
        function OverflowMenuPane(elementRef, i18n$$1, experimental$$1, animationFrameService, 
        // mark `elementService` as optional since making it mandatory would be a breaking change
        elementService) {
            if (animationFrameService === void 0) {
                animationFrameService = null;
            }
            if (elementService === void 0) {
                elementService = null;
            }
            var _this = _super.call(this, elementRef, elementService, animationFrameService) || this;
            _this.elementRef = elementRef;
            _this.i18n = i18n$$1;
            _this.experimental = experimental$$1;
            _this.animationFrameService = animationFrameService;
            _this.elementService = elementService;
            return _this;
        }
        OverflowMenuPane.prototype.onDialogInit = function () {
            var _this = this;
            var positionOverflowMenu = function (pos) {
                var offset;
                /*
                * 20 is half the width of the overflow menu trigger element.
                * we also move the element by half of it's own width, since
                * position service will try and center everything
                */
                var closestRel = utils.closestAttr("position", ["relative", "fixed", "absolute"], _this.elementRef.nativeElement);
                var topFix = closestRel ? closestRel.getBoundingClientRect().top * -1 : 0;
                var leftFix = closestRel ? closestRel.getBoundingClientRect().left * -1 : 0;
                offset = Math.round(_this.dialog.nativeElement.offsetWidth / 2) - 20;
                if (_this.dialogConfig.flip) {
                    return Position.position.addOffset(pos, topFix, (-offset + leftFix));
                }
                return Position.position.addOffset(pos, topFix, (offset + leftFix));
            };
            this.addGap["bottom"] = positionOverflowMenu;
            this.addGap["top"] = positionOverflowMenu;
            if (!this.dialogConfig.menuLabel) {
                this.dialogConfig.menuLabel = this.i18n.get().OVERFLOW_MENU.OVERFLOW;
            }
        };
        OverflowMenuPane.prototype.hostkeys = function (event) {
            var listItems = this.listItems();
            switch (event.key) {
                case "Down": // IE specific value
                case "ArrowDown":
                    event.preventDefault();
                    if (!common.isFocusInLastItem(event, listItems)) {
                        var index = listItems.findIndex(function (item) { return item === event.target; });
                        listItems[index + 1].focus();
                    }
                    else {
                        listItems[0].focus();
                    }
                    break;
                case "Up": // IE specific value
                case "ArrowUp":
                    event.preventDefault();
                    if (!common.isFocusInFirstItem(event, listItems)) {
                        var index = listItems.findIndex(function (item) { return item === event.target; });
                        listItems[index - 1].focus();
                    }
                    else {
                        listItems[listItems.length - 1].focus();
                    }
                    break;
                case "Home":
                    event.preventDefault();
                    listItems[0].focus();
                    break;
                case "End":
                    event.preventDefault();
                    listItems[listItems.length - 1].focus();
                    break;
                case "Esc": // IE specific value
                case "Escape":
                case "Tab":
                    event.stopImmediatePropagation();
                    this.doClose({
                        reason: exports.CloseReasons.interaction,
                        target: event.target
                    });
                    break;
                default: break;
            }
        };
        OverflowMenuPane.prototype.onClose = function (event) {
            this.doClose({
                reason: exports.CloseReasons.interaction,
                target: event.target
            });
        };
        OverflowMenuPane.prototype.afterDialogViewInit = function () {
            var focusElementList = this.listItems();
            focusElementList.forEach(function (button) {
                // Allows user to set tabindex to 0.
                if (button.getAttribute("tabindex") === null) {
                    button.tabIndex = -1;
                }
            });
            if (focusElementList[0]) {
                focusElementList[0].tabIndex = 0;
                focusElementList[0].focus();
            }
        };
        OverflowMenuPane.prototype.listItems = function () {
            var selector = ".bx--overflow-menu-options__option:not([disabled]) .bx--overflow-menu-options__btn";
            return Array.from(this.elementRef.nativeElement.querySelectorAll(selector));
        };
        OverflowMenuPane.decorators = [
            { type: core.Component, args: [{
                        selector: "ibm-overflow-menu-pane",
                        template: "\n\t\t<ul\n\t\t\t[attr.aria-label]=\"dialogConfig.menuLabel\"\n\t\t\t[ngClass]=\"{'bx--overflow-menu--flip': dialogConfig.flip}\"\n\t\t\trole=\"menu\"\n\t\t\t#dialog\n\t\t\tclass=\"bx--overflow-menu-options bx--overflow-menu-options--open\"\n\t\t\trole=\"menu\"\n\t\t\t(click)=\"onClose($event)\"\n\t\t\t[attr.aria-label]=\"dialogConfig.menuLabel\">\n\t\t\t<ng-template\n\t\t\t\t[ngTemplateOutlet]=\"dialogConfig.content\"\n\t\t\t\t[ngTemplateOutletContext]=\"{overflowMenu: this}\">\n\t\t\t</ng-template>\n\t\t</ul>\n\t"
                    }] }
        ];
        /** @nocollapse */
        OverflowMenuPane.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: i18n.I18n },
                { type: experimental.ExperimentalService },
                { type: utils.AnimationFrameService, decorators: [{ type: core.Optional }] },
                { type: utils.ElementService, decorators: [{ type: core.Optional }] }
            ];
        };
        OverflowMenuPane.propDecorators = {
            hostkeys: [{ type: core.HostListener, args: ["keydown", ["$event"],] }]
        };
        return OverflowMenuPane;
    }(Dialog));

    var OverflowMenuCustomPane = /** @class */ (function (_super) {
        __extends(OverflowMenuCustomPane, _super);
        function OverflowMenuCustomPane(elementRef, i18n$$1, animationFrameService, 
        // mark `elementService` as optional since making it mandatory would be a breaking change
        elementService) {
            if (animationFrameService === void 0) {
                animationFrameService = null;
            }
            if (elementService === void 0) {
                elementService = null;
            }
            var _this = _super.call(this, elementRef, elementService, animationFrameService) || this;
            _this.elementRef = elementRef;
            _this.i18n = i18n$$1;
            _this.animationFrameService = animationFrameService;
            _this.elementService = elementService;
            return _this;
        }
        OverflowMenuCustomPane.prototype.onDialogInit = function () {
            var _this = this;
            var positionOverflowMenu = function (pos) {
                var offset;
                /*
                * 20 is half the width of the overflow menu trigger element.
                * we also move the element by half of it's own width, since
                * position service will try and center everything
                */
                var closestRel = utils.closestAttr("position", ["relative", "fixed", "absolute"], _this.elementRef.nativeElement);
                var topFix = closestRel ? closestRel.getBoundingClientRect().top * -1 : 0;
                var leftFix = closestRel ? closestRel.getBoundingClientRect().left * -1 : 0;
                offset = Math.round(_this.dialog.nativeElement.offsetWidth / 2) - 20;
                if (_this.dialogConfig.flip) {
                    return Position.position.addOffset(pos, topFix, (-offset + leftFix));
                }
                return Position.position.addOffset(pos, topFix, (offset + leftFix));
            };
            this.addGap["bottom"] = positionOverflowMenu;
            this.addGap["top"] = positionOverflowMenu;
            if (!this.dialogConfig.menuLabel) {
                this.dialogConfig.menuLabel = this.i18n.get().OVERFLOW_MENU.OVERFLOW;
            }
        };
        OverflowMenuCustomPane.decorators = [
            { type: core.Component, args: [{
                        selector: "ibm-overflow-custom-menu-pane",
                        template: "\n\t\t<div\n\t\t\t[attr.aria-label]=\"dialogConfig.menuLabel\"\n\t\t\t[ngClass]=\"{'bx--overflow-menu--flip': dialogConfig.flip}\"\n\t\t\tclass=\"bx--overflow-menu-options bx--overflow-menu-options--open\"\n\t\t\trole=\"menu\"\n\t\t\t(click)=\"doClose()\"\n\t\t\t#dialog\n\t\t\t[attr.aria-label]=\"dialogConfig.menuLabel\">\n\t\t\t<ng-template\n\t\t\t\t[ngTemplateOutlet]=\"dialogConfig.content\"\n\t\t\t\t[ngTemplateOutletContext]=\"{overflowMenu: this}\">\n\t\t\t</ng-template>\n\t\t</div>\n\t"
                    }] }
        ];
        /** @nocollapse */
        OverflowMenuCustomPane.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: i18n.I18n },
                { type: utils.AnimationFrameService, decorators: [{ type: core.Optional }] },
                { type: utils.ElementService, decorators: [{ type: core.Optional }] }
            ];
        };
        return OverflowMenuCustomPane;
    }(Dialog));

    /**
     * Directive for extending `Dialog` to create overflow menus.
     *
     * class: OverflowMenuDirective (extends DialogDirective)
     *
     *
     * selector: `ibmOverflowMenu`
     *
     *
     * ```html
     * <div [ibmOverflowMenu]="templateRef"></div>
     * <ng-template #templateRef>
     * 	<!-- overflow menu options here -->
     * </ng-template>
     * ```
     *
     * ```html
     * <div [ibmOverflowMenu]="templateRef" [customPane]="true"></div>
     * <ng-template #templateRef>
     *  <!-- custom content goes here -->
     * </ng-template>
     * ```
     */
    var OverflowMenuDirective = /** @class */ (function (_super) {
        __extends(OverflowMenuDirective, _super);
        /**
         * Creates an instance of `OverflowMenuDirective`.
         */
        function OverflowMenuDirective(elementRef, viewContainerRef, dialogService, eventService) {
            var _this = _super.call(this, elementRef, viewContainerRef, dialogService, eventService) || this;
            _this.elementRef = elementRef;
            _this.viewContainerRef = viewContainerRef;
            _this.dialogService = dialogService;
            _this.eventService = eventService;
            /**
             * Controls wether the overflow menu is flipped
             */
            _this.flip = false;
            /**
             * Classes to add to the dialog container
             */
            _this.wrapperClass = "";
            /**
             * Set to true to for custom content
             */
            _this.customPane = false;
            return _this;
        }
        OverflowMenuDirective.prototype.ngAfterContentInit = function () {
            this.dialogService.setContext({ component: this.customPane ? OverflowMenuCustomPane : OverflowMenuPane });
        };
        OverflowMenuDirective.prototype.updateConfig = function () {
            this.dialogConfig.content = this.ibmOverflowMenu;
            this.dialogConfig.flip = this.flip;
            this.dialogConfig.offset = this.offset;
            this.dialogConfig.wrapperClass = this.wrapperClass;
        };
        OverflowMenuDirective.prototype.hostkeys = function (event) {
            switch (event.key) {
                case "Enter":
                case " ":
                    event.preventDefault();
                    break;
            }
        };
        OverflowMenuDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: "[ibmOverflowMenu]",
                        exportAs: "ibmOverflowMenu",
                        providers: [
                            DialogService
                        ]
                    },] }
        ];
        /** @nocollapse */
        OverflowMenuDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.ViewContainerRef },
                { type: DialogService },
                { type: utils.EventService }
            ];
        };
        OverflowMenuDirective.propDecorators = {
            ibmOverflowMenu: [{ type: core.Input }],
            flip: [{ type: core.Input }],
            offset: [{ type: core.Input }],
            wrapperClass: [{ type: core.Input }],
            customPane: [{ type: core.Input }],
            hostkeys: [{ type: core.HostListener, args: ["keydown", ["$event"],] }]
        };
        return OverflowMenuDirective;
    }(DialogDirective));

    /**
     * The OverFlow menu component encapsulates the OverFlowMenu directive, and the menu iconography into one convienent component
     *
     * [See demo](../../?path=/story/overflow-menu--basic)
     *
     * html:
     * ```
     * <ibm-overflow-menu>
     *	<ibm-overflow-menu-option>Option 1</ibm-overflow-menu-option>
     *	<ibm-overflow-menu-option>Option 2</ibm-overflow-menu-option>
     * </ibm-overflow-menu>
     * ```
     *
     * <example-url>../../iframe.html?id=overflow-menu--basic</example-url>
     */
    var OverflowMenu = /** @class */ (function () {
        function OverflowMenu(elementRef, i18n$$1) {
            this.elementRef = elementRef;
            this.i18n = i18n$$1;
            this.buttonLabel = this.i18n.get().OVERFLOW_MENU.OVERFLOW;
            this.flip = false;
            this.placement = "bottom";
            this.open = false;
            this.openChange = new core.EventEmitter();
            this.wrapperClass = "";
            /**
             * This appends additional classes to the overflow trigger/button.
             */
            this.triggerClass = "";
        }
        OverflowMenu.prototype.handleOpenChange = function (event) {
            this.open = event;
            this.openChange.emit(event);
        };
        OverflowMenu.decorators = [
            { type: core.Component, args: [{
                        selector: "ibm-overflow-menu",
                        template: "\n\t\t<button\n\t\t\t[ibmOverflowMenu]=\"options\"\n\t\t\t[ngClass]=\"{'bx--overflow-menu--open': open}\"\n\t\t\tclass=\"bx--overflow-menu {{triggerClass}}\"\n\t\t\t[attr.aria-label]=\"buttonLabel\"\n\t\t\t[flip]=\"flip\"\n\t\t\t[isOpen]=\"open\"\n\t\t\t(isOpenChange)=\"handleOpenChange($event)\"\n\t\t\t[offset]=\"offset\"\n\t\t\t[wrapperClass]=\"wrapperClass\"\n\t\t\taria-haspopup=\"true\"\n\t\t\tclass=\"bx--overflow-menu\"\n\t\t\ttype=\"button\"\n\t\t\t[placement]=\"placement\">\n\t\t\t<ng-template *ngIf=\"customTrigger; else defaultIcon\" [ngTemplateOutlet]=\"customTrigger\"></ng-template>\n\t\t</button>\n\t\t<ng-template #options>\n\t\t\t<ng-content></ng-content>\n\t\t</ng-template>\n\t\t<ng-template #defaultIcon>\n\t\t\t<svg ibmIcon=\"overflow-menu--vertical\" size=\"16\" class=\"bx--overflow-menu__icon\"></svg>\n\t\t</ng-template>\n\t",
                        encapsulation: core.ViewEncapsulation.None,
                        styles: ["\n\t\t.bx--overflow-menu--open {\n\t\t\topacity: 1\n\t\t}\n\n\t\t/*\n\t\tRotate the overflow menu container as well as the icon, since\n\t\twe calculate our menu position based on the container, not the icon.\n\t\t*/\n\t\t.bx--data-table-v2 .bx--overflow-menu {\n\t\t\ttransform: rotate(90deg);\n\t\t}\n\n\t\t.bx--data-table-v2 .bx--overflow-menu__icon {\n\t\t\ttransform: rotate(180deg);\n\t\t}\n\t"]
                    }] }
        ];
        /** @nocollapse */
        OverflowMenu.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: i18n.I18n }
            ];
        };
        OverflowMenu.propDecorators = {
            buttonLabel: [{ type: core.Input }],
            flip: [{ type: core.Input }],
            placement: [{ type: core.Input }],
            open: [{ type: core.Input }],
            openChange: [{ type: core.Output }],
            customTrigger: [{ type: core.Input }],
            offset: [{ type: core.Input }],
            wrapperClass: [{ type: core.Input }],
            triggerClass: [{ type: core.Input }],
            overflowMenuDirective: [{ type: core.ContentChild, args: [OverflowMenuDirective, { static: false },] }]
        };
        return OverflowMenu;
    }());

    /**
     * Available HTML anchor targets
     */
    var Target;
    (function (Target) {
        Target["self"] = "_self";
        Target["blank"] = "_blank";
        Target["parent"] = "_parent";
        Target["top"] = "_top";
    })(Target || (Target = {}));
    /**
     * Security HTML anchor rel when target is set
     */
    var REL = "noreferrer noopener";
    /**
     * `OverflowMenuOption` represents a single option in an overflow menu
     *
     * Presently it has three possible states - normal, disabled, and danger:
     * ```
     * <ibm-overflow-menu-option>Simple option</ibm-overflow-menu-option>
     * <ibm-overflow-menu-option disabled="true">Disabled</ibm-overflow-menu-option>
     * <ibm-overflow-menu-option type="danger">Danger option</ibm-overflow-menu-option>
     * ```
     *
     * For content that expands beyond the overflow menu `OverflowMenuOption` automatically adds a title attribute.
     */
    var OverflowMenuOption = /** @class */ (function () {
        function OverflowMenuOption(elementRef) {
            this.elementRef = elementRef;
            this.optionClass = "bx--overflow-menu-options__option";
            this.role = "presentation";
            /**
             * toggles between `normal` and `danger` states
             */
            this.type = "normal";
            /**
             * disable/enable interactions
             */
            this.disabled = false;
            this.selected = new core.EventEmitter();
            this.tabIndex = -1;
            // note: title must be a real attribute (i.e. not a getter) as of Angular@6 due to
            // change after checked errors
            this.title = null;
        }
        Object.defineProperty(OverflowMenuOption.prototype, "isDanger", {
            get: function () {
                return this.type === "danger";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OverflowMenuOption.prototype, "isDisabled", {
            get: function () {
                return this.disabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OverflowMenuOption.prototype, "target", {
            get: function () {
                return this._target;
            },
            /**
             * Allows to add a target to the anchor
             */
            set: function (value) {
                if (!Object.values(Target).includes(value)) {
                    console.warn("`target` must have one of the following values: " + Object.values(Target).join(", ") + ".\nPlease use the `Target` enum exported by carbon-components-angular");
                    return;
                }
                this._target = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OverflowMenuOption.prototype, "rel", {
            /**
             * rel only returns its value if target is defined
             */
            get: function () {
                return this._target ? REL : null;
            },
            enumerable: true,
            configurable: true
        });
        OverflowMenuOption.prototype.onClick = function () {
            this.selected.emit();
        };
        OverflowMenuOption.prototype.onFocus = function () {
            var _this = this;
            setTimeout(function () { return _this.tabIndex = 0; });
        };
        OverflowMenuOption.prototype.onBlur = function () {
            var _this = this;
            setTimeout(function () { return _this.tabIndex = -1; });
        };
        OverflowMenuOption.prototype.ngAfterViewInit = function () {
            var button = this.elementRef.nativeElement.querySelector("button, a");
            var textContainer = button.querySelector(".bx--overflow-menu-options__option-content");
            if (textContainer.scrollWidth > textContainer.offsetWidth) {
                this.title = button.textContent;
            }
        };
        OverflowMenuOption.decorators = [
            { type: core.Component, args: [{
                        selector: "ibm-overflow-menu-option",
                        template: "\n\t\t<button\n\t\t\t*ngIf=\"!href\"\n\t\t\tclass=\"bx--overflow-menu-options__btn\"\n\t\t\trole=\"menuitem\"\n\t\t\t[tabindex]=\"tabIndex\"\n\t\t\t(focus)=\"onFocus()\"\n\t\t\t(blur)=\"onBlur()\"\n\t\t\t(click)=\"onClick()\"\n\t\t\t[disabled]=\"disabled\"\n\t\t\t[attr.title]=\"title\">\n\t\t\t<ng-container *ngTemplateOutlet=\"tempOutlet\"></ng-container>\n\t\t</button>\n\n\t\t<a\n\t\t\t*ngIf=\"href\"\n\t\t\tclass=\"bx--overflow-menu-options__btn\"\n\t\t\trole=\"menuitem\"\n\t\t\t[tabindex]=\"tabIndex\"\n\t\t\t(focus)=\"onFocus()\"\n\t\t\t(blur)=\"onBlur()\"\n\t\t\t(click)=\"onClick()\"\n\t\t\t[attr.disabled]=\"disabled\"\n\t\t\t[href]=\"href\"\n\t\t\t[attr.target]=\"target\"\n\t\t\t[attr.rel]=\"rel\"\n\t\t\t[attr.title]=\"title\">\n\t\t\t<ng-container *ngTemplateOutlet=\"tempOutlet\"></ng-container>\n\t\t</a>\n\n\t\t<ng-template #tempOutlet>\n\t\t\t<div class=\"bx--overflow-menu-options__option-content\">\n\t\t\t\t<ng-content></ng-content>\n\t\t\t</div>\n\t\t</ng-template>\n\t"
                    }] }
        ];
        /** @nocollapse */
        OverflowMenuOption.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        OverflowMenuOption.propDecorators = {
            optionClass: [{ type: core.HostBinding, args: ["class",] }],
            role: [{ type: core.HostBinding, args: ["attr.role",] }],
            isDanger: [{ type: core.HostBinding, args: ["class.bx--overflow-menu-options__option--danger",] }],
            isDisabled: [{ type: core.HostBinding, args: ["class.bx--overflow-menu-options__option--disabled",] }],
            type: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            href: [{ type: core.Input }],
            target: [{ type: core.Input }],
            selected: [{ type: core.Output }]
        };
        return OverflowMenuOption;
    }());

    // modules
    var DialogModule = /** @class */ (function () {
        function DialogModule() {
        }
        DialogModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            Dialog,
                            Tooltip,
                            TooltipDefinition,
                            TooltipIcon,
                            OverflowMenu,
                            OverflowMenuPane,
                            OverflowMenuCustomPane,
                            DialogDirective,
                            TooltipDirective,
                            EllipsisTooltip,
                            OverflowMenuDirective,
                            OverflowMenuOption
                        ],
                        exports: [
                            Dialog,
                            Tooltip,
                            TooltipDefinition,
                            TooltipIcon,
                            OverflowMenu,
                            OverflowMenuPane,
                            OverflowMenuCustomPane,
                            DialogDirective,
                            TooltipDirective,
                            EllipsisTooltip,
                            OverflowMenuDirective,
                            OverflowMenuOption
                        ],
                        providers: [DialogService],
                        entryComponents: [
                            Dialog,
                            Tooltip,
                            OverflowMenuPane,
                            OverflowMenuCustomPane
                        ],
                        imports: [
                            common$1.CommonModule,
                            i18n.I18nModule,
                            placeholder.PlaceholderModule,
                            experimental.ExperimentalModule,
                            utils.UtilsModule,
                            icon.IconModule
                        ]
                    },] }
        ];
        return DialogModule;
    }());

    /**
     * Generated bundle index. Do not edit.
     */

    exports.DialogService = DialogService;
    exports.Dialog = Dialog;
    exports.DialogDirective = DialogDirective;
    exports.Tooltip = Tooltip;
    exports.TooltipDefinition = TooltipDefinition;
    exports.TooltipIcon = TooltipIcon;
    exports.TooltipDirective = TooltipDirective;
    exports.EllipsisTooltip = EllipsisTooltip;
    exports.OverflowMenu = OverflowMenu;
    exports.OverflowMenuPane = OverflowMenuPane;
    exports.OverflowMenuCustomPane = OverflowMenuCustomPane;
    exports.OverflowMenuDirective = OverflowMenuDirective;
    exports.OverflowMenuOption = OverflowMenuOption;
    exports.DialogModule = DialogModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=carbon-components-angular-dialog.umd.js.map