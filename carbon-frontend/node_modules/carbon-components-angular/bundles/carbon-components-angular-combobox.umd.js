/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-combobox.umd.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/forms'), require('rxjs/operators'), require('@angular/core'), require('@angular/common'), require('carbon-components-angular/dropdown'), require('carbon-components-angular/i18n'), require('carbon-components-angular/utils'), require('carbon-components-angular/icon')) :
    typeof define === 'function' && define.amd ? define('carbon-components-angular/combobox', ['exports', '@angular/forms', 'rxjs/operators', '@angular/core', '@angular/common', 'carbon-components-angular/dropdown', 'carbon-components-angular/i18n', 'carbon-components-angular/utils', 'carbon-components-angular/icon'], factory) :
    (factory((global['carbon-components-angular'] = global['carbon-components-angular'] || {}, global['carbon-components-angular'].combobox = {}),global.ng.forms,global.rxjs.operators,global.ng.core,global.ng.common,global['carbon-components-angular'].dropdown,global['carbon-components-angular'].i18n,global['carbon-components-angular'].utils,global['carbon-components-angular'].icon));
}(this, (function (exports,forms,operators,core,common,dropdown,i18n,utils,icon) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    /**
     * ComboBoxes are similar to dropdowns, except a combobox provides an input field for users to search items and (optionally) add their own.
     * Multi-select comboboxes also provide "pills" of selected items.
     *
     * [See demo](../../?path=/story/combobox--basic)
     *
     * <example-url>../../iframe.html?id=combobox--basic</example-url>
     */
    var ComboBox = /** @class */ (function () {
        /**
         * Creates an instance of ComboBox.
         */
        function ComboBox(elementRef, documentService, dropdownService, i18n$$1) {
            this.elementRef = elementRef;
            this.documentService = documentService;
            this.dropdownService = dropdownService;
            this.i18n = i18n$$1;
            this.id = "dropdown-" + ComboBox.comboBoxCount++;
            /**
             * List of items to fill the content with.
             *
             * **Example:**
             * ```javascript
             * items = [
             *		{
             *			content: "Abacus",
             *			selected: false
             *		},
             *		{
             *			content: "Byte",
             *			selected: false,
             *		},
             *		{
             *			content: "Computer",
             *			selected: false
             *		},
             *		{
             *			content: "Digital",
             *			selected: false
             *		}
             * ];
             * ```
             *
             */
            this.items = [];
            /**
             * Combo box type (supporting single or multi selection of items).
             */
            this.type = "single";
            /**
             * Combo box render size.
             *
             * @deprecated since v4
             */
            this.size = "md";
            /**
             * set to `true` to place the dropdown view inline with the component
             */
            this.appendInline = null;
            /**
             * Set to `true` for invalid state.
             */
            this.invalid = false;
            /**
             * Max length value to limit input characters
             */
            this.maxLength = null;
            /**
             * `light` or `dark` dropdown theme
             */
            this.theme = "dark";
            /**
             * Specify feedback (mode) of the selection.
             * `top`: selected item jumps to top
             * `fixed`: selected item stays at its position
             * `top-after-reopen`: selected item jump to top after reopen dropdown
             */
            this.selectionFeedback = "top-after-reopen";
            /**
             * Specify autocomplete attribute of text input
             */
            this.autocomplete = "list";
            /**
             * Set to `true` to disable combobox.
             */
            this.disabled = false;
            /**
             * Emits a ListItem
             *
             * Example:
             * ```javascript
             * {
             * 		content: "one",
             * 		selected: true
             * }
             * ```
             */
            this.selected = new core.EventEmitter();
            /**
             * Intended to be used to add items to the list.
             *
             * Emits an event that includes the current item list, the suggested index for the new item, and a simple ListItem
             *
             * Example:
             * ```javascript
             *	{
             *		items: [{content: "one", selected: true}, {content: "two", selected: true}],
             *		index: 1,
             *		value: {
             *			content: "some user string",
             *			selected: false
             *		}
             *	}
             * ```
             *
             *
             * Example:
             * ```javascript
             * {
             *	after: 1,
             *	value: "some user string"
             * }
             * ```
             */
            this.submit = new core.EventEmitter();
            /** emits an empty event when the menu is closed */
            this.close = new core.EventEmitter();
            /** emits the search string from the input */
            this.search = new core.EventEmitter();
            this.hostClass = true;
            // @HostBinding("attr.role") role = "combobox";
            this.display = "block";
            this.open = false;
            this.showClearButton = false;
            /** Selected items for multi-select combo-boxes. */
            this.pills = [];
            /** used to update the displayValue */
            this.selectedValue = "";
            this.keyboardNav = this._keyboardNav.bind(this);
            this.noop = this._noop.bind(this);
            this.onTouchedCallback = this._noop;
            this.propagateChangeCallback = this._noop;
            this._placeholder = this.i18n.getOverridable("COMBOBOX.PLACEHOLDER");
            this._closeMenuAria = this.i18n.getOverridable("COMBOBOX.A11Y.CLOSE_MENU");
            this._openMenuAria = this.i18n.getOverridable("COMBOBOX.A11Y.OPEN_MENU");
            this._clearSelectionsTitle = this.i18n.getOverridable("COMBOBOX.CLEAR_SELECTIONS");
            this._clearSelectionsAria = this.i18n.getOverridable("COMBOBOX.A11Y.CLEAR_SELECTIONS");
            this._clearSelectionTitle = this.i18n.getOverridable("COMBOBOX.CLEAR_SELECTED");
            this._clearSelectionAria = this.i18n.getOverridable("COMBOBOX.A11Y.CLEAR_SELECTED");
        }
        Object.defineProperty(ComboBox.prototype, "placeholder", {
            get: function () {
                return this._placeholder.value;
            },
            /**
             * Text to show when nothing is selected.
             */
            set: function (value) {
                this._placeholder.override(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComboBox.prototype, "openMenuAria", {
            get: function () {
                return this._openMenuAria.value;
            },
            /**
             * Value to display for accessibility purposes on the combobox control menu when closed
             */
            set: function (value) {
                this._openMenuAria.override(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComboBox.prototype, "closeMenuAria", {
            get: function () {
                return this._closeMenuAria.value;
            },
            /**
             * Value to display for accessibility purposes on the combobox control menu when opened
             */
            set: function (value) {
                this._closeMenuAria.override(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComboBox.prototype, "clearSelectionsTitle", {
            get: function () {
                return this._clearSelectionsTitle.value;
            },
            /**
             * Value to display on the clear selections icon, when multi is selected
             */
            set: function (value) {
                this._clearSelectionsTitle.override(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComboBox.prototype, "clearSelectionsAria", {
            get: function () {
                return this._clearSelectionsAria.value;
            },
            /**
             * Value to display for accessibility purposes to clear selections, when multi is selected
             */
            set: function (value) {
                this._clearSelectionsAria.override(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComboBox.prototype, "clearSelectionTitle", {
            get: function () {
                return this._clearSelectionTitle.value;
            },
            /**
             * Value to display on the clear the selected item icon, when single is selected
             */
            set: function (value) {
                this._clearSelectionTitle.override(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComboBox.prototype, "clearSelectionAria", {
            get: function () {
                return this._clearSelectionAria.value;
            },
            /**
             * Value to display for accessibility purposes on the clear the selected item icon, when single is selected
             */
            set: function (value) {
                this._clearSelectionAria.override(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Lifecycle hook.
         * Updates pills if necessary.
         *
         */
        ComboBox.prototype.ngOnChanges = function (changes) {
            if (changes.items) {
                this.view.items = changes.items.currentValue;
                // If new items are added into the combobox while there is search input,
                // repeat the search.
                this.onSearch(this.input.nativeElement.value, false);
                this.updateSelected();
            }
        };
        /**
         * Sets initial state that depends on child components
         * Subscribes to select events and handles focus/filtering/initial list updates
         */
        ComboBox.prototype.ngAfterContentInit = function () {
            var _this = this;
            if (this.view) {
                this.view.type = this.type;
                this.view.select.subscribe(function (event) {
                    if (_this.type === "multi") {
                        _this.updatePills();
                        if (_this.itemValueKey && _this.view.getSelected()) {
                            var values = _this.view.getSelected().map(function (item) { return item[_this.itemValueKey]; });
                            _this.propagateChangeCallback(values);
                            // otherwise just pass up the values from `getSelected`
                        }
                        else {
                            _this.propagateChangeCallback(_this.view.getSelected());
                        }
                    }
                    else {
                        if (event.item && event.item.selected) {
                            _this.showClearButton = true;
                            _this.selectedValue = event.item.content;
                            if (_this.itemValueKey) {
                                _this.propagateChangeCallback(event.item[_this.itemValueKey]);
                            }
                            else {
                                _this.propagateChangeCallback(event.item);
                            }
                        }
                        else {
                            _this.selectedValue = "";
                            _this.propagateChangeCallback(null);
                        }
                        // not guarding these since the nativeElement has to be loaded
                        // for select to even fire
                        // only focus for "organic" selections
                        if (event && !event.isUpdate) {
                            _this.elementRef.nativeElement.querySelector("input").focus();
                            _this.view.filterBy("");
                        }
                        _this.closeDropdown();
                    }
                    if (event && !event.isUpdate) {
                        _this.selected.emit(event);
                    }
                });
                // update the rest of combobox with any pre-selected items
                // setTimeout just defers the call to the next check cycle
                setTimeout(function () {
                    _this.updateSelected();
                });
                this.view.blurIntent.pipe(operators.filter(function (v) { return v === "top"; })).subscribe(function () {
                    _this.elementRef.nativeElement.querySelector(".bx--text-input").focus();
                });
            }
        };
        /**
         * Binds event handlers against the rendered view
         */
        ComboBox.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.documentService.handleClick(function (event) {
                if (!_this.elementRef.nativeElement.contains(event.target) &&
                    !_this.dropdownMenu.nativeElement.contains(event.target)) {
                    if (_this.open) {
                        _this.closeDropdown();
                    }
                }
            });
            // if appendInline is default valued (null) we should:
            // 1. if there are scrollable parents (not including body) don't append inline
            //    this should also cover the case where the dropdown is in a modal
            //    (where we _do_ want to append to the placeholder)
            if (this.appendInline === null && utils.hasScrollableParents(this.elementRef.nativeElement)) {
                this.appendInline = false;
                // 2. otherwise we should append inline
            }
            else if (this.appendInline === null) {
                this.appendInline = true;
            }
        };
        /**
         * Removing the `Dropdown` from the body if it is appended to the body.
         */
        ComboBox.prototype.ngOnDestroy = function () {
            if (!this.appendInline) {
                this._appendToDropdown();
            }
        };
        /**
         * Handles `Escape/Tab` key closing the dropdown, and arrow up/down focus to/from the dropdown list.
         */
        ComboBox.prototype.hostkeys = function (ev) {
            var _this = this;
            if (ev.key === "Escape") {
                this.closeDropdown();
            }
            else if ((ev.key === "ArrowDown" || ev.key === "Down") // `"Down"` is IE specific value
                && (!this.dropdownMenu || !this.dropdownMenu.nativeElement.contains(ev.target))) {
                ev.stopPropagation();
                this.openDropdown();
                setTimeout(function () { return _this.view.getCurrentElement().focus(); }, 0);
            }
            if (this.open && ev.key === "Tab" &&
                (this.dropdownMenu.nativeElement.contains(ev.target) || ev.target === this.input.nativeElement)) {
                this.closeDropdown();
            }
            if (this.open && ev.key === "Tab" && ev.shiftKey) {
                this.closeDropdown();
            }
        };
        /*
         * no-op method for null event listeners, and other no op calls
         */
        ComboBox.prototype._noop = function () { };
        /*
         * propagates the value provided from ngModel
         */
        ComboBox.prototype.writeValue = function (value) {
            var _this = this;
            var e_1, _a, e_2, _b;
            if (this.type === "single") {
                if (this.itemValueKey) {
                    // clone the specified item and update its state
                    var newValue = Object.assign({}, this.view.getListItems().find(function (item) { return item[_this.itemValueKey] === value; }));
                    newValue.selected = true;
                    this.view.propagateSelected([newValue]);
                }
                else {
                    // all items in propagateSelected must be iterable
                    this.view.propagateSelected([value || ""]);
                }
                this.showClearButton = !!(value && this.view.getSelected().length);
            }
            else {
                if (this.itemValueKey) {
                    // clone the items and update their state based on the received value array
                    // this way we don't lose any additional metadata that may be passed in via the `items` Input
                    var newValues = [];
                    try {
                        for (var value_1 = __values(value), value_1_1 = value_1.next(); !value_1_1.done; value_1_1 = value_1.next()) {
                            var v = value_1_1.value;
                            try {
                                for (var _c = __values(this.view.getListItems()), _d = _c.next(); !_d.done; _d = _c.next()) {
                                    var item = _d.value;
                                    if (item[this.itemValueKey] === v) {
                                        newValues.push(Object.assign({}, item, { selected: true }));
                                    }
                                }
                            }
                            catch (e_2_1) {
                                e_2 = { error: e_2_1 };
                            }
                            finally {
                                try {
                                    if (_d && !_d.done && (_b = _c.return))
                                        _b.call(_c);
                                }
                                finally {
                                    if (e_2)
                                        throw e_2.error;
                                }
                            }
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (value_1_1 && !value_1_1.done && (_a = value_1.return))
                                _a.call(value_1);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                    this.view.propagateSelected(newValues);
                }
                else {
                    this.view.propagateSelected(value ? value : [""]);
                }
            }
            this.updateSelected();
        };
        ComboBox.prototype.onBlur = function () {
            this.onTouchedCallback();
        };
        ComboBox.prototype.registerOnChange = function (fn) {
            this.propagateChangeCallback = fn;
        };
        ComboBox.prototype.registerOnTouched = function (fn) {
            this.onTouchedCallback = fn;
        };
        /**
         * `ControlValueAccessor` method to programmatically disable the combobox.
         *
         * ex: `this.formGroup.get("myCoolCombobox").disable();`
         */
        ComboBox.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        /**
         * Called by `n-pill-input` when the selected pills have changed.
         */
        ComboBox.prototype.updatePills = function () {
            this.pills = this.view.getSelected() || [];
            this.checkForReorder();
        };
        ComboBox.prototype.clearSelected = function () {
            this.items = this.items.map(function (item) {
                if (!item.disabled) {
                    item.selected = false;
                }
                return item;
            });
            this.view.items = this.items;
            this.updatePills();
            // clearSelected can only fire on type=multi
            // so we just emit getSelected() (just in case there's any disabled but selected items)
            var selected = this.view.getSelected();
            this.propagateChangeCallback(selected);
            this.selected.emit(selected);
        };
        /**
         * Closes the dropdown and emits the close event.
         */
        ComboBox.prototype.closeDropdown = function () {
            this.open = false;
            this.checkForReorder();
            this.close.emit();
            if (!this.appendInline) {
                this._appendToDropdown();
            }
        };
        /**
         * Opens the dropdown.
         */
        ComboBox.prototype.openDropdown = function () {
            if (this.disabled) {
                return;
            }
            this.open = true;
            if (!this.appendInline) {
                this._appendToBody();
            }
        };
        /**
         * Toggles the dropdown.
         */
        ComboBox.prototype.toggleDropdown = function () {
            if (this.open) {
                this.closeDropdown();
            }
            else {
                this.openDropdown();
            }
        };
        /**
         * Sets the list group filter, and manages single select item selection.
         */
        ComboBox.prototype.onSearch = function (searchString, shouldEmitSearch) {
            if (shouldEmitSearch === void 0) {
                shouldEmitSearch = true;
            }
            if (shouldEmitSearch) {
                this.search.emit(searchString);
            }
            this.showClearButton = !!searchString;
            this.view.filterBy(searchString);
            if (searchString !== "") {
                this.openDropdown();
            }
            else {
                this.selectedValue = "";
                if (this.type === "multi" &&
                    (this.selectionFeedback === "top" || this.selectionFeedback === "top-after-reopen")) {
                    this.view.reorderSelected();
                }
            }
            if (this.type === "single") {
                // deselect if the input doesn't match the content
                // of any given item
                var matches = this.view.getListItems().some(function (item) { return item.content.toLowerCase().includes(searchString.toLowerCase()); });
                if (!matches) {
                    var selected = this.view.getSelected();
                    if (!selected || !selected[0]) {
                        this.view.filterBy("");
                    }
                }
            }
        };
        /**
         * Intended to be used to add items to the list.
         */
        ComboBox.prototype.onSubmit = function (event) {
            this.submit.emit({
                items: this.view.getListItems(),
                index: 0,
                value: {
                    content: event.target.value,
                    selected: false
                }
            });
        };
        ComboBox.prototype.clearInput = function (event) {
            event.stopPropagation();
            event.preventDefault();
            if (this.type === "single") { // don't want to clear selected or close if multi
                this.clearSelected();
                this.closeDropdown();
            }
            this.selectedValue = "";
            this.input.nativeElement.value = "";
            this.showClearButton = false;
            this.input.nativeElement.focus();
            this.onSearch(this.input.nativeElement.value);
        };
        ComboBox.prototype.isTemplate = function (value) {
            return value instanceof core.TemplateRef;
        };
        /**
         * Handles keyboard events so users are controlling the `Dropdown` instead of unintentionally controlling outside elements.
         */
        ComboBox.prototype._keyboardNav = function (event) {
            // "Esc" is an IE specific value
            if ((event.key === "Escape" || event.key === "Esc") && this.open) {
                event.stopImmediatePropagation(); // don't unintentionally close modal if inside of it
            }
            if (event.key === "Escape" || event.key === "Esc") {
                event.preventDefault();
                this.closeDropdown();
                this.input.nativeElement.focus();
            }
            else if (this.open && event.key === "Tab") {
                // this way focus will start on the next focusable item from the dropdown
                // not the top of the body!
                this.input.nativeElement.focus();
                this.input.nativeElement.dispatchEvent(new KeyboardEvent("keydown", { bubbles: true, cancelable: true, key: "Tab" }));
                this.closeDropdown();
            }
        };
        /**
         * Creates the `Dropdown` list as an element that is appended to the DOM body.
         */
        ComboBox.prototype._appendToBody = function () {
            this.dropdownService.appendToBody(this.listbox.nativeElement, this.dropdownMenu.nativeElement, "" + this.elementRef.nativeElement.className + (this.open ? " bx--list-box--expanded" : ""));
            this.dropdownMenu.nativeElement.addEventListener("keydown", this.keyboardNav, true);
        };
        /**
         * Creates the `Dropdown` list appending it to the dropdown parent object instead of the body.
         */
        ComboBox.prototype._appendToDropdown = function () {
            this.dropdownService.appendToDropdown(this.elementRef.nativeElement);
            this.dropdownMenu.nativeElement.removeEventListener("keydown", this.keyboardNav, true);
        };
        ComboBox.prototype.updateSelected = function () {
            var selected = this.view.getSelected();
            if (this.type === "multi") {
                this.updatePills();
            }
            else if (selected) {
                var value = selected[0] ? selected[0].content : "";
                var changeCallbackValue = selected[0] ? selected[0] : "";
                this.selectedValue = value;
                this.showClearButton = !!value;
            }
        };
        ComboBox.prototype.checkForReorder = function () {
            var topAfterReopen = !this.open && this.selectionFeedback === "top-after-reopen";
            if ((this.type === "multi") && (topAfterReopen || this.selectionFeedback === "top")) {
                this.view.reorderSelected(this.selectionFeedback === "top");
            }
        };
        ComboBox.comboBoxCount = 0;
        ComboBox.decorators = [
            { type: core.Component, args: [{
                        selector: "ibm-combo-box",
                        template: "\n\t\t<label\n\t\t\t*ngIf=\"label\"\n\t\t\t[for]=\"id\"\n\t\t\tclass=\"bx--label\"\n\t\t\t[ngClass]=\"{'bx--label--disabled': disabled}\">\n\t\t\t<ng-container *ngIf=\"!isTemplate(label)\">{{label}}</ng-container>\n\t\t\t<ng-template *ngIf=\"isTemplate(label)\" [ngTemplateOutlet]=\"label\"></ng-template>\n\t\t</label>\n\t\t<div\n\t\t\t#listbox\n\t\t\t[ngClass]=\"{\n\t\t\t\t'bx--multi-select': type === 'multi',\n\t\t\t\t'bx--combo-box': type === 'single' || !pills.length,\n\t\t\t\t'bx--list-box--light': theme === 'light',\n\t\t\t\t'bx--list-box--expanded': open,\n\t\t\t\t'bx--list-box--sm': size === 'sm',\n\t\t\t\t'bx--list-box--xl': size === 'xl',\n\t\t\t\t'bx--list-box--disabled': disabled\n\t\t\t}\"\n\t\t\tclass=\"bx--combo-box bx--list-box\"\n\t\t\trole=\"combobox\"\n\t\t\t[id]=\"id\"\n\t\t\t[attr.data-invalid]=\"(invalid ? true : null)\">\n\t\t\t<div\n\t\t\t\t[attr.aria-expanded]=\"open\"\n\t\t\t\trole=\"button\"\n\t\t\t\tclass=\"bx--list-box__field\"\n\t\t\t\ttype=\"button\"\n\t\t\t\ttabindex=\"-1\"\n\t\t\t\taria-haspopup=\"true\"\n\t\t\t\t(click)=\"toggleDropdown()\"\n\t\t\t\t(blur)=\"onBlur()\">\n\t\t\t\t<button\n\t\t\t\t\t*ngIf=\"type === 'multi' && pills.length > 0\"\n\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t(click)=\"clearSelected()\"\n\t\t\t\t\t(blur)=\"onBlur()\"\n\t\t\t\t\t(keydown.enter)=\"clearSelected()\"\n\t\t\t\t\tclass=\"bx--tag--filter bx--list-box__selection--multi\"\n\t\t\t\t\t[title]=\"clearSelectionsTitle\"\n\t\t\t\t\t[attr.aria-label]=\"clearSelectionAria\">\n\t\t\t\t\t{{ pills.length }}\n\t\t\t\t\t<svg\n\t\t\t\t\t\tfocusable=\"false\"\n\t\t\t\t\t\tpreserveAspectRatio=\"xMidYMid meet\"\n\t\t\t\t\t\tstyle=\"will-change: transform;\"\n\t\t\t\t\t\trole=\"img\"\n\t\t\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\t\t\t\twidth=\"16\"\n\t\t\t\t\t\theight=\"16\"\n\t\t\t\t\t\tviewBox=\"0 0 16 16\"\n\t\t\t\t\t\taria-hidden=\"true\">\n\t\t\t\t\t\t<path d=\"M12 4.7l-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8z\"></path>\n\t\t\t\t\t</svg>\n\t\t\t\t</button>\n\t\t\t\t<input\n\t\t\t\t\t#input\n\t\t\t\t\ttype=\"text\"\n\t\t\t\t\trole=\"searchbox\"\n\t\t\t\t\t[disabled]=\"disabled\"\n\t\t\t\t\t(input)=\"onSearch($event.target.value)\"\n\t\t\t\t\t(blur)=\"onBlur()\"\n\t\t\t\t\t(keydown.enter)=\"onSubmit($event)\"\n\t\t\t\t\t[value]=\"selectedValue\"\n\t\t\t\t\tclass=\"bx--text-input\"\n\t\t\t\t\t[ngClass]=\"{'bx--text-input--empty': !showClearButton}\"\n\t\t\t\t\ttabindex=\"0\"\n\t\t\t\t\t[attr.aria-labelledby]=\"id\"\n\t\t\t\t\t[attr.maxlength]=\"maxLength\"\n\t\t\t\t\taria-haspopup=\"true\"\n\t\t\t\t\t[attr.aria-autocomplete]=\"autocomplete\"\n\t\t\t\t\t[placeholder]=\"placeholder\"/>\n\t\t\t\t<svg\n\t\t\t\t\t*ngIf=\"invalid\"\n\t\t\t\t\tibmIcon=\"warning--filled\"\n\t\t\t\t\tsize=\"16\"\n\t\t\t\t\tclass=\"bx--list-box__invalid-icon\">\n\t\t\t\t</svg>\n\t\t\t\t<div\n\t\t\t\t\t*ngIf=\"showClearButton\"\n\t\t\t\t\trole=\"button\"\n\t\t\t\t\tclass=\"bx--list-box__selection\"\n\t\t\t\t\ttabindex=\"0\"\n\t\t\t\t\t[attr.aria-label]=\"clearSelectionAria\"\n\t\t\t\t\t[title]=\"clearSelectionTitle\"\n\t\t\t\t\t(keyup.enter)=\"clearInput($event)\"\n\t\t\t\t\t(click)=\"clearInput($event)\"\n\t\t\t\t\t(blur)=\"onBlur()\">\n\t\t\t\t\t<svg ibmIcon=\"close\" size=\"16\"></svg>\n\t\t\t\t</div>\n\t\t\t\t<svg\n\t\t\t\t\tibmIcon=\"chevron--down\"\n\t\t\t\t\tsize=\"16\"\n\t\t\t\t\t[ngClass]=\"{'bx--list-box__menu-icon--open': open}\"\n\t\t\t\t\tclass=\"bx--list-box__menu-icon\"\n\t\t\t\t\t[title]=\"open ? closeMenuAria : openMenuAria\"\n\t\t\t\t\t[ariaLabel]=\"open ? closeMenuAria : openMenuAria\">\n\t\t\t\t</svg>\n\t\t\t</div>\n\t\t\t<div #dropdownMenu>\n\t\t\t\t<ng-content *ngIf=\"open\"></ng-content>\n\t\t\t</div>\n\t\t</div>\n\t\t<div\n\t\t\t*ngIf=\"helperText && !invalid\"\n\t\t\tclass=\"bx--form__helper-text\"\n\t\t\t[ngClass]=\"{'bx--form__helper-text--disabled': disabled}\">\n\t\t\t<ng-container *ngIf=\"!isTemplate(helperText)\">{{helperText}}</ng-container>\n\t\t\t<ng-template *ngIf=\"isTemplate(helperText)\" [ngTemplateOutlet]=\"helperText\"></ng-template>\n\t\t</div>\n\t\t<div *ngIf=\"invalid\" class=\"bx--form-requirement\">\n\t\t\t<ng-container *ngIf=\"!isTemplate(invalidText)\">{{ invalidText }}</ng-container>\n\t\t\t<ng-template *ngIf=\"isTemplate(invalidText)\" [ngTemplateOutlet]=\"invalidText\"></ng-template>\n\t\t</div>\n\t",
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: ComboBox,
                                multi: true
                            }
                        ]
                    }] }
        ];
        /** @nocollapse */
        ComboBox.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: utils.DocumentService },
                { type: dropdown.DropdownService },
                { type: i18n.I18n }
            ];
        };
        ComboBox.propDecorators = {
            placeholder: [{ type: core.Input }],
            openMenuAria: [{ type: core.Input }],
            closeMenuAria: [{ type: core.Input }],
            clearSelectionsTitle: [{ type: core.Input }],
            clearSelectionsAria: [{ type: core.Input }],
            clearSelectionTitle: [{ type: core.Input }],
            clearSelectionAria: [{ type: core.Input }],
            id: [{ type: core.Input }],
            items: [{ type: core.Input }],
            type: [{ type: core.Input }],
            size: [{ type: core.Input }],
            itemValueKey: [{ type: core.Input }],
            label: [{ type: core.Input }],
            helperText: [{ type: core.Input }],
            appendInline: [{ type: core.Input }],
            invalid: [{ type: core.Input }],
            invalidText: [{ type: core.Input }],
            maxLength: [{ type: core.Input }],
            theme: [{ type: core.Input }],
            selectionFeedback: [{ type: core.Input }],
            autocomplete: [{ type: core.Input }],
            disabled: [{ type: core.HostBinding, args: ["attr.aria-disabled",] }, { type: core.Input }],
            selected: [{ type: core.Output }],
            submit: [{ type: core.Output }],
            close: [{ type: core.Output }],
            search: [{ type: core.Output }],
            view: [{ type: core.ContentChild, args: [dropdown.AbstractDropdownView, { static: true },] }],
            dropdownMenu: [{ type: core.ViewChild, args: ["dropdownMenu", { static: false },] }],
            input: [{ type: core.ViewChild, args: ["input", { static: true },] }],
            listbox: [{ type: core.ViewChild, args: ["listbox", { static: true },] }],
            hostClass: [{ type: core.HostBinding, args: ["class.bx--list-box__wrapper",] }],
            display: [{ type: core.HostBinding, args: ["style.display",] }],
            hostkeys: [{ type: core.HostListener, args: ["keydown", ["$event"],] }]
        };
        return ComboBox;
    }());

    var ComboBoxModule = /** @class */ (function () {
        function ComboBoxModule() {
        }
        ComboBoxModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ComboBox
                        ],
                        exports: [
                            ComboBox,
                            dropdown.DropdownModule
                        ],
                        imports: [
                            common.CommonModule,
                            dropdown.DropdownModule,
                            i18n.I18nModule,
                            utils.UtilsModule,
                            icon.IconModule
                        ],
                        providers: [dropdown.DropdownService]
                    },] }
        ];
        return ComboBoxModule;
    }());

    /**
     * Generated bundle index. Do not edit.
     */

    exports.ComboBox = ComboBox;
    exports.ComboBoxModule = ComboBoxModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=carbon-components-angular-combobox.umd.js.map