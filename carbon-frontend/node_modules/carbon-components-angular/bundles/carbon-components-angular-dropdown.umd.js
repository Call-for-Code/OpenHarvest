/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-dropdown.umd.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@carbon/utils-position'), require('rxjs'), require('rxjs/operators'), require('@angular/core'), require('@angular/common'), require('@angular/forms'), require('carbon-components-angular/i18n'), require('carbon-components-angular/placeholder'), require('carbon-components-angular/utils'), require('carbon-components-angular/icon')) :
    typeof define === 'function' && define.amd ? define('carbon-components-angular/dropdown', ['exports', '@carbon/utils-position', 'rxjs', 'rxjs/operators', '@angular/core', '@angular/common', '@angular/forms', 'carbon-components-angular/i18n', 'carbon-components-angular/placeholder', 'carbon-components-angular/utils', 'carbon-components-angular/icon'], factory) :
    (factory((global['carbon-components-angular'] = global['carbon-components-angular'] || {}, global['carbon-components-angular'].dropdown = {}),global.utilsPosition,global.rxjs,global.rxjs.operators,global.ng.core,global.ng.common,global.ng.forms,global['carbon-components-angular'].i18n,global['carbon-components-angular'].placeholder,global['carbon-components-angular'].utils,global['carbon-components-angular'].icon));
}(this, (function (exports,utilsPosition,rxjs,operators,core,common,forms,i18n,placeholder,utils,icon) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * A component that intends to be used within `Dropdown` must provide an implementation that extends this base class.
     * It also must provide the base class in the `@Component` meta-data.
     * ex: `providers: [{provide: AbstractDropdownView, useExisting: forwardRef(() => MyDropdownView)}]`
     */
    var AbstractDropdownView = /** @class */ (function () {
        function AbstractDropdownView() {
            /**
             * Specifies whether or not the `DropdownList` supports selecting multiple items as opposed to single
             * item selection.
             */
            this.type = "single";
            /**
             * Specifies the render size of the items within the `AbstractDropdownView`.
             *
             * @deprecated since v4
             */
            this.size = "md";
        }
        Object.defineProperty(AbstractDropdownView.prototype, "items", {
            get: function () { return; },
            /**
             * The items to be displayed in the list within the `AbstractDropDownView`.
             */
            set: function (value) { },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the `ListItem` that is subsequent to the selected item in the `DropdownList`.
         */
        AbstractDropdownView.prototype.getNextItem = function () { return; };
        /**
         * Returns a boolean if the currently selected item is preceded by another
         */
        AbstractDropdownView.prototype.hasNextElement = function () { return; };
        /**
         * Returns the `HTMLElement` for the item that is subsequent to the selected item.
         */
        AbstractDropdownView.prototype.getNextElement = function () { return; };
        /**
         * Returns the `ListItem` that precedes the selected item within `DropdownList`.
         */
        AbstractDropdownView.prototype.getPrevItem = function () { return; };
        /**
         * Returns a boolean if the currently selected item is followed by another
         */
        AbstractDropdownView.prototype.hasPrevElement = function () { return; };
        /**
         * Returns the `HTMLElement` for the item that precedes the selected item.
         */
        AbstractDropdownView.prototype.getPrevElement = function () { return; };
        /**
         * Returns the selected leaf level item(s) within the `DropdownList`.
         */
        AbstractDropdownView.prototype.getSelected = function () { return; };
        /**
         * Returns the `ListItem` that is selected within `DropdownList`.
         */
        AbstractDropdownView.prototype.getCurrentItem = function () { return; };
        /**
         * Returns the `HTMLElement` for the item that is selected within the `DropdownList`.
         */
        AbstractDropdownView.prototype.getCurrentElement = function () { return; };
        /**
         * Guaranteed to return the current items as an Array.
         */
        AbstractDropdownView.prototype.getListItems = function () { return; };
        /**
         * Transforms array input list of items to the correct state by updating the selected item(s).
         */
        AbstractDropdownView.prototype.propagateSelected = function (value) { };
        /**
         *
         * @param value value to filter the list by
         */
        AbstractDropdownView.prototype.filterBy = function (value) { };
        /**
         * Initializes focus in the list
         * In most cases this just calls `getCurrentElement().focus()`
         */
        AbstractDropdownView.prototype.initFocus = function () { };
        /**
         * Subscribe the function passed to an internal observable that will resolve once the items are ready
         */
        AbstractDropdownView.prototype.onItemsReady = function (subcription) { };
        /**
         * Reorder selected items bringing them to the top of the list
         */
        AbstractDropdownView.prototype.reorderSelected = function (moveFocus) { };
        AbstractDropdownView.decorators = [
            { type: core.Directive, args: [{ selector: "[ibmAbstractDropdownView]" },] }
        ];
        AbstractDropdownView.propDecorators = {
            items: [{ type: core.Input }],
            select: [{ type: core.Output }],
            blurIntent: [{ type: core.Output }]
        };
        return AbstractDropdownView;
    }());

    var defaultOffset = { top: 0, left: 0 };
    var DropdownService = /** @class */ (function () {
        function DropdownService(placeholderService, animationFrameService) {
            this.placeholderService = placeholderService;
            this.animationFrameService = animationFrameService;
            /**
             * Maintains an Event Observable Subscription for the global requestAnimationFrame.
             * requestAnimationFrame is tracked only if the `Dropdown` is appended to the body otherwise we don't need it
             */
            this.animationFrameSubscription = new rxjs.Subscription();
            this._offset = defaultOffset;
        }
        Object.defineProperty(DropdownService.prototype, "offset", {
            get: function () {
                return this._offset;
            },
            set: function (value) {
                this._offset = Object.assign({}, defaultOffset, value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Appends the menu to the body, or a `ibm-placeholder` (if defined)
         *
         * @param parentRef container to position relative to
         * @param menuRef menu to be appended to body
         * @param classList any extra classes we should wrap the container with
         */
        DropdownService.prototype.appendToBody = function (parentRef, menuRef, classList) {
            var _this = this;
            // build the dropdown list container
            menuRef.style.display = "block";
            var dropdownWrapper = document.createElement("div");
            dropdownWrapper.className = "dropdown " + classList;
            dropdownWrapper.style.width = parentRef.offsetWidth + "px";
            dropdownWrapper.style.position = "absolute";
            dropdownWrapper.appendChild(menuRef);
            // append it to the placeholder
            if (this.placeholderService.hasPlaceholderRef()) {
                this.placeholderService.appendElement(dropdownWrapper);
                // or append it directly to the body
            }
            else {
                document.body.appendChild(dropdownWrapper);
            }
            this.menuInstance = dropdownWrapper;
            this.animationFrameSubscription = this.animationFrameService.tick.subscribe(function () {
                _this.positionDropdown(parentRef, dropdownWrapper);
            });
            // run one position in sync, so we're less likely to have the view "jump" as we focus
            this.positionDropdown(parentRef, dropdownWrapper);
            return dropdownWrapper;
        };
        /**
         * Reattach the dropdown menu to the parent container
         * @param hostRef container to append to
         */
        DropdownService.prototype.appendToDropdown = function (hostRef) {
            // if the instance is already removed don't try and remove it again
            if (!this.menuInstance) {
                return;
            }
            var instance = this.menuInstance;
            var menu = instance.firstElementChild;
            // clean up the instance
            this.menuInstance = null;
            menu.style.display = "none";
            hostRef.appendChild(menu);
            this.animationFrameSubscription.unsubscribe();
            if (this.placeholderService.hasPlaceholderRef() && this.placeholderService.hasElement(instance)) {
                this.placeholderService.removeElement(instance);
            }
            else if (document.body.contains(instance)) {
                document.body.removeChild(instance);
            }
            return instance;
        };
        /**
         * position an open dropdown relative to the given parentRef
         */
        DropdownService.prototype.updatePosition = function (parentRef) {
            this.positionDropdown(parentRef, this.menuInstance);
        };
        DropdownService.prototype.ngOnDestroy = function () {
            this.animationFrameSubscription.unsubscribe();
        };
        DropdownService.prototype.positionDropdown = function (parentRef, menuRef) {
            if (!menuRef) {
                return;
            }
            var leftOffset = 0;
            var boxMenu = menuRef.querySelector(".bx--list-box__menu");
            if (boxMenu) {
                // If the parentRef and boxMenu are in a different left position relative to the
                // window, the the boxMenu position has already been flipped and a check needs to be done
                // to see if it needs to stay flipped.
                if (parentRef.getBoundingClientRect().left !== boxMenu.getBoundingClientRect().left) {
                    // The getBoundingClientRect().right of the boxMenu if it were hypothetically flipped
                    // back into the original position before the flip.
                    var testBoxMenuRightEdgePos = parentRef.getBoundingClientRect().left - boxMenu.getBoundingClientRect().left + boxMenu.getBoundingClientRect().right;
                    if (testBoxMenuRightEdgePos > (window.innerWidth || document.documentElement.clientWidth)) {
                        leftOffset = parentRef.offsetWidth - boxMenu.offsetWidth;
                    }
                    // If it has not already been flipped, check if it is necessary to flip, ie. if the
                    // boxMenu is outside of the right viewPort.
                }
                else if (boxMenu.getBoundingClientRect().right > (window.innerWidth || document.documentElement.clientWidth)) {
                    leftOffset = parentRef.offsetWidth - boxMenu.offsetWidth;
                }
            }
            // If ibm-placeholder has a parent with a position(relative|fixed|absolute) account for the parent offset
            var closestMenuWithPos = utils.closestAttr("position", ["relative", "fixed", "absolute"], menuRef.parentElement);
            var topPos = closestMenuWithPos ? closestMenuWithPos.getBoundingClientRect().top * -1 : this.offset.top;
            var leftPos = closestMenuWithPos ? closestMenuWithPos.getBoundingClientRect().left * -1 : this.offset.left + leftOffset;
            var pos = utilsPosition.position.findAbsolute(parentRef, menuRef, "bottom");
            pos = utilsPosition.position.addOffset(pos, topPos, leftPos);
            utilsPosition.position.setElement(menuRef, pos);
        };
        DropdownService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        DropdownService.ctorParameters = function () {
            return [
                { type: placeholder.PlaceholderService },
                { type: utils.AnimationFrameService }
            ];
        };
        return DropdownService;
    }());

    /**
     * Drop-down lists enable users to select one or more items from a list.
     *
     * #### Opening behavior/List DOM placement
     * By default the dropdown will try to figure out the best placement for the dropdown list.
     *
     * If it's not contained within any scrolling elements, it will open inline, if it _is_
     * contained within a scrolling container it will try to open in the body, or an `ibm-placeholder`.
     *
     * To control this behavior you can use the `appendInline` input:
     * - `[appendInline]="null"` is the default (auto detection)
     * - `[appendInline]="false"` will always append to the body/`ibm-placeholder`
     * - `[appendInline]="true"` will always append inline (next to the dropdown button)
     *
     * [See demo](../../?path=/story/dropdown--basic)
     *
     * <example-url>../../iframe.html?id=dropdown--basic</example-url>
     */
    var Dropdown = /** @class */ (function () {
        /**
         * Creates an instance of Dropdown.
         */
        function Dropdown(elementRef, i18n$$1, dropdownService, appRef, elementService) {
            this.elementRef = elementRef;
            this.i18n = i18n$$1;
            this.dropdownService = dropdownService;
            this.appRef = appRef;
            this.elementService = elementService;
            this.id = "dropdown-" + Dropdown.dropdownCount++;
            /**
             * Value displayed if no item is selected.
             */
            this.placeholder = "";
            /**
             * The selected value from the `Dropdown`. Can be a string or template.
             */
            this.displayValue = "";
            /**
             * Sets the optional clear button tooltip text.
             */
            this.clearText = this.i18n.get().DROPDOWN.CLEAR;
            /**
             * Size to render the dropdown field.
             *
             * @deprecated since v4
             */
            this.size = "md";
            /**
             * Defines whether or not the `Dropdown` supports selecting multiple items as opposed to single
             * item selection.
             */
            this.type = "single";
            /**
             * `light` or `dark` dropdown theme
             */
            this.theme = "dark";
            /**
             * Set to `true` to disable the dropdown.
             */
            this.disabled = false;
            /**
             * Set to `true` for a loading dropdown.
             */
            this.skeleton = false;
            /**
             * Set to `true` for an inline dropdown.
             */
            this.inline = false;
            /**
             * Set to `true` for a dropdown without arrow key activation.
             */
            this.disableArrowKeys = false;
            /**
             * Set to `true` for invalid state.
             */
            this.invalid = false;
            /**
             * set to `true` to place the dropdown view inline with the component
             */
            this.appendInline = null;
            /**
             * Specify feedback (mode) of the selection.
             * `top`: selected item jumps to top
             * `fixed`: selected item stays at it's position
             * `top-after-reopen`: selected item jump to top after reopen dropdown
             */
            this.selectionFeedback = "top-after-reopen";
            /**
             * Accessible label for the button that opens the dropdown list.
             * Defaults to the `DROPDOWN.OPEN` value from the i18n service.
             */
            this.menuButtonLabel = this.i18n.get().DROPDOWN.OPEN;
            /**
             * Provides the label for the "# selected" text.
             * Defaults to the `DROPDOWN.SELECTED` value from the i18n service.
             */
            this.selectedLabel = this.i18n.get().DROPDOWN.SELECTED;
            /**
             * Emits selection events.
             */
            this.selected = new core.EventEmitter();
            /**
             * Emits event notifying to other classes that the `Dropdown` has been closed (collapsed).
             */
            this.onClose = new core.EventEmitter();
            /**
             * Emits event notifying to other classes that the `Dropdown` has been closed (collapsed).
             */
            this.close = new core.EventEmitter();
            this.hostClass = true;
            /**
             * Set to `true` if the dropdown is closed (not expanded).
             */
            this.menuIsClosed = true;
            /**
             * controls whether the `drop-up` class is applied
             */
            this._dropUp = false;
            // .bind creates a new function, so we declare the methods below
            // but .bind them up here
            this.noop = this._noop.bind(this);
            this.outsideClick = this._outsideClick.bind(this);
            this.outsideKey = this._outsideKey.bind(this);
            this.keyboardNav = this._keyboardNav.bind(this);
            this.visibilitySubscription = new rxjs.Subscription();
            this.onTouchedCallback = this._noop;
            // primarily used to capture and propagate input to `writeValue` before the content is available
            this.writtenValue = [];
            /**
             * function passed in by `registerOnChange`
             */
            this.propagateChange = function (_) { };
        }
        Object.defineProperty(Dropdown.prototype, "value", {
            get: function () {
                return this.itemValueKey;
            },
            /**
             * Deprecated. Use `itemValueKey` instead.
             * Specifies the property to be used as the return value to `ngModel`
             * @deprecated since v4 use itemValueKey instead
             */
            set: function (newValue) {
                console.warn("Dropdown `value` property has been deprecated. Use `itemValueKey` instead");
                this.itemValueKey = newValue;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Updates the `type` property in the `@ContentChild`.
         * The `type` property specifies whether the `Dropdown` allows single selection or multi selection.
         */
        Dropdown.prototype.ngOnInit = function () {
            if (this.view) {
                this.view.type = this.type;
            }
        };
        /**
         * Initializes classes and subscribes to events for single or multi selection.
         */
        Dropdown.prototype.ngAfterContentInit = function () {
            var _this = this;
            if (!this.view) {
                return;
            }
            if ((this.writtenValue && this.writtenValue.length) || typeof this.writtenValue === "number") {
                this.writeValue(this.writtenValue);
            }
            this.view.type = this.type;
            this.view.size = this.size;
            this.view.select.subscribe(function (event) {
                if (_this.type === "multi") {
                    // if we have a `value` selector and selected items map them appropriately
                    if (_this.itemValueKey && _this.view.getSelected()) {
                        var values = _this.view.getSelected().map(function (item) { return item[_this.itemValueKey]; });
                        _this.propagateChange(values);
                        // otherwise just pass up the values from `getSelected`
                    }
                    else {
                        _this.propagateChange(_this.view.getSelected());
                    }
                }
                else {
                    _this.closeMenu();
                    if (event.item && event.item.selected) {
                        if (_this.itemValueKey) {
                            _this.propagateChange(event.item[_this.itemValueKey]);
                        }
                        else {
                            _this.propagateChange(event.item);
                        }
                    }
                    else {
                        _this.propagateChange(null);
                    }
                }
                // only emit selected for "organic" selections
                if (event && !event.isUpdate) {
                    _this.checkForReorder();
                    _this.selected.emit(event);
                }
                // manually tick the app so the view picks up any changes
                _this.appRef.tick();
            });
        };
        Dropdown.prototype.ngAfterViewInit = function () {
            // if appendInline is default valued (null) we should:
            // 1. if there are scrollable parents (not including body) don't append inline
            //    this should also cover the case where the dropdown is in a modal
            //    (where we _do_ want to append to the placeholder)
            if (this.appendInline === null && utils.hasScrollableParents(this.elementRef.nativeElement)) {
                this.appendInline = false;
                // 2. otherwise we should append inline
            }
            else if (this.appendInline === null) {
                this.appendInline = true;
            }
            this.checkForReorder();
        };
        /**
         * Removing the `Dropdown` from the body if it is appended to the body.
         */
        Dropdown.prototype.ngOnDestroy = function () {
            if (!this.appendInline) {
                this._appendToDropdown();
            }
        };
        /**
         * Propagates the injected `value`.
         */
        Dropdown.prototype.writeValue = function (value) {
            var _this = this;
            // cache the written value so we can use it in `AfterContentInit`
            this.writtenValue = value;
            this.view.onItemsReady(function () {
                var e_1, _a, e_2, _b;
                // propagate null/falsey as an array (deselect everything)
                if (!value) {
                    _this.view.propagateSelected([value]);
                }
                else if (_this.type === "single") {
                    if (_this.itemValueKey) {
                        // clone the specified item and update its state
                        var newValue = Object.assign({}, _this.view.getListItems().find(function (item) { return item[_this.itemValueKey] === value; }));
                        newValue.selected = true;
                        _this.view.propagateSelected([newValue]);
                    }
                    else {
                        // pass the singular value as an array of ListItem
                        _this.view.propagateSelected([value]);
                    }
                }
                else {
                    if (_this.itemValueKey) {
                        // clone the items and update their state based on the received value array
                        // this way we don't lose any additional metadata that may be passed in via the `items` Input
                        var newValues = [];
                        try {
                            for (var value_1 = __values(value), value_1_1 = value_1.next(); !value_1_1.done; value_1_1 = value_1.next()) {
                                var v = value_1_1.value;
                                try {
                                    for (var _c = __values(_this.view.getListItems()), _d = _c.next(); !_d.done; _d = _c.next()) {
                                        var item = _d.value;
                                        if (item[_this.itemValueKey] === v) {
                                            newValues.push(Object.assign({}, item, { selected: true }));
                                        }
                                    }
                                }
                                catch (e_2_1) {
                                    e_2 = { error: e_2_1 };
                                }
                                finally {
                                    try {
                                        if (_d && !_d.done && (_b = _c.return))
                                            _b.call(_c);
                                    }
                                    finally {
                                        if (e_2)
                                            throw e_2.error;
                                    }
                                }
                            }
                        }
                        catch (e_1_1) {
                            e_1 = { error: e_1_1 };
                        }
                        finally {
                            try {
                                if (value_1_1 && !value_1_1.done && (_a = value_1.return))
                                    _a.call(value_1);
                            }
                            finally {
                                if (e_1)
                                    throw e_1.error;
                            }
                        }
                        _this.view.propagateSelected(newValues);
                    }
                    else {
                        // we can safely assume we're passing an array of `ListItem`s
                        _this.view.propagateSelected(value);
                    }
                }
                _this.checkForReorder();
            });
        };
        Dropdown.prototype.onBlur = function () {
            this.onTouchedCallback();
        };
        Dropdown.prototype.registerOnChange = function (fn) {
            this.propagateChange = fn;
        };
        /**
         * Registering the function injected to control the touch use of the `Dropdown`.
         */
        Dropdown.prototype.registerOnTouched = function (fn) {
            this.onTouchedCallback = fn;
        };
        /**
         * `ControlValueAccessor` method to programmatically disable the dropdown.
         *
         * ex: `this.formGroup.get("myDropdown").disable();`
         *
         * @param isDisabled `true` to disable the input
         */
        Dropdown.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        /**
         * Adds keyboard functionality for navigation, selection and closing of the `Dropdown`.
         */
        // "Esc", "Spacebar", "Down", and "Up" are IE specific values
        Dropdown.prototype.onKeyDown = function (event) {
            if ((event.key === "Escape" || event.key === "Esc") && !this.menuIsClosed) {
                event.stopImmediatePropagation(); // don't unintentionally close other widgets that listen for Escape
            }
            if (event.key === "Escape" || event.key === "Esc") {
                event.preventDefault();
                this.closeMenu();
                this.dropdownButton.nativeElement.focus();
            }
            else if (this.menuIsClosed && (event.key === " " || event.key === "ArrowDown" || event.key === "ArrowUp" ||
                event.key === "Spacebar" || event.key === "Down" || event.key === "Up")) {
                if (this.disableArrowKeys && (event.key === "ArrowDown" || event.key === "ArrowUp" || event.key === "Down" || event.key === "Up")) {
                    return;
                }
                event.preventDefault();
                this.openMenu();
            }
            if (!this.menuIsClosed && event.key === "Tab" && this.dropdownMenu.nativeElement.contains(event.target)) {
                this.closeMenu();
            }
            if (!this.menuIsClosed && event.key === "Tab" && event.shiftKey) {
                this.closeMenu();
            }
            if (this.type === "multi") {
                return;
            }
            if (this.menuIsClosed) {
                this.closedDropdownNavigation(event);
            }
        };
        Dropdown.prototype.closedDropdownNavigation = function (event) {
            // "Down", and "Up" are IE specific values
            if (event.key === "ArrowDown" || event.key === "Down") {
                event.preventDefault();
                this.view.getCurrentItem().selected = false;
                var item = this.view.getNextItem();
                if (item) {
                    item.selected = true;
                }
            }
            else if (event.key === "ArrowUp" || event.key === "Up") {
                event.preventDefault();
                this.view.getCurrentItem().selected = false;
                var item = this.view.getPrevItem();
                if (item) {
                    item.selected = true;
                }
            }
        };
        /**
         * Returns the display value if there is a selection and displayValue is set,
         * if there is just a selection the ListItem content property will be returned,
         * otherwise the placeholder will be returned.
         */
        Dropdown.prototype.getDisplayStringValue = function () {
            if (!this.view) {
                return;
            }
            var selected = this.view.getSelected();
            if (selected.length && (!this.displayValue || !this.isRenderString())) {
                if (this.type === "multi") {
                    return rxjs.of(this.placeholder);
                }
                else {
                    return rxjs.of(selected[0].content);
                }
            }
            else if (selected.length && this.isRenderString()) {
                return rxjs.of(this.displayValue);
            }
            return rxjs.of(this.placeholder);
        };
        Dropdown.prototype.isRenderString = function () {
            return typeof this.displayValue === "string";
        };
        Dropdown.prototype.getRenderTemplateContext = function () {
            if (!this.view) {
                return;
            }
            var selected = this.view.getSelected();
            if (this.type === "multi") {
                return { items: selected };
            }
            else if (selected && selected.length > 0) {
                return { item: selected[0] }; // this is to be compatible with the dropdown-list template
            }
            else {
                return {};
            }
        };
        Dropdown.prototype.getSelectedCount = function () {
            if (this.view.getSelected()) {
                return this.view.getSelected().length;
            }
        };
        Dropdown.prototype.clearSelected = function () {
            var e_3, _a;
            if (this.disabled) {
                return;
            }
            try {
                for (var _b = __values(this.view.getListItems()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var item = _c.value;
                    item.selected = false;
                }
            }
            catch (e_3_1) {
                e_3 = { error: e_3_1 };
            }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return))
                        _a.call(_b);
                }
                finally {
                    if (e_3)
                        throw e_3.error;
                }
            }
            this.selected.emit([]);
            this.propagateChange([]);
        };
        /**
         * Returns `true` if there is a value selected.
         */
        Dropdown.prototype.valueSelected = function () {
            if (this.view.getSelected()) {
                return true;
            }
            return false;
        };
        Dropdown.prototype._noop = function () { };
        /**
         * Handles clicks outside of the `Dropdown`.
         */
        Dropdown.prototype._outsideClick = function (event) {
            if (!this.elementRef.nativeElement.contains(event.target) &&
                // if we're appendToBody the list isn't within the _elementRef,
                // so we've got to check if our target is possibly in there too.
                !this.dropdownMenu.nativeElement.contains(event.target)) {
                this.closeMenu();
            }
        };
        Dropdown.prototype._outsideKey = function (event) {
            if (!this.menuIsClosed && event.key === "Tab" && this.dropdownMenu.nativeElement.contains(event.target)) {
                this.closeMenu();
            }
        };
        /**
         * Handles keyboard events so users are controlling the `Dropdown` instead of unintentionally controlling outside elements.
         */
        Dropdown.prototype._keyboardNav = function (event) {
            // "Esc" is an IE specific value
            if ((event.key === "Escape" || event.key === "Esc") && !this.menuIsClosed) {
                event.stopImmediatePropagation(); // don't unintentionally close modal if inside of it
            }
            if (event.key === "Escape" || event.key === "Esc") {
                event.preventDefault();
                this.closeMenu();
                this.dropdownButton.nativeElement.focus();
            }
            else if (!this.menuIsClosed && event.key === "Tab") {
                // this way focus will start on the next focusable item from the dropdown
                // not the top of the body!
                this.dropdownButton.nativeElement.focus();
                this.dropdownButton.nativeElement.dispatchEvent(new KeyboardEvent("keydown", { bubbles: true, cancelable: true, key: "Tab" }));
                this.closeMenu();
            }
        };
        /**
         * Creates the `Dropdown` list appending it to the dropdown parent object instead of the body.
         */
        Dropdown.prototype._appendToDropdown = function () {
            this.dropdownService.appendToDropdown(this.elementRef.nativeElement);
            this.dropdownMenu.nativeElement.removeEventListener("keydown", this.keyboardNav, true);
        };
        /**
         * Creates the `Dropdown` list as an element that is appended to the DOM body.
         */
        Dropdown.prototype._appendToBody = function () {
            var lightClass = this.theme === "light" ? " bx--list-box--light" : "";
            var expandedClass = !this.menuIsClosed ? " bx--list-box--expanded" : "";
            this.dropdownService.appendToBody(this.dropdownButton.nativeElement, this.dropdownMenu.nativeElement, "" + this.elementRef.nativeElement.className + lightClass + expandedClass);
            this.dropdownMenu.nativeElement.addEventListener("keydown", this.keyboardNav, true);
        };
        /**
         * Detects whether or not the `Dropdown` list is visible within all scrollable parents.
         * This can be overridden by passing in a value to the `dropUp` input.
         */
        Dropdown.prototype._shouldDropUp = function () {
            // check if dropdownMenu exists first.
            var menu = this.dropdownMenu && this.dropdownMenu.nativeElement.querySelector(".bx--list-box__menu");
            // check if menu exists first.
            var menuRect = menu && menu.getBoundingClientRect();
            if (menu && menuRect) {
                var scrollableParents = utils.getScrollableParents(menu);
                return scrollableParents.reduce(function (shouldDropUp, parent) {
                    var parentRect = parent.getBoundingClientRect();
                    var isBelowParent = !(menuRect.bottom <= parentRect.bottom);
                    return shouldDropUp || isBelowParent;
                }, false);
            }
            return false;
        };
        /**
         * Expands the dropdown menu in the view.
         */
        Dropdown.prototype.openMenu = function () {
            var _this = this;
            // prevents the dropdown from opening when list of items is empty
            if (this.view.getListItems().length === 0) {
                return;
            }
            this._dropUp = false;
            this.menuIsClosed = false;
            // move the dropdown list to the body if we're not appending inline
            // and position it relative to the dropdown wrapper
            if (!this.appendInline) {
                var target = this.dropdownButton.nativeElement;
                var parent_1 = this.elementRef.nativeElement;
                this.visibilitySubscription = this.elementService
                    .visibility(target, parent_1)
                    .subscribe(function (value) {
                    if (!value.visible) {
                        _this.closeMenu();
                    }
                });
                this._appendToBody();
            }
            // set the dropdown menu to drop up if it's near the bottom of the screen
            // setTimeout lets us measure after it's visible in the DOM
            setTimeout(function () {
                if (_this.dropUp === null || _this.dropUp === undefined) {
                    _this._dropUp = _this._shouldDropUp();
                }
            }, 0);
            // we bind noop to document.body.firstElementChild to allow safari to fire events
            // from document. Then we unbind everything later to keep things light.
            document.body.firstElementChild.addEventListener("click", this.noop, true);
            document.body.firstElementChild.addEventListener("keydown", this.noop, true);
            document.addEventListener("click", this.outsideClick, true);
            document.addEventListener("keydown", this.outsideKey, true);
            setTimeout(function () { return _this.view.initFocus(); }, 0);
        };
        /**
         * Collapsing the dropdown menu and removing unnecessary `EventListeners`.
         */
        Dropdown.prototype.closeMenu = function () {
            // return early if the menu is already closed
            if (this.menuIsClosed) {
                return;
            }
            this.menuIsClosed = true;
            this.checkForReorder();
            this.onClose.emit();
            this.close.emit();
            // focus the trigger button when we close ...
            this.dropdownButton.nativeElement.focus();
            // remove the conditional once this api is settled and part of abstract-dropdown-view.class
            if (this.view["disableScroll"]) {
                this.view["disableScroll"]();
            }
            // move the list back in the component on close
            if (!this.appendInline) {
                this.visibilitySubscription.unsubscribe();
                this._appendToDropdown();
            }
            document.body.firstElementChild.removeEventListener("click", this.noop, true);
            document.body.firstElementChild.removeEventListener("keydown", this.noop, true);
            document.removeEventListener("click", this.outsideClick, true);
            document.removeEventListener("keydown", this.outsideKey, true);
        };
        /**
         * Controls toggling menu states between open/expanded and closed/collapsed.
         */
        Dropdown.prototype.toggleMenu = function () {
            if (this.menuIsClosed) {
                this.openMenu();
            }
            else {
                this.closeMenu();
            }
        };
        Dropdown.prototype.isTemplate = function (value) {
            return value instanceof core.TemplateRef;
        };
        /**
         * Controls when it's needed to apply the selection feedback
         */
        Dropdown.prototype.checkForReorder = function () {
            var topAfterReopen = this.menuIsClosed && this.selectionFeedback === "top-after-reopen";
            if ((this.type === "multi") && (topAfterReopen || this.selectionFeedback === "top")) {
                this.view.reorderSelected(this.selectionFeedback === "top");
            }
        };
        Dropdown.dropdownCount = 0;
        Dropdown.decorators = [
            { type: core.Component, args: [{
                        selector: "ibm-dropdown",
                        template: "\n\t<label *ngIf=\"label\" [for]=\"id\" class=\"bx--label\">\n\t\t<ng-container *ngIf=\"!isTemplate(label)\">{{label}}</ng-container>\n\t\t<ng-template *ngIf=\"isTemplate(label)\" [ngTemplateOutlet]=\"label\"></ng-template>\n\t</label>\n\t<div\n\t\tclass=\"bx--list-box\"\n\t\t[ngClass]=\"{\n\t\t\t'bx--dropdown': type !== 'multi',\n\t\t\t'bx--multiselect': type === 'multi',\n\t\t\t'bx--multi-select--selected': type === 'multi' && getSelectedCount() > 0,\n\t\t\t'bx--dropdown--light': theme === 'light',\n\t\t\t'bx--list-box--light': theme === 'light',\n\t\t\t'bx--list-box--inline': inline,\n\t\t\t'bx--skeleton': skeleton,\n\t\t\t'bx--dropdown--disabled bx--list-box--disabled': disabled,\n\t\t\t'bx--dropdown--invalid': invalid,\n\t\t\t'bx--dropdown--xl bx--list-box--xl': size === 'xl',\n\t\t\t'bx--dropdown--sm bx--list-box--sm': size === 'sm',\n\t\t\t'bx--list-box--expanded': !menuIsClosed\n\t\t}\">\n\t\t<button\n\t\t\t#dropdownButton\n\t\t\t[id]=\"id\"\n\t\t\ttype=\"button\"\n\t\t\tclass=\"bx--list-box__field\"\n\t\t\t[ngClass]=\"{'a': !menuIsClosed}\"\n\t\t\t[attr.aria-expanded]=\"!menuIsClosed\"\n\t\t\t[attr.aria-disabled]=\"disabled\"\n\t\t\taria-haspopup=\"listbox\"\n\t\t\t(click)=\"disabled ? $event.stopPropagation() : toggleMenu()\"\n\t\t\t(blur)=\"onBlur()\"\n\t\t\t[attr.disabled]=\"disabled ? true : null\">\n\t\t\t<div\n\t\t\t\t(click)=\"clearSelected()\"\n\t\t\t\t(keydown.enter)=\"clearSelected()\"\n\t\t\t\t*ngIf=\"type === 'multi' && getSelectedCount() > 0\"\n\t\t\t\tclass=\"bx--list-box__selection bx--tag--filter bx--list-box__selection--multi\"\n\t\t\t\ttabindex=\"0\"\n\t\t\t\t[title]=\"clearText\">\n\t\t\t\t{{getSelectedCount()}}\n\t\t\t\t<svg\n\t\t\t\t\tfocusable=\"false\"\n\t\t\t\t\tpreserveAspectRatio=\"xMidYMid meet\"\n\t\t\t\t\tstyle=\"will-change: transform;\"\n\t\t\t\t\trole=\"img\"\n\t\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\t\t\twidth=\"16\"\n\t\t\t\t\theight=\"16\"\n\t\t\t\t\tviewBox=\"0 0 16 16\"\n\t\t\t\t\taria-hidden=\"true\">\n\t\t\t\t\t<path d=\"M12 4.7l-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8z\"></path>\n\t\t\t\t</svg>\n\t\t\t</div>\n\t\t\t<span *ngIf=\"isRenderString()\" class=\"bx--list-box__label\">{{getDisplayStringValue() | async}}</span>\n\t\t\t<ng-template\n\t\t\t\t*ngIf=\"!isRenderString()\"\n\t\t\t\t[ngTemplateOutletContext]=\"getRenderTemplateContext()\"\n\t\t\t\t[ngTemplateOutlet]=\"displayValue\">\n\t\t\t</ng-template>\n\t\t\t<svg\n\t\t\t\t*ngIf=\"invalid\"\n\t\t\t\tclass=\"bx--dropdown__invalid-icon\"\n\t\t\t\tibmIcon=\"warning--filled\"\n\t\t\t\tsize=\"16\">\n\t\t\t</svg>\n\t\t\t<svg\n\t\t\t\t*ngIf=\"!skeleton\"\n\t\t\t\tibmIcon=\"chevron--down\"\n\t\t\t\tsize=\"16\"\n\t\t\t\tclass=\"bx--list-box__menu-icon\"\n\t\t\t\t[attr.aria-label]=\"menuButtonLabel\"\n\t\t\t\t[ngClass]=\"{'bx--list-box__menu-icon--open': !menuIsClosed }\">\n\t\t\t</svg>\n\t\t</button>\n\t\t<div\n\t\t\t#dropdownMenu\n\t\t\t[ngClass]=\"{\n\t\t\t\t'bx--list-box--up': this.dropUp !== null && this.dropUp !== undefined ? dropUp : _dropUp\n\t\t\t}\">\n\t\t\t<ng-content *ngIf=\"!menuIsClosed\"></ng-content>\n\t\t</div>\n\t</div>\n\t<div *ngIf=\"helperText && !invalid\" class=\"bx--form__helper-text\">\n\t\t<ng-container *ngIf=\"!isTemplate(helperText)\">{{helperText}}</ng-container>\n\t\t<ng-template *ngIf=\"isTemplate(helperText)\" [ngTemplateOutlet]=\"helperText\"></ng-template>\n\t</div>\n\t<div *ngIf=\"invalid\" class=\"bx--form-requirement\">\n\t\t<ng-container *ngIf=\"!isTemplate(invalidText)\">{{ invalidText }}</ng-container>\n\t\t<ng-template *ngIf=\"isTemplate(invalidText)\" [ngTemplateOutlet]=\"invalidText\"></ng-template>\n\t</div>\n\t",
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: Dropdown,
                                multi: true
                            }
                        ]
                    }] }
        ];
        /** @nocollapse */
        Dropdown.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: i18n.I18n },
                { type: DropdownService },
                { type: core.ApplicationRef },
                { type: utils.ElementService }
            ];
        };
        Dropdown.propDecorators = {
            id: [{ type: core.Input }],
            label: [{ type: core.Input }],
            helperText: [{ type: core.Input }],
            placeholder: [{ type: core.Input }],
            displayValue: [{ type: core.Input }],
            clearText: [{ type: core.Input }],
            size: [{ type: core.Input }],
            type: [{ type: core.Input }],
            theme: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            skeleton: [{ type: core.Input }],
            inline: [{ type: core.Input }],
            disableArrowKeys: [{ type: core.Input }],
            invalid: [{ type: core.Input }],
            invalidText: [{ type: core.Input }],
            appendInline: [{ type: core.Input }],
            scrollableContainer: [{ type: core.Input }],
            value: [{ type: core.Input }],
            itemValueKey: [{ type: core.Input }],
            selectionFeedback: [{ type: core.Input }],
            menuButtonLabel: [{ type: core.Input }],
            selectedLabel: [{ type: core.Input }],
            dropUp: [{ type: core.Input }],
            selected: [{ type: core.Output }],
            onClose: [{ type: core.Output }],
            close: [{ type: core.Output }],
            view: [{ type: core.ContentChild, args: [AbstractDropdownView, { static: true },] }],
            dropdownButton: [{ type: core.ViewChild, args: ["dropdownButton", { static: true },] }],
            dropdownMenu: [{ type: core.ViewChild, args: ["dropdownMenu", { static: true },] }],
            hostClass: [{ type: core.HostBinding, args: ["class.bx--dropdown__wrapper",] }],
            onKeyDown: [{ type: core.HostListener, args: ["keydown", ["$event"],] }]
        };
        return Dropdown;
    }());

    /**
     * returns an observable bound to keydown events that
     * filters to a single element where the first letter of
     * it's textContent matches the key pressed
     *
     * @param target element to watch
     * @param elements elements to search
     */
    function watchFocusJump(target, elements) {
        return rxjs.fromEvent(target, "keydown")
            .pipe(operators.debounceTime(150), operators.map(function (ev) {
            var el = elements.find(function (itemEl) {
                return itemEl.textContent.trim().toLowerCase().startsWith(ev.key);
            });
            if (el) {
                return el;
            }
        }), operators.filter(function (el) { return !!el; }));
    }

    /**
     * ```html
     * <ibm-dropdown-list [items]="listItems"></ibm-dropdown-list>
     * ```
     * ```typescript
     * listItems = [
     * 	{
     * 		content: "item one",
     * 		selected: false
     * 	},
     * 	{
     * 		content: "item two",
     * 		selected: false,
     * 	},
     * 	{
     * 		content: "item three",
     * 		selected: false
     * 	},
     * 	{
     * 		content: "item four",
     * 		selected: false
     * 	}
     * ];
     * ```
     */
    var DropdownList = /** @class */ (function () {
        /**
         * Creates an instance of `DropdownList`.
         */
        function DropdownList(elementRef, i18n$$1) {
            this.elementRef = elementRef;
            this.i18n = i18n$$1;
            this.ariaLabel = this.i18n.get().DROPDOWN_LIST.LABEL;
            /**
             * Template to bind to items in the `DropdownList` (optional).
             */
            this.listTpl = null;
            /**
             * Event to emit selection of a list item within the `DropdownList`.
             */
            this.select = new core.EventEmitter();
            /**
             * Event to emit scroll event of a list within the `DropdownList`.
             */
            this.scroll = new core.EventEmitter();
            /**
             * Event to suggest a blur on the view.
             * Emits _after_ the first/last item has been focused.
             * ex.
             * ArrowUp -> focus first item
             * ArrowUp -> emit event
             *
             * When this event fires focus should be placed on some element outside of the list - blurring the list as a result
             */
            this.blurIntent = new core.EventEmitter();
            /**
             * Defines whether or not the `DropdownList` supports selecting multiple items as opposed to single
             * item selection.
             */
            this.type = "single";
            /**
             * Defines the rendering size of the `DropdownList` input component.
             *
             * @deprecated since v4
             */
            this.size = "md";
            /**
             * Holds the list of items that will be displayed in the `DropdownList`.
             * It differs from the the complete set of items when filtering is used (but
             * it is always a subset of the total items in `DropdownList`).
             */
            this.displayItems = [];
            /**
             * Maintains the index for the selected item within the `DropdownList`.
             */
            this.index = -1;
            /**
             * Useful representation of the items, should be accessed via `getListItems`.
             */
            this._items = [];
        }
        Object.defineProperty(DropdownList.prototype, "items", {
            get: function () {
                return this._originalItems;
            },
            /**
             * The list items belonging to the `DropdownList`.
             */
            set: function (value) {
                var _this = this;
                if (rxjs.isObservable(value)) {
                    if (this._itemsSubscription) {
                        this._itemsSubscription.unsubscribe();
                    }
                    this._itemsReady = new rxjs.Observable(function (observer) {
                        _this._itemsSubscription = value.subscribe(function (v) {
                            _this.updateList(v);
                            observer.next(true);
                            observer.complete();
                        });
                    });
                    this.onItemsReady(null);
                }
                else {
                    this.updateList(value);
                }
                this._originalItems = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Retrieves array of list items and index of the selected item after view has rendered.
         * Additionally, any Observables for the `DropdownList` are initialized.
         */
        DropdownList.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.index = this.getListItems().findIndex(function (item) { return item.selected; });
            this.setupFocusObservable();
            setTimeout(function () {
                _this.doEmitSelect(true);
            });
        };
        /**
         * Removes any Observables on destruction of the component.
         */
        DropdownList.prototype.ngOnDestroy = function () {
            if (this.focusJump) {
                this.focusJump.unsubscribe();
            }
            if (this._itemsSubscription) {
                this._itemsSubscription.unsubscribe();
            }
        };
        DropdownList.prototype.doEmitSelect = function (isUpdate) {
            if (isUpdate === void 0) {
                isUpdate = true;
            }
            if (this.type === "single") {
                this.select.emit({ item: this._items.find(function (item) { return item.selected; }), isUpdate: isUpdate });
            }
            else {
                // abuse javascripts object mutability until we can break the API and switch to
                // { items: [], isUpdate: true }
                var selected = this.getSelected() || [];
                selected["isUpdate"] = isUpdate;
                this.select.emit(selected);
            }
        };
        /**
         * Updates the displayed list of items and then retrieves the most current properties for the `DropdownList` from the DOM.
         */
        DropdownList.prototype.updateList = function (items) {
            var _this = this;
            this._items = items.map(function (item) { return Object.assign({}, item); });
            this.displayItems = this._items;
            this.index = this._items.findIndex(function (item) { return item.selected; });
            this.setupFocusObservable();
            setTimeout(function () {
                if (_this.getSelected() !== []) {
                    return;
                }
                _this.doEmitSelect();
            });
        };
        /**
         * Filters the items being displayed in the DOM list.
         */
        DropdownList.prototype.filterBy = function (query) {
            if (query === void 0) {
                query = "";
            }
            if (query) {
                this.displayItems = this.getListItems().filter(function (item) { return item.content.toLowerCase().includes(query.toLowerCase()); });
            }
            else {
                this.displayItems = this.getListItems();
            }
            // reset the index since the list has changed visually
            this.index = 0;
        };
        /**
         * Initializes (or re-initializes) the Observable that handles switching focus to an element based on
         * key input matching the first letter of the item in the list.
         */
        DropdownList.prototype.setupFocusObservable = function () {
            if (!this.list) {
                return;
            }
            if (this.focusJump) {
                this.focusJump.unsubscribe();
            }
            var elList = Array.from(this.list.nativeElement.querySelectorAll("li"));
            this.focusJump = watchFocusJump(this.list.nativeElement, elList)
                .subscribe(function (el) {
                el.focus();
            });
        };
        /**
         * Returns the `ListItem` that is subsequent to the selected item in the `DropdownList`.
         */
        DropdownList.prototype.getNextItem = function () {
            if (this.index < this.displayItems.length - 1) {
                this.index++;
            }
            return this.displayItems[this.index];
        };
        /**
         * Returns `true` if the selected item is not the last item in the `DropdownList`.
         */
        DropdownList.prototype.hasNextElement = function () {
            if (this.index < this.displayItems.length - 1) {
                return true;
            }
            return false;
        };
        /**
         * Returns the `HTMLElement` for the item that is subsequent to the selected item.
         */
        DropdownList.prototype.getNextElement = function () {
            if (this.index < this.displayItems.length - 1) {
                this.index++;
            }
            var elem = this.listElementList.toArray()[this.index].nativeElement;
            var item = this.displayItems[this.index];
            if (item.disabled) {
                return this.getNextElement();
            }
            return elem;
        };
        /**
         * Returns the `ListItem` that precedes the selected item within `DropdownList`.
         */
        DropdownList.prototype.getPrevItem = function () {
            if (this.index > 0) {
                this.index--;
            }
            return this.displayItems[this.index];
        };
        /**
         * Returns `true` if the selected item is not the first in the list.
         */
        DropdownList.prototype.hasPrevElement = function () {
            if (this.index > 0) {
                return true;
            }
            return false;
        };
        /**
         * Returns the `HTMLElement` for the item that precedes the selected item.
         */
        DropdownList.prototype.getPrevElement = function () {
            if (this.index > 0) {
                this.index--;
            }
            var elem = this.listElementList.toArray()[this.index].nativeElement;
            var item = this.displayItems[this.index];
            if (item.disabled) {
                return this.getPrevElement();
            }
            return elem;
        };
        /**
         * Returns the `ListItem` that is selected within `DropdownList`.
         */
        DropdownList.prototype.getCurrentItem = function () {
            if (this.index < 0) {
                return this.displayItems[0];
            }
            return this.displayItems[this.index];
        };
        /**
         * Returns the `HTMLElement` for the item that is selected within the `DropdownList`.
         */
        DropdownList.prototype.getCurrentElement = function () {
            if (this.index < 0) {
                return this.listElementList.first.nativeElement;
            }
            return this.listElementList.toArray()[this.index].nativeElement;
        };
        /**
         * Returns the items as an Array
         */
        DropdownList.prototype.getListItems = function () {
            return this._items;
        };
        /**
         * Returns a list containing the selected item(s) in the `DropdownList`.
         */
        DropdownList.prototype.getSelected = function () {
            var selected = this.getListItems().filter(function (item) { return item.selected; });
            if (selected.length === 0) {
                return [];
            }
            return selected;
        };
        /**
         * Transforms array input list of items to the correct state by updating the selected item(s).
         */
        DropdownList.prototype.propagateSelected = function (value) {
            var _this = this;
            // if we get a non-array, log out an error (since it is one)
            if (!Array.isArray(value)) {
                console.error(this.constructor.name + ".propagateSelected expects an Array<ListItem>, got " + JSON.stringify(value));
            }
            this.onItemsReady(function () {
                var e_1, _a, e_2, _b;
                try {
                    // loop through the list items and update the `selected` state for matching items in `value`
                    for (var _c = __values(_this.getListItems()), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var oldItem = _d.value;
                        // copy the item
                        var tempOldItem = Object.assign({}, oldItem);
                        // deleted selected because it's what we _want_ to change
                        delete tempOldItem.selected;
                        // stringify for compare
                        tempOldItem = JSON.stringify(tempOldItem);
                        try {
                            for (var value_1 = __values(value), value_1_1 = value_1.next(); !value_1_1.done; value_1_1 = value_1.next()) {
                                var newItem = value_1_1.value;
                                // copy the item
                                var tempNewItem = Object.assign({}, newItem);
                                // deleted selected because it's what we _want_ to change
                                delete tempNewItem.selected;
                                // stringify for compare
                                tempNewItem = JSON.stringify(tempNewItem);
                                // do the compare
                                if (tempOldItem.includes(tempNewItem)) {
                                    oldItem.selected = newItem.selected;
                                    // if we've found a matching item, we can stop looping
                                    break;
                                }
                                else {
                                    oldItem.selected = false;
                                }
                            }
                        }
                        catch (e_2_1) {
                            e_2 = { error: e_2_1 };
                        }
                        finally {
                            try {
                                if (value_1_1 && !value_1_1.done && (_b = value_1.return))
                                    _b.call(value_1);
                            }
                            finally {
                                if (e_2)
                                    throw e_2.error;
                            }
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return))
                            _a.call(_c);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
            });
        };
        /**
         * Initializes focus in the list, effectively a wrapper for `getCurrentElement().focus()`
         */
        DropdownList.prototype.initFocus = function () {
            // ensure we start at this first item if nothing is already selected
            if (this.index < 0) {
                this.index = 0;
            }
            this.getCurrentElement().focus();
        };
        /**
         * Manages the keyboard accessibility for navigation and selection within a `DropdownList`.
         */
        DropdownList.prototype.doKeyDown = function (event, item) {
            // "Spacebar", "Down", and "Up" are IE specific values
            if (event.key === "Enter" || event.key === " " || event.key === "Spacebar") {
                if (this.listElementList.some(function (option) { return option.nativeElement === event.target; })) {
                    event.preventDefault();
                }
                if (event.key === "Enter") {
                    this.doClick(event, item);
                }
            }
            else if (event.key === "ArrowDown" || event.key === "ArrowUp" || event.key === "Down" || event.key === "Up") {
                event.preventDefault();
                if (event.key === "ArrowDown" || event.key === "Down") {
                    if (this.hasNextElement()) {
                        this.getNextElement().focus();
                    }
                    else {
                        this.blurIntent.emit("bottom");
                    }
                }
                else if (event.key === "ArrowUp" || event.key === "Up") {
                    if (this.hasPrevElement()) {
                        this.getPrevElement().focus();
                    }
                    else {
                        this.blurIntent.emit("top");
                    }
                }
            }
        };
        /**
         * Emits the selected item or items after a mouse click event has occurred.
         */
        DropdownList.prototype.doClick = function (event, item) {
            var e_3, _a;
            event.preventDefault();
            if (!item.disabled) {
                if (this.type === "single") {
                    item.selected = true;
                    try {
                        // reset the selection
                        for (var _b = __values(this.getListItems()), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var otherItem = _c.value;
                            if (item !== otherItem) {
                                otherItem.selected = false;
                            }
                        }
                    }
                    catch (e_3_1) {
                        e_3 = { error: e_3_1 };
                    }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return))
                                _a.call(_b);
                        }
                        finally {
                            if (e_3)
                                throw e_3.error;
                        }
                    }
                }
                else {
                    item.selected = !item.selected;
                }
                this.index = this.displayItems.indexOf(item);
                this.doEmitSelect(false);
            }
        };
        DropdownList.prototype.onItemFocus = function (index) {
            var element = this.listElementList.toArray()[index].nativeElement;
            element.classList.add("bx--list-box__menu-item--highlighted");
            element.tabIndex = 0;
        };
        DropdownList.prototype.onItemBlur = function (index) {
            var element = this.listElementList.toArray()[index].nativeElement;
            element.classList.remove("bx--list-box__menu-item--highlighted");
            element.tabIndex = -1;
        };
        /**
         * Emits the scroll event of the options list
         */
        DropdownList.prototype.emitScroll = function (event) {
            var atTop = event.srcElement.scrollTop === 0;
            var atBottom = event.srcElement.scrollHeight - event.srcElement.scrollTop === event.srcElement.clientHeight;
            var customScrollEvent = { atTop: atTop, atBottom: atBottom, event: event };
            this.scroll.emit(customScrollEvent);
        };
        /**
         * Subscribe the function passed to an internal observable that will resolve once the items are ready
         */
        DropdownList.prototype.onItemsReady = function (subcription) {
            // this subscription will auto unsubscribe because of the `first()` pipe
            (this._itemsReady || rxjs.of(true)).pipe(operators.first()).subscribe(subcription);
        };
        DropdownList.prototype.reorderSelected = function (moveFocus) {
            var _this = this;
            if (moveFocus === void 0) {
                moveFocus = false;
            }
            this.displayItems = __spread(this.getSelected(), this.getListItems().filter(function (item) { return !item.selected; }));
            if (moveFocus) {
                setTimeout(function () { return _this.getCurrentElement().focus(); });
            }
        };
        DropdownList.decorators = [
            { type: core.Component, args: [{
                        selector: "ibm-dropdown-list",
                        template: "\n\t\t<ul\n\t\t\t#list\n\t\t\trole=\"listbox\"\n\t\t\tclass=\"bx--list-box__menu bx--multi-select\"\n\t\t\t(scroll)=\"emitScroll($event)\"\n\t\t\t[attr.aria-label]=\"ariaLabel\">\n\t\t\t<li\n\t\t\t\trole=\"option\"\n\t\t\t\t*ngFor=\"let item of displayItems; let i = index\"\n\t\t\t\t(click)=\"doClick($event, item)\"\n\t\t\t\t(keydown)=\"doKeyDown($event, item)\"\n\t\t\t\t(focus)=\"onItemFocus(i)\"\n\t\t\t\t(blur)=\"onItemBlur(i)\"\n\t\t\t\tclass=\"bx--list-box__menu-item\"\n\t\t\t\t[ngClass]=\"{\n\t\t\t\t\t'bx--list-box__menu-item--active': item.selected,\n\t\t\t\t\tdisabled: item.disabled\n\t\t\t\t}\"\n\t\t\t\t[title]=\"item.content\">\n\t\t\t\t<div\n\t\t\t\t\t#listItem\n\t\t\t\t\ttabindex=\"-1\"\n\t\t\t\t\tclass=\"bx--list-box__menu-item__option\">\n\t\t\t\t\t<div\n\t\t\t\t\t\t*ngIf=\"!listTpl && type === 'multi'\"\n\t\t\t\t\t\tclass=\"bx--form-item bx--checkbox-wrapper\">\n\t\t\t\t\t\t<label\n\t\t\t\t\t\t\t[attr.data-contained-checkbox-state]=\"item.selected\"\n\t\t\t\t\t\t\tclass=\"bx--checkbox-label\">\n\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\tclass=\"bx--checkbox\"\n\t\t\t\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\t\t\t\t[checked]=\"item.selected\"\n\t\t\t\t\t\t\t\t[disabled]=\"item.disabled\"\n\t\t\t\t\t\t\t\ttabindex=\"-1\">\n\t\t\t\t\t\t\t<span class=\"bx--checkbox-appearance\"></span>\n\t\t\t\t\t\t\t<span class=\"bx--checkbox-label-text\">{{item.content}}</span>\n\t\t\t\t\t\t</label>\n\t\t\t\t\t</div>\n\t\t\t\t\t<ng-container *ngIf=\"!listTpl && type === 'single'\">{{item.content}}</ng-container>\n\t\t\t\t\t<svg\n\t\t\t\t\t\t*ngIf=\"!listTpl && type === 'single'\"\n\t\t\t\t\t\tibmIcon=\"checkmark\"\n\t\t\t\t\t\tsize=\"16\"\n\t\t\t\t\t\tclass=\"bx--list-box__menu-item__selected-icon\">\n\t\t\t\t\t</svg>\n\t\t\t\t\t<ng-template\n\t\t\t\t\t\t*ngIf=\"listTpl\"\n\t\t\t\t\t\t[ngTemplateOutletContext]=\"{item: item}\"\n\t\t\t\t\t\t[ngTemplateOutlet]=\"listTpl\">\n\t\t\t\t\t</ng-template>\n\t\t\t\t</div>\n\t\t\t</li>\n\t\t</ul>",
                        providers: [
                            {
                                provide: AbstractDropdownView,
                                useExisting: DropdownList
                            }
                        ]
                    }] }
        ];
        /** @nocollapse */
        DropdownList.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: i18n.I18n }
            ];
        };
        DropdownList.propDecorators = {
            ariaLabel: [{ type: core.Input }],
            items: [{ type: core.Input }],
            listTpl: [{ type: core.Input }],
            select: [{ type: core.Output }],
            scroll: [{ type: core.Output }],
            blurIntent: [{ type: core.Output }],
            list: [{ type: core.ViewChild, args: ["list", { static: true },] }],
            type: [{ type: core.Input }],
            listElementList: [{ type: core.ViewChildren, args: ["listItem",] }]
        };
        return DropdownList;
    }());

    var ScrollableList = /** @class */ (function () {
        function ScrollableList(elementRef) {
            this.elementRef = elementRef;
            /**
             * Optional target list to scroll
             */
            this.nScrollableList = null;
            /**
             * Enables or disables scrolling for the whole directive
             */
            this.scrollEnabled = true;
            /**
             * How many lines to scroll by each time `wheel` fires
             * Defaults to 10 - based on testing this isn't too fast or slow on any platform
             */
            this.scrollBy = 10;
            this.canScrollUp = false;
            this.canScrollDown = false;
            this.list = this.elementRef.nativeElement;
        }
        ScrollableList.prototype.ngOnChanges = function (changes) {
            var _this = this;
            if (changes.scrollEnabled) {
                if (changes.scrollEnabled.currentValue) {
                    this.list.style.overflow = "hidden";
                    this.scrollUpTarget.style.display = "flex";
                    this.scrollDownTarget.style.display = "flex";
                    this.canScrollUp = true;
                    this.canScrollDown = true;
                    this.updateScrollHeight();
                    this.checkScrollArrows();
                    setTimeout(function () {
                        _this.checkScrollArrows();
                    });
                }
                else {
                    this.scrollUpTarget.style.display = "none";
                    this.scrollDownTarget.style.display = "none";
                    this.canScrollUp = false;
                    this.canScrollDown = false;
                    this.list.style.height = null;
                    this.list.style.overflow = null;
                    clearInterval(this.hoverScrollInterval);
                }
            }
        };
        ScrollableList.prototype.ngAfterViewInit = function () {
            var _this = this;
            if (this.nScrollableList) {
                this.list = this.elementRef.nativeElement.querySelector(this.nScrollableList);
            }
            this.scrollUpTarget.addEventListener("mouseover", function () { return _this.onHoverUp(true); });
            this.scrollUpTarget.addEventListener("mouseout", function () { return _this.onHoverUp(false); });
            this.scrollDownTarget.addEventListener("mouseover", function () { return _this.onHoverDown(true); });
            this.scrollDownTarget.addEventListener("mouseout", function () { return _this.onHoverDown(false); });
        };
        ScrollableList.prototype.updateScrollHeight = function () {
            if (this.scrollEnabled) {
                var container = this.elementRef.nativeElement.parentElement;
                var containerRect = container.getBoundingClientRect();
                var innerHeightDiff = this.list.getBoundingClientRect().top - containerRect.top;
                var outerHeightDiff = containerRect.height - (containerRect.bottom - window.innerHeight);
                // 40 gives us some padding between the bottom of the list,
                // the bottom of the window, and the scroll down button
                var height = outerHeightDiff - innerHeightDiff - 40;
                this.list.style.height = height + "px";
            }
        };
        ScrollableList.prototype.checkScrollArrows = function () {
            var scrollUpHeight = this.scrollUpTarget.offsetHeight;
            var scrollDownHeight = this.scrollDownTarget.offsetHeight;
            if (this.list.scrollTop === 0) {
                if (this.canScrollUp) {
                    this.list.style.height = parseInt(this.list.style.height, 10) + scrollUpHeight + "px";
                }
                this.scrollUpTarget.style.display = "none";
                this.canScrollUp = false;
            }
            else if (this.list.scrollTop === this.list.scrollTopMax) {
                if (this.canScrollDown) {
                    this.list.style.height = parseInt(this.list.style.height, 10) + scrollDownHeight + "px";
                }
                this.scrollDownTarget.style.display = "none";
                this.canScrollDown = false;
            }
            else {
                if (!this.canScrollUp) {
                    this.list.style.height = parseInt(this.list.style.height, 10) - scrollUpHeight + "px";
                }
                if (!this.canScrollDown) {
                    this.list.style.height = parseInt(this.list.style.height, 10) - scrollDownHeight + "px";
                }
                this.scrollUpTarget.style.display = "flex";
                this.scrollDownTarget.style.display = "flex";
                this.canScrollUp = true;
                this.canScrollDown = true;
            }
        };
        ScrollableList.prototype.onWheel = function (event) {
            if (event.deltaY < 0) {
                this.list.scrollTop -= this.scrollBy;
            }
            else {
                this.list.scrollTop += this.scrollBy;
            }
            // only prevent the parent/window from scrolling if we can scroll
            if (!(this.list.scrollTop === this.list.scrollTopMax || this.list.scrollTop === 0)) {
                event.preventDefault();
                event.stopPropagation();
            }
            this.checkScrollArrows();
        };
        ScrollableList.prototype.onTouchStart = function (event) {
            if (event.touches[0]) {
                this.lastTouch = event.touches[0].clientY;
            }
        };
        ScrollableList.prototype.onTouchMove = function (event) {
            event.preventDefault();
            event.stopPropagation();
            if (event.touches[0]) {
                var touch = event.touches[0];
                this.list.scrollTop += this.lastTouch - touch.clientY;
                this.lastTouch = touch.clientY;
                this.checkScrollArrows();
            }
        };
        ScrollableList.prototype.hoverScrollBy = function (hovering, amount) {
            var _this = this;
            if (hovering) {
                this.hoverScrollInterval = setInterval(function () {
                    _this.list.scrollTop += amount;
                    _this.checkScrollArrows();
                }, 1);
            }
            else {
                clearInterval(this.hoverScrollInterval);
            }
        };
        ScrollableList.prototype.onHoverUp = function (hovering) {
            // how many px/lines to scroll by on hover
            // 3 is just a random number that felt good
            // 1 and 2 are too slow, 4 works but it might be a tad fast
            this.hoverScrollBy(hovering, -3);
        };
        ScrollableList.prototype.onHoverDown = function (hovering) {
            this.hoverScrollBy(hovering, 3);
        };
        ScrollableList.prototype.onKeyDown = function (event) {
            if (event.key === "ArrowDown" || event.key === "ArrowUp") {
                this.checkScrollArrows();
            }
        };
        ScrollableList.decorators = [
            { type: core.Directive, args: [{
                        selector: "[ibmScrollableList]",
                        exportAs: "scrollable-list"
                    },] }
        ];
        /** @nocollapse */
        ScrollableList.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        ScrollableList.propDecorators = {
            nScrollableList: [{ type: core.Input }],
            scrollEnabled: [{ type: core.Input }],
            scrollUpTarget: [{ type: core.Input }],
            scrollDownTarget: [{ type: core.Input }],
            scrollBy: [{ type: core.Input }],
            onWheel: [{ type: core.HostListener, args: ["wheel", ["$event"],] }],
            onTouchStart: [{ type: core.HostListener, args: ["touchstart", ["$event"],] }],
            onTouchMove: [{ type: core.HostListener, args: ["touchmove", ["$event"],] }],
            onKeyDown: [{ type: core.HostListener, args: ["keydown", ["$event"],] }]
        };
        return ScrollableList;
    }());

    var DropdownModule = /** @class */ (function () {
        function DropdownModule() {
        }
        DropdownModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            Dropdown,
                            DropdownList,
                            ScrollableList,
                            AbstractDropdownView
                        ],
                        exports: [
                            Dropdown,
                            DropdownList,
                            ScrollableList,
                            AbstractDropdownView
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            i18n.I18nModule,
                            placeholder.PlaceholderModule,
                            utils.UtilsModule,
                            icon.IconModule
                        ],
                        providers: [DropdownService]
                    },] }
        ];
        return DropdownModule;
    }());

    /**
     * Generated bundle index. Do not edit.
     */

    exports.Dropdown = Dropdown;
    exports.DropdownList = DropdownList;
    exports.ScrollableList = ScrollableList;
    exports.AbstractDropdownView = AbstractDropdownView;
    exports.DropdownService = DropdownService;
    exports.DropdownModule = DropdownModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=carbon-components-angular-dropdown.umd.js.map