/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-utils.umd.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@carbon/utils-position'), require('rxjs/operators'), require('@angular/core'), require('rxjs')) :
    typeof define === 'function' && define.amd ? define('carbon-components-angular/utils', ['exports', '@carbon/utils-position', 'rxjs/operators', '@angular/core', 'rxjs'], factory) :
    (factory((global['carbon-components-angular'] = global['carbon-components-angular'] || {}, global['carbon-components-angular'].utils = {}),global.utilsPosition,global.rxjs.operators,global.ng.core,global.rxjs));
}(this, (function (exports,utilsPosition,operators,core,rxjs) { 'use strict';

    function findSiblingElem(target, direction) {
        if (target[direction]) {
            if (target[direction].classList.contains("disabled")) {
                return findSiblingElem(target[direction], direction);
            }
            return target[direction];
        }
    }
    function findNextElem(target) {
        return findSiblingElem(target, "nextElementSibling");
    }
    function findPrevElem(target) {
        return findSiblingElem(target, "previousElementSibling");
    }
    // check for Hight contrast mode
    function HcModeChecker() {
        var colorTest = "rgb(255, 0, 0)";
        var htmlChecker = document.createElement("div");
        htmlChecker.classList.add("hc-checker");
        document.body.appendChild(htmlChecker);
        if (window.getComputedStyle(htmlChecker).backgroundColor.toString() !== colorTest) {
            document.body.classList.add("a11y");
        }
        document.body.removeChild(htmlChecker);
    }
    function focusNextTree(elem, rootElem) {
        if (rootElem === void 0) {
            rootElem = null;
        }
        if (elem) {
            var focusable = elem.querySelector("[tabindex='0']");
            if (focusable) {
                focusable.focus();
            }
            else {
                focusNextElem(elem, rootElem);
            }
        }
    }
    function focusNextElem(elem, rootElem) {
        if (rootElem === void 0) {
            rootElem = null;
        }
        if (elem) {
            var nextElem = elem.nextElementSibling;
            if (nextElem) {
                var focusableElem = nextElem.querySelector("[tabindex='0']");
                if (focusableElem) {
                    focusableElem.focus();
                }
                else {
                    focusNextElem(nextElem, rootElem);
                }
            }
            else {
                if (rootElem) {
                    var nextRootElem = rootElem.nextElementSibling;
                    if (nextRootElem) {
                        focusNextTree(nextRootElem, rootElem);
                    }
                }
            }
        }
    }
    function focusPrevElem(elem, parentRef) {
        if (parentRef === void 0) {
            parentRef = null;
        }
        if (elem) {
            var prevElem = elem.previousElementSibling;
            if (prevElem) {
                var focusableElem = prevElem.querySelector("[tabindex='0']");
                if (focusableElem) {
                    if (focusableElem.getAttribute("aria-expanded") === "true") {
                        var lastFocElms = prevElem.querySelectorAll("[tabindex='0']");
                        var arrLen = lastFocElms.length - 1;
                        for (var i = arrLen; i >= 0; i--) {
                            if (!!(lastFocElms[i].offsetWidth || lastFocElms[i].offsetHeight ||
                                lastFocElms[i].getClientRects().length)) {
                                focusableElem = lastFocElms[i];
                                break;
                            }
                        }
                    }
                    focusableElem.focus();
                }
                else {
                    focusPrevElem(prevElem, parentRef);
                }
            }
            else {
                if (parentRef) {
                    parentRef.querySelector("[tabindex='0']").focus();
                }
            }
        }
    }

    var AnimationFrameServiceSingleton = /** @class */ (function () {
        function AnimationFrameServiceSingleton(ngZone) {
            var _this = this;
            this.ngZone = ngZone;
            this.frameSource = new rxjs.Subject();
            this.tick = this.frameSource.asObservable();
            this.ngZone.runOutsideAngular(function () {
                _this.animationFrameId = requestAnimationFrame(_this.doTick.bind(_this));
            });
        }
        AnimationFrameServiceSingleton.prototype.ngOnDestroy = function () {
            cancelAnimationFrame(this.animationFrameId);
        };
        AnimationFrameServiceSingleton.prototype.doTick = function (frame) {
            var _this = this;
            this.frameSource.next(frame);
            this.ngZone.runOutsideAngular(function () {
                requestAnimationFrame(_this.doTick.bind(_this));
            });
        };
        AnimationFrameServiceSingleton.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        AnimationFrameServiceSingleton.ctorParameters = function () {
            return [
                { type: core.NgZone }
            ];
        };
        return AnimationFrameServiceSingleton;
    }());
    var AnimationFrameService = /** @class */ (function () {
        function AnimationFrameService(singleton) {
            this.singleton = singleton;
            this.tick = rxjs.from(this.singleton.tick);
        }
        AnimationFrameService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        AnimationFrameService.ctorParameters = function () {
            return [
                { type: AnimationFrameServiceSingleton }
            ];
        };
        return AnimationFrameService;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    // custom deep object merge
    var merge = function (target) {
        var objects = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            objects[_i - 1] = arguments[_i];
        }
        var e_1, _a;
        try {
            for (var objects_1 = __values(objects), objects_1_1 = objects_1.next(); !objects_1_1.done; objects_1_1 = objects_1.next()) {
                var object = objects_1_1.value;
                for (var key in object) {
                    if (object.hasOwnProperty(key)) {
                        // since we're dealing just with JSON this simple check should be enough
                        if (object[key] instanceof Object) {
                            if (!target[key]) {
                                target[key] = {};
                            }
                            // recursively merge into the target
                            // most translations only run 3 or 4 levels deep, so no stack explosions
                            target[key] = merge(target[key], object[key]);
                        }
                        else {
                            target[key] = object[key];
                        }
                    }
                }
            }
        }
        catch (e_1_1) {
            e_1 = { error: e_1_1 };
        }
        finally {
            try {
                if (objects_1_1 && !objects_1_1.done && (_a = objects_1.return))
                    _a.call(objects_1);
            }
            finally {
                if (e_1)
                    throw e_1.error;
            }
        }
        return target;
    };

    /**
     * Checks if a given element is scrollable.
     * If the element has an overflow set as part of its computed style it can scroll.
     * @param element the element to check scrollability
     */
    var isScrollableElement = function (element) {
        var computedStyle = getComputedStyle(element);
        return (computedStyle.overflow === "auto" ||
            computedStyle.overflow === "scroll" ||
            computedStyle["overflow-y"] === "auto" ||
            computedStyle["overflow-y"] === "scroll" ||
            computedStyle["overflow-x"] === "auto" ||
            computedStyle["overflow-x"] === "scroll");
    };
    /**
     * Checks if an element is visible within a container
     * @param element the element to check
     * @param container the container to check
     */
    var isVisibleInContainer = function (element, container) {
        var elementRect = element.getBoundingClientRect();
        var containerRect = container.getBoundingClientRect();
        // If there exists `height: 100%` on the `html` or `body` tag of an application,
        // it causes the calculation to return true if you need to scroll before the element is seen.
        // In that case we calculate its visibility based on the window viewport.
        if (container.tagName === "BODY" || container.tagName === "HTML") {
            // This checks if element is within the top, bottom, left and right of viewport, ie. if the element is visible in
            // the screen. This also takes into account partial visibility of an element.
            var isAboveViewport = elementRect.top < 0 && (elementRect.top + element.clientHeight) < 0;
            var isLeftOfViewport = elementRect.left < 0;
            var isBelowViewport = (elementRect.bottom - element.clientHeight) > (window.innerHeight || document.documentElement.clientHeight);
            var isRightOfViewport = elementRect.right > (window.innerWidth || document.documentElement.clientWidth);
            var isVisibleInViewport = !(isAboveViewport || isBelowViewport || isLeftOfViewport || isRightOfViewport);
            return isVisibleInViewport;
        }
        return (
        // This also accounts for partial visibility. It will still return true if the element is partially visible inside the container.
        (elementRect.bottom - element.clientHeight) <= (containerRect.bottom + (container.offsetHeight - container.clientHeight) / 2) &&
            elementRect.top >= (-element.clientHeight));
    };
    var getScrollableParents = function (node) {
        var elements = [document.body];
        while (node.parentElement && node !== document.body) {
            if (isScrollableElement(node)) {
                elements.push(node);
            }
            node = node.parentElement;
        }
        return elements;
    };
    var hasScrollableParents = function (node) {
        while (node.parentElement && node !== document.body) {
            if (isScrollableElement(node)) {
                return true;
            }
            node = node.parentElement;
        }
        return false;
    };
    /**
     * Returns an observable that emits whenever any scrollable parent element scrolls
     *
     * @param node root element to start finding scrolling parents from
     */
    var scrollableParentsObservable = function (node) {
        var windowScroll = rxjs.fromEvent(window, "scroll", { passive: true }).pipe(operators.map(function (event) {
            return (
            // update the event target to be something useful. In this case `body` is a sensible replacement
            Object.assign({}, event, { target: document.body }));
        }));
        var observables = [windowScroll];
        // walk the parents and subscribe to all the scroll events we can
        while (node.parentElement && node !== document.body) {
            if (isScrollableElement(node)) {
                observables.push(rxjs.fromEvent(node, "scroll", { passive: true }));
            }
            node = node.parentElement;
        }
        return rxjs.merge.apply(void 0, __spread(observables));
    };

    function clone(obj) {
        return JSON.parse(JSON.stringify(obj));
    }
    function matchesAttr(el, attr, val) {
        var styles = window.getComputedStyle(el);
        return val.includes(styles[attr]);
    }
    function closestAttr(s, t, element) {
        var el = element;
        if (!element) {
            return null;
        }
        do {
            if (matchesAttr(el, s, t)) {
                return el;
            }
            el = el.parentElement || el.parentNode;
        } while (el !== null && el.nodeType === 1);
        return null;
    }

    var ElementService = /** @class */ (function () {
        function ElementService(singleton) {
            this.singleton = singleton;
            this.tick = rxjs.from(this.singleton.tick);
        }
        ElementService.prototype.visibility = function (target, parentElement) {
            if (parentElement === void 0) {
                parentElement = target;
            }
            var scrollableParents = getScrollableParents(parentElement);
            return this.tick.pipe(operators.map(function () {
                var e_1, _a;
                try {
                    for (var scrollableParents_1 = __values(scrollableParents), scrollableParents_1_1 = scrollableParents_1.next(); !scrollableParents_1_1.done; scrollableParents_1_1 = scrollableParents_1.next()) {
                        var parent_1 = scrollableParents_1_1.value;
                        if (!isVisibleInContainer(target, parent_1)) {
                            return {
                                visible: false
                            };
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (scrollableParents_1_1 && !scrollableParents_1_1.done && (_a = scrollableParents_1.return))
                            _a.call(scrollableParents_1);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                return {
                    visible: true
                };
            }));
        };
        ElementService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        ElementService.ctorParameters = function () {
            return [
                { type: AnimationFrameServiceSingleton }
            ];
        };
        return ElementService;
    }());

    var getEventObservable = function (targetElement, eventType) {
        switch (eventType) {
            case "scroll":
            case "resize":
            case "touchstart":
            case "touchmove":
            case "touchend":
                return rxjs.fromEvent(targetElement, eventType, { passive: true });
            default:
                return rxjs.fromEvent(targetElement, eventType);
        }
    };

    var DocumentService = /** @class */ (function () {
        function DocumentService() {
            this.globalEvents = new Map();
            this.documentRef = document;
            this.subscriptions = new rxjs.Subscription();
        }
        DocumentService.prototype.handleEvent = function (eventType, callback) {
            if (!this.globalEvents.has(eventType)) {
                if (this.documentRef) {
                    this.globalEvents.set(eventType, getEventObservable(this.documentRef, eventType));
                }
                else {
                    this.globalEvents.set(eventType, new rxjs.Observable());
                }
            }
            var observable = this.globalEvents.get(eventType);
            this.subscriptions.add(observable.subscribe(callback));
        };
        DocumentService.prototype.handleClick = function (callback) {
            this.handleEvent("click", callback);
        };
        DocumentService.prototype.ngOnDestroy = function () {
            this.subscriptions.unsubscribe();
            this.globalEvents = null;
        };
        DocumentService.decorators = [
            { type: core.Injectable }
        ];
        return DocumentService;
    }());

    var EventService = /** @class */ (function () {
        function EventService(documentService) {
            this.documentService = documentService;
            this.subscriptions = new rxjs.Subscription();
            this.targets = new WeakMap();
        }
        EventService.prototype.on = function (targetElement, eventType, callback) {
            if (!this.targets.has(targetElement)) {
                this.targets.set(targetElement, new Map());
            }
            var eventMap = this.targets.get(targetElement);
            if (!eventMap.has(eventType)) {
                eventMap.set(eventType, getEventObservable(targetElement, eventType));
            }
            var subscription = eventMap.get(eventType).subscribe(callback);
            this.subscriptions.add(subscription);
        };
        EventService.prototype.onDocument = function (eventType, callback) {
            this.documentService.handleEvent(eventType, callback);
        };
        EventService.prototype.ngOnDestroy = function () {
            this.subscriptions.unsubscribe();
        };
        EventService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        EventService.ctorParameters = function () {
            return [
                { type: DocumentService }
            ];
        };
        return EventService;
    }());

    // either provides a new instance of DocumentService, or returns the parent
    function DOCUMENT_SERVICE_PROVIDER_FACTORY(parentService) {
        return parentService || new DocumentService();
    }
    // DocumentService *must* be a singleton to ensure that we handle events and other document level settings once (and only once)
    var DOCUMENT_SERVICE_PROVIDER = {
        provide: DocumentService,
        deps: [[new core.Optional(), new core.SkipSelf(), DocumentService]],
        useFactory: DOCUMENT_SERVICE_PROVIDER_FACTORY
    };
    // either provides a new instance of AnimationFrameServiceSingleton, or returns the parent
    function ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER_FACTORY(parentService, ngZone) {
        return parentService || new AnimationFrameServiceSingleton(ngZone);
    }
    // AnimationFrameServiceSingleton is a singleton so we don't have a ton of duplicate RAFs firing (better for scheduling)
    var ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER = {
        provide: AnimationFrameServiceSingleton,
        deps: [[new core.Optional(), new core.SkipSelf(), AnimationFrameServiceSingleton], core.NgZone],
        useFactory: ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER_FACTORY
    };
    var UtilsModule = /** @class */ (function () {
        function UtilsModule() {
        }
        UtilsModule.decorators = [
            { type: core.NgModule, args: [{
                        providers: [
                            DOCUMENT_SERVICE_PROVIDER,
                            ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER,
                            AnimationFrameServiceSingleton,
                            DocumentService,
                            AnimationFrameService,
                            ElementService,
                            EventService
                        ]
                    },] }
        ];
        return UtilsModule;
    }());

    var _scrollbarWidth = -1;
    function getScrollbarWidth() {
        // lets not recreate this whole thing every time
        if (_scrollbarWidth >= 0) {
            return _scrollbarWidth;
        }
        // do the calculations the first time
        var outer = document.createElement("div");
        outer.style.visibility = "hidden";
        outer.style.width = "100px";
        outer.style.msOverflowStyle = "scrollbar"; // needed for WinJS apps
        document.body.appendChild(outer);
        var widthNoScroll = outer.offsetWidth;
        // force scrollbars
        outer.style.overflow = "scroll";
        // add innerdiv
        var inner = document.createElement("div");
        inner.style.width = "100%";
        outer.appendChild(inner);
        var widthWithScroll = inner.offsetWidth;
        // remove divs
        outer.parentNode.removeChild(outer);
        _scrollbarWidth = widthNoScroll - widthWithScroll;
        return _scrollbarWidth;
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.PLACEMENTS = utilsPosition.PLACEMENTS;
    exports.Position = utilsPosition.Position;
    exports.defaultPositions = utilsPosition.defaultPositions;
    exports.position = utilsPosition.position;
    exports.HcModeChecker = HcModeChecker;
    exports.findNextElem = findNextElem;
    exports.findPrevElem = findPrevElem;
    exports.focusNextElem = focusNextElem;
    exports.focusNextTree = focusNextTree;
    exports.focusPrevElem = focusPrevElem;
    exports.AnimationFrameService = AnimationFrameService;
    exports.AnimationFrameServiceSingleton = AnimationFrameServiceSingleton;
    exports.merge = merge;
    exports.getScrollableParents = getScrollableParents;
    exports.hasScrollableParents = hasScrollableParents;
    exports.isScrollableElement = isScrollableElement;
    exports.isVisibleInContainer = isVisibleInContainer;
    exports.scrollableParentsObservable = scrollableParentsObservable;
    exports.clone = clone;
    exports.closestAttr = closestAttr;
    exports.ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER = ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER;
    exports.ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER_FACTORY = ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER_FACTORY;
    exports.DOCUMENT_SERVICE_PROVIDER = DOCUMENT_SERVICE_PROVIDER;
    exports.DOCUMENT_SERVICE_PROVIDER_FACTORY = DOCUMENT_SERVICE_PROVIDER_FACTORY;
    exports.UtilsModule = UtilsModule;
    exports.getScrollbarWidth = getScrollbarWidth;
    exports.ElementService = ElementService;
    exports.EventService = EventService;
    exports.getEventObservable = getEventObservable;
    exports.DocumentService = DocumentService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=carbon-components-angular-utils.umd.js.map