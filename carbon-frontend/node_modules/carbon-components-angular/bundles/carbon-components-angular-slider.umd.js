/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-slider.umd.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/forms'), require('@angular/core'), require('@angular/common'), require('carbon-components-angular/utils')) :
    typeof define === 'function' && define.amd ? define('carbon-components-angular/slider', ['exports', '@angular/forms', '@angular/core', '@angular/common', 'carbon-components-angular/utils'], factory) :
    (factory((global['carbon-components-angular'] = global['carbon-components-angular'] || {}, global['carbon-components-angular'].slider = {}),global.ng.forms,global.ng.core,global.ng.common,global['carbon-components-angular'].utils));
}(this, (function (exports,forms,core,common,utils) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * Used to select from ranges of values. [See here](https://www.carbondesignsystem.com/components/slider/usage) for usage information.
     *
     * [See demo](../../?path=/story/slider--advanced)
     *
     * The simplest possible slider usage looks something like:
     * ```html
     * <ibm-slider></ibm-slider>
     * ```
     *
     * That will render a slider without labels or alternative value input. Labels can be provided by
     * elements with `[minLabel]` and `[maxLabel]` attributes, and an `input` (may use the `ibmInput` directive) can be supplied
     * for use as an alternative value field.
     *
     * ex:
     * ```html
     * <!-- full example -->
     * <ibm-slider>
     *		<span minLabel>0GB</span>
     *		<span maxLabel>100GB</span>
     *		<input/>
     *	</ibm-slider>
     * <!-- with just an input -->
     * <ibm-slider>
     *		<input/>
     *	</ibm-slider>
     * <!-- with just one label -->
     * <ibm-slider>
     *		<span maxLabel>Maximum</span>
     *	</ibm-slider>
     * ```
     *
     * Slider supports `NgModel` by default, as well as two way binding to the `value` input.
     *
     * <example-url>../../iframe.html?id=slider--advanced</example-url>
     */
    var Slider = /** @class */ (function () {
        function Slider(elementRef, eventService) {
            this.elementRef = elementRef;
            this.eventService = eventService;
            /** The interval for our range */
            this.step = 1;
            /** Base ID for the slider. The min and max labels get IDs `${this.id}-bottom-range` and `${this.id}-top-range` respectively */
            this.id = "slider-" + Slider.count++;
            /** Value used to "multiply" the `step` when using arrow keys to select values */
            this.shiftMultiplier = 4;
            /** Set to `true` for a loading slider */
            this.skeleton = false;
            /** Set to `true` for a slider without arrow key interactions. */
            this.disableArrowKeys = false;
            /** Emits every time a new value is selected */
            this.valueChange = new core.EventEmitter();
            this.hostClass = true;
            this.bottomRangeId = this.id + "-bottom-range";
            this.topRangeId = this.id + "-top-range";
            this.fractionComplete = 0;
            this.isMouseDown = false;
            this._min = 0;
            this._max = 100;
            this._value = [this.min];
            this._previousValue = [this.min];
            this._disabled = false;
            this._focusedThumbIndex = 0;
            /** Send changes back to the model */
            this.propagateChange = function (_) { };
            /** Callback to notify the model when our input has been touched */
            this.onTouched = function () { };
        }
        Object.defineProperty(Slider.prototype, "min", {
            get: function () {
                return this._min;
            },
            /** The lower bound of our range */
            set: function (v) {
                if (!v) {
                    return;
                }
                this._min = v;
                // force the component to update
                this.value = this.value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Slider.prototype, "max", {
            get: function () {
                return this._max;
            },
            /** The upper bound of our range */
            set: function (v) {
                if (!v) {
                    return;
                }
                this._max = v;
                // force the component to update
                this.value = this.value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Slider.prototype, "value", {
            get: function () {
                if (this.isRange()) {
                    return this._value;
                }
                return this._value[0];
            },
            /** Set the initial value. Available for two way binding */
            set: function (v) {
                var _this = this;
                if (!v) {
                    v = [this.min];
                }
                if (typeof v === "number" || typeof v === "string") {
                    v = [Number(v)];
                }
                if (v[0] < this.min) {
                    v[0] = this.min;
                }
                if (v[0] > this.max) {
                    v[0] = this.max;
                }
                if (this.isRange()) {
                    if (this._previousValue[0] !== v[0]) { // left moved
                        if (v[0] > v[1] - this.step) {
                            // stop the left handle if surpassing the right one
                            v[0] = v[1] - this.step;
                        }
                        else if (v[0] > this.max) {
                            v[0] = this.max;
                        }
                        else if (v[0] < this.min) {
                            v[0] = this.min;
                        }
                    }
                    if (this._previousValue[1] !== v[1]) { // right moved
                        if (v[1] > this.max) {
                            v[1] = this.max;
                        }
                        else if (v[1] < this._value[0] + this.step) {
                            // stop the right handle if surpassing the left one
                            v[1] = this._value[0] + this.step;
                        }
                        else if (v[1] < this.min) {
                            v[1] = this.min;
                        }
                    }
                }
                this._previousValue = __spread(this._value); // store a copy, enable detection which handle moved
                this._value = __spread(v); // triggers change detection when ngModel value is an array (for range)
                if (this.isRange() && this.filledTrack) {
                    this.updateTrackRangeWidth();
                }
                else if (this.filledTrack) {
                    this.filledTrack.nativeElement.style.transform = "translate(0%, -50%) " + this.scaleX(this.getFractionComplete(v[0]));
                }
                if (this.inputs && this.inputs.length) {
                    this.inputs.forEach(function (input, index) {
                        input.value = _this._value[index].toString();
                    });
                }
                var valueToEmit = this.isRange() ? v : v[0];
                this.propagateChange(valueToEmit);
                this.valueChange.emit(valueToEmit);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Slider.prototype, "disabled", {
            get: function () {
                return this._disabled;
            },
            /** Disables the range visually and functionally */
            set: function (v) {
                this._disabled = v;
                // for some reason `this.input` never exists here, so we have to query for it here too
                var inputs = this.getInputs();
                if (inputs && inputs.length > 0) {
                    inputs.forEach(function (input) { return input.disabled = v; });
                }
            },
            enumerable: true,
            configurable: true
        });
        Slider.prototype.ngAfterViewInit = function () {
            var _this = this;
            // bind mousemove and mouseup to the document so we don't have issues tracking the mouse
            this.eventService.onDocument("mousemove", this.onMouseMove.bind(this));
            this.eventService.onDocument("mouseup", this.onMouseUp.bind(this));
            // apply any values we got from before the view initialized
            this.value = this.value;
            // TODO: ontouchstart/ontouchmove/ontouchend
            // set up the optional input
            this.inputs = this.getInputs();
            if (this.inputs && this.inputs.length > 0) {
                this.inputs.forEach(function (input, index) {
                    input.type = "number";
                    input.classList.add("bx--slider-text-input");
                    input.classList.add("bx--text-input");
                    input.setAttribute("aria-labelledby", _this.bottomRangeId + " " + _this.topRangeId);
                    input.value = index < _this._value.length ? _this._value[index].toString() : _this.max.toString();
                    // bind events on our optional input
                    _this.eventService.on(input, "change", function (event) { return _this.onChange(event, index); });
                    if (index === 0) {
                        _this.eventService.on(input, "focus", _this.onFocus.bind(_this));
                    }
                });
            }
        };
        Slider.prototype.trackThumbsBy = function (index, item) {
            return index;
        };
        /** Register a change propagation function for `ControlValueAccessor` */
        Slider.prototype.registerOnChange = function (fn) {
            this.propagateChange = fn;
        };
        /** Register a callback to notify when our input has been touched */
        Slider.prototype.registerOnTouched = function (fn) {
            this.onTouched = fn;
        };
        /** Receives a value from the model */
        Slider.prototype.writeValue = function (v) {
            this.value = v;
        };
        /**
         * Returns the amount of "completeness" of a value as a fraction of the total track width
         */
        Slider.prototype.getFractionComplete = function (value) {
            if (!this.track) {
                return 0;
            }
            var trackWidth = this.track.nativeElement.getBoundingClientRect().width;
            return this.convertToPx(value) / trackWidth;
        };
        /** Helper function to return the CSS transform `scaleX` function */
        Slider.prototype.scaleX = function (complete) {
            return "scaleX(" + complete + ")";
        };
        /** Converts a given px value to a "real" value in our range */
        Slider.prototype.convertToValue = function (pxAmount) {
            // basic concept borrowed from carbon-components
            // ref: https://github.com/IBM/carbon-components/blob/43bf3abdc2f8bdaa38aa84e0f733adde1e1e8894/src/components/slider/slider.js#L147-L151
            var range = this.max - this.min;
            var trackWidth = this.track.nativeElement.getBoundingClientRect().width;
            var unrounded = pxAmount / trackWidth;
            var rounded = Math.round((range * unrounded) / this.step) * this.step;
            return rounded + this.min;
        };
        /** Converts a given "real" value to a px value we can update the view with */
        Slider.prototype.convertToPx = function (value) {
            if (!this.track) {
                return 0;
            }
            var trackWidth = this.track.nativeElement.getBoundingClientRect().width;
            if (value >= this.max) {
                return trackWidth;
            }
            if (value <= this.min) {
                return 0;
            }
            // account for value shifting by subtracting min from value and max
            return Math.round(trackWidth * ((value - this.min) / (this.max - this.min)));
        };
        /**
         * Increments the value by the step value, or the step value multiplied by the `multiplier` argument.
         *
         * @argument multiplier Defaults to `1`, multiplied with the step value.
         */
        Slider.prototype.incrementValue = function (multiplier, index) {
            if (multiplier === void 0) {
                multiplier = 1;
            }
            if (index === void 0) {
                index = 0;
            }
            this._value[index] = this._value[index] + (this.step * multiplier);
            this.value = this.value; // run the setter
        };
        /**
         * Decrements the value by the step value, or the step value multiplied by the `multiplier` argument.
         *
         * @argument multiplier Defaults to `1`, multiplied with the step value.
         */
        Slider.prototype.decrementValue = function (multiplier, index) {
            if (multiplier === void 0) {
                multiplier = 1;
            }
            if (index === void 0) {
                index = 0;
            }
            this._value[index] = this._value[index] - (this.step * multiplier);
            this.value = this.value; // run the setter
        };
        /**
         * Determines if the slider is in range mode.
         */
        Slider.prototype.isRange = function () {
            return this._value.length > 1;
        };
        /**
         * Range mode only.
         * Updates the track width to span from the low thumb to the high thumb
         */
        Slider.prototype.updateTrackRangeWidth = function () {
            var fraction = this.getFractionComplete(this._value[0]);
            var fraction2 = this.getFractionComplete(this._value[1]);
            this.filledTrack.nativeElement.style.transform = "translate(" + fraction * 100 + "%, -50%) " + this.scaleX(fraction2 - fraction);
        };
        /** Change handler for the optional input */
        Slider.prototype.onChange = function (event, index) {
            this._value[index] = Number(event.target.value);
            this.value = this.value;
        };
        /** Handles clicks on the range track, and setting the value to it's "real" equivalent */
        Slider.prototype.onClick = function (event) {
            if (this.disabled) {
                return;
            }
            var trackLeft = this.track.nativeElement.getBoundingClientRect().left;
            this._value[0] = this.convertToValue(event.clientX - trackLeft);
            this.value = this.value;
        };
        /** Focus handler for the optional input */
        Slider.prototype.onFocus = function (_a) {
            var target = _a.target;
            target.select();
        };
        /** Mouse move handler. Responsible for updating the value and visual selection based on mouse movement */
        Slider.prototype.onMouseMove = function (event) {
            if (this.disabled || !this.isMouseDown) {
                return;
            }
            var track = this.track.nativeElement.getBoundingClientRect();
            var value;
            if (event.clientX - track.left <= track.width
                && event.clientX - track.left >= 0) {
                value = this.convertToValue(event.clientX - track.left);
            }
            // if the mouse is beyond the max, set the value to `max`
            if (event.clientX - track.left > track.width) {
                value = this.max;
            }
            // if the mouse is below the min, set the value to `min`
            if (event.clientX - track.left < 0) {
                value = this.min;
            }
            if (value !== undefined) {
                this._value[this._focusedThumbIndex] = value;
                this.value = this.value;
            }
        };
        /**
         * Enables the `onMouseMove` handler
         *
         * @param {boolean} thumb If true then `thumb` is clicked down, otherwise `thumb2` is clicked down.
         */
        Slider.prototype.onMouseDown = function (event, index) {
            if (index === void 0) {
                index = 0;
            }
            event.preventDefault();
            if (this.disabled) {
                return;
            }
            this._focusedThumbIndex = index;
            this.thumbs.toArray()[index].nativeElement.focus();
            this.isMouseDown = true;
        };
        /** Disables the `onMouseMove` handler */
        Slider.prototype.onMouseUp = function () {
            this.isMouseDown = false;
        };
        /**
         * Calls `incrementValue` for ArrowRight and ArrowUp, `decrementValue` for ArrowLeft and ArrowDown.
         *
         * @param {boolean} thumb If true then `thumb` is pressed down, otherwise `thumb2` is pressed down.
         */
        Slider.prototype.onKeyDown = function (event, index) {
            if (index === void 0) {
                index = 0;
            }
            if (this.disableArrowKeys) {
                return;
            }
            var multiplier = event.shiftKey ? this.shiftMultiplier : 1;
            if (event.key === "ArrowLeft" || event.key === "ArrowDown") {
                this.decrementValue(multiplier, index);
                this.thumbs.toArray()[index].nativeElement.focus();
                event.preventDefault();
            }
            else if (event.key === "ArrowRight" || event.key === "ArrowUp") {
                this.incrementValue(multiplier, index);
                this.thumbs.toArray()[index].nativeElement.focus();
                event.preventDefault();
            }
        };
        Slider.prototype.isTemplate = function (value) {
            return value instanceof core.TemplateRef;
        };
        /** Get optional input fields */
        Slider.prototype.getInputs = function () {
            return this.elementRef.nativeElement.querySelectorAll("input:not([type=range])");
        };
        /** Used to generate unique IDs */
        Slider.count = 0;
        Slider.decorators = [
            { type: core.Component, args: [{
                        selector: "ibm-slider",
                        template: "\n\t\t<ng-container *ngIf=\"!skeleton; else skeletonTemplate\">\n\t\t\t<label *ngIf=\"label\" [for]=\"id\" class=\"bx--label\">\n\t\t\t\t<ng-container *ngIf=\"!isTemplate(label)\">{{label}}</ng-container>\n\t\t\t\t<ng-template *ngIf=\"isTemplate(label)\" [ngTemplateOutlet]=\"label\"></ng-template>\n\t\t\t</label>\n\t\t\t<div class=\"bx--slider-container\">\n\t\t\t\t<label [id]=\"bottomRangeId\" class=\"bx--slider__range-label\">\n\t\t\t\t\t<ng-content select=\"[minLabel]\"></ng-content>\n\t\t\t\t</label>\n\t\t\t\t<div\n\t\t\t\t\tclass=\"bx--slider\"\n\t\t\t\t\t[ngClass]=\"{'bx--slider--disabled': disabled}\">\n\t\t\t\t\t<ng-container *ngIf=\"!isRange()\">\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t#thumbs\n\t\t\t\t\t\t\trole=\"slider\"\n\t\t\t\t\t\t\t[id]=\"id\"\n\t\t\t\t\t\t\tclass=\"bx--slider__thumb\"\n\t\t\t\t\t\t\t[ngStyle]=\"{left: getFractionComplete(value) * 100 + '%'}\"\n\t\t\t\t\t\t\ttabindex=\"0\"\n\t\t\t\t\t\t\t(mousedown)=\"onMouseDown($event)\"\n\t\t\t\t\t\t\t(keydown)=\"onKeyDown($event)\">\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</ng-container>\n\t\t\t\t\t<ng-container *ngIf=\"isRange()\">\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t#thumbs\n\t\t\t\t\t\t\t*ngFor=\"let thumb of value; let i = index; trackBy: trackThumbsBy\"\n\t\t\t\t\t\t\trole=\"slider\"\n\t\t\t\t\t\t\t[id]=\"id + (i > 0 ? '-' + i : '')\"\n\t\t\t\t\t\t\tclass=\"bx--slider__thumb\"\n\t\t\t\t\t\t\t[ngStyle]=\"{left: getFractionComplete(thumb) * 100 + '%'}\"\n\t\t\t\t\t\t\ttabindex=\"0\"\n\t\t\t\t\t\t\t(mousedown)=\"onMouseDown($event, i)\"\n\t\t\t\t\t\t\t(keydown)=\"onKeyDown($event, i)\">\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</ng-container>\n\t\t\t\t\t<div\n\t\t\t\t\t\t#track\n\t\t\t\t\t\tclass=\"bx--slider__track\"\n\t\t\t\t\t\t(click)=\"onClick($event)\">\n\t\t\t\t\t</div>\n\t\t\t\t\t<div\n\t\t\t\t\t\t#filledTrack\n\t\t\t\t\t\tclass=\"bx--slider__filled-track\">\n\t\t\t\t\t</div>\n\t\t\t\t\t<input\n\t\t\t\t\t\t#range\n\t\t\t\t\t\taria-label=\"slider\"\n\t\t\t\t\t\tclass=\"bx--slider__input\"\n\t\t\t\t\t\ttype=\"range\"\n\t\t\t\t\t\t[step]=\"step\"\n\t\t\t\t\t\t[min]=\"min\"\n\t\t\t\t\t\t[max]=\"max\"\n\t\t\t\t\t\t[value]=\"value.toString()\">\n\t\t\t\t</div>\n\t\t\t\t<label [id]=\"topRangeId\" class=\"bx--slider__range-label\">\n\t\t\t\t\t<ng-content select=\"[maxLabel]\"></ng-content>\n\t\t\t\t</label>\n\t\t\t\t<ng-content select=\"input\"></ng-content>\n\t\t\t</div>\n\t\t</ng-container>\n\n\t\t<ng-template #skeletonTemplate>\n\t\t\t<label *ngIf=\"label\" class=\"bx--label bx--skeleton\"></label>\n\t\t\t<div class=\"bx--slider-container bx--skeleton\">\n\t\t\t\t<span class=\"bx--slider__range-label\"></span>\n\t\t\t\t<div class=\"bx--slider\">\n\t\t\t\t\t<div class=\"bx--slider__thumb\"></div>\n\t\t\t\t\t<div class=\"bx--slider__track\"></div>\n\t\t\t\t\t<div class=\"bx--slider__filled-track\"></div>\n\t\t\t\t</div>\n\t\t\t\t<span class=\"bx--slider__range-label\"></span>\n\t\t\t</div>\n\t\t</ng-template>\n\t",
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: Slider,
                                multi: true
                            }
                        ]
                    }] }
        ];
        /** @nocollapse */
        Slider.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: utils.EventService }
            ];
        };
        Slider.propDecorators = {
            min: [{ type: core.Input }],
            max: [{ type: core.Input }],
            step: [{ type: core.Input }],
            value: [{ type: core.Input }],
            id: [{ type: core.Input }],
            shiftMultiplier: [{ type: core.Input }],
            skeleton: [{ type: core.Input }],
            label: [{ type: core.Input }],
            disableArrowKeys: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            valueChange: [{ type: core.Output }],
            hostClass: [{ type: core.HostBinding, args: ["class.bx--form-item",] }],
            thumbs: [{ type: core.ViewChildren, args: ["thumbs",] }],
            track: [{ type: core.ViewChild, args: ["track", { static: false },] }],
            filledTrack: [{ type: core.ViewChild, args: ["filledTrack", { static: false },] }],
            range: [{ type: core.ViewChild, args: ["range", { static: false },] }]
        };
        return Slider;
    }());

    var SliderModule = /** @class */ (function () {
        function SliderModule() {
        }
        SliderModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [Slider],
                        exports: [Slider],
                        imports: [
                            common.CommonModule,
                            utils.UtilsModule
                        ]
                    },] }
        ];
        return SliderModule;
    }());

    /**
     * Generated bundle index. Do not edit.
     */

    exports.Slider = Slider;
    exports.SliderModule = SliderModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=carbon-components-angular-slider.umd.js.map