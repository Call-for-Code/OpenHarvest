/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-modal.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { tap, delay } from 'rxjs/operators';
import { cycleTabs, getFocusElementList } from 'carbon-components-angular/common';
import { CommonModule } from '@angular/common';
import { ButtonModule } from 'carbon-components-angular/forms';
import { I18n, I18nModule } from 'carbon-components-angular/i18n';
import { PlaceholderService, PlaceholderModule } from 'carbon-components-angular/placeholder';
import { ExperimentalService, ExperimentalModule } from 'carbon-components-angular/experimental';
import { Output, EventEmitter, Input, Directive, Component, Inject, ViewChild, Optional, ComponentFactoryResolver, Injector, Injectable, HostListener, HostBinding, NgModule } from '@angular/core';
import { IconModule } from 'carbon-components-angular/icon';

/**
 * Extend `BaseModal` in your custom modal implementations to ensure consistent close behavior.
 *
 * `ModalService` depends on the `close` event to correctly clean up the component.
 */
class BaseModal {
    constructor() {
        /**
         * Base event emitter to propagate close events
         */
        this.close = new EventEmitter();
        /**
         * Controls the open state of the modal
         */
        this.open = false;
    }
    /**
     * Default method to handle closing the modal
     */
    closeModal() {
        this.close.emit();
    }
}
BaseModal.decorators = [
    { type: Directive, args: [{ selector: "[ibmBaseModal]" },] }
];
BaseModal.propDecorators = {
    close: [{ type: Output }],
    open: [{ type: Input }]
};

/**
 * Component to create standard modals for presenting content or asking for user's input.
 * It can show as a passive modal showing only text or show as a transactional modal with
 * multiple buttons for different actions for the user to choose from.
 *
 * Using a modal in your application requires `ibm-placeholder` which would generally be
 * placed near the end of your app component template (app.component.ts or app.component.html) as:
 *
 * ```html
 * <ibm-placeholder></ibm-placeholder>
 * ```
 *
 * Example of opening the modal:
 *
 * ```typescript
 * \@Component({
 *  selector: "app-modal-demo",
 *  template: `
 *   <button class="btn--primary" (click)="openModal()">Open modal</button>
 *   <ibm-placeholder></ibm-placeholder>`
 * })
 * export class ModalDemo {
 * 	openModal() {
 * 		this.modalService.show({
 *			modalType: "default",
 *			label: "optional header text",
 *			title: "Modal title",
 *			text: "Modal text",
 *			buttons: [{
 *				text: "Button text",
 *				type: "primary",
 *				click: clickFunction
 *			}]
 *		});
 * 	}
 * }
 * ```
 */
class AlertModal extends BaseModal {
    /**
     * Creates an instance of `AlertModal`.
     */
    constructor(type = "default", label, title, content, size, hasScrollingContent = null, buttons = [], onClose) {
        super();
        this.type = type;
        this.label = label;
        this.title = title;
        this.content = content;
        this.size = size;
        this.hasScrollingContent = hasScrollingContent;
        this.buttons = buttons;
        this.onClose = onClose;
        for (let i = 0; i < this.buttons.length; i++) {
            const button = this.buttons[i];
            if (!button.id) {
                button.id = `alert-modal-button-${i}`;
            }
            if (!button.type) {
                button.type = "secondary";
            }
        }
    }
    ngAfterViewInit() {
        if (!this.modalContent) {
            return false;
        }
        const element = this.modalContent.nativeElement;
        if (element.scrollHeight > element.clientHeight) {
            element.tabIndex = 0;
        }
        else {
            element.tabIndex = -1;
        }
    }
    buttonClicked(buttonIndex) {
        const button = this.buttons[buttonIndex];
        if (button.click) {
            button.click();
        }
        this.closeModal();
    }
    dismissModal(trigger) {
        if (this.onClose && this.onClose(trigger) === false) {
            return;
        }
        this.closeModal();
    }
}
AlertModal.decorators = [
    { type: Component, args: [{
                selector: "ibm-alert-modal",
                template: `
		<ibm-modal
			[size]="size"
			[theme]="type"
			[ariaLabel]="title"
			[hasScrollingContent]="hasScrollingContent"
			[open]="open"
			(overlaySelected)="dismissModal('overlay')">
			<ibm-modal-header (closeSelect)="dismissModal('close')">
				<p ibmModalHeaderLabel class="bx--type-delta">{{label}}</p>
				<p ibmModalHeaderHeading class="bx--type-beta">{{title}}</p>
			</ibm-modal-header>
			<div ibmModalContent #modalContent>
				<p [innerHTML]="content"></p>
			</div>
			<ibm-modal-footer *ngIf="buttons.length > 0">
				<ng-container *ngFor="let button of buttons; let i = index">
					<button
						[ibmButton]="button.type"
						(click)="buttonClicked(i)"
						[id]="button.id"
						[attr.modal-primary-focus]="(button.type.indexOf('primary') !== -1 ? '' : null)">
						{{button.text}}
					</button>
				</ng-container>
			</ibm-modal-footer>
		</ibm-modal>
	`
            }] }
];
/** @nocollapse */
AlertModal.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: ["type",] }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: ["label",] }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: ["title",] }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: ["content",] }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: ["size",] }] },
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: ["hasScrollingContent",] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: ["buttons",] }] },
    { type: Function, decorators: [{ type: Optional }, { type: Inject, args: ["close",] }] }
];
AlertModal.propDecorators = {
    modalContent: [{ type: ViewChild, args: ["modalContent", { static: true },] }]
};

var AlertModalType;
(function (AlertModalType) {
    AlertModalType["default"] = "default";
    AlertModalType["danger"] = "danger";
})(AlertModalType || (AlertModalType = {}));
var ModalButtonType;
(function (ModalButtonType) {
    ModalButtonType["primary"] = "primary";
    ModalButtonType["secondary"] = "secondary";
    ModalButtonType["tertiary"] = "tertiary";
    ModalButtonType["ghost"] = "ghost";
    ModalButtonType["danger"] = "danger";
    ModalButtonType["danger_primary"] = "danger--primary";
})(ModalButtonType || (ModalButtonType = {}));

class ModalFooter {
}
ModalFooter.decorators = [
    { type: Component, args: [{
                selector: "ibm-modal-footer",
                template: `
		<footer class="bx--modal-footer">
			<ng-content></ng-content>
		</footer>
	`
            }] }
];

/**
 * ***Inputs***
 * ```html
 * <ibm-modal-header>Header text</ibm-modal-header>
 * ```
 *
 * ***Outputs***
 * ```html
 * <ibm-modal-header (closeSelect)="closeModal()">Header text</ibm-modal-header>
 * ```
 */
class ModalHeader {
    constructor(i18n, experimental) {
        this.i18n = i18n;
        this.experimental = experimental;
        /**
         * Sets the style on the modal heading based on its category.
         */
        this.theme = "default";
        /**
         * Accessible label for the header close button.
         * Defaults to the `MODAL.CLOSE` value from the i18n service.
         */
        this.closeLabel = this.i18n.get().MODAL.CLOSE;
        /**
         * To emit the event of clicking on the close icon within the modal.
         */
        this.closeSelect = new EventEmitter();
    }
    /**
     * Handles click for the close icon button within the `Modal`.
     */
    onClose() {
        this.closeSelect.emit();
    }
}
ModalHeader.decorators = [
    { type: Component, args: [{
                selector: "ibm-modal-header",
                template: `
		<header class="{{theme}} bx--modal-header">
			<ng-content></ng-content>
			<button
				type="button"
				class="bx--modal-close"
				(click)="onClose()">
				<span class="bx--assistive-text">{{ closeLabel }}</span>
				<svg ibmIcon="close" size="20" class="bx--modal-close__icon"></svg>
			</button>
		</header>

	`
            }] }
];
/** @nocollapse */
ModalHeader.ctorParameters = () => [
    { type: I18n },
    { type: ExperimentalService }
];
ModalHeader.propDecorators = {
    theme: [{ type: Input }],
    closeLabel: [{ type: Input }],
    closeSelect: [{ type: Output }]
};

/**
 * Modal service handles instantiating and destroying modal instances.
 * Uses PlaceholderService to track open instances, and for it's placeholder view reference.
 */
class ModalService {
    /**
     * Creates an instance of `ModalService`.
     */
    constructor(resolver, placeholderService) {
        this.resolver = resolver;
        this.placeholderService = placeholderService;
    }
    /**
     * Creates and renders the modal component that is passed in.
     * `inputs` is an optional parameter of `data` that can be passed to the `Modal` component.
     */
    create(data) {
        let defaults = { inputs: {} };
        data = Object.assign({}, defaults, data);
        const inputProviders = Object.keys(data.inputs).map(inputName => ({
            provide: inputName,
            useValue: data.inputs[inputName]
        }));
        const injector = Injector.create(inputProviders);
        const factory = this.resolver.resolveComponentFactory(data.component);
        let focusedElement = document.activeElement;
        let component = this.placeholderService.createComponent(factory, injector);
        setTimeout(() => {
            component.instance.open = true;
        });
        component["previouslyFocusedElement"] = focusedElement; // used to return focus to previously focused element
        component.instance.close.pipe(
        // trigger the close animation
        tap(() => {
            component.instance.open = false;
        }), 
        // delay closing by an arbitrary amount to allow the animation to finish
        delay(150)).subscribe(() => {
            this.placeholderService.destroyComponent(component);
            // filter out our component
            ModalService.modalList = ModalService.modalList.filter(c => c !== component);
        });
        component.onDestroy(() => {
            focusedElement.focus();
        });
        ModalService.modalList.push(component);
        return component;
    }
    /**
     * Creates and renders a new alert modal component.
     * @param data You can pass in:
     * `type` - "default" | "danger" = "default",
     * `label` - a label shown over the title,
     * `title` - modal's title,
     * `content` - modal's content, could include HTML tags.
     * `buttons` is an array of objects
     * `close` custom close function
     * ```
     * {
     * 		text: "Button text",
     * 		type: "primary" | "secondary" | "tertiary" | "ghost" | "danger" | "danger--primary" = "primary",
     * 		click: clickFunction,
     * }
     * ```
     */
    show(data) {
        return this.create({
            component: AlertModal,
            inputs: {
                type: data.type,
                label: data.label,
                title: data.title,
                content: data.content,
                hasScrollingContent: data.hasScrollingContent || null,
                size: data.size,
                buttons: data.buttons || [],
                close: data.close || (() => { })
            }
        });
    }
    /**
     * Destroys the modal on the supplied index.
     * When called without parameters it destroys the most recently created/top most modal.
     */
    destroy(index = -1) {
        // return if nothing to destroy because it's already destroyed
        if (index >= ModalService.modalList.length || ModalService.modalList.length === 0) {
            return;
        }
        // on negative index destroy the last on the list (top modal)
        if (index < 0) {
            index = ModalService.modalList.length - 1;
        }
        this.placeholderService.destroyComponent(ModalService.modalList[index]);
        ModalService.modalList.splice(index, 1);
    }
}
// track all our open modals
ModalService.modalList = [];
ModalService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ModalService.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: PlaceholderService }
];

/**
 * Component to create modals for presenting content.
 *
 * [See demo](../../?path=/story/modal--basic)
 *
 * Using a modal in your application requires `ibm-placeholder` which would generally be
 * placed near the end of your app component template (app.component.ts or app.component.html) as:
 *
```html
<ibm-placeholder></ibm-placeholder>
```
 *
 * A more complete example for `Modal` is given as follows:
 *
 * Example modal definition:
 *
```typescript
@Component({
    selector: "app-sample-modal",
    template: `
                <ibm-modal size="xl" (overlaySelected)="closeModal()">
                    <ibm-modal-header (closeSelect)="closeModal()">Header text</ibm-modal-header>
                        <section class="modal-body">
                            <h1>Sample modal works.</h1>
                            <button class="btn--icon-link" nPopover="Hello there" title="Popover title" placement="right" appendInline="true">
                                <svg ibmIcon="info" size="sm"></ibm-icon>
                            </button>
                            {{modalText}}
                        </section>
                    <ibm-modal-footer><button ibmButton="primary" (click)="closeModal()">Close</button></ibm-modal-footer>
                </ibm-modal>`,
    styleUrls: ["./sample-modal.component.scss"]
})
export class SampleModal extends BaseModal {
    modalText: string;
    constructor(protected injector: Injector) {
        super();
        this.modalText = this.injector.get("modalText");
    }
}
```
 *
 * Example of opening the modal:
 *
```typescript
@Component({
    selector: "app-modal-demo",
    template: `
                <button ibmButton="primary" (click)="openModal('drill')">Drill-down modal</button>
                <ibm-placeholder></ibm-placeholder>`
})
export class ModalDemo {
    openModal() {
        this.modalService.create({component: SampleModal, inputs: {modalText: "Hello universe."}});
    }
}
```
 *
 * <example-url>../../iframe.html?id=modal--basic</example-url>
 */
class Modal {
    /**
     * Creates an instance of `Modal`.
     */
    constructor(modalService) {
        this.modalService = modalService;
        /**
         * Classification of the modal.
         */
        this.theme = "default";
        this.ariaLabel = "default";
        /**
         * Controls the visibility of the modal when used directly in a template
         */
        this.open = false;
        /**
         * Specify whether the modal contains scrolling content. This property overrides the automatic
         * detection of the existence of scrolling content. Set this property to `true` to force
         * overflow indicator to show up or to `false` to force overflow indicator to disappear.
         * It is set to `null` by default which indicates not to override automatic detection.
         */
        this.hasScrollingContent = null;
        /**
         * Emits event when click occurs within `n-overlay` element. This is to track click events occurring outside bounds of the `Modal` object.
         */
        this.overlaySelected = new EventEmitter();
        /**
         * To emit the closing event of the modal window.
         */
        this.close = new EventEmitter();
        /**
         * An element should have 'modal-primary-focus' as an attribute to receive initial focus within the `Modal` component.
         */
        this.selectorPrimaryFocus = "[modal-primary-focus]";
    }
    /**
     * Label for the modal.
     *
     * @deprecated since v4
     */
    set modalLabel(value) {
        this.ariaLabel = value;
    }
    get modalLabel() {
        return this.ariaLabel;
    }
    ngOnChanges({ open }) {
        if (open) {
            if (open.currentValue) {
                // `100` is just enough time to allow the modal
                // to become visible, so that we can set focus
                setTimeout(() => this.focusInitialElement(), 100);
            }
            else if (this.trigger) {
                this.trigger.focus();
            }
        }
    }
    /**
     * Set document focus to be on the modal component after it is initialized.
     */
    ngAfterViewInit() {
        this.focusInitialElement();
    }
    /**
     * Handle keyboard events to close modal and tab through the content within the modal.
     */
    handleKeyboardEvent(event) {
        switch (event.key) {
            case "Escape": {
                event.stopImmediatePropagation(); // prevents events being fired for multiple modals if more than 2 open
                this.modalService.destroy(); // destroy top (latest) modal
                this.close.emit();
                break;
            }
            case "Tab": {
                cycleTabs(event, this.modal.nativeElement);
                break;
            }
        }
    }
    /**
     * This detects whether or not the modal contains scrolling content.
     *
     * To force trigger a detection (ie. on window resize), change or reset the value of the modal content.
     *
     * Use the `hasScrollingContent` input to manually override the overflow indicator.
     */
    get shouldShowScrollbar() {
        const modalContent = this.modal ? this.modal.nativeElement.querySelector(".bx--modal-content") : null;
        if (modalContent) {
            const modalContentHeight = modalContent.getBoundingClientRect().height;
            const modalContentScrollHeight = modalContent.scrollHeight;
            return modalContentScrollHeight > modalContentHeight;
        }
        else {
            return false;
        }
    }
    focusInitialElement() {
        const primaryFocusElement = this.modal.nativeElement.querySelector(this.selectorPrimaryFocus);
        if (primaryFocusElement && primaryFocusElement.focus) {
            setTimeout(() => primaryFocusElement.focus());
        }
        else if (getFocusElementList(this.modal.nativeElement).length > 0) {
            setTimeout(() => getFocusElementList(this.modal.nativeElement)[0].focus());
        }
        else {
            setTimeout(() => this.modal.nativeElement.focus());
        }
    }
}
Modal.decorators = [
    { type: Component, args: [{
                selector: "ibm-modal",
                template: `
		<ibm-overlay
			[theme]="theme"
			[open]="open"
			(overlaySelect)="overlaySelected.emit()">
			<div
				class="bx--modal-container"
				[ngClass]="{
					'bx--modal-container--xs': size === 'xs',
					'bx--modal-container--sm': size === 'sm',
					'bx--modal-container--lg': size === 'lg'
				}"
				role="dialog"
				aria-modal="true"
				style="z-index:1;"
				[attr.aria-label]="ariaLabel"
				#modal>
				<ng-content></ng-content>
				<div
					*ngIf="hasScrollingContent !== null ? hasScrollingContent : shouldShowScrollbar"
					class="bx--modal-content--overflow-indicator">
				</div>
			</div>
		</ibm-overlay>
	`
            }] }
];
/** @nocollapse */
Modal.ctorParameters = () => [
    { type: ModalService }
];
Modal.propDecorators = {
    size: [{ type: Input }],
    theme: [{ type: Input }],
    modalLabel: [{ type: Input }],
    ariaLabel: [{ type: Input }],
    open: [{ type: Input }],
    trigger: [{ type: Input }],
    hasScrollingContent: [{ type: Input }],
    overlaySelected: [{ type: Output }],
    close: [{ type: Output }],
    modal: [{ type: ViewChild, args: ["modal", { static: true },] }],
    handleKeyboardEvent: [{ type: HostListener, args: ["keydown", ["$event"],] }]
};

/**
 * Component for the overlay object that acts as a backdrop to the `Modal` component.
 *
 * The main purpose for this component is to be able to handle click events that fall outside
 * the bounds of the `Modal` component.
 */
class Overlay {
    constructor() {
        /**
         * Classification of the modal.
         */
        this.theme = "default";
        this.open = false;
        /**
         * To emit the event where the user selects the overlay behind the `Modal`.
         */
        this.overlaySelect = new EventEmitter();
    }
    /**
     * Handles the user clicking on the `Overlay` which resides outside the `Modal` object.
     */
    overlayClick(event) {
        if (event.target !== this.overlay.nativeElement) {
            return;
        }
        event.stopPropagation();
        this.overlaySelect.emit(event);
    }
}
Overlay.decorators = [
    { type: Component, args: [{
                selector: "ibm-overlay",
                template: `
		<section
			class="bx--modal bx--modal-tall"
			[ngClass]="{
				'bx--modal--danger': theme === 'danger',
				'is-visible': open
			}"
			(click)="overlayClick($event)"
			#overlay>
			<ng-content></ng-content>
		</section>
	`
            }] }
];
Overlay.propDecorators = {
    theme: [{ type: Input }],
    open: [{ type: Input }],
    overlaySelect: [{ type: Output }],
    overlay: [{ type: ViewChild, args: ["overlay", { static: true },] }]
};

class ModalContent {
    constructor() {
        this.modalContentClass = true;
        /**
         * Provide whether the modal content has a form element.
         * If `true` is used here, non-form child content should have `bx--modal-content__regular-content` class.
         */
        this.hasForm = false;
    }
}
ModalContent.decorators = [
    { type: Directive, args: [{
                selector: "[ibmModalContent]"
            },] }
];
ModalContent.propDecorators = {
    modalContentClass: [{ type: HostBinding, args: ["class.bx--modal-content",] }],
    hasForm: [{ type: HostBinding, args: ["class.bx--modal-content--with-form",] }, { type: Input }]
};

class ModalContentText {
    constructor() {
        this.modalContentTextClass = true;
    }
}
ModalContentText.decorators = [
    { type: Directive, args: [{
                selector: "[ibmModalContentText]"
            },] }
];
ModalContentText.propDecorators = {
    modalContentTextClass: [{ type: HostBinding, args: ["class.bx--modal-content__text",] }]
};

class ModalHeaderHeading {
    constructor() {
        this.modalHeaderHeadingClass = true;
    }
}
ModalHeaderHeading.decorators = [
    { type: Directive, args: [{
                selector: "[ibmModalHeaderHeading]"
            },] }
];
ModalHeaderHeading.propDecorators = {
    modalHeaderHeadingClass: [{ type: HostBinding, args: ["class.bx--modal-header__heading",] }]
};

class ModalHeaderLabel {
    constructor() {
        this.modalHeaderLabelClass = true;
    }
}
ModalHeaderLabel.decorators = [
    { type: Directive, args: [{
                selector: "[ibmModalHeaderLabel]"
            },] }
];
ModalHeaderLabel.propDecorators = {
    modalHeaderLabelClass: [{ type: HostBinding, args: ["class.bx--modal-header__label",] }]
};

// modules
class ModalModule {
}
ModalModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    AlertModal,
                    Modal,
                    ModalHeader,
                    ModalFooter,
                    Overlay,
                    ModalContent,
                    ModalContentText,
                    ModalHeaderHeading,
                    ModalHeaderLabel,
                    BaseModal
                ],
                exports: [
                    AlertModal,
                    Modal,
                    ModalHeader,
                    ModalFooter,
                    ModalContent,
                    ModalContentText,
                    ModalHeaderHeading,
                    ModalHeaderLabel,
                    BaseModal
                ],
                entryComponents: [
                    AlertModal,
                    Modal,
                    ModalFooter,
                    ModalHeader
                ],
                providers: [ModalService],
                imports: [
                    CommonModule,
                    ButtonModule,
                    I18nModule,
                    PlaceholderModule,
                    ExperimentalModule,
                    IconModule
                ]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { AlertModal, AlertModalType, ModalButtonType, BaseModal, ModalFooter, ModalHeader, Modal, ModalModule, ModalService, Overlay, ModalContent, ModalContentText, ModalHeaderHeading, ModalHeaderLabel };

//# sourceMappingURL=carbon-components-angular-modal.js.map