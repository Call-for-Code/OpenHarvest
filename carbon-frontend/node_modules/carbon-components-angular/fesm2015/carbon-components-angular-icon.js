/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-icon.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { toString, getAttributes } from '@carbon/icon-helpers';
import { Injectable, Directive, ElementRef, Input, NgModule, Optional, SkipSelf } from '@angular/core';
import { CommonModule } from '@angular/common';
import Add16 from '@carbon/icons/es/add/16';
import Calendar16 from '@carbon/icons/es/calendar/16';
import CaretDown16 from '@carbon/icons/es/caret--down/16';
import CaretLeft16 from '@carbon/icons/es/caret--left/16';
import CaretRight16 from '@carbon/icons/es/caret--right/16';
import CaretUp16 from '@carbon/icons/es/caret--up/16';
import Checkmark16 from '@carbon/icons/es/checkmark/16';
import CheckmarkFilled16 from '@carbon/icons/es/checkmark--filled/16';
import CheckmarkOutline16 from '@carbon/icons/es/checkmark--outline/16';
import ChevronDown16 from '@carbon/icons/es/chevron--down/16';
import ChevronRight16 from '@carbon/icons/es/chevron--right/16';
import Close16 from '@carbon/icons/es/close/16';
import Close20 from '@carbon/icons/es/close/20';
import Copy16 from '@carbon/icons/es/copy/16';
import Delete16 from '@carbon/icons/es/delete/16';
import Download16 from '@carbon/icons/es/download/16';
import ErrorFilled16 from '@carbon/icons/es/error--filled/16';
import InformationFilled16 from '@carbon/icons/es/information--filled/16';
import Menu16 from '@carbon/icons/es/menu/16';
import Menu20 from '@carbon/icons/es/menu/20';
import OverflowMenuVertical16 from '@carbon/icons/es/overflow-menu--vertical/16';
import OverflowMenuHorizontal16 from '@carbon/icons/es/overflow-menu--horizontal/16';
import Save16 from '@carbon/icons/es/save/16';
import Search16 from '@carbon/icons/es/search/16';
import Settings16 from '@carbon/icons/es/settings/16';
import Warning16 from '@carbon/icons/es/warning/16';
import WarningFilled16 from '@carbon/icons/es/warning--filled/16';

/**
 * Abstract class that represent a cache of icons.
 *
 * The actual caching mechanism will be implementation specific,
 * but it's likely a good idea to key by the icons name and/or size.
 * Icon name and size will always be strings, and they will be the two consistent
 * identifiers of an icon. For the purposes of storage additonal descriptor properties may
 * be used, but the name and size are the only ones guarenteed to be passed for lookup purposes.
 */
class IconCache {
}
/**
 * Custom error for when a name can't be found
 */
class IconNameNotFoundError extends Error {
    constructor(name) {
        super(`Icon ${name} not found`);
    }
}
/**
 * Custom error for when a specific size can't be found
 */
class IconSizeNotFoundError extends Error {
    constructor(size, name) {
        super("Size ${size} for ${name} not found");
    }
}
/**
 * Concrete implementation of `IconCache` as a simple in memory cache
 */
class IconMemoryCache extends IconCache {
    constructor() {
        super(...arguments);
        this.iconMap = new Map();
    }
    get(name, size) {
        if (!this.iconMap.has(name)) {
            throw new IconNameNotFoundError(name);
        }
        const sizeMap = this.iconMap.get(name);
        if (!sizeMap.has(size)) {
            throw new IconSizeNotFoundError(size, name);
        }
        return sizeMap.get(size);
    }
    set(name, size, descriptor) {
        if (!this.iconMap.has(name)) {
            this.iconMap.set(name, new Map());
        }
        const sizeMap = this.iconMap.get(name);
        sizeMap.set(size, descriptor);
    }
}
/**
 * The icon service is a singleton service responsible for registering and retriving icons from `@carbon/icons`.
 *
 * It's important to register icons before use. It's reccommended to register your icons early, likely in your app.component.
 *
 * To allow for improved tree shaking _do not_ import all the icons from `@carbon/icons` and register them.
 * Instead register only the icons in use by your application. If your application makes use of lazy loaded
 * modules you may also lazy load the icons used in that module by registering them early on in that module.
 *
 * `ngOnInit` should be sufficiantly early to register icons.
 *
 * Example:
 * ```
 * import { Accessibility16 } from "@carbon/icons";
 *
 * // ...
 *
 * class MyComponent implements OnInit {
 * 	constructor(protected iconService: IconService) {}
 *
 * 	// ...
 *
 * 	ngOnInit() {
 * 		this.iconService.register(Accessibility16);
 * 	}
 *
 * 	// ...
 * }
 * ```
 *
 * If needed it is possible to register an icon under a different name, via `registerAs`.
 */
class IconService {
    constructor() {
        this.iconCache = new IconMemoryCache();
    }
    /**
     * Registers an array of icons based on the metadata provided by `@carbon/cions`
     */
    registerAll(descriptors) {
        descriptors.forEach(icon => this.register(icon));
    }
    /**
     * Registers an icon based on the metadata provided by `@carbon/icons`
     */
    register(descriptor) {
        const { name } = descriptor;
        this.registerAs(name, descriptor);
    }
    /**
     * Registers an icon based on a uniqe name and metadata provided by `@carbon/icons`
     */
    registerAs(name, descriptor) {
        const { size } = descriptor;
        this.iconCache.set(name, size.toString(), descriptor);
    }
    /**
     * Gets an icon, converts it to a string, and caches the result
     */
    get(name, size) {
        try {
            const icon = this.iconCache.get(name, size.toString());
            if (!icon.svg) {
                icon.svg = toString(icon);
            }
            return icon;
        }
        catch (e) {
            throw e;
        }
    }
    /**
     * Configure various service settings (caching strategy ...)
     */
    configure(options) {
        this.iconCache = options.cache;
    }
}
IconService.decorators = [
    { type: Injectable }
];

/**
 * A directive for applying styling to an input element.
 *
 * Example:
 *
 * ```html
 * <input ibmText/>
 * ```
 *
 * See the [vanilla carbon docs](http://www.carbondesignsystem.com/components/text-input/code) for more detail.
 */
class IconDirective {
    constructor(elementRef, iconService) {
        this.elementRef = elementRef;
        this.iconService = iconService;
        this.ibmIcon = "";
        this.size = "16";
        this.title = "";
        this.ariaLabel = "";
        this.ariaLabelledBy = "";
        this.ariaHidden = "";
        this.isFocusable = false;
    }
    ngAfterViewInit() {
        const root = this.elementRef.nativeElement;
        let icon;
        try {
            icon = this.iconService.get(this.ibmIcon, this.size.toString());
        }
        catch (error) {
            console.warn(error);
            // bail out
            return;
        }
        const domParser = new DOMParser();
        const rawSVG = icon.svg;
        const svgElement = domParser.parseFromString(rawSVG, "image/svg+xml").documentElement;
        let node = root.tagName.toUpperCase() !== "SVG" ? svgElement : svgElement.firstChild;
        while (node) {
            // importNode makes a clone of the node
            // this ensures we keep looping over the nodes in the parsed document
            root.appendChild(root.ownerDocument.importNode(node, true));
            // type the node because the angular compiler freaks out if it
            // ends up thinking it's a `Node` instead of a `ChildNode`
            node = node.nextSibling;
        }
        const svg = root.tagName.toUpperCase() !== "SVG" ? svgElement : root;
        svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        const attributes = getAttributes({
            width: icon.attrs.height,
            height: icon.attrs.height,
            viewBox: icon.attrs.viewBox,
            title: this.title,
            "aria-label": this.ariaLabel,
            "aria-labelledby": this.ariaLabelledBy,
            "aria-hidden": this.ariaHidden,
            focusable: this.isFocusable.toString()
        });
        const attrKeys = Object.keys(attributes);
        for (let i = 0; i < attrKeys.length; i++) {
            const key = attrKeys[i];
            const value = attributes[key];
            if (key === "title") {
                continue;
            }
            if (value) {
                svg.setAttribute(key, value);
            }
        }
        if (attributes["title"]) {
            const title = document.createElement("title");
            title.textContent = attributes.title;
            IconDirective.titleIdCounter++;
            title.setAttribute("id", `${icon.name}-title-${IconDirective.titleIdCounter}`);
            // title must be first for screen readers
            svg.insertBefore(title, svg.firstElementChild);
            svg.setAttribute("aria-labelledby", `${icon.name}-title-${IconDirective.titleIdCounter}`);
        }
    }
}
IconDirective.titleIdCounter = 0;
IconDirective.decorators = [
    { type: Directive, args: [{
                selector: "[ibmIcon]"
            },] }
];
/** @nocollapse */
IconDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: IconService }
];
IconDirective.propDecorators = {
    ibmIcon: [{ type: Input }],
    size: [{ type: Input }],
    title: [{ type: Input }],
    ariaLabel: [{ type: Input }],
    ariaLabelledBy: [{ type: Input }],
    ariaHidden: [{ type: Input }],
    isFocusable: [{ type: Input }]
};

// modules
// either provides a new instance of IconService, or returns the parent
function ICON_SERVICE_PROVIDER_FACTORY(parentService) {
    return parentService || new IconService();
}
// icon service *must* be a singleton to ensure that icons are accessible globally and not duplicated
const ICON_SERVICE_PROVIDER = {
    provide: IconService,
    deps: [[new Optional(), new SkipSelf(), IconService]],
    useFactory: ICON_SERVICE_PROVIDER_FACTORY
};
class IconModule {
    constructor(iconService) {
        this.iconService = iconService;
        iconService.registerAll([
            Add16,
            Calendar16,
            CaretDown16,
            CaretLeft16,
            CaretRight16,
            CaretUp16,
            Checkmark16,
            CheckmarkFilled16,
            CheckmarkOutline16,
            ChevronDown16,
            ChevronRight16,
            Close16,
            Close20,
            Copy16,
            Delete16,
            Download16,
            ErrorFilled16,
            InformationFilled16,
            Menu16,
            Menu20,
            OverflowMenuVertical16,
            OverflowMenuHorizontal16,
            Save16,
            Search16,
            Settings16,
            Warning16,
            WarningFilled16
        ]);
    }
}
IconModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IconDirective
                ],
                exports: [
                    IconDirective
                ],
                imports: [
                    CommonModule
                ],
                providers: [
                    ICON_SERVICE_PROVIDER
                ]
            },] }
];
/** @nocollapse */
IconModule.ctorParameters = () => [
    { type: IconService }
];

/**
 * Generated bundle index. Do not edit.
 */

export { IconDirective, ICON_SERVICE_PROVIDER, ICON_SERVICE_PROVIDER_FACTORY, IconModule, IconCache, IconMemoryCache, IconNameNotFoundError, IconService, IconSizeNotFoundError };

//# sourceMappingURL=carbon-components-angular-icon.js.map