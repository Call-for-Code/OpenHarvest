/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-dropdown.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { position } from '@carbon/utils-position';
import { Subscription, of, fromEvent, Observable, isObservable } from 'rxjs';
import { debounceTime, map, filter, first } from 'rxjs/operators';
import { Input, Output, EventEmitter, Directive, Injectable, Component, ElementRef, ContentChild, ViewChild, HostListener, HostBinding, TemplateRef, ApplicationRef, ViewChildren, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { I18n, I18nModule } from 'carbon-components-angular/i18n';
import { PlaceholderService, PlaceholderModule } from 'carbon-components-angular/placeholder';
import { AnimationFrameService, closestAttr, ElementService, getScrollableParents, hasScrollableParents, UtilsModule } from 'carbon-components-angular/utils';
import { IconModule } from 'carbon-components-angular/icon';

/**
 * A component that intends to be used within `Dropdown` must provide an implementation that extends this base class.
 * It also must provide the base class in the `@Component` meta-data.
 * ex: `providers: [{provide: AbstractDropdownView, useExisting: forwardRef(() => MyDropdownView)}]`
 */
class AbstractDropdownView {
    constructor() {
        /**
         * Specifies whether or not the `DropdownList` supports selecting multiple items as opposed to single
         * item selection.
         */
        this.type = "single";
        /**
         * Specifies the render size of the items within the `AbstractDropdownView`.
         *
         * @deprecated since v4
         */
        this.size = "md";
    }
    /**
     * The items to be displayed in the list within the `AbstractDropDownView`.
     */
    set items(value) { }
    get items() { return; }
    /**
     * Returns the `ListItem` that is subsequent to the selected item in the `DropdownList`.
     */
    getNextItem() { return; }
    /**
     * Returns a boolean if the currently selected item is preceded by another
     */
    hasNextElement() { return; }
    /**
     * Returns the `HTMLElement` for the item that is subsequent to the selected item.
     */
    getNextElement() { return; }
    /**
     * Returns the `ListItem` that precedes the selected item within `DropdownList`.
     */
    getPrevItem() { return; }
    /**
     * Returns a boolean if the currently selected item is followed by another
     */
    hasPrevElement() { return; }
    /**
     * Returns the `HTMLElement` for the item that precedes the selected item.
     */
    getPrevElement() { return; }
    /**
     * Returns the selected leaf level item(s) within the `DropdownList`.
     */
    getSelected() { return; }
    /**
     * Returns the `ListItem` that is selected within `DropdownList`.
     */
    getCurrentItem() { return; }
    /**
     * Returns the `HTMLElement` for the item that is selected within the `DropdownList`.
     */
    getCurrentElement() { return; }
    /**
     * Guaranteed to return the current items as an Array.
     */
    getListItems() { return; }
    /**
     * Transforms array input list of items to the correct state by updating the selected item(s).
     */
    propagateSelected(value) { }
    /**
     *
     * @param value value to filter the list by
     */
    filterBy(value) { }
    /**
     * Initializes focus in the list
     * In most cases this just calls `getCurrentElement().focus()`
     */
    initFocus() { }
    /**
     * Subscribe the function passed to an internal observable that will resolve once the items are ready
     */
    onItemsReady(subcription) { }
    /**
     * Reorder selected items bringing them to the top of the list
     */
    reorderSelected(moveFocus) { }
}
AbstractDropdownView.decorators = [
    { type: Directive, args: [{ selector: "[ibmAbstractDropdownView]" },] }
];
AbstractDropdownView.propDecorators = {
    items: [{ type: Input }],
    select: [{ type: Output }],
    blurIntent: [{ type: Output }]
};

const defaultOffset = { top: 0, left: 0 };
class DropdownService {
    constructor(placeholderService, animationFrameService) {
        this.placeholderService = placeholderService;
        this.animationFrameService = animationFrameService;
        /**
         * Maintains an Event Observable Subscription for the global requestAnimationFrame.
         * requestAnimationFrame is tracked only if the `Dropdown` is appended to the body otherwise we don't need it
         */
        this.animationFrameSubscription = new Subscription();
        this._offset = defaultOffset;
    }
    set offset(value) {
        this._offset = Object.assign({}, defaultOffset, value);
    }
    get offset() {
        return this._offset;
    }
    /**
     * Appends the menu to the body, or a `ibm-placeholder` (if defined)
     *
     * @param parentRef container to position relative to
     * @param menuRef menu to be appended to body
     * @param classList any extra classes we should wrap the container with
     */
    appendToBody(parentRef, menuRef, classList) {
        // build the dropdown list container
        menuRef.style.display = "block";
        const dropdownWrapper = document.createElement("div");
        dropdownWrapper.className = `dropdown ${classList}`;
        dropdownWrapper.style.width = parentRef.offsetWidth + "px";
        dropdownWrapper.style.position = "absolute";
        dropdownWrapper.appendChild(menuRef);
        // append it to the placeholder
        if (this.placeholderService.hasPlaceholderRef()) {
            this.placeholderService.appendElement(dropdownWrapper);
            // or append it directly to the body
        }
        else {
            document.body.appendChild(dropdownWrapper);
        }
        this.menuInstance = dropdownWrapper;
        this.animationFrameSubscription = this.animationFrameService.tick.subscribe(() => {
            this.positionDropdown(parentRef, dropdownWrapper);
        });
        // run one position in sync, so we're less likely to have the view "jump" as we focus
        this.positionDropdown(parentRef, dropdownWrapper);
        return dropdownWrapper;
    }
    /**
     * Reattach the dropdown menu to the parent container
     * @param hostRef container to append to
     */
    appendToDropdown(hostRef) {
        // if the instance is already removed don't try and remove it again
        if (!this.menuInstance) {
            return;
        }
        const instance = this.menuInstance;
        const menu = instance.firstElementChild;
        // clean up the instance
        this.menuInstance = null;
        menu.style.display = "none";
        hostRef.appendChild(menu);
        this.animationFrameSubscription.unsubscribe();
        if (this.placeholderService.hasPlaceholderRef() && this.placeholderService.hasElement(instance)) {
            this.placeholderService.removeElement(instance);
        }
        else if (document.body.contains(instance)) {
            document.body.removeChild(instance);
        }
        return instance;
    }
    /**
     * position an open dropdown relative to the given parentRef
     */
    updatePosition(parentRef) {
        this.positionDropdown(parentRef, this.menuInstance);
    }
    ngOnDestroy() {
        this.animationFrameSubscription.unsubscribe();
    }
    positionDropdown(parentRef, menuRef) {
        if (!menuRef) {
            return;
        }
        let leftOffset = 0;
        const boxMenu = menuRef.querySelector(".bx--list-box__menu");
        if (boxMenu) {
            // If the parentRef and boxMenu are in a different left position relative to the
            // window, the the boxMenu position has already been flipped and a check needs to be done
            // to see if it needs to stay flipped.
            if (parentRef.getBoundingClientRect().left !== boxMenu.getBoundingClientRect().left) {
                // The getBoundingClientRect().right of the boxMenu if it were hypothetically flipped
                // back into the original position before the flip.
                const testBoxMenuRightEdgePos = parentRef.getBoundingClientRect().left - boxMenu.getBoundingClientRect().left + boxMenu.getBoundingClientRect().right;
                if (testBoxMenuRightEdgePos > (window.innerWidth || document.documentElement.clientWidth)) {
                    leftOffset = parentRef.offsetWidth - boxMenu.offsetWidth;
                }
                // If it has not already been flipped, check if it is necessary to flip, ie. if the
                // boxMenu is outside of the right viewPort.
            }
            else if (boxMenu.getBoundingClientRect().right > (window.innerWidth || document.documentElement.clientWidth)) {
                leftOffset = parentRef.offsetWidth - boxMenu.offsetWidth;
            }
        }
        // If ibm-placeholder has a parent with a position(relative|fixed|absolute) account for the parent offset
        const closestMenuWithPos = closestAttr("position", ["relative", "fixed", "absolute"], menuRef.parentElement);
        const topPos = closestMenuWithPos ? closestMenuWithPos.getBoundingClientRect().top * -1 : this.offset.top;
        const leftPos = closestMenuWithPos ? closestMenuWithPos.getBoundingClientRect().left * -1 : this.offset.left + leftOffset;
        let pos = position.findAbsolute(parentRef, menuRef, "bottom");
        pos = position.addOffset(pos, topPos, leftPos);
        position.setElement(menuRef, pos);
    }
}
DropdownService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DropdownService.ctorParameters = () => [
    { type: PlaceholderService },
    { type: AnimationFrameService }
];

/**
 * Drop-down lists enable users to select one or more items from a list.
 *
 * #### Opening behavior/List DOM placement
 * By default the dropdown will try to figure out the best placement for the dropdown list.
 *
 * If it's not contained within any scrolling elements, it will open inline, if it _is_
 * contained within a scrolling container it will try to open in the body, or an `ibm-placeholder`.
 *
 * To control this behavior you can use the `appendInline` input:
 * - `[appendInline]="null"` is the default (auto detection)
 * - `[appendInline]="false"` will always append to the body/`ibm-placeholder`
 * - `[appendInline]="true"` will always append inline (next to the dropdown button)
 *
 * [See demo](../../?path=/story/dropdown--basic)
 *
 * <example-url>../../iframe.html?id=dropdown--basic</example-url>
 */
class Dropdown {
    /**
     * Creates an instance of Dropdown.
     */
    constructor(elementRef, i18n, dropdownService, appRef, elementService) {
        this.elementRef = elementRef;
        this.i18n = i18n;
        this.dropdownService = dropdownService;
        this.appRef = appRef;
        this.elementService = elementService;
        this.id = `dropdown-${Dropdown.dropdownCount++}`;
        /**
         * Value displayed if no item is selected.
         */
        this.placeholder = "";
        /**
         * The selected value from the `Dropdown`. Can be a string or template.
         */
        this.displayValue = "";
        /**
         * Sets the optional clear button tooltip text.
         */
        this.clearText = this.i18n.get().DROPDOWN.CLEAR;
        /**
         * Size to render the dropdown field.
         *
         * @deprecated since v4
         */
        this.size = "md";
        /**
         * Defines whether or not the `Dropdown` supports selecting multiple items as opposed to single
         * item selection.
         */
        this.type = "single";
        /**
         * `light` or `dark` dropdown theme
         */
        this.theme = "dark";
        /**
         * Set to `true` to disable the dropdown.
         */
        this.disabled = false;
        /**
         * Set to `true` for a loading dropdown.
         */
        this.skeleton = false;
        /**
         * Set to `true` for an inline dropdown.
         */
        this.inline = false;
        /**
         * Set to `true` for a dropdown without arrow key activation.
         */
        this.disableArrowKeys = false;
        /**
         * Set to `true` for invalid state.
         */
        this.invalid = false;
        /**
         * set to `true` to place the dropdown view inline with the component
         */
        this.appendInline = null;
        /**
         * Specify feedback (mode) of the selection.
         * `top`: selected item jumps to top
         * `fixed`: selected item stays at it's position
         * `top-after-reopen`: selected item jump to top after reopen dropdown
         */
        this.selectionFeedback = "top-after-reopen";
        /**
         * Accessible label for the button that opens the dropdown list.
         * Defaults to the `DROPDOWN.OPEN` value from the i18n service.
         */
        this.menuButtonLabel = this.i18n.get().DROPDOWN.OPEN;
        /**
         * Provides the label for the "# selected" text.
         * Defaults to the `DROPDOWN.SELECTED` value from the i18n service.
         */
        this.selectedLabel = this.i18n.get().DROPDOWN.SELECTED;
        /**
         * Emits selection events.
         */
        this.selected = new EventEmitter();
        /**
         * Emits event notifying to other classes that the `Dropdown` has been closed (collapsed).
         */
        this.onClose = new EventEmitter();
        /**
         * Emits event notifying to other classes that the `Dropdown` has been closed (collapsed).
         */
        this.close = new EventEmitter();
        this.hostClass = true;
        /**
         * Set to `true` if the dropdown is closed (not expanded).
         */
        this.menuIsClosed = true;
        /**
         * controls whether the `drop-up` class is applied
         */
        this._dropUp = false;
        // .bind creates a new function, so we declare the methods below
        // but .bind them up here
        this.noop = this._noop.bind(this);
        this.outsideClick = this._outsideClick.bind(this);
        this.outsideKey = this._outsideKey.bind(this);
        this.keyboardNav = this._keyboardNav.bind(this);
        this.visibilitySubscription = new Subscription();
        this.onTouchedCallback = this._noop;
        // primarily used to capture and propagate input to `writeValue` before the content is available
        this.writtenValue = [];
        /**
         * function passed in by `registerOnChange`
         */
        this.propagateChange = (_) => { };
    }
    /**
     * Deprecated. Use `itemValueKey` instead.
     * Specifies the property to be used as the return value to `ngModel`
     * @deprecated since v4 use itemValueKey instead
     */
    set value(newValue) {
        console.warn("Dropdown `value` property has been deprecated. Use `itemValueKey` instead");
        this.itemValueKey = newValue;
    }
    get value() {
        return this.itemValueKey;
    }
    /**
     * Updates the `type` property in the `@ContentChild`.
     * The `type` property specifies whether the `Dropdown` allows single selection or multi selection.
     */
    ngOnInit() {
        if (this.view) {
            this.view.type = this.type;
        }
    }
    /**
     * Initializes classes and subscribes to events for single or multi selection.
     */
    ngAfterContentInit() {
        if (!this.view) {
            return;
        }
        if ((this.writtenValue && this.writtenValue.length) || typeof this.writtenValue === "number") {
            this.writeValue(this.writtenValue);
        }
        this.view.type = this.type;
        this.view.size = this.size;
        this.view.select.subscribe(event => {
            if (this.type === "multi") {
                // if we have a `value` selector and selected items map them appropriately
                if (this.itemValueKey && this.view.getSelected()) {
                    const values = this.view.getSelected().map(item => item[this.itemValueKey]);
                    this.propagateChange(values);
                    // otherwise just pass up the values from `getSelected`
                }
                else {
                    this.propagateChange(this.view.getSelected());
                }
            }
            else {
                this.closeMenu();
                if (event.item && event.item.selected) {
                    if (this.itemValueKey) {
                        this.propagateChange(event.item[this.itemValueKey]);
                    }
                    else {
                        this.propagateChange(event.item);
                    }
                }
                else {
                    this.propagateChange(null);
                }
            }
            // only emit selected for "organic" selections
            if (event && !event.isUpdate) {
                this.checkForReorder();
                this.selected.emit(event);
            }
            // manually tick the app so the view picks up any changes
            this.appRef.tick();
        });
    }
    ngAfterViewInit() {
        // if appendInline is default valued (null) we should:
        // 1. if there are scrollable parents (not including body) don't append inline
        //    this should also cover the case where the dropdown is in a modal
        //    (where we _do_ want to append to the placeholder)
        if (this.appendInline === null && hasScrollableParents(this.elementRef.nativeElement)) {
            this.appendInline = false;
            // 2. otherwise we should append inline
        }
        else if (this.appendInline === null) {
            this.appendInline = true;
        }
        this.checkForReorder();
    }
    /**
     * Removing the `Dropdown` from the body if it is appended to the body.
     */
    ngOnDestroy() {
        if (!this.appendInline) {
            this._appendToDropdown();
        }
    }
    /**
     * Propagates the injected `value`.
     */
    writeValue(value) {
        // cache the written value so we can use it in `AfterContentInit`
        this.writtenValue = value;
        this.view.onItemsReady(() => {
            // propagate null/falsey as an array (deselect everything)
            if (!value) {
                this.view.propagateSelected([value]);
            }
            else if (this.type === "single") {
                if (this.itemValueKey) {
                    // clone the specified item and update its state
                    const newValue = Object.assign({}, this.view.getListItems().find(item => item[this.itemValueKey] === value));
                    newValue.selected = true;
                    this.view.propagateSelected([newValue]);
                }
                else {
                    // pass the singular value as an array of ListItem
                    this.view.propagateSelected([value]);
                }
            }
            else {
                if (this.itemValueKey) {
                    // clone the items and update their state based on the received value array
                    // this way we don't lose any additional metadata that may be passed in via the `items` Input
                    let newValues = [];
                    for (const v of value) {
                        for (const item of this.view.getListItems()) {
                            if (item[this.itemValueKey] === v) {
                                newValues.push(Object.assign({}, item, { selected: true }));
                            }
                        }
                    }
                    this.view.propagateSelected(newValues);
                }
                else {
                    // we can safely assume we're passing an array of `ListItem`s
                    this.view.propagateSelected(value);
                }
            }
            this.checkForReorder();
        });
    }
    onBlur() {
        this.onTouchedCallback();
    }
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    /**
     * Registering the function injected to control the touch use of the `Dropdown`.
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * `ControlValueAccessor` method to programmatically disable the dropdown.
     *
     * ex: `this.formGroup.get("myDropdown").disable();`
     *
     * @param isDisabled `true` to disable the input
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * Adds keyboard functionality for navigation, selection and closing of the `Dropdown`.
     */
    // "Esc", "Spacebar", "Down", and "Up" are IE specific values
    onKeyDown(event) {
        if ((event.key === "Escape" || event.key === "Esc") && !this.menuIsClosed) {
            event.stopImmediatePropagation(); // don't unintentionally close other widgets that listen for Escape
        }
        if (event.key === "Escape" || event.key === "Esc") {
            event.preventDefault();
            this.closeMenu();
            this.dropdownButton.nativeElement.focus();
        }
        else if (this.menuIsClosed && (event.key === " " || event.key === "ArrowDown" || event.key === "ArrowUp" ||
            event.key === "Spacebar" || event.key === "Down" || event.key === "Up")) {
            if (this.disableArrowKeys && (event.key === "ArrowDown" || event.key === "ArrowUp" || event.key === "Down" || event.key === "Up")) {
                return;
            }
            event.preventDefault();
            this.openMenu();
        }
        if (!this.menuIsClosed && event.key === "Tab" && this.dropdownMenu.nativeElement.contains(event.target)) {
            this.closeMenu();
        }
        if (!this.menuIsClosed && event.key === "Tab" && event.shiftKey) {
            this.closeMenu();
        }
        if (this.type === "multi") {
            return;
        }
        if (this.menuIsClosed) {
            this.closedDropdownNavigation(event);
        }
    }
    closedDropdownNavigation(event) {
        // "Down", and "Up" are IE specific values
        if (event.key === "ArrowDown" || event.key === "Down") {
            event.preventDefault();
            this.view.getCurrentItem().selected = false;
            let item = this.view.getNextItem();
            if (item) {
                item.selected = true;
            }
        }
        else if (event.key === "ArrowUp" || event.key === "Up") {
            event.preventDefault();
            this.view.getCurrentItem().selected = false;
            let item = this.view.getPrevItem();
            if (item) {
                item.selected = true;
            }
        }
    }
    /**
     * Returns the display value if there is a selection and displayValue is set,
     * if there is just a selection the ListItem content property will be returned,
     * otherwise the placeholder will be returned.
     */
    getDisplayStringValue() {
        if (!this.view) {
            return;
        }
        let selected = this.view.getSelected();
        if (selected.length && (!this.displayValue || !this.isRenderString())) {
            if (this.type === "multi") {
                return of(this.placeholder);
            }
            else {
                return of(selected[0].content);
            }
        }
        else if (selected.length && this.isRenderString()) {
            return of(this.displayValue);
        }
        return of(this.placeholder);
    }
    isRenderString() {
        return typeof this.displayValue === "string";
    }
    getRenderTemplateContext() {
        if (!this.view) {
            return;
        }
        let selected = this.view.getSelected();
        if (this.type === "multi") {
            return { items: selected };
        }
        else if (selected && selected.length > 0) {
            return { item: selected[0] }; // this is to be compatible with the dropdown-list template
        }
        else {
            return {};
        }
    }
    getSelectedCount() {
        if (this.view.getSelected()) {
            return this.view.getSelected().length;
        }
    }
    clearSelected() {
        if (this.disabled) {
            return;
        }
        for (const item of this.view.getListItems()) {
            item.selected = false;
        }
        this.selected.emit([]);
        this.propagateChange([]);
    }
    /**
     * Returns `true` if there is a value selected.
     */
    valueSelected() {
        if (this.view.getSelected()) {
            return true;
        }
        return false;
    }
    _noop() { }
    /**
     * Handles clicks outside of the `Dropdown`.
     */
    _outsideClick(event) {
        if (!this.elementRef.nativeElement.contains(event.target) &&
            // if we're appendToBody the list isn't within the _elementRef,
            // so we've got to check if our target is possibly in there too.
            !this.dropdownMenu.nativeElement.contains(event.target)) {
            this.closeMenu();
        }
    }
    _outsideKey(event) {
        if (!this.menuIsClosed && event.key === "Tab" && this.dropdownMenu.nativeElement.contains(event.target)) {
            this.closeMenu();
        }
    }
    /**
     * Handles keyboard events so users are controlling the `Dropdown` instead of unintentionally controlling outside elements.
     */
    _keyboardNav(event) {
        // "Esc" is an IE specific value
        if ((event.key === "Escape" || event.key === "Esc") && !this.menuIsClosed) {
            event.stopImmediatePropagation(); // don't unintentionally close modal if inside of it
        }
        if (event.key === "Escape" || event.key === "Esc") {
            event.preventDefault();
            this.closeMenu();
            this.dropdownButton.nativeElement.focus();
        }
        else if (!this.menuIsClosed && event.key === "Tab") {
            // this way focus will start on the next focusable item from the dropdown
            // not the top of the body!
            this.dropdownButton.nativeElement.focus();
            this.dropdownButton.nativeElement.dispatchEvent(new KeyboardEvent("keydown", { bubbles: true, cancelable: true, key: "Tab" }));
            this.closeMenu();
        }
    }
    /**
     * Creates the `Dropdown` list appending it to the dropdown parent object instead of the body.
     */
    _appendToDropdown() {
        this.dropdownService.appendToDropdown(this.elementRef.nativeElement);
        this.dropdownMenu.nativeElement.removeEventListener("keydown", this.keyboardNav, true);
    }
    /**
     * Creates the `Dropdown` list as an element that is appended to the DOM body.
     */
    _appendToBody() {
        const lightClass = this.theme === "light" ? " bx--list-box--light" : "";
        const expandedClass = !this.menuIsClosed ? " bx--list-box--expanded" : "";
        this.dropdownService.appendToBody(this.dropdownButton.nativeElement, this.dropdownMenu.nativeElement, `${this.elementRef.nativeElement.className}${lightClass}${expandedClass}`);
        this.dropdownMenu.nativeElement.addEventListener("keydown", this.keyboardNav, true);
    }
    /**
     * Detects whether or not the `Dropdown` list is visible within all scrollable parents.
     * This can be overridden by passing in a value to the `dropUp` input.
     */
    _shouldDropUp() {
        // check if dropdownMenu exists first.
        const menu = this.dropdownMenu && this.dropdownMenu.nativeElement.querySelector(".bx--list-box__menu");
        // check if menu exists first.
        const menuRect = menu && menu.getBoundingClientRect();
        if (menu && menuRect) {
            const scrollableParents = getScrollableParents(menu);
            return scrollableParents.reduce((shouldDropUp, parent) => {
                const parentRect = parent.getBoundingClientRect();
                const isBelowParent = !(menuRect.bottom <= parentRect.bottom);
                return shouldDropUp || isBelowParent;
            }, false);
        }
        return false;
    }
    /**
     * Expands the dropdown menu in the view.
     */
    openMenu() {
        // prevents the dropdown from opening when list of items is empty
        if (this.view.getListItems().length === 0) {
            return;
        }
        this._dropUp = false;
        this.menuIsClosed = false;
        // move the dropdown list to the body if we're not appending inline
        // and position it relative to the dropdown wrapper
        if (!this.appendInline) {
            const target = this.dropdownButton.nativeElement;
            const parent = this.elementRef.nativeElement;
            this.visibilitySubscription = this.elementService
                .visibility(target, parent)
                .subscribe(value => {
                if (!value.visible) {
                    this.closeMenu();
                }
            });
            this._appendToBody();
        }
        // set the dropdown menu to drop up if it's near the bottom of the screen
        // setTimeout lets us measure after it's visible in the DOM
        setTimeout(() => {
            if (this.dropUp === null || this.dropUp === undefined) {
                this._dropUp = this._shouldDropUp();
            }
        }, 0);
        // we bind noop to document.body.firstElementChild to allow safari to fire events
        // from document. Then we unbind everything later to keep things light.
        document.body.firstElementChild.addEventListener("click", this.noop, true);
        document.body.firstElementChild.addEventListener("keydown", this.noop, true);
        document.addEventListener("click", this.outsideClick, true);
        document.addEventListener("keydown", this.outsideKey, true);
        setTimeout(() => this.view.initFocus(), 0);
    }
    /**
     * Collapsing the dropdown menu and removing unnecessary `EventListeners`.
     */
    closeMenu() {
        // return early if the menu is already closed
        if (this.menuIsClosed) {
            return;
        }
        this.menuIsClosed = true;
        this.checkForReorder();
        this.onClose.emit();
        this.close.emit();
        // focus the trigger button when we close ...
        this.dropdownButton.nativeElement.focus();
        // remove the conditional once this api is settled and part of abstract-dropdown-view.class
        if (this.view["disableScroll"]) {
            this.view["disableScroll"]();
        }
        // move the list back in the component on close
        if (!this.appendInline) {
            this.visibilitySubscription.unsubscribe();
            this._appendToDropdown();
        }
        document.body.firstElementChild.removeEventListener("click", this.noop, true);
        document.body.firstElementChild.removeEventListener("keydown", this.noop, true);
        document.removeEventListener("click", this.outsideClick, true);
        document.removeEventListener("keydown", this.outsideKey, true);
    }
    /**
     * Controls toggling menu states between open/expanded and closed/collapsed.
     */
    toggleMenu() {
        if (this.menuIsClosed) {
            this.openMenu();
        }
        else {
            this.closeMenu();
        }
    }
    isTemplate(value) {
        return value instanceof TemplateRef;
    }
    /**
     * Controls when it's needed to apply the selection feedback
     */
    checkForReorder() {
        const topAfterReopen = this.menuIsClosed && this.selectionFeedback === "top-after-reopen";
        if ((this.type === "multi") && (topAfterReopen || this.selectionFeedback === "top")) {
            this.view.reorderSelected(this.selectionFeedback === "top");
        }
    }
}
Dropdown.dropdownCount = 0;
Dropdown.decorators = [
    { type: Component, args: [{
                selector: "ibm-dropdown",
                template: `
	<label *ngIf="label" [for]="id" class="bx--label">
		<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
		<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
	</label>
	<div
		class="bx--list-box"
		[ngClass]="{
			'bx--dropdown': type !== 'multi',
			'bx--multiselect': type === 'multi',
			'bx--multi-select--selected': type === 'multi' && getSelectedCount() > 0,
			'bx--dropdown--light': theme === 'light',
			'bx--list-box--light': theme === 'light',
			'bx--list-box--inline': inline,
			'bx--skeleton': skeleton,
			'bx--dropdown--disabled bx--list-box--disabled': disabled,
			'bx--dropdown--invalid': invalid,
			'bx--dropdown--xl bx--list-box--xl': size === 'xl',
			'bx--dropdown--sm bx--list-box--sm': size === 'sm',
			'bx--list-box--expanded': !menuIsClosed
		}">
		<button
			#dropdownButton
			[id]="id"
			type="button"
			class="bx--list-box__field"
			[ngClass]="{'a': !menuIsClosed}"
			[attr.aria-expanded]="!menuIsClosed"
			[attr.aria-disabled]="disabled"
			aria-haspopup="listbox"
			(click)="disabled ? $event.stopPropagation() : toggleMenu()"
			(blur)="onBlur()"
			[attr.disabled]="disabled ? true : null">
			<div
				(click)="clearSelected()"
				(keydown.enter)="clearSelected()"
				*ngIf="type === 'multi' && getSelectedCount() > 0"
				class="bx--list-box__selection bx--tag--filter bx--list-box__selection--multi"
				tabindex="0"
				[title]="clearText">
				{{getSelectedCount()}}
				<svg
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					style="will-change: transform;"
					role="img"
					xmlns="http://www.w3.org/2000/svg"
					width="16"
					height="16"
					viewBox="0 0 16 16"
					aria-hidden="true">
					<path d="M12 4.7l-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8z"></path>
				</svg>
			</div>
			<span *ngIf="isRenderString()" class="bx--list-box__label">{{getDisplayStringValue() | async}}</span>
			<ng-template
				*ngIf="!isRenderString()"
				[ngTemplateOutletContext]="getRenderTemplateContext()"
				[ngTemplateOutlet]="displayValue">
			</ng-template>
			<svg
				*ngIf="invalid"
				class="bx--dropdown__invalid-icon"
				ibmIcon="warning--filled"
				size="16">
			</svg>
			<svg
				*ngIf="!skeleton"
				ibmIcon="chevron--down"
				size="16"
				class="bx--list-box__menu-icon"
				[attr.aria-label]="menuButtonLabel"
				[ngClass]="{'bx--list-box__menu-icon--open': !menuIsClosed }">
			</svg>
		</button>
		<div
			#dropdownMenu
			[ngClass]="{
				'bx--list-box--up': this.dropUp !== null && this.dropUp !== undefined ? dropUp : _dropUp
			}">
			<ng-content *ngIf="!menuIsClosed"></ng-content>
		</div>
	</div>
	<div *ngIf="helperText && !invalid" class="bx--form__helper-text">
		<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
		<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
	</div>
	<div *ngIf="invalid" class="bx--form-requirement">
		<ng-container *ngIf="!isTemplate(invalidText)">{{ invalidText }}</ng-container>
		<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
	</div>
	`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: Dropdown,
                        multi: true
                    }
                ]
            }] }
];
/** @nocollapse */
Dropdown.ctorParameters = () => [
    { type: ElementRef },
    { type: I18n },
    { type: DropdownService },
    { type: ApplicationRef },
    { type: ElementService }
];
Dropdown.propDecorators = {
    id: [{ type: Input }],
    label: [{ type: Input }],
    helperText: [{ type: Input }],
    placeholder: [{ type: Input }],
    displayValue: [{ type: Input }],
    clearText: [{ type: Input }],
    size: [{ type: Input }],
    type: [{ type: Input }],
    theme: [{ type: Input }],
    disabled: [{ type: Input }],
    skeleton: [{ type: Input }],
    inline: [{ type: Input }],
    disableArrowKeys: [{ type: Input }],
    invalid: [{ type: Input }],
    invalidText: [{ type: Input }],
    appendInline: [{ type: Input }],
    scrollableContainer: [{ type: Input }],
    value: [{ type: Input }],
    itemValueKey: [{ type: Input }],
    selectionFeedback: [{ type: Input }],
    menuButtonLabel: [{ type: Input }],
    selectedLabel: [{ type: Input }],
    dropUp: [{ type: Input }],
    selected: [{ type: Output }],
    onClose: [{ type: Output }],
    close: [{ type: Output }],
    view: [{ type: ContentChild, args: [AbstractDropdownView, { static: true },] }],
    dropdownButton: [{ type: ViewChild, args: ["dropdownButton", { static: true },] }],
    dropdownMenu: [{ type: ViewChild, args: ["dropdownMenu", { static: true },] }],
    hostClass: [{ type: HostBinding, args: ["class.bx--dropdown__wrapper",] }],
    onKeyDown: [{ type: HostListener, args: ["keydown", ["$event"],] }]
};

/**
 * returns an observable bound to keydown events that
 * filters to a single element where the first letter of
 * it's textContent matches the key pressed
 *
 * @param target element to watch
 * @param elements elements to search
 */
function watchFocusJump(target, elements) {
    return fromEvent(target, "keydown")
        .pipe(debounceTime(150), map((ev) => {
        let el = elements.find((itemEl) => itemEl.textContent.trim().toLowerCase().startsWith(ev.key));
        if (el) {
            return el;
        }
    }), filter(el => !!el));
}

/**
 * ```html
 * <ibm-dropdown-list [items]="listItems"></ibm-dropdown-list>
 * ```
 * ```typescript
 * listItems = [
 * 	{
 * 		content: "item one",
 * 		selected: false
 * 	},
 * 	{
 * 		content: "item two",
 * 		selected: false,
 * 	},
 * 	{
 * 		content: "item three",
 * 		selected: false
 * 	},
 * 	{
 * 		content: "item four",
 * 		selected: false
 * 	}
 * ];
 * ```
 */
class DropdownList {
    /**
     * Creates an instance of `DropdownList`.
     */
    constructor(elementRef, i18n) {
        this.elementRef = elementRef;
        this.i18n = i18n;
        this.ariaLabel = this.i18n.get().DROPDOWN_LIST.LABEL;
        /**
         * Template to bind to items in the `DropdownList` (optional).
         */
        this.listTpl = null;
        /**
         * Event to emit selection of a list item within the `DropdownList`.
         */
        this.select = new EventEmitter();
        /**
         * Event to emit scroll event of a list within the `DropdownList`.
         */
        this.scroll = new EventEmitter();
        /**
         * Event to suggest a blur on the view.
         * Emits _after_ the first/last item has been focused.
         * ex.
         * ArrowUp -> focus first item
         * ArrowUp -> emit event
         *
         * When this event fires focus should be placed on some element outside of the list - blurring the list as a result
         */
        this.blurIntent = new EventEmitter();
        /**
         * Defines whether or not the `DropdownList` supports selecting multiple items as opposed to single
         * item selection.
         */
        this.type = "single";
        /**
         * Defines the rendering size of the `DropdownList` input component.
         *
         * @deprecated since v4
         */
        this.size = "md";
        /**
         * Holds the list of items that will be displayed in the `DropdownList`.
         * It differs from the the complete set of items when filtering is used (but
         * it is always a subset of the total items in `DropdownList`).
         */
        this.displayItems = [];
        /**
         * Maintains the index for the selected item within the `DropdownList`.
         */
        this.index = -1;
        /**
         * Useful representation of the items, should be accessed via `getListItems`.
         */
        this._items = [];
    }
    /**
     * The list items belonging to the `DropdownList`.
     */
    set items(value) {
        if (isObservable(value)) {
            if (this._itemsSubscription) {
                this._itemsSubscription.unsubscribe();
            }
            this._itemsReady = new Observable((observer) => {
                this._itemsSubscription = value.subscribe(v => {
                    this.updateList(v);
                    observer.next(true);
                    observer.complete();
                });
            });
            this.onItemsReady(null);
        }
        else {
            this.updateList(value);
        }
        this._originalItems = value;
    }
    get items() {
        return this._originalItems;
    }
    /**
     * Retrieves array of list items and index of the selected item after view has rendered.
     * Additionally, any Observables for the `DropdownList` are initialized.
     */
    ngAfterViewInit() {
        this.index = this.getListItems().findIndex(item => item.selected);
        this.setupFocusObservable();
        setTimeout(() => {
            this.doEmitSelect(true);
        });
    }
    /**
     * Removes any Observables on destruction of the component.
     */
    ngOnDestroy() {
        if (this.focusJump) {
            this.focusJump.unsubscribe();
        }
        if (this._itemsSubscription) {
            this._itemsSubscription.unsubscribe();
        }
    }
    doEmitSelect(isUpdate = true) {
        if (this.type === "single") {
            this.select.emit({ item: this._items.find(item => item.selected), isUpdate: isUpdate });
        }
        else {
            // abuse javascripts object mutability until we can break the API and switch to
            // { items: [], isUpdate: true }
            const selected = this.getSelected() || [];
            selected["isUpdate"] = isUpdate;
            this.select.emit(selected);
        }
    }
    /**
     * Updates the displayed list of items and then retrieves the most current properties for the `DropdownList` from the DOM.
     */
    updateList(items) {
        this._items = items.map(item => Object.assign({}, item));
        this.displayItems = this._items;
        this.index = this._items.findIndex(item => item.selected);
        this.setupFocusObservable();
        setTimeout(() => {
            if (this.getSelected() !== []) {
                return;
            }
            this.doEmitSelect();
        });
    }
    /**
     * Filters the items being displayed in the DOM list.
     */
    filterBy(query = "") {
        if (query) {
            this.displayItems = this.getListItems().filter(item => item.content.toLowerCase().includes(query.toLowerCase()));
        }
        else {
            this.displayItems = this.getListItems();
        }
        // reset the index since the list has changed visually
        this.index = 0;
    }
    /**
     * Initializes (or re-initializes) the Observable that handles switching focus to an element based on
     * key input matching the first letter of the item in the list.
     */
    setupFocusObservable() {
        if (!this.list) {
            return;
        }
        if (this.focusJump) {
            this.focusJump.unsubscribe();
        }
        let elList = Array.from(this.list.nativeElement.querySelectorAll("li"));
        this.focusJump = watchFocusJump(this.list.nativeElement, elList)
            .subscribe(el => {
            el.focus();
        });
    }
    /**
     * Returns the `ListItem` that is subsequent to the selected item in the `DropdownList`.
     */
    getNextItem() {
        if (this.index < this.displayItems.length - 1) {
            this.index++;
        }
        return this.displayItems[this.index];
    }
    /**
     * Returns `true` if the selected item is not the last item in the `DropdownList`.
     */
    hasNextElement() {
        if (this.index < this.displayItems.length - 1) {
            return true;
        }
        return false;
    }
    /**
     * Returns the `HTMLElement` for the item that is subsequent to the selected item.
     */
    getNextElement() {
        if (this.index < this.displayItems.length - 1) {
            this.index++;
        }
        let elem = this.listElementList.toArray()[this.index].nativeElement;
        let item = this.displayItems[this.index];
        if (item.disabled) {
            return this.getNextElement();
        }
        return elem;
    }
    /**
     * Returns the `ListItem` that precedes the selected item within `DropdownList`.
     */
    getPrevItem() {
        if (this.index > 0) {
            this.index--;
        }
        return this.displayItems[this.index];
    }
    /**
     * Returns `true` if the selected item is not the first in the list.
     */
    hasPrevElement() {
        if (this.index > 0) {
            return true;
        }
        return false;
    }
    /**
     * Returns the `HTMLElement` for the item that precedes the selected item.
     */
    getPrevElement() {
        if (this.index > 0) {
            this.index--;
        }
        let elem = this.listElementList.toArray()[this.index].nativeElement;
        let item = this.displayItems[this.index];
        if (item.disabled) {
            return this.getPrevElement();
        }
        return elem;
    }
    /**
     * Returns the `ListItem` that is selected within `DropdownList`.
     */
    getCurrentItem() {
        if (this.index < 0) {
            return this.displayItems[0];
        }
        return this.displayItems[this.index];
    }
    /**
     * Returns the `HTMLElement` for the item that is selected within the `DropdownList`.
     */
    getCurrentElement() {
        if (this.index < 0) {
            return this.listElementList.first.nativeElement;
        }
        return this.listElementList.toArray()[this.index].nativeElement;
    }
    /**
     * Returns the items as an Array
     */
    getListItems() {
        return this._items;
    }
    /**
     * Returns a list containing the selected item(s) in the `DropdownList`.
     */
    getSelected() {
        let selected = this.getListItems().filter(item => item.selected);
        if (selected.length === 0) {
            return [];
        }
        return selected;
    }
    /**
     * Transforms array input list of items to the correct state by updating the selected item(s).
     */
    propagateSelected(value) {
        // if we get a non-array, log out an error (since it is one)
        if (!Array.isArray(value)) {
            console.error(`${this.constructor.name}.propagateSelected expects an Array<ListItem>, got ${JSON.stringify(value)}`);
        }
        this.onItemsReady(() => {
            // loop through the list items and update the `selected` state for matching items in `value`
            for (let oldItem of this.getListItems()) {
                // copy the item
                let tempOldItem = Object.assign({}, oldItem);
                // deleted selected because it's what we _want_ to change
                delete tempOldItem.selected;
                // stringify for compare
                tempOldItem = JSON.stringify(tempOldItem);
                for (let newItem of value) {
                    // copy the item
                    let tempNewItem = Object.assign({}, newItem);
                    // deleted selected because it's what we _want_ to change
                    delete tempNewItem.selected;
                    // stringify for compare
                    tempNewItem = JSON.stringify(tempNewItem);
                    // do the compare
                    if (tempOldItem.includes(tempNewItem)) {
                        oldItem.selected = newItem.selected;
                        // if we've found a matching item, we can stop looping
                        break;
                    }
                    else {
                        oldItem.selected = false;
                    }
                }
            }
        });
    }
    /**
     * Initializes focus in the list, effectively a wrapper for `getCurrentElement().focus()`
     */
    initFocus() {
        // ensure we start at this first item if nothing is already selected
        if (this.index < 0) {
            this.index = 0;
        }
        this.getCurrentElement().focus();
    }
    /**
     * Manages the keyboard accessibility for navigation and selection within a `DropdownList`.
     */
    doKeyDown(event, item) {
        // "Spacebar", "Down", and "Up" are IE specific values
        if (event.key === "Enter" || event.key === " " || event.key === "Spacebar") {
            if (this.listElementList.some(option => option.nativeElement === event.target)) {
                event.preventDefault();
            }
            if (event.key === "Enter") {
                this.doClick(event, item);
            }
        }
        else if (event.key === "ArrowDown" || event.key === "ArrowUp" || event.key === "Down" || event.key === "Up") {
            event.preventDefault();
            if (event.key === "ArrowDown" || event.key === "Down") {
                if (this.hasNextElement()) {
                    this.getNextElement().focus();
                }
                else {
                    this.blurIntent.emit("bottom");
                }
            }
            else if (event.key === "ArrowUp" || event.key === "Up") {
                if (this.hasPrevElement()) {
                    this.getPrevElement().focus();
                }
                else {
                    this.blurIntent.emit("top");
                }
            }
        }
    }
    /**
     * Emits the selected item or items after a mouse click event has occurred.
     */
    doClick(event, item) {
        event.preventDefault();
        if (!item.disabled) {
            if (this.type === "single") {
                item.selected = true;
                // reset the selection
                for (let otherItem of this.getListItems()) {
                    if (item !== otherItem) {
                        otherItem.selected = false;
                    }
                }
            }
            else {
                item.selected = !item.selected;
            }
            this.index = this.displayItems.indexOf(item);
            this.doEmitSelect(false);
        }
    }
    onItemFocus(index) {
        const element = this.listElementList.toArray()[index].nativeElement;
        element.classList.add("bx--list-box__menu-item--highlighted");
        element.tabIndex = 0;
    }
    onItemBlur(index) {
        const element = this.listElementList.toArray()[index].nativeElement;
        element.classList.remove("bx--list-box__menu-item--highlighted");
        element.tabIndex = -1;
    }
    /**
     * Emits the scroll event of the options list
     */
    emitScroll(event) {
        const atTop = event.srcElement.scrollTop === 0;
        const atBottom = event.srcElement.scrollHeight - event.srcElement.scrollTop === event.srcElement.clientHeight;
        const customScrollEvent = { atTop, atBottom, event };
        this.scroll.emit(customScrollEvent);
    }
    /**
     * Subscribe the function passed to an internal observable that will resolve once the items are ready
     */
    onItemsReady(subcription) {
        // this subscription will auto unsubscribe because of the `first()` pipe
        (this._itemsReady || of(true)).pipe(first()).subscribe(subcription);
    }
    reorderSelected(moveFocus = false) {
        this.displayItems = [...this.getSelected(), ...this.getListItems().filter(item => !item.selected)];
        if (moveFocus) {
            setTimeout(() => this.getCurrentElement().focus());
        }
    }
}
DropdownList.decorators = [
    { type: Component, args: [{
                selector: "ibm-dropdown-list",
                template: `
		<ul
			#list
			role="listbox"
			class="bx--list-box__menu bx--multi-select"
			(scroll)="emitScroll($event)"
			[attr.aria-label]="ariaLabel">
			<li
				role="option"
				*ngFor="let item of displayItems; let i = index"
				(click)="doClick($event, item)"
				(keydown)="doKeyDown($event, item)"
				(focus)="onItemFocus(i)"
				(blur)="onItemBlur(i)"
				class="bx--list-box__menu-item"
				[ngClass]="{
					'bx--list-box__menu-item--active': item.selected,
					disabled: item.disabled
				}"
				[title]="item.content">
				<div
					#listItem
					tabindex="-1"
					class="bx--list-box__menu-item__option">
					<div
						*ngIf="!listTpl && type === 'multi'"
						class="bx--form-item bx--checkbox-wrapper">
						<label
							[attr.data-contained-checkbox-state]="item.selected"
							class="bx--checkbox-label">
							<input
								class="bx--checkbox"
								type="checkbox"
								[checked]="item.selected"
								[disabled]="item.disabled"
								tabindex="-1">
							<span class="bx--checkbox-appearance"></span>
							<span class="bx--checkbox-label-text">{{item.content}}</span>
						</label>
					</div>
					<ng-container *ngIf="!listTpl && type === 'single'">{{item.content}}</ng-container>
					<svg
						*ngIf="!listTpl && type === 'single'"
						ibmIcon="checkmark"
						size="16"
						class="bx--list-box__menu-item__selected-icon">
					</svg>
					<ng-template
						*ngIf="listTpl"
						[ngTemplateOutletContext]="{item: item}"
						[ngTemplateOutlet]="listTpl">
					</ng-template>
				</div>
			</li>
		</ul>`,
                providers: [
                    {
                        provide: AbstractDropdownView,
                        useExisting: DropdownList
                    }
                ]
            }] }
];
/** @nocollapse */
DropdownList.ctorParameters = () => [
    { type: ElementRef },
    { type: I18n }
];
DropdownList.propDecorators = {
    ariaLabel: [{ type: Input }],
    items: [{ type: Input }],
    listTpl: [{ type: Input }],
    select: [{ type: Output }],
    scroll: [{ type: Output }],
    blurIntent: [{ type: Output }],
    list: [{ type: ViewChild, args: ["list", { static: true },] }],
    type: [{ type: Input }],
    listElementList: [{ type: ViewChildren, args: ["listItem",] }]
};

class ScrollableList {
    constructor(elementRef) {
        this.elementRef = elementRef;
        /**
         * Optional target list to scroll
         */
        this.nScrollableList = null;
        /**
         * Enables or disables scrolling for the whole directive
         */
        this.scrollEnabled = true;
        /**
         * How many lines to scroll by each time `wheel` fires
         * Defaults to 10 - based on testing this isn't too fast or slow on any platform
         */
        this.scrollBy = 10;
        this.canScrollUp = false;
        this.canScrollDown = false;
        this.list = this.elementRef.nativeElement;
    }
    ngOnChanges(changes) {
        if (changes.scrollEnabled) {
            if (changes.scrollEnabled.currentValue) {
                this.list.style.overflow = "hidden";
                this.scrollUpTarget.style.display = "flex";
                this.scrollDownTarget.style.display = "flex";
                this.canScrollUp = true;
                this.canScrollDown = true;
                this.updateScrollHeight();
                this.checkScrollArrows();
                setTimeout(() => {
                    this.checkScrollArrows();
                });
            }
            else {
                this.scrollUpTarget.style.display = "none";
                this.scrollDownTarget.style.display = "none";
                this.canScrollUp = false;
                this.canScrollDown = false;
                this.list.style.height = null;
                this.list.style.overflow = null;
                clearInterval(this.hoverScrollInterval);
            }
        }
    }
    ngAfterViewInit() {
        if (this.nScrollableList) {
            this.list = this.elementRef.nativeElement.querySelector(this.nScrollableList);
        }
        this.scrollUpTarget.addEventListener("mouseover", () => this.onHoverUp(true));
        this.scrollUpTarget.addEventListener("mouseout", () => this.onHoverUp(false));
        this.scrollDownTarget.addEventListener("mouseover", () => this.onHoverDown(true));
        this.scrollDownTarget.addEventListener("mouseout", () => this.onHoverDown(false));
    }
    updateScrollHeight() {
        if (this.scrollEnabled) {
            const container = this.elementRef.nativeElement.parentElement;
            const containerRect = container.getBoundingClientRect();
            const innerHeightDiff = this.list.getBoundingClientRect().top - containerRect.top;
            const outerHeightDiff = containerRect.height - (containerRect.bottom - window.innerHeight);
            // 40 gives us some padding between the bottom of the list,
            // the bottom of the window, and the scroll down button
            const height = outerHeightDiff - innerHeightDiff - 40;
            this.list.style.height = `${height}px`;
        }
    }
    checkScrollArrows() {
        const scrollUpHeight = this.scrollUpTarget.offsetHeight;
        const scrollDownHeight = this.scrollDownTarget.offsetHeight;
        if (this.list.scrollTop === 0) {
            if (this.canScrollUp) {
                this.list.style.height = `${parseInt(this.list.style.height, 10) + scrollUpHeight}px`;
            }
            this.scrollUpTarget.style.display = "none";
            this.canScrollUp = false;
        }
        else if (this.list.scrollTop === this.list.scrollTopMax) {
            if (this.canScrollDown) {
                this.list.style.height = `${parseInt(this.list.style.height, 10) + scrollDownHeight}px`;
            }
            this.scrollDownTarget.style.display = "none";
            this.canScrollDown = false;
        }
        else {
            if (!this.canScrollUp) {
                this.list.style.height = `${parseInt(this.list.style.height, 10) - scrollUpHeight}px`;
            }
            if (!this.canScrollDown) {
                this.list.style.height = `${parseInt(this.list.style.height, 10) - scrollDownHeight}px`;
            }
            this.scrollUpTarget.style.display = "flex";
            this.scrollDownTarget.style.display = "flex";
            this.canScrollUp = true;
            this.canScrollDown = true;
        }
    }
    onWheel(event) {
        if (event.deltaY < 0) {
            this.list.scrollTop -= this.scrollBy;
        }
        else {
            this.list.scrollTop += this.scrollBy;
        }
        // only prevent the parent/window from scrolling if we can scroll
        if (!(this.list.scrollTop === this.list.scrollTopMax || this.list.scrollTop === 0)) {
            event.preventDefault();
            event.stopPropagation();
        }
        this.checkScrollArrows();
    }
    onTouchStart(event) {
        if (event.touches[0]) {
            this.lastTouch = event.touches[0].clientY;
        }
    }
    onTouchMove(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.touches[0]) {
            const touch = event.touches[0];
            this.list.scrollTop += this.lastTouch - touch.clientY;
            this.lastTouch = touch.clientY;
            this.checkScrollArrows();
        }
    }
    hoverScrollBy(hovering, amount) {
        if (hovering) {
            this.hoverScrollInterval = setInterval(() => {
                this.list.scrollTop += amount;
                this.checkScrollArrows();
            }, 1);
        }
        else {
            clearInterval(this.hoverScrollInterval);
        }
    }
    onHoverUp(hovering) {
        // how many px/lines to scroll by on hover
        // 3 is just a random number that felt good
        // 1 and 2 are too slow, 4 works but it might be a tad fast
        this.hoverScrollBy(hovering, -3);
    }
    onHoverDown(hovering) {
        this.hoverScrollBy(hovering, 3);
    }
    onKeyDown(event) {
        if (event.key === "ArrowDown" || event.key === "ArrowUp") {
            this.checkScrollArrows();
        }
    }
}
ScrollableList.decorators = [
    { type: Directive, args: [{
                selector: "[ibmScrollableList]",
                exportAs: "scrollable-list"
            },] }
];
/** @nocollapse */
ScrollableList.ctorParameters = () => [
    { type: ElementRef }
];
ScrollableList.propDecorators = {
    nScrollableList: [{ type: Input }],
    scrollEnabled: [{ type: Input }],
    scrollUpTarget: [{ type: Input }],
    scrollDownTarget: [{ type: Input }],
    scrollBy: [{ type: Input }],
    onWheel: [{ type: HostListener, args: ["wheel", ["$event"],] }],
    onTouchStart: [{ type: HostListener, args: ["touchstart", ["$event"],] }],
    onTouchMove: [{ type: HostListener, args: ["touchmove", ["$event"],] }],
    onKeyDown: [{ type: HostListener, args: ["keydown", ["$event"],] }]
};

class DropdownModule {
}
DropdownModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    Dropdown,
                    DropdownList,
                    ScrollableList,
                    AbstractDropdownView
                ],
                exports: [
                    Dropdown,
                    DropdownList,
                    ScrollableList,
                    AbstractDropdownView
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    I18nModule,
                    PlaceholderModule,
                    UtilsModule,
                    IconModule
                ],
                providers: [DropdownService]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { Dropdown, DropdownList, ScrollableList, AbstractDropdownView, DropdownService, DropdownModule };

//# sourceMappingURL=carbon-components-angular-dropdown.js.map