/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-tabs.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Subscription } from 'rxjs';
import { Component, Input, Output, EventEmitter, TemplateRef, HostBinding, ViewChild, ElementRef, HostListener, ContentChildren, ChangeDetectorRef, ViewChildren, ContentChild, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { EventService, UtilsModule } from 'carbon-components-angular/utils';

let nextId = 0;
/**
* The `Tab` component is a child of the `Tabs` component.
* It represents one `Tab` item and its content within a panel of other `Tab` items.
*
*
* `Tab` takes a string or `TemplateRef` for the header, and any content for the body of the tab.
* Disabled states should be handled by the application (ie. switch to the tab, but display some
* indication as to _why_ the tab is disabled).
*
* When the tab is selected the `select` output will be triggered.
* The `select` output will also be triggered for the active tab when the tabs are loaded or updated.
*
*
* Tab with string header:
*
* ```html
* <ibm-tab heading='tab1'>
* 	tab 1 content
* </ibm-tab>
* ```
*
* Tab with custom header:
*
* ```html
* <ng-template #tabHeading>
* 	<svg ibmIcon="facebook"
* 		size="sm"
* 		style="margin-right: 7px;">
* 	</svg>
* 	Hello Tab 1
* </ng-template>
* <ibm-tabs>
* 	<ibm-tab [heading]="tabHeading">
* 		Tab 1 content <svg ibmIcon="alert" size="lg"></svg>
* 	</ibm-tab>
* 	<ibm-tab heading='Tab2'>
* 		Tab 2 content
* 	</ibm-tab>
* 	<ibm-tab heading='Tab3'>
* 		Tab 3 content
* 	</ibm-tab>
* </ibm-tabs>
* ```
*/
class Tab {
    constructor() {
        /**
         * Boolean value reflects if the `Tab` is using a custom template for the heading.
         * Default value is false.
         */
        this.headingIsTemplate = false;
        /**
         * Indicates whether the `Tab` is active/selected.
         * Determines whether it's `TabPanel` is rendered.
         */
        this.active = false;
        /**
         * Indicates whether or not the `Tab` item is disabled.
         */
        this.disabled = false;
        this.tabIndex = 0;
        // do we need id's?
        /**
         * Sets the id of the `Tab`. Will be uniquely generated if not provided.
         */
        this.id = `n-tab-${nextId++}`;
        /**
         * Value 'selected' to be emitted after a new `Tab` is selected.
         */
        this.selected = new EventEmitter();
        /**
         * Used to set the id property on the element.
         */
        this.attrClass = this.id;
        this._cacheActive = false;
    }
    /**
     * Set to true to have Tab items cached and not reloaded on tab switching.
     */
    set cacheActive(shouldCache) {
        this._cacheActive = shouldCache;
    }
    get cacheActive() {
        return this._cacheActive;
    }
    /**
     * Checks for custom heading template on initialization and updates the value
     * of the boolean 'headingIsTemplate'.
     */
    ngOnInit() {
        if (this.heading instanceof TemplateRef) {
            this.headingIsTemplate = true;
        }
    }
    /**
     * Emit the status of the `Tab`, specifically 'select' and 'selected' properties.
     */
    doSelect() {
        this.selected.emit();
    }
    /**
    * Returns value indicating whether this `Tab` should be rendered in a `TabPanel`.
    */
    shouldRender() {
        return this.active || this.cacheActive;
    }
}
Tab.decorators = [
    { type: Component, args: [{
                selector: "ibm-tab",
                template: `
		<div
			[attr.tabindex]="tabIndex"
			role="tabpanel"
			*ngIf="shouldRender()"
			class="bx--tab-content"
			[ngStyle]="{'display': active ? null : 'none'}"
			[attr.aria-labelledby]="id + '-header'"
			aria-live="polite">
			<ng-content></ng-content>
		</div>
	`
            }] }
];
Tab.propDecorators = {
    heading: [{ type: Input }],
    title: [{ type: Input }],
    context: [{ type: Input }],
    active: [{ type: Input }],
    disabled: [{ type: Input }],
    tabIndex: [{ type: Input }],
    id: [{ type: Input }],
    cacheActive: [{ type: Input }],
    selected: [{ type: Output }],
    attrClass: [{ type: HostBinding, args: ["attr.id",] }]
};

class TabHeader {
    constructor() {
        /**
         * Indicates whether the `Tab` is active/selected.
         * Determines whether it's `TabPanel` is rendered.
         */
        this.active = false;
        /**
         * Indicates whether or not the `Tab` item is disabled.
         */
        this.disabled = false;
        /**
         * Value 'selected' to be emitted after a new `Tab` is selected.
         */
        this.selected = new EventEmitter();
        this._cacheActive = false;
    }
    /**
     * Set to 'true' to have pane reference cached and not reloaded on tab switching.
     */
    set cacheActive(shouldCache) {
        this._cacheActive = shouldCache;
        // Updates the pane references associated with the tab header when cache active is changed.
        if (this.paneReference) {
            this.paneReference.cacheActive = this.cacheActive;
        }
    }
    set paneTabIndex(tabIndex) {
        if (this.paneReference) {
            this.paneReference.tabIndex = tabIndex;
        }
    }
    get cacheActive() {
        return this._cacheActive;
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.title = this.title ? this.title : this.tabItem.nativeElement.textContent;
        });
    }
    selectTab() {
        this.tabItem.nativeElement.focus();
        if (!this.disabled) {
            this.selected.emit();
            this.active = true;
            if (this.paneReference) {
                this.paneReference.active = true;
            }
        }
    }
}
TabHeader.decorators = [
    { type: Component, args: [{
                selector: "ibm-tab-header",
                template: `
		<li
			[ngClass]="{
				'bx--tabs__nav-item--selected bx--tabs--scrollable__nav-item--selected': active,
				'bx--tabs__nav-item--disabled bx--tabs--scrollable__nav-item--disabled': disabled
			}"
			class="bx--tabs--scrollable__nav-item"
			role="presentation"
			(click)="selectTab()">
			<button
				#tabItem
				[attr.aria-selected]="active"
				draggable="false"
				class="bx--tabs--scrollable__nav-link"
				href="javascript:void(0)"
				[title]="title"
				[attr.tabindex]="(active? 0 : -1)"
				role="tab">
				<ng-content></ng-content>
			</button>
		</li>
	`
            }] }
];
TabHeader.propDecorators = {
    active: [{ type: Input }],
    disabled: [{ type: Input }],
    paneReference: [{ type: Input }],
    title: [{ type: Input }],
    cacheActive: [{ type: Input }],
    paneTabIndex: [{ type: Input }],
    selected: [{ type: Output }],
    tabItem: [{ type: ViewChild, args: ["tabItem", { static: true },] }]
};

class TabHeaderGroup {
    constructor(elementRef, changeDetectorRef, eventService) {
        this.elementRef = elementRef;
        this.changeDetectorRef = changeDetectorRef;
        this.eventService = eventService;
        /**
         * Set to `true` to put tabs in a loading state.
         */
        this.skeleton = false;
        /**
         * Set to 'true' to have all pane references associated with each tab header
         * in the tab header group cached and not reloaded on tab switching.
         */
        this.cacheActive = false;
        this.isNavigation = false;
        this.type = "default";
        /**
         * Keeps track of all the subscriptions to the tab header selection events.
         */
        this.selectedSubscriptionTracker = new Subscription();
        /**
         * Controls the manual focusing done by tabbing through headings.
         */
        this.currentSelectedIndex = 0;
        // width of the overflow buttons
        this.OVERFLOW_BUTTON_OFFSET = 40;
        this._cacheActive = false;
    }
    get hasHorizontalOverflow() {
        const tabList = this.headerContainer.nativeElement;
        return tabList.scrollWidth > tabList.clientWidth;
    }
    get leftOverflowNavButtonHidden() {
        const tabList = this.headerContainer.nativeElement;
        return !this.hasHorizontalOverflow || !tabList.scrollLeft;
    }
    get rightOverflowNavButtonHidden() {
        const tabList = this.headerContainer.nativeElement;
        return !this.hasHorizontalOverflow ||
            (tabList.scrollLeft + tabList.clientWidth) === tabList.scrollWidth;
    }
    // keyboard accessibility
    /**
     * Controls the keydown events used for tabbing through the headings.
     */
    keyboardInput(event) {
        let tabHeadersArray = Array.from(this.tabHeaderQuery);
        if (event.key === "Right" || event.key === "ArrowRight") {
            if (this.currentSelectedIndex < tabHeadersArray.length - 1) {
                event.preventDefault();
                if (this.followFocus && !tabHeadersArray[this.currentSelectedIndex + 1].disabled) {
                    tabHeadersArray[this.currentSelectedIndex + 1].selectTab();
                }
                else {
                    tabHeadersArray[this.currentSelectedIndex + 1].tabItem.nativeElement.focus();
                    this.currentSelectedIndex++;
                }
            }
            else {
                event.preventDefault();
                if (this.followFocus && !tabHeadersArray[0].disabled) {
                    tabHeadersArray[0].selectTab();
                }
                else {
                    tabHeadersArray[0].tabItem.nativeElement.focus();
                    this.currentSelectedIndex = 0;
                }
            }
        }
        if (event.key === "Left" || event.key === "ArrowLeft") {
            if (this.currentSelectedIndex > 0) {
                event.preventDefault();
                if (this.followFocus && !tabHeadersArray[this.currentSelectedIndex - 1].disabled) {
                    tabHeadersArray[this.currentSelectedIndex - 1].selectTab();
                }
                else {
                    tabHeadersArray[this.currentSelectedIndex - 1].tabItem.nativeElement.focus();
                    this.currentSelectedIndex--;
                }
            }
            else {
                event.preventDefault();
                if (this.followFocus && !tabHeadersArray[tabHeadersArray.length - 1].disabled) {
                    tabHeadersArray[tabHeadersArray.length - 1].selectTab();
                }
                else {
                    tabHeadersArray[tabHeadersArray.length - 1].tabItem.nativeElement.focus();
                    this.currentSelectedIndex = tabHeadersArray.length - 1;
                }
            }
        }
        if (event.key === "Home") {
            event.preventDefault();
            if (this.followFocus && !tabHeadersArray[0].disabled) {
                tabHeadersArray[0].selectTab();
            }
            else {
                tabHeadersArray[0].tabItem.nativeElement.focus();
                this.currentSelectedIndex = 0;
            }
        }
        if (event.key === "End") {
            event.preventDefault();
            if (this.followFocus && !tabHeadersArray[tabHeadersArray.length - 1].disabled) {
                tabHeadersArray[tabHeadersArray.length - 1].selectTab();
            }
            else {
                tabHeadersArray[tabHeadersArray.length - 1].tabItem.nativeElement.focus();
                this.currentSelectedIndex = tabHeadersArray.length - 1;
            }
        }
        // `"Spacebar"` is IE11 specific value
        if ((event.key === " " || event.key === "Spacebar") && !this.followFocus) {
            tabHeadersArray[this.currentSelectedIndex].selectTab();
        }
    }
    ngOnInit() {
        this.eventService.on(window, "resize", () => this.handleScroll());
    }
    ngAfterContentInit() {
        this.selectedSubscriptionTracker.unsubscribe();
        if (this.tabHeaderQuery) {
            this.tabHeaderQuery.toArray()
                .forEach(tabHeader => {
                tabHeader.cacheActive = this.cacheActive;
                tabHeader.paneTabIndex = this.isNavigation ? null : 0;
            });
        }
        const selectedSubscriptions = this.tabHeaderQuery.toArray().forEach(tabHeader => {
            tabHeader.selected.subscribe(() => {
                this.currentSelectedIndex = this.tabHeaderQuery.toArray().indexOf(tabHeader);
                // The Filter takes the current selected tab out, then all other headers are
                // deactivated and their associated pane references are also deactivated.
                this.tabHeaderQuery.toArray().filter(header => header !== tabHeader)
                    .forEach(filteredHeader => {
                    filteredHeader.active = false;
                    if (filteredHeader.paneReference) {
                        filteredHeader.paneReference.active = false;
                    }
                });
            });
        });
        this.selectedSubscriptionTracker.add(selectedSubscriptions);
        setTimeout(() => this.tabHeaderQuery.toArray()[this.currentSelectedIndex].selectTab());
    }
    ngOnChanges(changes) {
        if (this.tabHeaderQuery) {
            if (changes.cacheActive) {
                this.tabHeaderQuery.toArray().forEach(tabHeader => tabHeader.cacheActive = this.cacheActive);
            }
            if (changes.isNavigation) {
                this.tabHeaderQuery.toArray()
                    .forEach(tabHeader => tabHeader.paneTabIndex = this.isNavigation ? null : 0);
            }
        }
    }
    getSelectedTab() {
        const selected = this.tabHeaderQuery.toArray()[this.currentSelectedIndex];
        if (selected) {
            return selected;
        }
        return {
            headingIsTemplate: false,
            heading: ""
        };
    }
    handleScroll() {
        this.changeDetectorRef.markForCheck();
    }
    handleOverflowNavClick(direction, multiplier = 15) {
        const tabList = this.headerContainer.nativeElement;
        const { clientWidth, scrollLeft, scrollWidth } = tabList;
        if (direction === 1 && !scrollLeft) {
            tabList.scrollLeft += this.OVERFLOW_BUTTON_OFFSET;
        }
        tabList.scrollLeft += direction * multiplier;
        const leftEdgeReached = direction === -1 && scrollLeft < this.OVERFLOW_BUTTON_OFFSET;
        const rightEdgeReached = direction === 1 &&
            scrollLeft + clientWidth >= scrollWidth - this.OVERFLOW_BUTTON_OFFSET;
        if (leftEdgeReached) {
            this.rightOverflowNavButton.nativeElement.focus();
        }
        if (rightEdgeReached) {
            this.leftOverflowNavButton.nativeElement.focus();
        }
    }
    handleOverflowNavMouseDown(direction) {
        const tabList = this.headerContainer.nativeElement;
        this.overflowNavInterval = setInterval(() => {
            const { clientWidth, scrollLeft, scrollWidth } = tabList;
            // clear interval if scroll reaches left or right edge
            const leftEdgeReached = direction === -1 && scrollLeft < this.OVERFLOW_BUTTON_OFFSET;
            const rightEdgeReached = direction === 1 &&
                scrollLeft + clientWidth >= scrollWidth - this.OVERFLOW_BUTTON_OFFSET;
            if (leftEdgeReached || rightEdgeReached) {
                clearInterval(this.overflowNavInterval);
            }
            // account for overflow button appearing and causing tablist width change
            this.handleOverflowNavClick(direction);
        });
    }
    handleOverflowNavMouseUp() {
        clearInterval(this.overflowNavInterval);
    }
}
TabHeaderGroup.decorators = [
    { type: Component, args: [{
                selector: "ibm-tab-header-group",
                template: `
	<nav
		class="bx--tabs bx--tabs--scrollable"
		[ngClass]="{
			'bx--skeleton': skeleton,
			'bx--tabs--container bx--tabs--scrollable--container': type === 'container'
		}"
		role="navigation"
		[attr.aria-label]="ariaLabel"
		[attr.aria-labelledby]="ariaLabelledby">
		<button
			#leftOverflowNavButton
			type="button"
			[ngClass]="{
				'bx--tab--overflow-nav-button': hasHorizontalOverflow,
				'bx--tab--overflow-nav-button--hidden': leftOverflowNavButtonHidden
			}"
			(click)="handleOverflowNavClick(-1)"
			(mousedown)="handleOverflowNavMouseDown(-1)"
			(mouseup)="handleOverflowNavMouseUp()">
			<svg
				focusable="false"
				preserveAspectRatio="xMidYMid meet"
				xmlns="http://www.w3.org/2000/svg"
				fill="currentColor"
				width="16"
				height="16"
				viewBox="0 0 16 16"
				aria-hidden="true">
				<path d="M5 8L10 3 10.7 3.7 6.4 8 10.7 12.3 10 13z"></path>
			</svg>
		</button>
		<div *ngIf="!leftOverflowNavButtonHidden" class="bx--tabs__overflow-indicator--left"></div>
		<ul
			#tabList
			class="bx--tabs--scrollable__nav"
			role="tablist"
			(scroll)="handleScroll()">
			<li role="presentation">
				<ng-container *ngIf="contentBefore" [ngTemplateOutlet]="contentBefore"></ng-container>
			</li>
			<ng-content></ng-content>
			<li role="presentation">
				<ng-container *ngIf="contentAfter" [ngTemplateOutlet]="contentAfter"></ng-container>
			</li>
		</ul>
		<div *ngIf="!rightOverflowNavButtonHidden" class="bx--tabs__overflow-indicator--right"></div>
		<button
			#rightOverflowNavButton
			type="button"
			[ngClass]="{
				'bx--tab--overflow-nav-button': hasHorizontalOverflow,
				'bx--tab--overflow-nav-button--hidden': rightOverflowNavButtonHidden
			}"
			(click)="handleOverflowNavClick(1)"
			(mousedown)="handleOverflowNavMouseDown(1)"
			(mouseup)="handleOverflowNavMouseUp()">
			<svg
				focusable="false"
				preserveAspectRatio="xMidYMid meet"
				xmlns="http://www.w3.org/2000/svg"
				fill="currentColor"
				width="16"
				height="16"
				viewBox="0 0 16 16"
				aria-hidden="true">
				<path d="M11 8L6 13 5.3 12.3 9.6 8 5.3 3.7 6 3z"></path>
			</svg>
		</button>
	</nav>
	`
            }] }
];
/** @nocollapse */
TabHeaderGroup.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: EventService }
];
TabHeaderGroup.propDecorators = {
    followFocus: [{ type: Input }],
    skeleton: [{ type: Input }],
    ariaLabel: [{ type: Input }],
    ariaLabelledby: [{ type: Input }],
    contentAfter: [{ type: Input }],
    contentBefore: [{ type: Input }],
    cacheActive: [{ type: Input }],
    isNavigation: [{ type: Input }],
    type: [{ type: Input }],
    tabHeaderQuery: [{ type: ContentChildren, args: [TabHeader,] }],
    headerContainer: [{ type: ViewChild, args: ["tabList", { static: true },] }],
    rightOverflowNavButton: [{ type: ViewChild, args: ["rightOverflowNavButton", { static: true },] }],
    leftOverflowNavButton: [{ type: ViewChild, args: ["leftOverflowNavButton", { static: true },] }],
    keyboardInput: [{ type: HostListener, args: ["keydown", ["$event"],] }]
};

/**
 * The `TabHeaders` component contains the `Tab` items and controls scroll functionality
 * if content has overflow.
 */
class TabHeaders {
    constructor(elementRef, changeDetectorRef, eventService) {
        this.elementRef = elementRef;
        this.changeDetectorRef = changeDetectorRef;
        this.eventService = eventService;
        /**
         * Set to 'true' to have `Tab` items cached and not reloaded on tab switching.
         * Duplicate from `n-tabs` to support standalone headers
         */
        this.cacheActive = false;
        /**
         * Set to `true` to put tabs in a loading state.
         */
        this.skeleton = false;
        this.type = "default";
        /**
         * The index of the first visible tab.
         */
        this.firstVisibleTab = 0;
        // width of the overflow buttons
        this.OVERFLOW_BUTTON_OFFSET = 40;
    }
    get hasHorizontalOverflow() {
        const tabList = this.headerContainer.nativeElement;
        return tabList.scrollWidth > tabList.clientWidth;
    }
    get leftOverflowNavButtonHidden() {
        const tabList = this.headerContainer.nativeElement;
        return !this.hasHorizontalOverflow || !tabList.scrollLeft;
    }
    get rightOverflowNavButtonHidden() {
        const tabList = this.headerContainer.nativeElement;
        return !this.hasHorizontalOverflow ||
            (tabList.scrollLeft + tabList.clientWidth) === tabList.scrollWidth;
    }
    // keyboard accessibility
    /**
     * Controls the keydown events used for tabbing through the headings.
     */
    keyboardInput(event) {
        let tabsArray = Array.from(this.tabs);
        // "Right" is an ie11 specific value
        if (event.key === "Right" || event.key === "ArrowRight") {
            if (this.currentSelectedTab < this.allTabHeaders.length - 1) {
                event.preventDefault();
                if (this.followFocus) {
                    this.selectTab(event.target, tabsArray[this.currentSelectedTab + 1], this.currentSelectedTab);
                }
                this.allTabHeaders.toArray()[this.currentSelectedTab + 1].nativeElement.focus();
            }
            else {
                event.preventDefault();
                if (this.followFocus) {
                    this.selectTab(event.target, tabsArray[0], 0);
                }
                this.allTabHeaders.first.nativeElement.focus();
            }
        }
        // "Left" is an ie11 specific value
        if (event.key === "Left" || event.key === "ArrowLeft") {
            if (this.currentSelectedTab > 0) {
                event.preventDefault();
                if (this.followFocus) {
                    this.selectTab(event.target, tabsArray[this.currentSelectedTab - 1], this.currentSelectedTab);
                }
                this.allTabHeaders.toArray()[this.currentSelectedTab - 1].nativeElement.focus();
            }
            else {
                event.preventDefault();
                if (this.followFocus) {
                    this.selectTab(event.target, tabsArray[this.allTabHeaders.length - 1], this.allTabHeaders.length);
                }
                this.allTabHeaders.toArray()[this.allTabHeaders.length - 1].nativeElement.focus();
            }
        }
        if (event.key === "Home") {
            event.preventDefault();
            if (this.followFocus) {
                this.selectTab(event.target, tabsArray[0], 0);
            }
            this.allTabHeaders.toArray()[0].nativeElement.focus();
        }
        if (event.key === "End") {
            event.preventDefault();
            if (this.followFocus) {
                this.selectTab(event.target, tabsArray[this.allTabHeaders.length - 1], this.allTabHeaders.length);
            }
            this.allTabHeaders.toArray()[this.allTabHeaders.length - 1].nativeElement.focus();
        }
        // `"Spacebar"` is IE11 specific value
        if ((event.key === " " || event.key === "Spacebar") && !this.followFocus) {
            this.selectTab(event.target, tabsArray[this.currentSelectedTab], this.currentSelectedTab);
        }
    }
    ngOnInit() {
        this.eventService.on(window, "resize", () => this.handleScroll());
    }
    ngAfterContentInit() {
        if (!this.tabInput) {
            this.tabs = this.tabQuery;
        }
        else {
            this.tabs = this.tabInput;
        }
        this.tabs.forEach(tab => tab.cacheActive = this.cacheActive);
        this.tabs.changes.subscribe(() => {
            this.setFirstTab();
        });
        this.setFirstTab();
    }
    ngOnChanges(changes) {
        if (this.tabs && changes.cacheActive) {
            this.tabs.forEach(tab => tab.cacheActive = this.cacheActive);
        }
    }
    /**
     * Controls manually focusing tabs.
     */
    onTabFocus(ref, index) {
        this.currentSelectedTab = index;
        // reset scroll left because we're already handling it
        this.headerContainer.nativeElement.parentElement.scrollLeft = 0;
    }
    getSelectedTab() {
        const selected = this.tabs.find(tab => tab.active);
        if (selected) {
            return selected;
        }
        return { headingIsTemplate: false, heading: "" };
    }
    /**
     * Selects `Tab` 'tab' and moves it into view on the view DOM if it is not already.
     */
    selectTab(ref, tab, tabIndex) {
        if (tab.disabled) {
            return;
        }
        this.currentSelectedTab = tabIndex;
        this.tabs.forEach(_tab => _tab.active = false);
        tab.active = true;
        tab.doSelect();
    }
    handleScroll() {
        this.changeDetectorRef.markForCheck();
    }
    handleOverflowNavClick(direction, multiplier = 15) {
        const tabList = this.headerContainer.nativeElement;
        const { clientWidth, scrollLeft, scrollWidth } = tabList;
        if (direction === 1 && !scrollLeft) {
            tabList.scrollLeft += this.OVERFLOW_BUTTON_OFFSET;
        }
        tabList.scrollLeft += direction * multiplier;
        const leftEdgeReached = direction === -1 && scrollLeft < this.OVERFLOW_BUTTON_OFFSET;
        const rightEdgeReached = direction === 1 &&
            scrollLeft + clientWidth >= scrollWidth - this.OVERFLOW_BUTTON_OFFSET;
        if (leftEdgeReached) {
            this.rightOverflowNavButton.nativeElement.focus();
        }
        if (rightEdgeReached) {
            this.leftOverflowNavButton.nativeElement.focus();
        }
    }
    handleOverflowNavMouseDown(direction) {
        const tabList = this.headerContainer.nativeElement;
        this.overflowNavInterval = setInterval(() => {
            const { clientWidth, scrollLeft, scrollWidth } = tabList;
            // clear interval if scroll reaches left or right edge
            const leftEdgeReached = direction === -1 && scrollLeft < this.OVERFLOW_BUTTON_OFFSET;
            const rightEdgeReached = direction === 1 &&
                scrollLeft + clientWidth >= scrollWidth - this.OVERFLOW_BUTTON_OFFSET;
            if (leftEdgeReached || rightEdgeReached) {
                clearInterval(this.overflowNavInterval);
            }
            // account for overflow button appearing and causing tablist width change
            this.handleOverflowNavClick(direction);
        });
    }
    handleOverflowNavMouseUp() {
        clearInterval(this.overflowNavInterval);
    }
    /**
     * Determines which `Tab` is initially selected.
     */
    setFirstTab() {
        setTimeout(() => {
            let firstTab = this.tabs.find(tab => tab.active);
            if (!firstTab && this.tabs.first) {
                firstTab = this.tabs.first;
                firstTab.active = true;
            }
            if (firstTab) {
                firstTab.doSelect();
            }
        });
    }
}
TabHeaders.decorators = [
    { type: Component, args: [{
                selector: "ibm-tab-headers",
                template: `
		<nav
			class="bx--tabs--scrollable"
			[ngClass]="{
				'bx--skeleton': skeleton,
				'bx--tabs--container bx--tabs--scrollable--container': type === 'container'
			}"
			role="navigation"
			[attr.aria-label]="ariaLabel"
			[attr.aria-labelledby]="ariaLabelledby">
			<button
				#leftOverflowNavButton
				type="button"
				[ngClass]="{
					'bx--tab--overflow-nav-button': hasHorizontalOverflow,
					'bx--tab--overflow-nav-button--hidden': leftOverflowNavButtonHidden
				}"
				(click)="handleOverflowNavClick(-1)"
				(mousedown)="handleOverflowNavMouseDown(-1)"
				(mouseup)="handleOverflowNavMouseUp()">
				<svg
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					xmlns="http://www.w3.org/2000/svg"
					fill="currentColor"
					width="16"
					height="16"
					viewBox="0 0 16 16"
					aria-hidden="true">
					<path d="M5 8L10 3 10.7 3.7 6.4 8 10.7 12.3 10 13z"></path>
				</svg>
			</button>
			<div *ngIf="!leftOverflowNavButtonHidden" class="bx--tabs__overflow-indicator--left"></div>
			<ul
				#tabList
				class="bx--tabs--scrollable__nav"
				role="tablist"
				(scroll)="handleScroll()">
				<li role="presentation">
					<ng-container *ngIf="contentBefore" [ngTemplateOutlet]="contentBefore"></ng-container>
				</li>
				<li
					*ngFor="let tab of tabs; let i = index;"
					[ngClass]="{
						'bx--tabs__nav-item--selected bx--tabs--scrollable__nav-item--selected': tab.active,
						'bx--tabs__nav-item--disabled bx--tabs--scrollable__nav-item--disabled': tab.disabled
					}"
					class="bx--tabs--scrollable__nav-item"
					role="presentation"
					(click)="selectTab(tabItem, tab, i)">
					<button
						#tabItem
						[attr.aria-selected]="tab.active"
						[attr.tabindex]="(tab.active?0:-1)"
						[attr.aria-controls]="tab.id"
						[attr.aria-disabled]="tab.disabled"
						(focus)="onTabFocus(tabItem, i)"
						(click)="$event.preventDefault()"
						draggable="false"
						id="{{tab.id}}-header"
						class="bx--tabs--scrollable__nav-link"
						[title]="tab.title ? tab.title : tab.heading"
						href="#"
						role="tab">
						<ng-container *ngIf="!tab.headingIsTemplate">
							{{ tab.heading }}
						</ng-container>
						<ng-template
							*ngIf="tab.headingIsTemplate"
							[ngTemplateOutlet]="tab.heading"
							[ngTemplateOutletContext]="{$implicit: tab.context}">
						</ng-template>
					</button>
				</li>
				<li role="presentation">
					<ng-container *ngIf="contentAfter" [ngTemplateOutlet]="contentAfter"></ng-container>
				</li>
			</ul>
			<div *ngIf="!rightOverflowNavButtonHidden" class="bx--tabs__overflow-indicator--right"></div>
			<button
				#rightOverflowNavButton
				type="button"
				[ngClass]="{
					'bx--tab--overflow-nav-button': hasHorizontalOverflow,
					'bx--tab--overflow-nav-button--hidden': rightOverflowNavButtonHidden
				}"
				(click)="handleOverflowNavClick(1)"
				(mousedown)="handleOverflowNavMouseDown(1)"
				(mouseup)="handleOverflowNavMouseUp()">
				<svg
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					xmlns="http://www.w3.org/2000/svg"
					fill="currentColor"
					width="16"
					height="16"
					viewBox="0 0 16 16"
					aria-hidden="true">
					<path d="M11 8L6 13 5.3 12.3 9.6 8 5.3 3.7 6 3z"></path>
				</svg>
			</button>
		</nav>
	`
            }] }
];
/** @nocollapse */
TabHeaders.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: EventService }
];
TabHeaders.propDecorators = {
    tabInput: [{ type: Input, args: ["tabs",] }],
    cacheActive: [{ type: Input }],
    followFocus: [{ type: Input }],
    skeleton: [{ type: Input }],
    ariaLabel: [{ type: Input }],
    ariaLabelledby: [{ type: Input }],
    contentBefore: [{ type: Input }],
    contentAfter: [{ type: Input }],
    type: [{ type: Input }],
    headerContainer: [{ type: ViewChild, args: ["tabList", { static: true },] }],
    rightOverflowNavButton: [{ type: ViewChild, args: ["rightOverflowNavButton", { static: true },] }],
    leftOverflowNavButton: [{ type: ViewChild, args: ["leftOverflowNavButton", { static: true },] }],
    tabQuery: [{ type: ContentChildren, args: [Tab,] }],
    allTabHeaders: [{ type: ViewChildren, args: ["tabItem",] }],
    keyboardInput: [{ type: HostListener, args: ["keydown", ["$event"],] }]
};

/**
 * Build out your application's tabs using this component.
 * This is the parent of the `Tab` and `TabHeader` components.
 *
 * [See demo](../../?path=/story/tabs--basic)
 *
 * `Tabs` expects a set of `n-tab` elements
 *
 * ```html
 * <ibm-tabs>
 * 	<ibm-tab heading='tab1'>
 * 		tab 1 content
 * 	</ibm-tab>
 * 	<ibm-tab heading='tab1'>
 * 		tab 2 content
 * 	</ibm-tab>
 * 	<!-- ... -->
 * 	<ibm-tab heading='tab1'>
 * 		tab n content
 * 	</ibm-tab>
 * </ibm-tabs>
 * ```
 *
 * <example-url>../../iframe.html?id=tabs--basic</example-url>
 */
class Tabs {
    constructor() {
        /**
         * Takes either the string value 'top' or 'bottom' to place TabHeader
         * relative to the `TabPanel`s.
         */
        this.position = "top";
        /**
         * Set to 'true' to have `Tab` items cached and not reloaded on tab switching.
         */
        this.cacheActive = false;
        /**
         * Set to 'true' to have tabs automatically activated and have their content displayed when they receive focus.
         */
        this.followFocus = true;
        /**
         * Set to `true` to put tabs in a loading state.
         */
        this.skeleton = false;
        /**
         * Set to `true` to have the tabIndex of the all tabpanels be -1.
         */
        this.isNavigation = false;
        /**
         * Sets the type of the `TabHeader`s
         */
        this.type = "default";
    }
    /**
     * After content is initialized update `Tab`s to cache (if turned on) and set the initial
     * selected Tab item.
     */
    ngAfterContentInit() {
        if (this.tabHeaders) {
            this.tabHeaders.cacheActive = this.cacheActive;
        }
        this.tabs.forEach(tab => {
            tab.tabIndex = this.isNavigation ? null : 0;
        });
    }
    ngOnChanges(changes) {
        if (this.tabHeaders && changes.cacheActive) {
            this.tabHeaders.cacheActive = this.cacheActive;
        }
        if (this.tabs && changes.isNavigation) {
            this.tabs.forEach(tab => {
                tab.tabIndex = this.isNavigation ? null : 0;
            });
        }
    }
    /**
     * true if the n-tab's are passed directly to the component as children
     */
    hasTabHeaders() {
        return this.tabs.length > 0;
    }
}
Tabs.decorators = [
    { type: Component, args: [{
                selector: "ibm-tabs",
                template: `
			<ibm-tab-headers
				*ngIf="hasTabHeaders() && position === 'top'"
				[skeleton]="skeleton"
				[tabs]="tabs"
				[followFocus]="followFocus"
				[cacheActive]="cacheActive"
				[contentBefore]="before"
				[contentAfter]="after"
				[ariaLabel]="ariaLabel"
				[ariaLabelledby]="ariaLabelledby"
				[type]="type">
			</ibm-tab-headers>
			<ng-content></ng-content>
			<ng-template #before>
				<ng-content select="[before]"></ng-content>
			</ng-template>
			<ng-template #after>
				<ng-content select="[after]"></ng-content>
			</ng-template>
			<ibm-tab-headers
				*ngIf="hasTabHeaders() && position === 'bottom'"
				[skeleton]="skeleton"
				[tabs]="tabs"
				[cacheActive]="cacheActive"
				[type]="type">
			</ibm-tab-headers>
	`
            }] }
];
Tabs.propDecorators = {
    position: [{ type: Input }],
    cacheActive: [{ type: Input }],
    followFocus: [{ type: Input }],
    skeleton: [{ type: Input }],
    isNavigation: [{ type: Input }],
    ariaLabel: [{ type: Input }],
    ariaLabelledby: [{ type: Input }],
    type: [{ type: Input }],
    tabs: [{ type: ContentChildren, args: [Tab, { descendants: false },] }],
    tabHeaders: [{ type: ContentChild, args: [TabHeaders, { static: false },] }]
};

class TabsModule {
}
TabsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    Tabs,
                    Tab,
                    TabHeaders,
                    TabHeader,
                    TabHeaderGroup
                ],
                exports: [
                    Tabs,
                    Tab,
                    TabHeaders,
                    TabHeader,
                    TabHeaderGroup
                ],
                imports: [
                    CommonModule,
                    UtilsModule
                ]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { TabHeaderGroup, TabHeader, TabHeaders, Tab, Tabs, TabsModule };

//# sourceMappingURL=carbon-components-angular-tabs.js.map