/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-tiles.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Router } from '@angular/router';
import { merge } from 'carbon-components-angular/utils';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { Component, Input, Output, EventEmitter, Optional, ElementRef, ViewChild, HostListener, HostBinding, ContentChildren, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { I18n, I18nModule } from 'carbon-components-angular/i18n';
import { LinkModule } from 'carbon-components-angular/link';

/**
 * Build application's clickable tiles using this component.
 *
 * ## Basic usage
 *
 * ```html
 * <ibm-clickable-tile>
 * 		tile content
 * </ibm-clickable-tile>
 * ```
 */
class ClickableTile {
    constructor(router) {
        this.router = router;
        /**
         * Sets the `href` attribute on the `ibm-clickable-tile` element.
         */
        this.href = "#";
        /**
         * Set to `true` to disable the clickable tile.
         */
        this.disabled = false;
        /**
         * Emits the navigation status promise when the link is activated
         */
        this.navigation = new EventEmitter();
    }
    navigate(event) {
        if (this.router && this.route) {
            event.preventDefault();
            const status = this.router.navigate(this.route, this.routeExtras);
            this.navigation.emit(status);
        }
    }
}
ClickableTile.decorators = [
    { type: Component, args: [{
                selector: "ibm-clickable-tile",
                template: `
	<a
		ibmLink
		class="bx--tile bx--tile--clickable"
		tabindex="0"
		(click)="navigate($event)"
		[href]="href"
		[attr.target]="target"
		[attr.aria-disabled]="disabled">
		<ng-content></ng-content>
	</a>`
            }] }
];
/** @nocollapse */
ClickableTile.ctorParameters = () => [
    { type: Router, decorators: [{ type: Optional }] }
];
ClickableTile.propDecorators = {
    href: [{ type: Input }],
    target: [{ type: Input }],
    disabled: [{ type: Input }],
    route: [{ type: Input }],
    routeExtras: [{ type: Input }],
    navigation: [{ type: Output }]
};

class ExpandableTile {
    constructor(i18n, elementRef) {
        this.i18n = i18n;
        this.elementRef = elementRef;
        this.expanded = false;
        this.tileMaxHeight = 0;
        this.currentExpandedHeight = 0;
        this.element = this.elementRef.nativeElement;
        this.expand = this.i18n.getOverridable("TILES.EXPAND");
        this.collapse = this.i18n.getOverridable("TILES.COLLAPSE");
    }
    /**
     * Expects an object that contains some or all of:
     * ```
     * {
     *		"EXPAND": "Expand",
     *		"COLLAPSE": "Collapse",
     * }
     * ```
     */
    set translations(value) {
        const valueWithDefaults = merge(this.i18n.getMultiple("TILES"), value);
        this.expand.override(valueWithDefaults.EXPAND);
        this.collapse.override(valueWithDefaults.COLLAPSE);
    }
    ngAfterContentInit() {
        this.updateMaxHeight();
    }
    get expandedHeight() {
        const tile = this.element.querySelector(".bx--tile");
        const tilePadding = parseInt(getComputedStyle(tile).paddingBottom, 10) + parseInt(getComputedStyle(tile).paddingTop, 10);
        const expandedHeight = this.tileMaxHeight + tilePadding;
        if (!isNaN(expandedHeight)) {
            this.currentExpandedHeight = expandedHeight;
        }
        return this.currentExpandedHeight;
    }
    updateMaxHeight() {
        if (this.expanded) {
            this.tileMaxHeight = this.element.querySelector(".bx--tile-content").getBoundingClientRect().height;
        }
        else {
            this.tileMaxHeight = this.element.querySelector(".bx--tile-content__above-the-fold").getBoundingClientRect().height;
        }
    }
    onClick() {
        this.expanded = !this.expanded;
        this.updateMaxHeight();
    }
}
ExpandableTile.decorators = [
    { type: Component, args: [{
                selector: "ibm-expandable-tile",
                template: `
		<button
			class="bx--tile bx--tile--expandable"
			[ngClass]="{'bx--tile--is-expanded' : expanded}"
			[ngStyle]="{'max-height': expandedHeight + 'px'}"
			type="button"
			(click)="onClick()">
			<div class="bx--tile__chevron">
				<svg *ngIf="!expanded" width="12" height="7" viewBox="0 0 12 7" [attr.title]="expand.subject | async" role="img">
					<title>{{expand.subject | async}}</title>
					<path fill-rule="nonzero" d="M6.002 5.55L11.27 0l.726.685L6.003 7 0 .685.726 0z"/>
				</svg>
				<svg *ngIf="expanded" width="12" height="7" viewBox="0 0 12 7" [attr.title]="collapse.subject | async" role="img">
					<title>{{collapse.subject | async}}</title>
					<path fill-rule="nonzero" d="M6.002 5.55L11.27 0l.726.685L6.003 7 0 .685.726 0z"/>
				</svg>
			</div>
			<div class="bx--tile-content">
				<ng-content select=".bx--tile-content__above-the-fold"></ng-content>
				<ng-content select=".bx--tile-content__below-the-fold"></ng-content>
			</div>
		</button>
	`
            }] }
];
/** @nocollapse */
ExpandableTile.ctorParameters = () => [
    { type: I18n },
    { type: ElementRef }
];
ExpandableTile.propDecorators = {
    expanded: [{ type: Input }],
    translations: [{ type: Input }]
};

class SelectionTile {
    constructor(i18n) {
        this.i18n = i18n;
        /**
         * The unique id for the input.
         */
        this.id = `tile-${SelectionTile.tileCount}`;
        /**
         * Internal event used to notify the containing `TileGroup` of changes.
         */
        this.change = new EventEmitter();
        /**
         * Set by the containing `TileGroup`. Used for the `name` property on the input.
         */
        this.name = "tile-group-unbound";
        /**
         * Defines whether or not the `SelectionTile` supports selecting multiple tiles as opposed to single
         * tile selection.
         */
        this.multiple = true; // Set to true because of the way tile group sets it up.
        // If an initial selected value is set before input exists, we save
        // the value and check again when input exists in `AfterViewInit`.
        this._selected = null;
        SelectionTile.tileCount++;
    }
    /**
     * Updating the state of the input to match the state of the parameter passed in.
     * Set to `true` if this tile should be selected.
     */
    set selected(value) {
        // If an initial selected value is set before input exists, we save
        // the value and check again when input exists in `AfterViewInit`.
        this._selected = value ? true : null;
        if (this.input) {
            this.input.nativeElement.checked = this._selected;
        }
    }
    get selected() {
        return this.input ? this.input.nativeElement.checked : false;
    }
    ngAfterViewInit() {
        if (this.input) {
            setTimeout(() => {
                this.input.nativeElement.checked = this._selected;
            });
        }
    }
    keyboardInput(event) {
        if (event.key === "Enter" || event.key === "Spacebar" || event.key === " ") {
            this.selected = !this.selected;
            this.change.emit(event);
        }
    }
    onChange(event) {
        this.change.emit(event);
    }
}
SelectionTile.tileCount = 0;
SelectionTile.decorators = [
    { type: Component, args: [{
                selector: "ibm-selection-tile",
                template: `
		<label
			class="bx--tile bx--tile--selectable"
			tabindex="0"
			[for]="id"
			[ngClass]="{'bx--tile--is-selected' : selected}"
			[attr.aria-label]="i18n.get('TILES.TILE') | async">
			<input
				#input
				tabindex="-1"
				class="bx--tile-input"
				[id]="id"
				[type]="(multiple ? 'checkbox': 'radio')"
				[value]="value"
				[name]="name"
				(change)="onChange($event)"/>
			<div class="bx--tile__checkmark">
				<svg width="16" height="16" viewBox="0 0 16 16">
					<path d="M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16zm3.646-10.854L6.75 10.043 4.354 7.646l-.708.708 3.104 3.103 5.604-5.603-.708-.708z"
						fill-rule="evenodd"/>
				</svg>
			</div>
			<div class="bx--tile-content">
				<ng-content></ng-content>
			</div>
		</label>
	`
            }] }
];
/** @nocollapse */
SelectionTile.ctorParameters = () => [
    { type: I18n }
];
SelectionTile.propDecorators = {
    id: [{ type: Input }],
    selected: [{ type: Input }],
    value: [{ type: Input }],
    change: [{ type: Output }],
    input: [{ type: ViewChild, args: ["input", { static: true },] }],
    keyboardInput: [{ type: HostListener, args: ["keydown", ["$event"],] }]
};

class TileGroup {
    constructor() {
        /**
         * The tile group `name`
         */
        this.name = `tile-group-${TileGroup.tileGroupCount}`;
        /**
         * Set to `true` to support multiple tile selection
         */
        this.multiple = false;
        /**
         * Emits an event when the tile selection changes.
         *
         * Emits an object that looks like:
         * ```javascript
         * {
         * 	value: "something",
         * 	selected: true,
         * 	name: "tile-group-1"
         * }
         * ```
         */
        this.selected = new EventEmitter();
        this.tileGroupClass = true;
        this.unsubscribe$ = new Subject();
        this.unsubscribeTiles$ = new Subject();
        this.onChange = (_) => { };
        this.onTouched = () => { };
        TileGroup.tileGroupCount++;
    }
    ngAfterContentInit() {
        const updateTiles = () => {
            // remove old subscriptions
            this.unsubscribeTiles$.next();
            // react to changes
            // setTimeout to avoid ExpressionChangedAfterItHasBeenCheckedError
            setTimeout(() => {
                this.selectionTiles.forEach(tile => {
                    tile.name = this.name;
                    tile.change
                        .pipe(takeUntil(this.unsubscribeTiles$))
                        .subscribe(() => {
                        this.selected.emit({
                            value: tile.value,
                            selected: tile.selected,
                            name: this.name
                        });
                        this.onChange(tile.value);
                    });
                    tile.multiple = this.multiple;
                });
            });
        };
        updateTiles();
        this.selectionTiles.changes
            .pipe(takeUntil(this.unsubscribe$))
            .subscribe(_ => updateTiles());
    }
    ngOnDestroy() {
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
        // takes care of tile subscriptions when tile-group dies
        this.unsubscribeTiles$.next();
        this.unsubscribeTiles$.complete();
    }
    writeValue(value) {
        if (!this.selectionTiles) {
            return;
        }
        this.selectionTiles.forEach(tile => {
            if (tile.value === value) {
                tile.selected = true;
            }
            else {
                tile.selected = false;
            }
        });
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
}
TileGroup.tileGroupCount = 0;
TileGroup.decorators = [
    { type: Component, args: [{
                selector: "ibm-tile-group",
                template: `<ng-content select="ibm-selection-tile"></ng-content>`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: TileGroup,
                        multi: true
                    }
                ]
            }] }
];
/** @nocollapse */
TileGroup.ctorParameters = () => [];
TileGroup.propDecorators = {
    name: [{ type: Input }],
    multiple: [{ type: Input }],
    selected: [{ type: Output }],
    tileGroupClass: [{ type: HostBinding, args: ["class.bx--tile-group",] }],
    selectionTiles: [{ type: ContentChildren, args: [SelectionTile,] }]
};

/**
 * Build application's tiles using this component.
 *
 * [See demo](../../?path=/story/tiles--basic)
 *
 * ## Basic usage
 *
 * ```html
 * <ibm-tile>
 * 		tile content
 * </ibm-tile>
 * ```
 *
 * <example-url>../../iframe.html?id=tiles--basic</example-url>
 */
class Tile {
    constructor() {
        this.tileClass = true;
        this.theme = "dark";
    }
    get lightThemeEnabled() {
        return this.theme === "light";
    }
}
Tile.decorators = [
    { type: Component, args: [{
                selector: "ibm-tile",
                template: `<ng-content></ng-content>`
            }] }
];
Tile.propDecorators = {
    tileClass: [{ type: HostBinding, args: ["class.bx--tile",] }],
    lightThemeEnabled: [{ type: HostBinding, args: ["class.bx--tile--light",] }],
    theme: [{ type: Input }]
};

class TilesModule {
}
TilesModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    Tile,
                    ClickableTile,
                    ExpandableTile,
                    SelectionTile,
                    TileGroup
                ],
                exports: [
                    Tile,
                    ClickableTile,
                    ExpandableTile,
                    SelectionTile,
                    TileGroup
                ],
                imports: [
                    CommonModule,
                    I18nModule,
                    LinkModule
                ]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { ClickableTile, ExpandableTile, SelectionTile, TileGroup, Tile, TilesModule };

//# sourceMappingURL=carbon-components-angular-tiles.js.map