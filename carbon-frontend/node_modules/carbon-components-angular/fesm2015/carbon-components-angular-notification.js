/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-notification.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { of, isObservable } from 'rxjs';
import { ButtonModule } from 'carbon-components-angular/button';
import { CommonModule } from '@angular/common';
import { Injectable, ApplicationRef, Directive, HostBinding, Component, Input, Output, EventEmitter, ViewChild, ComponentFactoryResolver, Injector, NgZone, NgModule } from '@angular/core';
import { I18n, I18nModule } from 'carbon-components-angular/i18n';
import { ExperimentalService, ExperimentalModule } from 'carbon-components-angular/experimental';
import { LinkModule } from 'carbon-components-angular/link';
import { IconModule } from 'carbon-components-angular/icon';

class NotificationDisplayService {
    constructor(applicationRef) {
        this.applicationRef = applicationRef;
    }
    /**
     * Programatically closes notification based on `notificationRef`.	 *
     */
    close(notificationRef) {
        if (notificationRef.hostView) {
            setTimeout(() => {
                this.applicationRef.detachView(notificationRef.hostView);
                notificationRef.destroy();
            }, 200);
        }
    }
}
NotificationDisplayService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NotificationDisplayService.ctorParameters = () => [
    { type: ApplicationRef }
];

class NotificationSubtitle {
    constructor() {
        this.baseClass = true;
    }
}
NotificationSubtitle.decorators = [
    { type: Directive, args: [{
                selector: "[ibmNotificationSubtitle]"
            },] }
];
NotificationSubtitle.propDecorators = {
    baseClass: [{ type: HostBinding, args: ["class.bx--inline-notification__subtitle",] }]
};

class NotificationTitle {
    constructor() {
        this.baseClass = true;
    }
}
NotificationTitle.decorators = [
    { type: Directive, args: [{
                selector: "[ibmNotificationTitle]"
            },] }
];
NotificationTitle.propDecorators = {
    baseClass: [{ type: HostBinding, args: ["class.bx--inline-notification__title",] }]
};

/**
 * Notification messages are displayed toward the top of the UI and do not interrupt user’s work.
 *
 * [See demo](../../?path=/story/notification--basic)
 *
 * <example-url>../../iframe.html?id=notification--basic</example-url>
 */
class Notification {
    constructor(notificationDisplayService, i18n) {
        this.notificationDisplayService = notificationDisplayService;
        this.i18n = i18n;
        /**
         * Emits on close.
         */
        this.close = new EventEmitter();
        this.notificationID = `notification-${Notification.notificationCount++}`;
        this.notificationClass = true;
        this.role = "alert";
        this.defaultNotificationObj = {
            title: "",
            message: "",
            type: "info",
            showClose: true,
            closeLabel: this.i18n.get("NOTIFICATION.CLOSE_BUTTON")
        };
        this._notificationObj = Object.assign({}, this.defaultNotificationObj);
    }
    /**
     * Can have `type`, `title`, and `message` members.
     *
     * `type` can be one of `"info"`, `"warning"`, `"error"`, `"success"`
     *
     * `message` is the message to display
     */
    get notificationObj() {
        return this._notificationObj;
    }
    set notificationObj(obj) {
        if (obj.closeLabel) {
            obj.closeLabel = of(obj.closeLabel);
        }
        this._notificationObj = Object.assign({}, this.defaultNotificationObj, obj);
    }
    get isError() { return this.notificationObj.type === "error"; }
    get isInfo() { return this.notificationObj.type === "info"; }
    get isSuccess() { return this.notificationObj.type === "success"; }
    get isWarning() { return this.notificationObj.type === "warning"; }
    get isLowContrast() { return this.notificationObj.lowContrast; }
    get isCloseHidden() { return !this._notificationObj.showClose; }
    /**
     * Emits close event.
     */
    onClose() {
        this.close.emit();
    }
    onClick(action, event) {
        if (!action.click) {
            return;
        }
        if (isObservable(action.click)) {
            action.click.next({ event, action });
        }
        else {
            action.click({ event, action });
        }
    }
    destroy() {
        this.notificationDisplayService.close(this);
    }
}
Notification.notificationCount = 0;
Notification.decorators = [
    { type: Component, args: [{
                selector: "ibm-notification",
                template: `
		<div class="bx--inline-notification__details">
			<svg
				ibmIcon="error--filled"
				size="16"
				*ngIf="notificationObj.type === 'error'"
				class="bx--inline-notification__icon">
			</svg>
			<svg
				ibmIcon="warning--filled"
				size="16"
				*ngIf="notificationObj.type === 'warning'"
				class="bx--inline-notification__icon">
			</svg>
			<svg
				ibmIcon="checkmark--filled"
				size="16"
				*ngIf="notificationObj.type === 'success'"
				class="bx--inline-notification__icon">
			</svg>
			<svg
				ibmIcon="information--filled"
				size="16"
				*ngIf="notificationObj.type === 'info'"
				class="bx--inline-notification__icon">
			</svg>
			<div class="bx--inline-notification__text-wrapper">
				<p *ngIf="!notificationObj.template" ibmNotificationTitle [innerHTML]="notificationObj.title"></p>
				<div *ngIf="!notificationObj.template" ibmNotificationSubtitle>
					<span [innerHTML]="notificationObj.message"></span>
					<ng-container *ngFor="let link of notificationObj.links">
						<a ibmLink [href]="link.href"> {{link.text}}</a>
					</ng-container>
				</div>
				<ng-container *ngTemplateOutlet="notificationObj.template; context: { $implicit: notificationObj}"></ng-container>
			</div>
		</div>
		<div *ngFor="let action of notificationObj.actions">
			<button
				(click)="onClick(action, $event)"
				ibmButton="ghost"
				size="sm"
				class="bx--inline-notification__action-button"
				type="button">
				{{action.text}}
			</button>
		</div>
		<button
			*ngIf="!isCloseHidden"
			(click)="onClose()"
			class="bx--inline-notification__close-button"
			[attr.aria-label]="notificationObj.closeLabel | async"
			type="button">
			<svg ibmIcon="close" size="16" class="bx--inline-notification__close-icon"></svg>
		</button>
	`
            }] }
];
/** @nocollapse */
Notification.ctorParameters = () => [
    { type: NotificationDisplayService },
    { type: I18n }
];
Notification.propDecorators = {
    notificationObj: [{ type: Input }],
    close: [{ type: Output }],
    notification: [{ type: ViewChild, args: ["notification", { static: false },] }],
    notificationID: [{ type: HostBinding, args: ["attr.id",] }],
    notificationClass: [{ type: HostBinding, args: ["class.bx--inline-notification",] }],
    role: [{ type: HostBinding, args: ["attr.role",] }],
    isError: [{ type: HostBinding, args: ["class.bx--inline-notification--error",] }],
    isInfo: [{ type: HostBinding, args: ["class.bx--inline-notification--info",] }],
    isSuccess: [{ type: HostBinding, args: ["class.bx--inline-notification--success",] }],
    isWarning: [{ type: HostBinding, args: ["class.bx--inline-notification--warning",] }],
    isLowContrast: [{ type: HostBinding, args: ["class.bx--inline-notification--low-contrast",] }],
    isCloseHidden: [{ type: HostBinding, args: ["class.bx--inline-notification--hide-close-button",] }]
};

/**
 * Toast messages are displayed toward the top of the UI and do not interrupt user’s work.
 *
 * [See demo](../../?path=/story/notification--toast)
 *
 * <example-url>../../iframe.html?id=notification--toast</example-url>
 */
class Toast extends Notification {
    constructor(notificationDisplayService, i18n, experimental) {
        super(notificationDisplayService, i18n);
        this.notificationDisplayService = notificationDisplayService;
        this.i18n = i18n;
        this.experimental = experimental;
        this.toastID = `toast-${Toast.toastCount++}`;
        this.toastClass = true;
        this.role = "alert";
        // disable inline notification styles
        this.notificationClass = false;
    }
    get isError() { return this.notificationObj["type"] === "error"; }
    get isInfo() { return this.notificationObj["type"] === "info"; }
    get isSuccess() { return this.notificationObj["type"] === "success"; }
    get isWarning() { return this.notificationObj["type"] === "warning"; }
    get isLowContrast() { return this.notificationObj.lowContrast; }
    ngOnInit() {
        if (!this.notificationObj.closeLabel) {
            this.notificationObj.closeLabel = this.i18n.get().NOTIFICATION.CLOSE_BUTTON;
        }
    }
}
Toast.toastCount = 0;
Toast.decorators = [
    { type: Component, args: [{
                selector: "ibm-toast",
                template: `
		<svg
			ibmIcon="error--filled"
			size="16"
			*ngIf="notificationObj.type === 'error'"
			class="bx--toast-notification__icon">
		</svg>
		<svg
			ibmIcon="warning--filled"
			size="16"
			*ngIf="notificationObj.type === 'warning'"
			class="bx--toast-notification__icon">
		</svg>
		<svg
			ibmIcon="checkmark--filled"
			size="16"
			*ngIf="notificationObj.type === 'success'"
			class="bx--toast-notification__icon">
		</svg>
		<svg
			ibmIcon="information--filled"
			size="16"
			*ngIf="notificationObj.type === 'info'"
			class="bx--toast-notification__icon">
		</svg>
		<div class="bx--toast-notification__details">
			<h3 *ngIf="!notificationObj.template" ibmToastTitle [innerHTML]="notificationObj.title"></h3>
			<div *ngIf="!notificationObj.template" ibmToastSubtitle>
				<span [innerHTML]="notificationObj.subtitle"></span>
				<ng-container *ngFor="let link of notificationObj.links">
					<a ibmLink [href]="link.href"> {{link.text}}</a>
				</ng-container>
			</div>
			<p *ngIf="!notificationObj.template" ibmToastCaption [innerHTML]="notificationObj.caption"></p>
			<ng-container *ngTemplateOutlet="notificationObj.template; context: { $implicit: notificationObj}"></ng-container>
		</div>
		<button
			*ngIf="!isCloseHidden"
			class="bx--toast-notification__close-button"
			type="button"
			[attr.aria-label]="notificationObj.closeLabel"
			(click)="onClose()">
			<svg ibmIcon="close" size="16" class="bx--toast-notification__close-icon"></svg>
		</button>
	`
            }] }
];
/** @nocollapse */
Toast.ctorParameters = () => [
    { type: NotificationDisplayService },
    { type: I18n },
    { type: ExperimentalService }
];
Toast.propDecorators = {
    notificationObj: [{ type: Input }],
    toastID: [{ type: HostBinding, args: ["attr.id",] }],
    toastClass: [{ type: HostBinding, args: ["class.bx--toast-notification",] }],
    role: [{ type: HostBinding, args: ["attr.role",] }],
    isError: [{ type: HostBinding, args: ["class.bx--toast-notification--error",] }],
    isInfo: [{ type: HostBinding, args: ["class.bx--toast-notification--info",] }],
    isSuccess: [{ type: HostBinding, args: ["class.bx--toast-notification--success",] }],
    isWarning: [{ type: HostBinding, args: ["class.bx--toast-notification--warning",] }],
    isLowContrast: [{ type: HostBinding, args: ["class.bx--toast-notification--low-contrast",] }]
};

class ToastTitle {
    constructor() {
        this.baseClass = true;
    }
}
ToastTitle.decorators = [
    { type: Directive, args: [{
                selector: "[ibmToastTitle]"
            },] }
];
ToastTitle.propDecorators = {
    baseClass: [{ type: HostBinding, args: ["class.bx--toast-notification__title",] }]
};

class ToastSubtitle {
    constructor() {
        this.baseClass = true;
    }
}
ToastSubtitle.decorators = [
    { type: Directive, args: [{
                selector: "[ibmToastSubtitle]"
            },] }
];
ToastSubtitle.propDecorators = {
    baseClass: [{ type: HostBinding, args: ["class.bx--toast-notification__subtitle",] }]
};

class ToastCaption {
    constructor() {
        this.baseClass = true;
    }
}
ToastCaption.decorators = [
    { type: Directive, args: [{
                selector: "[ibmToastCaption]"
            },] }
];
ToastCaption.propDecorators = {
    baseClass: [{ type: HostBinding, args: ["class.bx--toast-notification__caption",] }]
};

/**
 * Provides a way to use the notification component.
 *
 * Notifications are displayed toward the top of the UI and do not interrupt the user’s work.
 */
class NotificationService {
    /**
     * Constructs NotificationService.
     *
     * @param injector
     * @param componentFactoryResolver
     * @param applicationRef
     */
    constructor(injector, componentFactoryResolver, applicationRef, ngZone) {
        this.injector = injector;
        this.componentFactoryResolver = componentFactoryResolver;
        this.applicationRef = applicationRef;
        this.ngZone = ngZone;
        /**
         * An array containing `ComponentRef`s to all the notifications this service instance
         * is responsible for.
         *
         */
        this.notificationRefs = new Array();
        this.onClose = new EventEmitter();
    }
    /**
     * Shows the notification based on the `notificationObj`.
     *
     * @param notificationObj Can have `type`, `message`, `target`, `duration` and `smart` members.
     *
     * **Members:**
     *
     * * `type` can be one of `"info"`, `"warning"`, `"danger"`, `"success"`
     * * `message` is message for notification to display
     * * `target` is css selector defining an element to append notification to. If not provided,
     * `showNotification()` creates a place for the notification in `body`
     * * `duration` is number of ms to close the notification after. If used in combination with `smart`,
     * it's added to the calculated timeout
     * * `smart`, set to `true` if you want to use smart notification.
     *
     * **Example:**
     * ```typescript
     * // Info notification, saying "Sample message." added to the element with id notification-container
     * // uses smart timeout with added duration of 1 second.
     * {
     *	type: "info",
     *	message: "Sample message.",
     *	target: "#notification-container",
     *	duration: 1000,
     *	smart: true
     * }
     * ```
     *
     * @param [notificationComp=Notification] If provided, used to resolve component factory
     */
    showNotification(notificationObj, notificationComp = Notification) {
        const componentFactory = this.componentFactoryResolver.resolveComponentFactory(notificationComp);
        let notificationRef = componentFactory.create(this.injector);
        notificationRef.instance.notificationObj = notificationObj; // typescript isn't being very smart here, so we type to any
        this.notificationRefs.push(notificationRef);
        this.onClose = notificationRef.instance.close;
        this.applicationRef.attachView(notificationRef.hostView);
        if (notificationObj.target) {
            document.querySelector(notificationObj.target).appendChild(notificationRef.location.nativeElement);
        }
        else {
            let body = document.querySelector("body");
            // get or create a container for alert list
            let notificationClassName = "notification-overlay";
            let notificationList = body.querySelector(`.${notificationClassName}`);
            if (!notificationList) {
                notificationList = document.createElement("div");
                notificationList.className = notificationClassName;
                body.appendChild(notificationList);
            }
            // add the notification to the top of the list
            if (notificationList.firstChild) {
                notificationList.insertBefore(notificationRef.location.nativeElement, notificationList.firstChild);
            }
            else {
                notificationList.appendChild(notificationRef.location.nativeElement);
            }
        }
        if (notificationObj.duration && notificationObj.duration > 0) {
            this.ngZone.runOutsideAngular(() => {
                setTimeout(() => {
                    this.ngZone.run(() => {
                        this.close(notificationRef);
                    });
                }, notificationObj.duration);
            });
        }
        if (notificationObj.smart) {
            this.ngZone.runOutsideAngular(() => {
                // let it disappear after calculated timeout
                setTimeout(() => {
                    this.ngZone.run(() => {
                        this.close(notificationRef);
                    });
                }, this.getSmartTimeout(notificationObj));
            });
        }
        this.onClose.subscribe(() => {
            this.close(notificationRef);
        });
        notificationRef.instance.componentRef = notificationRef;
        return notificationRef.instance;
    }
    showToast(notificationObj, notificationComp = Toast) {
        return this.showNotification(notificationObj, notificationComp);
    }
    /**
     * Programatically closes notification based on `notificationRef`.
     *
     * @param notificationRef `ComponentRef` of a notification or `Notification` component you wish to close
     */
    close(notificationRef) {
        if (notificationRef) {
            if (notificationRef instanceof Notification) {
                this.close(notificationRef.componentRef);
            }
            else {
                this.applicationRef.detachView(notificationRef.hostView);
                notificationRef.destroy();
                const index = this.notificationRefs.indexOf(notificationRef);
                if (index !== -1) {
                    this.notificationRefs.splice(index, 1);
                }
            }
        }
    }
    /**
     * Calculates the amount of time user needs to read the message in the notification.
     *
     * @param notificationObj Same object used to instantiate notification.
     *
     * In addition to `type` and `message` members, use `duration` member to add
     * some extra time (in ms) to timeout if you need to.
     * @returns calculated timeout (in ms) for smart notification
     */
    getSmartTimeout(notificationObj) {
        // calculate timeout
        let timeout = 600; // start with reaction time
        // custom duration
        timeout += notificationObj.duration || 0;
        // message type
        switch (notificationObj.type) {
            case "info":
            case "success":
            default: {
                break;
            }
            case "danger": {
                timeout += 3000;
                break;
            }
            case "warning": {
                timeout += 1500;
                break;
            }
        }
        // message length
        // average reader reads around 200 words per minute, or it takes them ~0.3s per word
        // let's use 1.5 factor for below average speed readers and have 0.45s per word
        let wordCount = notificationObj.message.trim().split(/\s+/).length;
        timeout += wordCount * 450;
        return timeout;
    }
    /**
     * OnDestroy hook.
     *
     * Destroys all living notifications it is responsible for.
     *
     */
    ngOnDestroy() {
        if (this.notificationRefs.length > 0) {
            for (let i = 0; i < this.notificationRefs.length; i++) {
                let notificationRef = this.notificationRefs[i];
                this.applicationRef.detachView(notificationRef.hostView);
                notificationRef.destroy();
            }
            this.notificationRefs.length = 0;
        }
    }
}
NotificationService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NotificationService.ctorParameters = () => [
    { type: Injector },
    { type: ComponentFactoryResolver },
    { type: ApplicationRef },
    { type: NgZone }
];

class NotificationModule {
}
NotificationModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    Notification,
                    Toast,
                    ToastTitle,
                    ToastSubtitle,
                    ToastCaption,
                    NotificationTitle,
                    NotificationSubtitle
                ],
                exports: [
                    Notification,
                    Toast,
                    ToastTitle,
                    ToastSubtitle,
                    ToastCaption,
                    NotificationTitle,
                    NotificationSubtitle
                ],
                entryComponents: [Notification, Toast],
                imports: [
                    ButtonModule,
                    CommonModule,
                    I18nModule,
                    ExperimentalModule,
                    LinkModule,
                    IconModule
                ],
                providers: [NotificationService, NotificationDisplayService]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { NotificationDisplayService, NotificationSubtitle, NotificationTitle, Notification, NotificationModule, NotificationService, ToastCaption, ToastSubtitle, ToastTitle, Toast };

//# sourceMappingURL=carbon-components-angular-notification.js.map