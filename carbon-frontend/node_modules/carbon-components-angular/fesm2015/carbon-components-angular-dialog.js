/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-dialog.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Subscription } from 'rxjs';
import { tabbableSelector, cycleTabs, getFocusElementList, isFocusInLastItem, isFocusInFirstItem } from 'carbon-components-angular/common';
import Position, { position } from '@carbon/utils-position';
import { Injector, ComponentFactoryResolver, Injectable, Component, Input, Output, EventEmitter, ElementRef, ViewChild, HostListener, Optional, Directive, ViewContainerRef, HostBinding, TemplateRef, ContentChild, ViewEncapsulation, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { I18n, I18nModule } from 'carbon-components-angular/i18n';
import { PlaceholderService, PlaceholderModule } from 'carbon-components-angular/placeholder';
import { ExperimentalService, ExperimentalModule } from 'carbon-components-angular/experimental';
import { AnimationFrameService, ElementService, EventService, closestAttr, UtilsModule } from 'carbon-components-angular/utils';
import { IconModule } from 'carbon-components-angular/icon';

/**
 * An enum of the various reasons a dialog may close. For use with `CloseMeta` and `shouldClose`
 *
 * It's expected that `interaction` will be a common closure reason.
 */
var CloseReasons;
(function (CloseReasons) {
    /**
     * For when the component is closed by being destroyed
     */
    CloseReasons[CloseReasons["destroyed"] = 0] = "destroyed";
    /**
     * For use in cases where the dialog closes for programmatic reasons other than destruction
     */
    CloseReasons[CloseReasons["programmatic"] = 1] = "programmatic";
    /**
     * interaction reasons will also provide a target for the interaction
     */
    CloseReasons[CloseReasons["interaction"] = 2] = "interaction";
    /**
     * For use in cases where the dialog closes due to being hidden
     */
    CloseReasons[CloseReasons["hidden"] = 3] = "hidden";
})(CloseReasons || (CloseReasons = {}));

/**
 * `Dialog` object to be injected into other components.
 */
class DialogService {
    /**
     * Creates an instance of `DialogService`.
     */
    constructor(componentFactoryResolver, injector, placeholderService) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.injector = injector;
        this.placeholderService = placeholderService;
    }
    /**
     * Closes all known `Dialog`s. Does not focus any previous elements, since we can't know which would be correct
     */
    static closeAll() {
        DialogService.dialogRefs.forEach(ref => ref.instance.doClose({
            reason: CloseReasons.programmatic
        }));
        DialogService.dialogRefs.clear();
    }
    /**
     * Set the context for the service. For example, the `component` property can be used to set the
     * default component that should be created by the service, for a given instance of the service.
     * @param options `{ component: any }` where `component` is a component that extends `dialog.component`
     */
    setContext(options) {
        this.componentFactory = this.componentFactoryResolver.resolveComponentFactory(options.component);
    }
    /**
     * If `dialogRef` is defined, the Dialog is already open. If
     * `dialogRef` is undefined, we create the `Dialog` component and reference to it.
     * A subscription is created to track if the `Dialog` should close.
     *
     * @param viewContainer a `ViewContainerRef` to instantiate the component against.
     * May be `null` if an `ibm-placeholder` exists and `dialogConfig.appendInline` is false
     * @param dialogConfig the `DialogConfig` for the component
     */
    open(viewContainer, dialogConfig, component) {
        let componentFactory = this.componentFactory;
        if (component) {
            componentFactory = this.componentFactoryResolver.resolveComponentFactory(component);
        }
        let dialogRef;
        if (dialogConfig.appendInline) {
            // add our component to the view
            dialogRef = viewContainer.createComponent(componentFactory, 0, this.injector);
        }
        else if (!this.placeholderService.hasPlaceholderRef()) {
            dialogRef = viewContainer.createComponent(componentFactory, 0, this.injector);
            if (dialogRef) {
                setTimeout(() => {
                    window.document.querySelector("body").appendChild(dialogRef.location.nativeElement);
                });
            }
        }
        else {
            dialogRef = this.placeholderService.createComponent(componentFactory, this.injector);
        }
        // keep track of all initialized dialogs
        DialogService.dialogRefs.add(dialogRef);
        // initialize some extra options
        dialogConfig["previouslyFocusedElement"] = document.activeElement;
        dialogRef.instance.dialogConfig = dialogConfig;
        dialogRef.instance.elementRef.nativeElement.focus();
        return dialogRef;
    }
    /**
     * On close of `Dialog` item, sets focus back to previous item, unsets
     * the current `dialogRef` item. Unsubscribes to the event of `Dialog` close.
     *
     * @param dialogRef the dialogRef to close
     */
    close(dialogRef) {
        // to handle the case where we have a null `this.dialogRef`
        if (!dialogRef) {
            return;
        }
        const elementToFocus = dialogRef.instance.dialogConfig["previouslyFocusedElement"];
        dialogRef.destroy();
        // update the globally tracked dialogRefs
        if (DialogService.dialogRefs.has(dialogRef)) {
            DialogService.dialogRefs.delete(dialogRef);
        }
        // Keeps the focus on the dialog trigger if there are no focusable elements. Change focus to previously focused element
        // if there are focusable elements in the dialog.
        if (!dialogRef.location.nativeElement.querySelectorAll(tabbableSelector)) {
            elementToFocus.focus();
        }
    }
    /**
     * Closes all known `Dialog`s. Does not focus any previous elements, since we can't know which would be correct
     *
     * @deprecated since v4. Use the static `DialogService.closeAll` instead
     */
    closeAll() {
        DialogService.closeAll();
    }
    /**
     * Fix for safari hijacking clicks.
     *
     * Runs on `ngOnInit` of every dialog. Ensures we don't have multiple listeners
     * because having many of them could degrade performance in certain cases (and is
     * not necessary for our use case)
     *
     * This is an internally used function, can change at any point (even get removed)
     * and changes to it won't be considered a breaking change. Use at your own risk.
     */
    singletonClickListen() {
        if (!DialogService.listeningForBodyClicks) {
            document.body.firstElementChild.addEventListener("click", () => null, true);
            DialogService.listeningForBodyClicks = true;
        }
    }
}
/**
 * Used in `singletonClickListen`, don't count on its existence and values.
 */
DialogService.listeningForBodyClicks = false;
/**
 * A set of all known dialog components
 */
DialogService.dialogRefs = new Set();
DialogService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DialogService.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: Injector },
    { type: PlaceholderService }
];

/**
 * Implements a `Dialog` that can be positioned anywhere on the page.
 * Used to implement a popover or tooltip.
 */
class Dialog {
    /**
     * Creates an instance of `Dialog`.
     * @param elementRef
     * @param elementService
     */
    constructor(elementRef, elementService, animationFrameService = null) {
        this.elementRef = elementRef;
        this.elementService = elementService;
        this.animationFrameService = animationFrameService;
        /**
         * Emits event that handles the closing of a `Dialog` object.
         */
        this.close = new EventEmitter();
        /**
         * Stores the data received from `dialogConfig`.
         */
        this.data = {};
        this.visibilitySubscription = new Subscription();
        this.animationFrameSubscription = new Subscription();
        /**
         * Handles offsetting the `Dialog` item based on the defined position
         * to not obscure the content beneath.
         */
        this.addGap = {
            "left": pos => position.addOffset(pos, 0, -this.dialogConfig.gap),
            "right": pos => position.addOffset(pos, 0, this.dialogConfig.gap),
            "top": pos => position.addOffset(pos, -this.dialogConfig.gap),
            "bottom": pos => position.addOffset(pos, this.dialogConfig.gap),
            "left-bottom": pos => position.addOffset(pos, 0, -this.dialogConfig.gap),
            "right-bottom": pos => position.addOffset(pos, 0, this.dialogConfig.gap)
        };
        /**
         * Extra placements. Child classes can add to this for use in `placeDialog`.
         */
        this.placements = {};
    }
    /**
     * Initialize the `Dialog`, set the placement and gap, and add a `Subscription` to resize events.
     */
    ngOnInit() {
        this.placement = this.dialogConfig.placement.split(",")[0];
        this.data = this.dialogConfig.data;
        // run any additional initialization code that consuming classes may have
        this.onDialogInit();
    }
    /**
     * After the DOM is ready, focus is set and dialog is placed
     * in respect to the parent element.
     */
    ngAfterViewInit() {
        const dialogElement = this.dialog.nativeElement;
        // split the wrapper class list and apply separately to avoid IE
        // 1. throwing an error due to assigning a readonly property (classList)
        // 2. throwing a SyntaxError due to passing an empty string to `add`
        if (this.dialogConfig.wrapperClass) {
            for (const extraClass of this.dialogConfig.wrapperClass.split(" ")) {
                dialogElement.classList.add(extraClass);
            }
        }
        // only focus the dialog if there are focusable elements within the dialog
        if (getFocusElementList(this.dialog.nativeElement).length > 0) {
            dialogElement.focus();
        }
        const parentElement = this.dialogConfig.parentRef.nativeElement;
        if (this.animationFrameService) {
            this.animationFrameSubscription = this.animationFrameService.tick.subscribe(() => {
                this.placeDialog();
            });
        }
        if (this.dialogConfig.closeWhenHidden) {
            this.visibilitySubscription = this.elementService
                .visibility(parentElement, parentElement)
                .subscribe(value => {
                this.placeDialog();
                if (!value.visible) {
                    this.doClose({
                        reason: CloseReasons.hidden
                    });
                }
            });
        }
        this.placeDialog();
        // run afterDialogViewInit on the next tick
        setTimeout(() => this.afterDialogViewInit());
    }
    /**
     * Empty method to be overridden by consuming classes to run any additional initialization code.
     */
    onDialogInit() { }
    /**
     * Empty method to be overridden by consuming classes to run any additional initialization code after the view is available.
     * NOTE: this does _not_ guarantee the dialog will be positioned, simply that it will exist in the DOM
     */
    afterDialogViewInit() { }
    /**
     * Uses the position service to position the `Dialog` in screen space
     */
    placeDialog() {
        const positionService = new Position(this.placements);
        // helper to find the position based on the current/given environment
        const findPosition = (reference, target, placement) => {
            let pos;
            if (this.dialogConfig.appendInline) {
                pos = this.addGap[placement](positionService.findRelative(reference, target, placement));
            }
            else {
                pos = this.addGap[placement](positionService.findAbsolute(reference, target, placement));
            }
            if (this.dialogConfig.offset) {
                // Apply vertical and horizontal offsets given through the dialogConfig
                pos.top = pos.top + this.dialogConfig.offset.y;
                pos.left = pos.left + this.dialogConfig.offset.x;
            }
            return pos;
        };
        let parentEl = this.dialogConfig.parentRef.nativeElement;
        let el = this.dialog.nativeElement;
        let dialogPlacement = this.placement;
        // split always returns an array, so we can just use the auto position logic
        // for single positions too
        const placements = this.dialogConfig.placement.split(",");
        // find the best placement
        dialogPlacement = positionService.findBestPlacement(parentEl, el, placements);
        // calculate the final position
        const pos = findPosition(parentEl, el, dialogPlacement);
        // update the element
        positionService.setElement(el, pos);
        setTimeout(() => { this.placement = dialogPlacement; });
    }
    /**
     * Sets up a KeyboardEvent to close `Dialog` with Escape key.
     * @param event
     */
    escapeClose(event) {
        switch (event.key) {
            case "Esc": // IE specific value
            case "Escape": {
                event.stopImmediatePropagation();
                this.doClose({
                    reason: CloseReasons.interaction,
                    target: event.target
                });
                break;
            }
            case "Tab": {
                cycleTabs(event, this.elementRef.nativeElement);
                break;
            }
        }
    }
    /**
     * Sets up a event Listener to close `Dialog` if click event occurs outside
     * `Dialog` object.
     * @param event
     */
    clickClose(event) {
        if (!this.elementRef.nativeElement.contains(event.target)
            && !this.dialogConfig.parentRef.nativeElement.contains(event.target)) {
            this.doClose({
                reason: CloseReasons.interaction,
                target: event.target
            });
        }
    }
    /**
     * Closes `Dialog` object by emitting the close event upwards to parents.
     */
    doClose(meta = { reason: CloseReasons.interaction }) {
        this.close.emit(meta);
    }
    /**
     * At destruction of component, `Dialog` unsubscribes from all the subscriptions.
     */
    ngOnDestroy() {
        this.visibilitySubscription.unsubscribe();
        if (this.animationFrameSubscription) {
            this.animationFrameSubscription.unsubscribe();
        }
    }
}
Dialog.decorators = [
    { type: Component, args: [{
                selector: "ibm-dialog",
                template: ""
            }] }
];
/** @nocollapse */
Dialog.ctorParameters = () => [
    { type: ElementRef },
    { type: ElementService },
    { type: AnimationFrameService, decorators: [{ type: Optional }] }
];
Dialog.propDecorators = {
    close: [{ type: Output }],
    dialogConfig: [{ type: Input }],
    dialog: [{ type: ViewChild, args: ["dialog", { static: false },] }],
    escapeClose: [{ type: HostListener, args: ["keydown", ["$event"],] }],
    clickClose: [{ type: HostListener, args: ["document:click", ["$event"],] }]
};

/**
 * A generic directive that can be inherited from to create dialogs (for example, a tooltip or popover)
 *
 * This class contains the relevant initialization code, specific templates, options, and additional inputs
 * should be specified in the derived class.
 *
 * NOTE: All child classes should add `DialogService` as a provider, otherwise they will lose context that
 * the service relies on.
 */
class DialogDirective {
    /**
     * Creates an instance of DialogDirective.
     * @param elementRef
     * @param viewContainerRef
     * @param dialogService
     * @param eventService
     */
    constructor(elementRef, viewContainerRef, dialogService, eventService) {
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
        this.dialogService = dialogService;
        this.eventService = eventService;
        /**
         * Title for the dialog
         */
        this.title = "";
        /**
         * Defines how the Dialog is triggered.(Hover and click behave the same on mobile - both respond to a single tap).
         * Do not add focusable elements if trigger is `hover` or `mouseenter`.
         */
        this.trigger = "click";
        /**
         * Defines how the Dialog close event is triggered.
         *
         * [See here](https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseleave_event)
         * for more on the difference between `mouseleave` and `mouseout`.
         *
         * Defaults to `click` when `trigger` is set to `click`.
         */
        this.closeTrigger = "mouseleave";
        /**
         * Placement of the dialog, usually relative to the element the directive is on.
         */
        this.placement = "left";
        /**
         * Spacing between the dialog and it's triggering element
         */
        this.gap = 0;
        /**
         * Set to `true` to open the dialog next to the triggering component
         */
        this.appendInline = false;
        /**
         * Optional data for templates
         */
        this.data = {};
        this.isOpen = false;
        /**
         * This prevents the dialog from being toggled
         */
        this.disabled = false;
        /**
         * Emits an event when the dialog is closed
         */
        this.onClose = new EventEmitter();
        /**
         * Emits an event when the dialog is opened
         */
        this.onOpen = new EventEmitter();
        /**
         * Emits an event when the state of `isOpen` changes. Allows `isOpen` to be double bound
         */
        this.isOpenChange = new EventEmitter();
        this.role = "button";
        this.hasPopup = true;
    }
    get ariaOwns() {
        return this.isOpen ? this.dialogConfig.compID : null;
    }
    ngOnChanges(changes) {
        // set the config object (this can [and should!] be added to in child classes depending on what they need)
        this.dialogConfig = {
            title: this.title,
            content: this.ibmDialog,
            placement: this.placement,
            parentRef: this.elementRef,
            gap: this.gap,
            trigger: this.trigger,
            closeTrigger: this.closeTrigger,
            shouldClose: this.shouldClose || (() => true),
            appendInline: this.appendInline,
            wrapperClass: this.wrapperClass,
            data: this.data,
            offset: this.offset,
            disabled: this.disabled
        };
        if (changes.isOpen) {
            if (changes.isOpen.currentValue) {
                this.open();
            }
            else {
                this.close({
                    reason: CloseReasons.programmatic
                });
            }
        }
        // Run any code a child class may need.
        this.onDialogChanges(changes);
        this.updateConfig();
    }
    /**
     * Sets the config object and binds events for hovering or clicking before
     * running code from child class.
     */
    ngOnInit() {
        // fix for safari hijacking clicks
        this.dialogService.singletonClickListen();
        const element = this.elementRef.nativeElement;
        this.eventService.on(element, "keydown", (event) => {
            // "Esc" is an IE specific value
            if (event.target === this.dialogConfig.parentRef.nativeElement &&
                (event.key === "Tab" || event.key === "Tab" && event.shiftKey) ||
                event.key === "Escape" || event.key === "Esc") {
                this.close({
                    reason: CloseReasons.interaction,
                    target: event.target
                });
            }
        });
        // bind events for hovering or clicking the host
        if (this.trigger === "hover" || this.trigger === "mouseenter") {
            this.eventService.on(element, "mouseenter", this.open.bind(this));
            this.eventService.on(element, this.closeTrigger, (event) => {
                this.close({
                    reason: CloseReasons.interaction,
                    target: event.target
                });
            });
            this.eventService.on(element, "focus", this.open.bind(this));
            this.eventService.on(element, "blur", (event) => {
                this.close({
                    reason: CloseReasons.interaction,
                    target: event.target
                });
            });
        }
        else {
            this.eventService.on(element, "click", (event) => {
                this.toggle({
                    reason: CloseReasons.interaction,
                    target: event.target
                });
            });
            this.eventService.on(element, "keydown", (event) => {
                // "Spacebar" is an IE specific value
                if (event.key === "Enter" || event.key === " " || event.key === "Spacebar") {
                    setTimeout(() => {
                        this.open();
                    });
                }
            });
        }
        DialogDirective.dialogCounter++;
        this.dialogConfig.compID = "dialog-" + DialogDirective.dialogCounter;
        // run any code a child class may need
        this.onDialogInit();
        this.updateConfig();
    }
    /**
     * When the host dies, kill the popover.
     * - Useful for use in a modal or similar.
     */
    ngOnDestroy() {
        this.close({
            reason: CloseReasons.destroyed
        });
    }
    /**
     * Helper method to call dialogService 'open'.
     * - Enforce accessibility by updating an aria attr for nativeElement.
     */
    open() {
        // don't allow dialogs to be opened if they're already open
        if (this.dialogRef || this.disabled) {
            return;
        }
        // actually open the dialog, emit events, and set the open state
        this.dialogRef = this.dialogService.open(this.viewContainerRef, this.dialogConfig);
        this.isOpen = true;
        this.onOpen.emit();
        this.isOpenChange.emit(true);
        // Handles emitting all the close events to clean everything up
        // Also enforce accessibility on close by updating an aria attr on the nativeElement.
        this.dialogRef.instance.close.subscribe((meta) => {
            if (!this.dialogRef) {
                return;
            }
            if (this.dialogConfig.shouldClose && this.dialogConfig.shouldClose(meta)) {
                // close the dialog, emit events, and clear out the open states
                this.dialogService.close(this.dialogRef);
                this.dialogRef = null;
                this.isOpen = false;
                this.onClose.emit();
                this.isOpenChange.emit(false);
            }
        });
        return this.dialogRef;
    }
    /**
     * Helper method to toggle the open state of the dialog
     */
    toggle(meta = { reason: CloseReasons.interaction }) {
        if (!this.isOpen) {
            this.open();
        }
        else {
            this.close(meta);
        }
    }
    /**
     * Helper method to close the dialogRef.
     */
    close(meta = { reason: CloseReasons.interaction }) {
        if (this.dialogRef) {
            setTimeout(() => {
                this.dialogRef.instance.doClose(meta);
            });
        }
    }
    /**
     * Empty method for child classes to override and specify additional init steps.
     * Run after DialogDirective completes it's ngOnInit.
     */
    onDialogInit() { }
    /**
     * Empty method for child to override and specify additional on changes steps.
     * run after DialogDirective completes it's ngOnChanges.
     */
    onDialogChanges(_changes) { }
    updateConfig() { }
}
DialogDirective.dialogCounter = 0;
DialogDirective.decorators = [
    { type: Directive, args: [{
                selector: "[ibmDialog]",
                exportAs: "ibmDialog",
                providers: [
                    DialogService
                ]
            },] }
];
/** @nocollapse */
DialogDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: DialogService },
    { type: EventService }
];
DialogDirective.propDecorators = {
    title: [{ type: Input }],
    ibmDialog: [{ type: Input }],
    trigger: [{ type: Input }],
    closeTrigger: [{ type: Input }],
    placement: [{ type: Input }],
    offset: [{ type: Input }],
    wrapperClass: [{ type: Input }],
    gap: [{ type: Input }],
    appendInline: [{ type: Input }],
    data: [{ type: Input }],
    isOpen: [{ type: Input }, { type: HostBinding, args: ["attr.aria-expanded",] }],
    disabled: [{ type: Input }],
    shouldClose: [{ type: Input }],
    onClose: [{ type: Output }],
    onOpen: [{ type: Output }],
    isOpenChange: [{ type: Output }],
    role: [{ type: HostBinding, args: ["attr.role",] }],
    hasPopup: [{ type: HostBinding, args: ["attr.aria-haspopup",] }],
    ariaOwns: [{ type: HostBinding, args: ["attr.aria-owns",] }]
};

/**
 * Extend the `Dialog` component to create a tooltip for exposing content.
 */
class Tooltip extends Dialog {
    constructor(elementRef, elementService, animationFrameService = null) {
        super(elementRef, elementService, animationFrameService);
        this.elementRef = elementRef;
        this.elementService = elementService;
        this.animationFrameService = animationFrameService;
        this.style = "inline-block";
        /**
         * Value is set to `true` if the `Tooltip` is to display a `TemplateRef` instead of a string.
         */
        this.hasContentTemplate = false;
        /**
         * Sets the role of the tooltip. If there's no focusable content we leave it as a `tooltip`,
         * if there _is_ focusable content we switch to the interactive `dialog` role.
         */
        this.role = "tooltip";
    }
    /**
     * Check whether there is a template for the `Tooltip` content.
     */
    onDialogInit() {
        this.addGap["bottom"] = pos => {
            const adjustedOffset = this.getAdjustOffset();
            return position.addOffset(pos, 3 + adjustedOffset.top, 0 + adjustedOffset.left);
        };
        this.addGap["top"] = pos => {
            const adjustedOffset = this.getAdjustOffset();
            return position.addOffset(pos, -10 + adjustedOffset.top, 0 + adjustedOffset.left);
        };
        this.addGap["left"] = pos => {
            const adjustedOffset = this.getAdjustOffset();
            return position.addOffset(pos, -3 + adjustedOffset.top, -6 + adjustedOffset.left);
        };
        this.addGap["right"] = pos => {
            const adjustedOffset = this.getAdjustOffset();
            return position.addOffset(pos, -3 + adjustedOffset.top, 6 + adjustedOffset.left);
        };
        this.hasContentTemplate = this.dialogConfig.content instanceof TemplateRef;
    }
    getAdjustOffset() {
        const closestWithPos = closestAttr("position", ["relative", "fixed", "absolute"], this.elementRef.nativeElement.parentElement);
        const topPos = closestWithPos ? closestWithPos.getBoundingClientRect().top * -1 : 0;
        const leftPos = closestWithPos ? closestWithPos.getBoundingClientRect().left * -1 : 0;
        return { top: topPos, left: leftPos };
    }
    afterDialogViewInit() {
        const focusableElements = getFocusElementList(this.dialog.nativeElement);
        if (focusableElements.length > 0) {
            this.role = "dialog";
            focusableElements[0].focus();
        }
    }
}
Tooltip.decorators = [
    { type: Component, args: [{
                selector: "ibm-tooltip",
                template: `
		<div
			#dialog
			[id]="dialogConfig.compID"
			[attr.role]="role"
			[attr.data-floating-menu-direction]="placement"
			class="bx--tooltip bx--tooltip--shown">
			<span class="bx--tooltip__caret" aria-hidden="true"></span>
			<ng-template
					*ngIf="hasContentTemplate"
					[ngTemplateOutlet]="dialogConfig.content"
					[ngTemplateOutletContext]="{tooltip: this}">
			</ng-template>
			<p
				*ngIf="!hasContentTemplate">
				{{dialogConfig.content}}
			</p>
		</div>
		`
            }] }
];
/** @nocollapse */
Tooltip.ctorParameters = () => [
    { type: ElementRef },
    { type: ElementService },
    { type: AnimationFrameService, decorators: [{ type: Optional }] }
];
Tooltip.propDecorators = {
    style: [{ type: HostBinding, args: ["style.display",] }]
};

class TooltipDefinition {
    constructor() {
        this.id = `definition-tooltip-${TooltipDefinition.tooltipItemCount++}`;
        /**
         * The placement in which the `TooltipDefinition` appears.
         * Set to `"top"` to have it positioned above the trigger text
         */
        this.placement = "bottom";
        this.alignment = "start";
        this.className = true;
        this.accessibility = true;
    }
}
TooltipDefinition.tooltipItemCount = 0;
TooltipDefinition.decorators = [
    { type: Component, args: [{
                selector: "ibm-tooltip-definition",
                template: `
		<button
			type="button"
			[ngClass]="{
				'bx--tooltip--bottom' : placement === 'bottom',
				'bx--tooltip--top' : placement === 'top',
				'bx--tooltip--align-start' : alignment === 'start',
				'bx--tooltip--align-center' : alignment === 'center',
				'bx--tooltip--align-end' : alignment === 'end'
			}"
			class="bx--tooltip__trigger bx--tooltip--a11y bx--tooltip__trigger--definition"
			[attr.aria-describedby]="id">
			<ng-content></ng-content>
		</button>
		<div class="bx--assistive-text" [id]="id" role="tooltip">{{content}}</div>
	`
            }] }
];
TooltipDefinition.propDecorators = {
    id: [{ type: Input }],
    content: [{ type: Input }],
    placement: [{ type: Input }],
    alignment: [{ type: Input }],
    className: [{ type: HostBinding, args: ["class.bx--tooltip--definition",] }],
    accessibility: [{ type: HostBinding, args: ["class.bx--tooltip--a11y",] }]
};

class TooltipIcon {
    constructor() {
        /**
         * The placement in which the `TooltipIcon` appears.
         * Set to `"top"` to have it positioned above the icon
         */
        this.placement = "bottom";
        this.alignment = "start";
        this.className = true;
    }
}
TooltipIcon.decorators = [
    { type: Component, args: [{
                selector: "ibm-tooltip-icon",
                template: `
		<button
			type="button"
			class="bx--tooltip__trigger bx--tooltip--a11y"
			[ngClass]="{
				'bx--tooltip--bottom' : placement === 'bottom',
				'bx--tooltip--top' : placement === 'top',
				'bx--tooltip--left' : placement === 'left',
				'bx--tooltip--right' : placement === 'right',
				'bx--tooltip--align-start' : alignment === 'start',
				'bx--tooltip--align-center' : alignment === 'center',
				'bx--tooltip--align-end' : alignment === 'end'
			}">
			<span class="bx--assistive-text">{{content}}</span>
			<ng-content></ng-content>
		</button>
	`
            }] }
];
TooltipIcon.propDecorators = {
    content: [{ type: Input }],
    placement: [{ type: Input }],
    alignment: [{ type: Input }],
    className: [{ type: HostBinding, args: ["class.bx--tooltip-icon",] }]
};

/**
 * Directive for extending `Dialog` to create tooltips.
 *
 * [See demo](../../?path=/story/tooltip--basic)
 *
 * class: TooltipDirective (extends PopoverDirective)
 *
 *
 * selector: `nTooltip`
 *
 *
 * ```html
 * <button nTooltip="I am a tooltip" placement="right" trigger="mouseenter" type="danger">Tooltip Right</button>
 * <button nTooltip="I am a tooltip" type="warning">Tooltip Top warning on click</button>
 * ```
 *
 * <example-url>../../iframe.html?id=tooltip--basic</example-url>
 */
class TooltipDirective extends DialogDirective {
    /**
     * Creates an instance of `TooltipDirective`.
     */
    constructor(elementRef, viewContainerRef, dialogService, eventService) {
        super(elementRef, viewContainerRef, dialogService, eventService);
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
        this.dialogService = dialogService;
        this.eventService = eventService;
        /**
         * Set tooltip type to reflect 'warning' or 'error' styles.
         */
        // tslint:disable-next-line:no-input-rename
        this.tooltipType = "";
        this.tabIndex = 0;
        this.className = true;
        dialogService.setContext({ component: Tooltip });
    }
    get descriptorId() {
        return this.isOpen ? this.dialogConfig.compID : null;
    }
    updateConfig() {
        this.dialogConfig.content = this.ibmTooltip;
        this.dialogConfig.type = this.tooltipType;
        this.dialogConfig.offset = this.offset;
    }
}
TooltipDirective.decorators = [
    { type: Directive, args: [{
                selector: "[ibmTooltip]",
                exportAs: "ibmTooltip",
                providers: [
                    DialogService
                ]
            },] }
];
/** @nocollapse */
TooltipDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: DialogService },
    { type: EventService }
];
TooltipDirective.propDecorators = {
    ibmTooltip: [{ type: Input }],
    tooltipType: [{ type: Input, args: ["tooltip-type",] }],
    tabIndex: [{ type: HostBinding, args: ["tabindex",] }],
    className: [{ type: HostBinding, args: ["class.bx--tooltip__trigger",] }],
    descriptorId: [{ type: HostBinding, args: ["attr.aria-describedby",] }]
};

/**
 * A directive that creates a tooltip `Dialog` for exposing truncated text.
 *
 * class: EllipsisTooltip (extends PopoverDirective)
 *
 * selector: `nEllipsisTooltip`
 *
 * ```html
 * <div class="ellipsis" nEllipsisTooltip>Tooltip for ellipsis because I can and I am really really long</div>
 * ```
 */
class EllipsisTooltip extends TooltipDirective {
    /**
     * If text is truncated, this appends the text to the dialog as content.
     * @returns null
     * @memberof EllipsisTooltip
     */
    updateTooltipContent() {
        if (this.elementRef.nativeElement.scrollWidth <= this.elementRef.nativeElement.offsetWidth) {
            this.disabled = true;
            return;
        }
        this.disabled = false;
        this.dialogConfig.content = this.elementRef.nativeElement.innerText;
    }
    onClick() {
        if (this.trigger === "click") {
            this.updateTooltipContent();
        }
    }
    onHover() {
        if (this.trigger === "hover" || this.trigger === "mouseenter") {
            this.updateTooltipContent();
        }
    }
    onFocus() {
        this.updateTooltipContent();
    }
}
EllipsisTooltip.decorators = [
    { type: Directive, args: [{
                selector: "[ibmEllipsisTooltip]",
                providers: [
                    DialogService
                ]
            },] }
];
EllipsisTooltip.propDecorators = {
    onClick: [{ type: HostListener, args: ["click",] }],
    onHover: [{ type: HostListener, args: ["mouseenter",] }],
    onFocus: [{ type: HostListener, args: ["focus",] }]
};

/**
 * Extend the `Dialog` component to create an overflow menu.
 *
 * Not used directly. See overflow-menu.component and overflow-menu.directive for more
 */
class OverflowMenuPane extends Dialog {
    constructor(elementRef, i18n, experimental, animationFrameService = null, 
    // mark `elementService` as optional since making it mandatory would be a breaking change
    elementService = null) {
        super(elementRef, elementService, animationFrameService);
        this.elementRef = elementRef;
        this.i18n = i18n;
        this.experimental = experimental;
        this.animationFrameService = animationFrameService;
        this.elementService = elementService;
    }
    onDialogInit() {
        const positionOverflowMenu = pos => {
            let offset;
            /*
            * 20 is half the width of the overflow menu trigger element.
            * we also move the element by half of it's own width, since
            * position service will try and center everything
            */
            const closestRel = closestAttr("position", ["relative", "fixed", "absolute"], this.elementRef.nativeElement);
            const topFix = closestRel ? closestRel.getBoundingClientRect().top * -1 : 0;
            const leftFix = closestRel ? closestRel.getBoundingClientRect().left * -1 : 0;
            offset = Math.round(this.dialog.nativeElement.offsetWidth / 2) - 20;
            if (this.dialogConfig.flip) {
                return position.addOffset(pos, topFix, (-offset + leftFix));
            }
            return position.addOffset(pos, topFix, (offset + leftFix));
        };
        this.addGap["bottom"] = positionOverflowMenu;
        this.addGap["top"] = positionOverflowMenu;
        if (!this.dialogConfig.menuLabel) {
            this.dialogConfig.menuLabel = this.i18n.get().OVERFLOW_MENU.OVERFLOW;
        }
    }
    hostkeys(event) {
        const listItems = this.listItems();
        switch (event.key) {
            case "Down": // IE specific value
            case "ArrowDown":
                event.preventDefault();
                if (!isFocusInLastItem(event, listItems)) {
                    const index = listItems.findIndex(item => item === event.target);
                    listItems[index + 1].focus();
                }
                else {
                    listItems[0].focus();
                }
                break;
            case "Up": // IE specific value
            case "ArrowUp":
                event.preventDefault();
                if (!isFocusInFirstItem(event, listItems)) {
                    const index = listItems.findIndex(item => item === event.target);
                    listItems[index - 1].focus();
                }
                else {
                    listItems[listItems.length - 1].focus();
                }
                break;
            case "Home":
                event.preventDefault();
                listItems[0].focus();
                break;
            case "End":
                event.preventDefault();
                listItems[listItems.length - 1].focus();
                break;
            case "Esc": // IE specific value
            case "Escape":
            case "Tab":
                event.stopImmediatePropagation();
                this.doClose({
                    reason: CloseReasons.interaction,
                    target: event.target
                });
                break;
            default: break;
        }
    }
    onClose(event) {
        this.doClose({
            reason: CloseReasons.interaction,
            target: event.target
        });
    }
    afterDialogViewInit() {
        const focusElementList = this.listItems();
        focusElementList.forEach(button => {
            // Allows user to set tabindex to 0.
            if (button.getAttribute("tabindex") === null) {
                button.tabIndex = -1;
            }
        });
        if (focusElementList[0]) {
            focusElementList[0].tabIndex = 0;
            focusElementList[0].focus();
        }
    }
    listItems() {
        const selector = ".bx--overflow-menu-options__option:not([disabled]) .bx--overflow-menu-options__btn";
        return Array.from(this.elementRef.nativeElement.querySelectorAll(selector));
    }
}
OverflowMenuPane.decorators = [
    { type: Component, args: [{
                selector: "ibm-overflow-menu-pane",
                template: `
		<ul
			[attr.aria-label]="dialogConfig.menuLabel"
			[ngClass]="{'bx--overflow-menu--flip': dialogConfig.flip}"
			role="menu"
			#dialog
			class="bx--overflow-menu-options bx--overflow-menu-options--open"
			role="menu"
			(click)="onClose($event)"
			[attr.aria-label]="dialogConfig.menuLabel">
			<ng-template
				[ngTemplateOutlet]="dialogConfig.content"
				[ngTemplateOutletContext]="{overflowMenu: this}">
			</ng-template>
		</ul>
	`
            }] }
];
/** @nocollapse */
OverflowMenuPane.ctorParameters = () => [
    { type: ElementRef },
    { type: I18n },
    { type: ExperimentalService },
    { type: AnimationFrameService, decorators: [{ type: Optional }] },
    { type: ElementService, decorators: [{ type: Optional }] }
];
OverflowMenuPane.propDecorators = {
    hostkeys: [{ type: HostListener, args: ["keydown", ["$event"],] }]
};

class OverflowMenuCustomPane extends Dialog {
    constructor(elementRef, i18n, animationFrameService = null, 
    // mark `elementService` as optional since making it mandatory would be a breaking change
    elementService = null) {
        super(elementRef, elementService, animationFrameService);
        this.elementRef = elementRef;
        this.i18n = i18n;
        this.animationFrameService = animationFrameService;
        this.elementService = elementService;
    }
    onDialogInit() {
        const positionOverflowMenu = pos => {
            let offset;
            /*
            * 20 is half the width of the overflow menu trigger element.
            * we also move the element by half of it's own width, since
            * position service will try and center everything
            */
            const closestRel = closestAttr("position", ["relative", "fixed", "absolute"], this.elementRef.nativeElement);
            const topFix = closestRel ? closestRel.getBoundingClientRect().top * -1 : 0;
            const leftFix = closestRel ? closestRel.getBoundingClientRect().left * -1 : 0;
            offset = Math.round(this.dialog.nativeElement.offsetWidth / 2) - 20;
            if (this.dialogConfig.flip) {
                return position.addOffset(pos, topFix, (-offset + leftFix));
            }
            return position.addOffset(pos, topFix, (offset + leftFix));
        };
        this.addGap["bottom"] = positionOverflowMenu;
        this.addGap["top"] = positionOverflowMenu;
        if (!this.dialogConfig.menuLabel) {
            this.dialogConfig.menuLabel = this.i18n.get().OVERFLOW_MENU.OVERFLOW;
        }
    }
}
OverflowMenuCustomPane.decorators = [
    { type: Component, args: [{
                selector: "ibm-overflow-custom-menu-pane",
                template: `
		<div
			[attr.aria-label]="dialogConfig.menuLabel"
			[ngClass]="{'bx--overflow-menu--flip': dialogConfig.flip}"
			class="bx--overflow-menu-options bx--overflow-menu-options--open"
			role="menu"
			(click)="doClose()"
			#dialog
			[attr.aria-label]="dialogConfig.menuLabel">
			<ng-template
				[ngTemplateOutlet]="dialogConfig.content"
				[ngTemplateOutletContext]="{overflowMenu: this}">
			</ng-template>
		</div>
	`
            }] }
];
/** @nocollapse */
OverflowMenuCustomPane.ctorParameters = () => [
    { type: ElementRef },
    { type: I18n },
    { type: AnimationFrameService, decorators: [{ type: Optional }] },
    { type: ElementService, decorators: [{ type: Optional }] }
];

/**
 * Directive for extending `Dialog` to create overflow menus.
 *
 * class: OverflowMenuDirective (extends DialogDirective)
 *
 *
 * selector: `ibmOverflowMenu`
 *
 *
 * ```html
 * <div [ibmOverflowMenu]="templateRef"></div>
 * <ng-template #templateRef>
 * 	<!-- overflow menu options here -->
 * </ng-template>
 * ```
 *
 * ```html
 * <div [ibmOverflowMenu]="templateRef" [customPane]="true"></div>
 * <ng-template #templateRef>
 *  <!-- custom content goes here -->
 * </ng-template>
 * ```
 */
class OverflowMenuDirective extends DialogDirective {
    /**
     * Creates an instance of `OverflowMenuDirective`.
     */
    constructor(elementRef, viewContainerRef, dialogService, eventService) {
        super(elementRef, viewContainerRef, dialogService, eventService);
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
        this.dialogService = dialogService;
        this.eventService = eventService;
        /**
         * Controls wether the overflow menu is flipped
         */
        this.flip = false;
        /**
         * Classes to add to the dialog container
         */
        this.wrapperClass = "";
        /**
         * Set to true to for custom content
         */
        this.customPane = false;
    }
    ngAfterContentInit() {
        this.dialogService.setContext({ component: this.customPane ? OverflowMenuCustomPane : OverflowMenuPane });
    }
    updateConfig() {
        this.dialogConfig.content = this.ibmOverflowMenu;
        this.dialogConfig.flip = this.flip;
        this.dialogConfig.offset = this.offset;
        this.dialogConfig.wrapperClass = this.wrapperClass;
    }
    hostkeys(event) {
        switch (event.key) {
            case "Enter":
            case " ":
                event.preventDefault();
                break;
        }
    }
}
OverflowMenuDirective.decorators = [
    { type: Directive, args: [{
                selector: "[ibmOverflowMenu]",
                exportAs: "ibmOverflowMenu",
                providers: [
                    DialogService
                ]
            },] }
];
/** @nocollapse */
OverflowMenuDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: DialogService },
    { type: EventService }
];
OverflowMenuDirective.propDecorators = {
    ibmOverflowMenu: [{ type: Input }],
    flip: [{ type: Input }],
    offset: [{ type: Input }],
    wrapperClass: [{ type: Input }],
    customPane: [{ type: Input }],
    hostkeys: [{ type: HostListener, args: ["keydown", ["$event"],] }]
};

/**
 * The OverFlow menu component encapsulates the OverFlowMenu directive, and the menu iconography into one convienent component
 *
 * [See demo](../../?path=/story/overflow-menu--basic)
 *
 * html:
 * ```
 * <ibm-overflow-menu>
 *	<ibm-overflow-menu-option>Option 1</ibm-overflow-menu-option>
 *	<ibm-overflow-menu-option>Option 2</ibm-overflow-menu-option>
 * </ibm-overflow-menu>
 * ```
 *
 * <example-url>../../iframe.html?id=overflow-menu--basic</example-url>
 */
class OverflowMenu {
    constructor(elementRef, i18n) {
        this.elementRef = elementRef;
        this.i18n = i18n;
        this.buttonLabel = this.i18n.get().OVERFLOW_MENU.OVERFLOW;
        this.flip = false;
        this.placement = "bottom";
        this.open = false;
        this.openChange = new EventEmitter();
        this.wrapperClass = "";
        /**
         * This appends additional classes to the overflow trigger/button.
         */
        this.triggerClass = "";
    }
    handleOpenChange(event) {
        this.open = event;
        this.openChange.emit(event);
    }
}
OverflowMenu.decorators = [
    { type: Component, args: [{
                selector: "ibm-overflow-menu",
                template: `
		<button
			[ibmOverflowMenu]="options"
			[ngClass]="{'bx--overflow-menu--open': open}"
			class="bx--overflow-menu {{triggerClass}}"
			[attr.aria-label]="buttonLabel"
			[flip]="flip"
			[isOpen]="open"
			(isOpenChange)="handleOpenChange($event)"
			[offset]="offset"
			[wrapperClass]="wrapperClass"
			aria-haspopup="true"
			class="bx--overflow-menu"
			type="button"
			[placement]="placement">
			<ng-template *ngIf="customTrigger; else defaultIcon" [ngTemplateOutlet]="customTrigger"></ng-template>
		</button>
		<ng-template #options>
			<ng-content></ng-content>
		</ng-template>
		<ng-template #defaultIcon>
			<svg ibmIcon="overflow-menu--vertical" size="16" class="bx--overflow-menu__icon"></svg>
		</ng-template>
	`,
                encapsulation: ViewEncapsulation.None,
                styles: [`
		.bx--overflow-menu--open {
			opacity: 1
		}

		/*
		Rotate the overflow menu container as well as the icon, since
		we calculate our menu position based on the container, not the icon.
		*/
		.bx--data-table-v2 .bx--overflow-menu {
			transform: rotate(90deg);
		}

		.bx--data-table-v2 .bx--overflow-menu__icon {
			transform: rotate(180deg);
		}
	`]
            }] }
];
/** @nocollapse */
OverflowMenu.ctorParameters = () => [
    { type: ElementRef },
    { type: I18n }
];
OverflowMenu.propDecorators = {
    buttonLabel: [{ type: Input }],
    flip: [{ type: Input }],
    placement: [{ type: Input }],
    open: [{ type: Input }],
    openChange: [{ type: Output }],
    customTrigger: [{ type: Input }],
    offset: [{ type: Input }],
    wrapperClass: [{ type: Input }],
    triggerClass: [{ type: Input }],
    overflowMenuDirective: [{ type: ContentChild, args: [OverflowMenuDirective, { static: false },] }]
};

/**
 * Available HTML anchor targets
 */
var Target;
(function (Target) {
    Target["self"] = "_self";
    Target["blank"] = "_blank";
    Target["parent"] = "_parent";
    Target["top"] = "_top";
})(Target || (Target = {}));
/**
 * Security HTML anchor rel when target is set
 */
const REL = "noreferrer noopener";
/**
 * `OverflowMenuOption` represents a single option in an overflow menu
 *
 * Presently it has three possible states - normal, disabled, and danger:
 * ```
 * <ibm-overflow-menu-option>Simple option</ibm-overflow-menu-option>
 * <ibm-overflow-menu-option disabled="true">Disabled</ibm-overflow-menu-option>
 * <ibm-overflow-menu-option type="danger">Danger option</ibm-overflow-menu-option>
 * ```
 *
 * For content that expands beyond the overflow menu `OverflowMenuOption` automatically adds a title attribute.
 */
class OverflowMenuOption {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.optionClass = "bx--overflow-menu-options__option";
        this.role = "presentation";
        /**
         * toggles between `normal` and `danger` states
         */
        this.type = "normal";
        /**
         * disable/enable interactions
         */
        this.disabled = false;
        this.selected = new EventEmitter();
        this.tabIndex = -1;
        // note: title must be a real attribute (i.e. not a getter) as of Angular@6 due to
        // change after checked errors
        this.title = null;
    }
    get isDanger() {
        return this.type === "danger";
    }
    get isDisabled() {
        return this.disabled;
    }
    /**
     * Allows to add a target to the anchor
     */
    set target(value) {
        if (!Object.values(Target).includes(value)) {
            console.warn(`\`target\` must have one of the following values: ${Object.values(Target).join(", ")}.
Please use the \`Target\` enum exported by carbon-components-angular`);
            return;
        }
        this._target = value;
    }
    get target() {
        return this._target;
    }
    /**
     * rel only returns its value if target is defined
     */
    get rel() {
        return this._target ? REL : null;
    }
    onClick() {
        this.selected.emit();
    }
    onFocus() {
        setTimeout(() => this.tabIndex = 0);
    }
    onBlur() {
        setTimeout(() => this.tabIndex = -1);
    }
    ngAfterViewInit() {
        const button = this.elementRef.nativeElement.querySelector("button, a");
        const textContainer = button.querySelector(".bx--overflow-menu-options__option-content");
        if (textContainer.scrollWidth > textContainer.offsetWidth) {
            this.title = button.textContent;
        }
    }
}
OverflowMenuOption.decorators = [
    { type: Component, args: [{
                selector: "ibm-overflow-menu-option",
                template: `
		<button
			*ngIf="!href"
			class="bx--overflow-menu-options__btn"
			role="menuitem"
			[tabindex]="tabIndex"
			(focus)="onFocus()"
			(blur)="onBlur()"
			(click)="onClick()"
			[disabled]="disabled"
			[attr.title]="title">
			<ng-container *ngTemplateOutlet="tempOutlet"></ng-container>
		</button>

		<a
			*ngIf="href"
			class="bx--overflow-menu-options__btn"
			role="menuitem"
			[tabindex]="tabIndex"
			(focus)="onFocus()"
			(blur)="onBlur()"
			(click)="onClick()"
			[attr.disabled]="disabled"
			[href]="href"
			[attr.target]="target"
			[attr.rel]="rel"
			[attr.title]="title">
			<ng-container *ngTemplateOutlet="tempOutlet"></ng-container>
		</a>

		<ng-template #tempOutlet>
			<div class="bx--overflow-menu-options__option-content">
				<ng-content></ng-content>
			</div>
		</ng-template>
	`
            }] }
];
/** @nocollapse */
OverflowMenuOption.ctorParameters = () => [
    { type: ElementRef }
];
OverflowMenuOption.propDecorators = {
    optionClass: [{ type: HostBinding, args: ["class",] }],
    role: [{ type: HostBinding, args: ["attr.role",] }],
    isDanger: [{ type: HostBinding, args: ["class.bx--overflow-menu-options__option--danger",] }],
    isDisabled: [{ type: HostBinding, args: ["class.bx--overflow-menu-options__option--disabled",] }],
    type: [{ type: Input }],
    disabled: [{ type: Input }],
    href: [{ type: Input }],
    target: [{ type: Input }],
    selected: [{ type: Output }]
};

// modules
class DialogModule {
}
DialogModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    Dialog,
                    Tooltip,
                    TooltipDefinition,
                    TooltipIcon,
                    OverflowMenu,
                    OverflowMenuPane,
                    OverflowMenuCustomPane,
                    DialogDirective,
                    TooltipDirective,
                    EllipsisTooltip,
                    OverflowMenuDirective,
                    OverflowMenuOption
                ],
                exports: [
                    Dialog,
                    Tooltip,
                    TooltipDefinition,
                    TooltipIcon,
                    OverflowMenu,
                    OverflowMenuPane,
                    OverflowMenuCustomPane,
                    DialogDirective,
                    TooltipDirective,
                    EllipsisTooltip,
                    OverflowMenuDirective,
                    OverflowMenuOption
                ],
                providers: [DialogService],
                entryComponents: [
                    Dialog,
                    Tooltip,
                    OverflowMenuPane,
                    OverflowMenuCustomPane
                ],
                imports: [
                    CommonModule,
                    I18nModule,
                    PlaceholderModule,
                    ExperimentalModule,
                    UtilsModule,
                    IconModule
                ]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { DialogService, Dialog, DialogDirective, Tooltip, TooltipDefinition, TooltipIcon, TooltipDirective, EllipsisTooltip, OverflowMenu, OverflowMenuPane, OverflowMenuCustomPane, OverflowMenuDirective, OverflowMenuOption, CloseReasons, DialogModule };

//# sourceMappingURL=carbon-components-angular-dialog.js.map