/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-radio.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Component, Input, HostBinding, Output, EventEmitter, ContentChildren, forwardRef, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';

/**
 * Used to emit changes performed on a `Radio`.
 */
class RadioChange {
    constructor(source, value) {
        this.source = source;
        this.value = value;
    }
}

/**
 * class: Radio (extends Checkbox)
 *
 * selector: `n-radio`
 *
 * source: `src/forms/radio.component.ts`
 *
 * ```html
 * <ibm-radio [(ngModel)]="radioState">Radio</ibm-radio>
 * ```
 *
 * Also see: [`RadioGroup`](#ibm-radio-group)
 */
class Radio {
    constructor() {
        this.checked = false;
        this.name = "";
        this.disabled = false;
        this.labelPlacement = "right";
        /**
         * Used to set the `aria-label` attribute on the input label.
         */
        this.ariaLabel = "";
        /**
         * Sets the HTML required attribute
         */
        this.required = false;
        /**
         * The value of the `Radio`.
         */
        this.value = "";
        /**
         * Set to `true` for a loading table.
         */
        this.skeleton = false;
        /**
         * The id for the `Radio`.
         */
        this.id = `radio-${Radio.radioCount++}`;
        /**
         * emits when the state of the radio changes
         */
        this.change = new EventEmitter();
        this.hostClass = true;
        this._labelledby = "";
        /**
         * Handler provided by the `RadioGroup` to bubble events up
         */
        this.radioChangeHandler = (event) => { };
    }
    set ariaLabelledby(value) {
        this._labelledby = value;
    }
    get ariaLabelledby() {
        if (this._labelledby) {
            return this._labelledby;
        }
        return `label-${this.id}`;
    }
    get labelLeft() {
        return this.labelPlacement === "left";
    }
    /**
     * Synchronizes with the `RadioGroup` in the event of a changed `Radio`.
     * Emits the changes of both the `RadioGroup` and `Radio`.
     */
    onChange(event) {
        event.stopPropagation();
    }
    onClick(event) {
        this.checked = event.target.checked;
        const radioEvent = new RadioChange(this, this.value);
        this.change.emit(radioEvent);
        this.radioChangeHandler(radioEvent);
    }
    /**
     * Method called by `RadioGroup` with a callback function to bubble `RadioChange` events
     * @param fn callback that expects a `RadioChange` as an argument
     */
    registerRadioChangeHandler(fn) {
        this.radioChangeHandler = fn;
    }
}
/**
 * Used to dynamically create unique ids for the `Radio`.
 */
Radio.radioCount = 0;
Radio.decorators = [
    { type: Component, args: [{
                selector: "ibm-radio",
                template: `
		<input
			*ngIf="!skeleton"
			class="bx--radio-button"
			type="radio"
			[checked]="checked"
			[disabled]="disabled"
			[name]="name"
			[id]="id"
			[required]="required"
			[value]="value"
			[attr.aria-labelledby]="ariaLabelledby"
			(change)="onChange($event)"
			(click)="onClick($event)">
		<div *ngIf="skeleton" class="bx--radio-button bx--skeleton"></div>
		<label
			class="bx--radio-button__label"
			[attr.aria-label]="ariaLabel"
			[ngClass]="{
				'bx--skeleton': skeleton
			}"
			[for]="id"
			id="label-{{id}}">
			<span class="bx--radio-button__appearance"></span>
			<ng-content></ng-content>
		</label>
	`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: Radio,
                        multi: true
                    }
                ]
            }] }
];
Radio.propDecorators = {
    checked: [{ type: Input }],
    name: [{ type: Input }],
    disabled: [{ type: Input }],
    labelPlacement: [{ type: Input }],
    ariaLabelledby: [{ type: Input }],
    ariaLabel: [{ type: Input }],
    required: [{ type: Input }],
    value: [{ type: Input }],
    skeleton: [{ type: Input }],
    id: [{ type: Input }],
    change: [{ type: Output }],
    hostClass: [{ type: HostBinding, args: ["class.bx--radio-button-wrapper",] }],
    labelLeft: [{ type: HostBinding, args: ["class.bx--radio-button-wrapper--label-left",] }]
};

/**
 * [See demo](../../?path=/story/radio--basic)
 *
 * class: RadioGroup
 *
 * selector: `ibm-radio-group`
 *
 * source: `src/forms/radio.component.ts`
 *
 *
 * Ex:
 * ```html
 * <ibm-radio-group [(ngModel)]="radio">
 * 	<ibm-radio *ngFor="let one of manyRadios" [value]="one">
 *		Radio {{one}}
 * 	</ibm-radio>
 * </ibm-radio-group>
 *
 * Radio selected: {{radio}}
 * ```
 *
 * ```typescript
 * manyRadios = ["one", "two", "three", "four", "five", "six"];
 * ```
 *
 * Also see: [`Radio`](#ibm-radio)
 *
 * <example-url>../../iframe.html?id=radio--basic</example-url>
 */
class RadioGroup {
    constructor() {
        this.orientation = "horizontal";
        this.labelPlacement = "right";
        /**
         * Emits event notifying other classes of a change using a `RadioChange` class.
         */
        this.change = new EventEmitter();
        /**
         * Set to true to disable the whole radio group
         */
        this.disabled = false;
        /**
         * Binds 'bx--form-item' value to the class for `RadioGroup`.
         */
        this.radioButtonGroupClass = true;
        /**
         * To track whether the `RadioGroup` has been initialized.
         */
        this.isInitialized = false;
        /**
         * Reflects whether or not the input is disabled and cannot be selected.
         */
        this._disabled = false;
        /**
         * Reflects whether or not the dropdown is loading.
         */
        this._skeleton = false;
        /**
         * The value of the selected option within the `RadioGroup`.
         */
        this._value = null;
        /**
         * The `Radio` within the `RadioGroup` that is selected.
         */
        this._selected = null;
        /**
         * The name attribute associated with the `RadioGroup`.
         */
        this._name = `radio-group-${RadioGroup.radioGroupCount++}`;
        /**
         * Needed to properly implement ControlValueAccessor.
         */
        this.onTouched = () => { };
        /**
         * Method set in registerOnChange to propagate changes back to the form.
         */
        this.propagateChange = (_) => { };
    }
    /**
     * Sets the passed in `Radio` item as the selected input within the `RadioGroup`.
     */
    set selected(selected) {
        this._selected = selected;
        this.value = selected ? selected.value : null;
        this.checkSelectedRadio();
    }
    /**
     * Returns the `Radio` that is selected within the `RadioGroup`.
     */
    get selected() {
        return this._selected;
    }
    /**
     * Sets the value/state of the selected `Radio` within the `RadioGroup` to the passed in value.
     */
    set value(newValue) {
        if (this._value !== newValue) {
            this._value = newValue;
            this.updateSelectedRadioFromValue();
            this.checkSelectedRadio();
        }
    }
    /**
     * Returns the value/state of the selected `Radio` within the `RadioGroup`.
     */
    get value() {
        return this._value;
    }
    /**
     * Replaces the name associated with the `RadioGroup` with the provided parameter.
     */
    set name(name) {
        this._name = name;
        this.updateRadios();
    }
    /**
     * Returns the associated name of the `RadioGroup`.
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the skeleton value in the `RadioGroup` if there is one.
     */
    get skeleton() {
        return this._skeleton;
    }
    /**
     * Sets the skeleton value for all `Radio` to the skeleton value of `RadioGroup`.
     */
    set skeleton(value) {
        this._skeleton = value;
        this.updateChildren();
    }
    /**
     * Updates the selected `Radio` to be checked (selected).
     */
    checkSelectedRadio() {
        if (this.selected && !this._selected.checked) {
            this.selected.checked = true;
        }
    }
    /**
     * Use the value of the `RadioGroup` to update the selected radio to the right state (selected state).
     */
    updateSelectedRadioFromValue() {
        let alreadySelected = this._selected != null && this._selected.value === this._value;
        if (this.radios && !alreadySelected) {
            this._selected = null;
            this.radios.forEach(radio => {
                if (radio.checked || radio.value === this._value) {
                    this._selected = radio;
                }
            });
        }
    }
    /**
     * Creates a class of `RadioChange` to emit the change in the `RadioGroup`.
     */
    emitChangeEvent(event) {
        this.change.emit(event);
        this.propagateChange(event.value);
        this.onTouched();
    }
    /**
     * Synchronizes radio properties.
     */
    updateRadios() {
        if (this.radios) {
            setTimeout(() => {
                this.radios.forEach(radio => radio.name = this.name);
                if (this.labelPlacement === "left") {
                    this.radios.forEach(radio => radio.labelPlacement = "left");
                }
            });
        }
    }
    /**
     * Updates the value of the `RadioGroup` using the provided parameter.
     */
    writeValue(value) {
        this.value = value;
        setTimeout(() => {
            this.updateSelectedRadioFromValue();
            this.checkSelectedRadio();
        });
    }
    ngAfterContentInit() {
        this.radios.changes.subscribe(() => {
            this.updateRadios();
            this.updateRadioChangeHandler();
        });
        this.updateChildren();
        this.updateRadioChangeHandler();
    }
    ngAfterViewInit() {
        this.updateRadios();
    }
    /**
     * Used to set method to propagate changes back to the form.
     */
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    /**
     * Registers a callback to be triggered when the control has been touched.
     * @param fn Callback to be triggered when the checkbox is touched.
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    updateChildren() {
        if (this.radios) {
            this.radios.forEach(child => child.skeleton = this.skeleton);
        }
    }
    updateRadioChangeHandler() {
        this.radios.forEach(radio => {
            radio.registerRadioChangeHandler((event) => {
                // update selected and value from the event
                this._selected = event.source;
                this._value = event.value;
                // bubble the event
                this.emitChangeEvent(event);
            });
        });
    }
}
/**
 * Used for creating the `RadioGroup` 'name' property dynamically.
 */
RadioGroup.radioGroupCount = 0;
RadioGroup.decorators = [
    { type: Component, args: [{
                selector: "ibm-radio-group",
                template: `
		<div
			class="bx--radio-button-group"
			[attr.aria-label]="ariaLabel"
			[attr.aria-labelledby]="ariaLabelledby"
			[ngClass]="{
				'bx--radio-button-group--vertical': orientation === 'vertical',
				'bx--radio-button-group--label-left': orientation === 'vertical' && labelPlacement === 'left'
			}">
			<ng-content></ng-content>
		</div>
	`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: RadioGroup,
                        multi: true
                    }
                ]
            }] }
];
RadioGroup.propDecorators = {
    orientation: [{ type: Input }],
    labelPlacement: [{ type: Input }],
    ariaLabel: [{ type: Input }],
    ariaLabelledby: [{ type: Input }],
    change: [{ type: Output }],
    radios: [{ type: ContentChildren, args: [forwardRef(() => Radio),] }],
    selected: [{ type: Input }],
    value: [{ type: Input }],
    name: [{ type: Input }],
    disabled: [{ type: Input }],
    skeleton: [{ type: Input }],
    radioButtonGroupClass: [{ type: HostBinding, args: ["class.bx--form-item",] }]
};

// modules
class RadioModule {
}
RadioModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    Radio,
                    RadioGroup
                ],
                exports: [
                    Radio,
                    RadioGroup
                ],
                imports: [
                    CommonModule,
                    FormsModule
                ]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { RadioChange, RadioGroup, Radio, RadioModule };

//# sourceMappingURL=carbon-components-angular-radio.js.map