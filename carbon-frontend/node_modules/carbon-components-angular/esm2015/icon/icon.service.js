/**
 *
 * carbon-angular v0.0.0 | icon.service.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Injectable } from "@angular/core";
import { toString } from "@carbon/icon-helpers";
/**
 * Abstract class that represent a cache of icons.
 *
 * The actual caching mechanism will be implementation specific,
 * but it's likely a good idea to key by the icons name and/or size.
 * Icon name and size will always be strings, and they will be the two consistent
 * identifiers of an icon. For the purposes of storage additonal descriptor properties may
 * be used, but the name and size are the only ones guarenteed to be passed for lookup purposes.
 */
export class IconCache {
}
/**
 * Custom error for when a name can't be found
 */
export class IconNameNotFoundError extends Error {
    constructor(name) {
        super(`Icon ${name} not found`);
    }
}
/**
 * Custom error for when a specific size can't be found
 */
export class IconSizeNotFoundError extends Error {
    constructor(size, name) {
        super("Size ${size} for ${name} not found");
    }
}
/**
 * Concrete implementation of `IconCache` as a simple in memory cache
 */
export class IconMemoryCache extends IconCache {
    constructor() {
        super(...arguments);
        this.iconMap = new Map();
    }
    get(name, size) {
        if (!this.iconMap.has(name)) {
            throw new IconNameNotFoundError(name);
        }
        const sizeMap = this.iconMap.get(name);
        if (!sizeMap.has(size)) {
            throw new IconSizeNotFoundError(size, name);
        }
        return sizeMap.get(size);
    }
    set(name, size, descriptor) {
        if (!this.iconMap.has(name)) {
            this.iconMap.set(name, new Map());
        }
        const sizeMap = this.iconMap.get(name);
        sizeMap.set(size, descriptor);
    }
}
/**
 * The icon service is a singleton service responsible for registering and retriving icons from `@carbon/icons`.
 *
 * It's important to register icons before use. It's reccommended to register your icons early, likely in your app.component.
 *
 * To allow for improved tree shaking _do not_ import all the icons from `@carbon/icons` and register them.
 * Instead register only the icons in use by your application. If your application makes use of lazy loaded
 * modules you may also lazy load the icons used in that module by registering them early on in that module.
 *
 * `ngOnInit` should be sufficiantly early to register icons.
 *
 * Example:
 * ```
 * import { Accessibility16 } from "@carbon/icons";
 *
 * // ...
 *
 * class MyComponent implements OnInit {
 * 	constructor(protected iconService: IconService) {}
 *
 * 	// ...
 *
 * 	ngOnInit() {
 * 		this.iconService.register(Accessibility16);
 * 	}
 *
 * 	// ...
 * }
 * ```
 *
 * If needed it is possible to register an icon under a different name, via `registerAs`.
 */
export class IconService {
    constructor() {
        this.iconCache = new IconMemoryCache();
    }
    /**
     * Registers an array of icons based on the metadata provided by `@carbon/cions`
     */
    registerAll(descriptors) {
        descriptors.forEach(icon => this.register(icon));
    }
    /**
     * Registers an icon based on the metadata provided by `@carbon/icons`
     */
    register(descriptor) {
        const { name } = descriptor;
        this.registerAs(name, descriptor);
    }
    /**
     * Registers an icon based on a uniqe name and metadata provided by `@carbon/icons`
     */
    registerAs(name, descriptor) {
        const { size } = descriptor;
        this.iconCache.set(name, size.toString(), descriptor);
    }
    /**
     * Gets an icon, converts it to a string, and caches the result
     */
    get(name, size) {
        try {
            const icon = this.iconCache.get(name, size.toString());
            if (!icon.svg) {
                icon.svg = toString(icon);
            }
            return icon;
        }
        catch (e) {
            throw e;
        }
    }
    /**
     * Configure various service settings (caching strategy ...)
     */
    configure(options) {
        this.iconCache = options.cache;
    }
}
IconService.decorators = [
    { type: Injectable }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWNvbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9pY29uLyIsInNvdXJjZXMiOlsiaWNvbi5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBNkVoRDs7Ozs7Ozs7R0FRRztBQUNILE1BQU0sT0FBZ0IsU0FBUztDQVM5QjtBQUVEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLHFCQUFzQixTQUFRLEtBQUs7SUFDL0MsWUFBWSxJQUFZO1FBQ3ZCLEtBQUssQ0FBQyxRQUFRLElBQUksWUFBWSxDQUFDLENBQUM7SUFDakMsQ0FBQztDQUNEO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8scUJBQXNCLFNBQVEsS0FBSztJQUMvQyxZQUFZLElBQVksRUFBRSxJQUFZO1FBQ3JDLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO0lBQzdDLENBQUM7Q0FDRDtBQUVEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLGVBQWdCLFNBQVEsU0FBUztJQUE5Qzs7UUFDUyxZQUFPLEdBQUcsSUFBSSxHQUFHLEVBQStCLENBQUM7SUFvQjFELENBQUM7SUFsQkEsR0FBRyxDQUFDLElBQVksRUFBRSxJQUFZO1FBQzdCLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUM1QixNQUFNLElBQUkscUJBQXFCLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDdEM7UUFDRCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN2QyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUN2QixNQUFNLElBQUkscUJBQXFCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQzVDO1FBQ0QsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFRCxHQUFHLENBQUMsSUFBWSxFQUFFLElBQVksRUFBRSxVQUFrQjtRQUNqRCxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDNUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLElBQUksR0FBRyxFQUFFLENBQUMsQ0FBQztTQUNsQztRQUNELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQy9CLENBQUM7Q0FDRDtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBK0JHO0FBRUgsTUFBTSxPQUFPLFdBQVc7SUFEeEI7UUFFUyxjQUFTLEdBQWMsSUFBSSxlQUFlLEVBQUUsQ0FBQztJQThDdEQsQ0FBQztJQTVDQTs7T0FFRztJQUNJLFdBQVcsQ0FBQyxXQUFxQjtRQUN2QyxXQUFXLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFRDs7T0FFRztJQUNJLFFBQVEsQ0FBQyxVQUFrQjtRQUNqQyxNQUFNLEVBQUUsSUFBSSxFQUFFLEdBQUcsVUFBNEIsQ0FBQztRQUM5QyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQztJQUNuQyxDQUFDO0lBRUQ7O09BRUc7SUFDSSxVQUFVLENBQUMsSUFBWSxFQUFFLFVBQWtCO1FBQ2pELE1BQU0sRUFBRSxJQUFJLEVBQUUsR0FBRyxVQUE0QixDQUFDO1FBQzlDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksR0FBRyxDQUFDLElBQVksRUFBRSxJQUFZO1FBQ3BDLElBQUk7WUFDSCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFtQixDQUFDO1lBQ3pFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFO2dCQUNkLElBQUksQ0FBQyxHQUFHLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQzFCO1lBQ0QsT0FBTyxJQUFJLENBQUM7U0FDWjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1gsTUFBTSxDQUFDLENBQUM7U0FDUjtJQUNGLENBQUM7SUFFRDs7T0FFRztJQUNJLFNBQVMsQ0FBQyxPQUE2QjtRQUM3QyxJQUFJLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7SUFDaEMsQ0FBQzs7O1lBL0NELFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IHRvU3RyaW5nIH0gZnJvbSBcIkBjYXJib24vaWNvbi1oZWxwZXJzXCI7XG5cbi8vIGljb24gaW1wb3J0c1xuaW1wb3J0IHtcblx0QWRkMTYsXG5cdENhbGVuZGFyMTYsXG5cdENhcmV0RG93bjE2LFxuXHRDYXJldExlZnQxNixcblx0Q2FyZXRSaWdodDE2LFxuXHRDYXJldFVwMTYsXG5cdENoZWNrbWFyazE2LFxuXHRDaGVja21hcmtGaWxsZWQxNixcblx0Q2hlY2ttYXJrT3V0bGluZTE2LFxuXHRDaGV2cm9uRG93bjE2LFxuXHRDaGV2cm9uUmlnaHQxNixcblx0Q2xvc2UxNixcblx0Q29weTE2LFxuXHREZWxldGUxNixcblx0RG93bmxvYWQxNixcblx0RXJyb3JGaWxsZWQxNixcblx0SW5mb3JtYXRpb25GaWxsZWQxNixcblx0TWVudTE2LFxuXHRPdmVyZmxvd01lbnVWZXJ0aWNhbDE2LFxuXHRTYXZlMTYsXG5cdFNldHRpbmdzMTYsXG5cdFdhcm5pbmcxNixcblx0V2FybmluZ0ZpbGxlZDE2XG59IGZyb20gXCJAY2FyYm9uL2ljb25zXCI7XG5cbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIHBhcnNlZCBpY29uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSWNvbkRlc2NyaXB0b3Ige1xuXHQvKipcblx0ICogVGhlIGVsZW1lbnQgdG8gcmVuZGVyLiBGb3IgdGhlIHJvb3QgdGhpcyBpcyBgc3ZnYFxuXHQgKi9cblx0ZWxlbTogc3RyaW5nO1xuXHQvKipcblx0ICogQW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIGVsZW1lbnQuXG5cdCAqXG5cdCAqIFRoZSB0eXBlIGhlcmUgaXMgbm9uLWV4aGF1c3RpdmUuXG5cdCAqL1xuXHRhdHRyczoge1xuXHRcdHhtbG5zOiBzdHJpbmcsXG5cdFx0Ly8gbmVlZGVkIGJ5IHRoZSBpY29uIGRpcmVjdGl2ZSB0byBkZXRlcm1pbmUgb3RoZXIgYXR0cmlidXRlc1xuXHRcdHZpZXdCb3g6IHN0cmluZyxcblx0XHRmaWxsOiBzdHJpbmcsXG5cdFx0Ly8gbmVlZGVkIGJ5IHRoZSBpY29uIGRpcmVjdGl2ZSB0byBkZXRlcm1pbmUgb3RoZXIgYXR0cmlidXRlc1xuXHRcdHdpZHRoOiBzdHJpbmcsXG5cdFx0Ly8gbmVlZGVkIGJ5IHRoZSBpY29uIGRpcmVjdGl2ZSB0byBkZXRlcm1pbmUgb3RoZXIgYXR0cmlidXRlc1xuXHRcdGhlaWdodDogc3RyaW5nLFxuXHRcdFt4OiBzdHJpbmddOiBzdHJpbmdcblx0fTtcblx0LyoqXG5cdCAqIFRoZSBjb250ZW50IChjaGlsZHJlbikgb2YgdGhlIGVsZW1lbnQgYXMgYW4gYXJyYXkgb2YgYEljb25EZXNjcmlwdG9yYHNcblx0ICogKHVzdWFsbHkgd2l0aG91dCBhIGZldyBmaWVsZHMsIG5hbWVseSBgbmFtZWAgYW5kIGBzaXplYClcblx0ICovXG5cdGNvbnRlbnQ6IEljb25EZXNjcmlwdG9yW107XG5cdC8qKlxuXHQgKiBUaGUgbmFtZSBvZiB0aGUgaWNvbi5cblx0ICpcblx0ICogTmVlZGVkIGJ5IHRoZSBpY29uIHNlcnZpY2UuXG5cdCAqL1xuXHRuYW1lOiBzdHJpbmc7XG5cdC8qKlxuXHQgKiBUaGUgc2l6ZSBvZiB0aGUgaWNvbiBpbiBwaXhlbHMuXG5cdCAqXG5cdCAqIE5lZWRlZCBieSB0aGUgaWNvbiBzZXJ2aWNlLlxuXHQgKi9cblx0c2l6ZTogbnVtYmVyO1xuXHQvKipcblx0ICogT3B0aW9uYWwuIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb21waWxlZCBzdmcuXG5cdCAqIElmIG1pc3NpbmcgdGhlIGljb24gc2VydmljZSB3aWxsIGFkZCB0aGlzLlxuXHQgKi9cblx0c3ZnPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIHRoYXQgcmVwcmVzZW50IGEgY2FjaGUgb2YgaWNvbnMuXG4gKlxuICogVGhlIGFjdHVhbCBjYWNoaW5nIG1lY2hhbmlzbSB3aWxsIGJlIGltcGxlbWVudGF0aW9uIHNwZWNpZmljLFxuICogYnV0IGl0J3MgbGlrZWx5IGEgZ29vZCBpZGVhIHRvIGtleSBieSB0aGUgaWNvbnMgbmFtZSBhbmQvb3Igc2l6ZS5cbiAqIEljb24gbmFtZSBhbmQgc2l6ZSB3aWxsIGFsd2F5cyBiZSBzdHJpbmdzLCBhbmQgdGhleSB3aWxsIGJlIHRoZSB0d28gY29uc2lzdGVudFxuICogaWRlbnRpZmllcnMgb2YgYW4gaWNvbi4gRm9yIHRoZSBwdXJwb3NlcyBvZiBzdG9yYWdlIGFkZGl0b25hbCBkZXNjcmlwdG9yIHByb3BlcnRpZXMgbWF5XG4gKiBiZSB1c2VkLCBidXQgdGhlIG5hbWUgYW5kIHNpemUgYXJlIHRoZSBvbmx5IG9uZXMgZ3VhcmVudGVlZCB0byBiZSBwYXNzZWQgZm9yIGxvb2t1cCBwdXJwb3Nlcy5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEljb25DYWNoZSB7XG5cdC8qKlxuXHQgKiBGaW5kcyBhbmQgcmV0dXJucyBhbiBpY29uIGJhc2VkIG9uIGl0J3MgbmFtZSBhbmQgc2l6ZVxuXHQgKi9cblx0YWJzdHJhY3QgZ2V0KG5hbWU6IHN0cmluZywgc2l6ZTogc3RyaW5nKTogb2JqZWN0O1xuXHQvKipcblx0ICogc3RvcmVzIGFuIGljb24gZGVzY3JpcHRvciB0byB0aGUgY2FjaGVcblx0ICovXG5cdGFic3RyYWN0IHNldChuYW1lOiBzdHJpbmcsIHNpemU6IHN0cmluZywgZGVzY3JpcHRvcjogb2JqZWN0KTogdm9pZDtcbn1cblxuLyoqXG4gKiBDdXN0b20gZXJyb3IgZm9yIHdoZW4gYSBuYW1lIGNhbid0IGJlIGZvdW5kXG4gKi9cbmV4cG9ydCBjbGFzcyBJY29uTmFtZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG5hbWU6IHN0cmluZykge1xuXHRcdHN1cGVyKGBJY29uICR7bmFtZX0gbm90IGZvdW5kYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDdXN0b20gZXJyb3IgZm9yIHdoZW4gYSBzcGVjaWZpYyBzaXplIGNhbid0IGJlIGZvdW5kXG4gKi9cbmV4cG9ydCBjbGFzcyBJY29uU2l6ZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKHNpemU6IHN0cmluZywgbmFtZTogc3RyaW5nKSB7XG5cdFx0c3VwZXIoXCJTaXplICR7c2l6ZX0gZm9yICR7bmFtZX0gbm90IGZvdW5kXCIpO1xuXHR9XG59XG5cbi8qKlxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgYEljb25DYWNoZWAgYXMgYSBzaW1wbGUgaW4gbWVtb3J5IGNhY2hlXG4gKi9cbmV4cG9ydCBjbGFzcyBJY29uTWVtb3J5Q2FjaGUgZXh0ZW5kcyBJY29uQ2FjaGUge1xuXHRwcml2YXRlIGljb25NYXAgPSBuZXcgTWFwPHN0cmluZywgTWFwPHN0cmluZywgb2JqZWN0Pj4oKTtcblxuXHRnZXQobmFtZTogc3RyaW5nLCBzaXplOiBzdHJpbmcpIHtcblx0XHRpZiAoIXRoaXMuaWNvbk1hcC5oYXMobmFtZSkpIHtcblx0XHRcdHRocm93IG5ldyBJY29uTmFtZU5vdEZvdW5kRXJyb3IobmFtZSk7XG5cdFx0fVxuXHRcdGNvbnN0IHNpemVNYXAgPSB0aGlzLmljb25NYXAuZ2V0KG5hbWUpO1xuXHRcdGlmICghc2l6ZU1hcC5oYXMoc2l6ZSkpIHtcblx0XHRcdHRocm93IG5ldyBJY29uU2l6ZU5vdEZvdW5kRXJyb3Ioc2l6ZSwgbmFtZSk7XG5cdFx0fVxuXHRcdHJldHVybiBzaXplTWFwLmdldChzaXplKTtcblx0fVxuXG5cdHNldChuYW1lOiBzdHJpbmcsIHNpemU6IHN0cmluZywgZGVzY3JpcHRvcjogb2JqZWN0KSB7XG5cdFx0aWYgKCF0aGlzLmljb25NYXAuaGFzKG5hbWUpKSB7XG5cdFx0XHR0aGlzLmljb25NYXAuc2V0KG5hbWUsIG5ldyBNYXAoKSk7XG5cdFx0fVxuXHRcdGNvbnN0IHNpemVNYXAgPSB0aGlzLmljb25NYXAuZ2V0KG5hbWUpO1xuXHRcdHNpemVNYXAuc2V0KHNpemUsIGRlc2NyaXB0b3IpO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGljb24gc2VydmljZSBpcyBhIHNpbmdsZXRvbiBzZXJ2aWNlIHJlc3BvbnNpYmxlIGZvciByZWdpc3RlcmluZyBhbmQgcmV0cml2aW5nIGljb25zIGZyb20gYEBjYXJib24vaWNvbnNgLlxuICpcbiAqIEl0J3MgaW1wb3J0YW50IHRvIHJlZ2lzdGVyIGljb25zIGJlZm9yZSB1c2UuIEl0J3MgcmVjY29tbWVuZGVkIHRvIHJlZ2lzdGVyIHlvdXIgaWNvbnMgZWFybHksIGxpa2VseSBpbiB5b3VyIGFwcC5jb21wb25lbnQuXG4gKlxuICogVG8gYWxsb3cgZm9yIGltcHJvdmVkIHRyZWUgc2hha2luZyBfZG8gbm90XyBpbXBvcnQgYWxsIHRoZSBpY29ucyBmcm9tIGBAY2FyYm9uL2ljb25zYCBhbmQgcmVnaXN0ZXIgdGhlbS5cbiAqIEluc3RlYWQgcmVnaXN0ZXIgb25seSB0aGUgaWNvbnMgaW4gdXNlIGJ5IHlvdXIgYXBwbGljYXRpb24uIElmIHlvdXIgYXBwbGljYXRpb24gbWFrZXMgdXNlIG9mIGxhenkgbG9hZGVkXG4gKiBtb2R1bGVzIHlvdSBtYXkgYWxzbyBsYXp5IGxvYWQgdGhlIGljb25zIHVzZWQgaW4gdGhhdCBtb2R1bGUgYnkgcmVnaXN0ZXJpbmcgdGhlbSBlYXJseSBvbiBpbiB0aGF0IG1vZHVsZS5cbiAqXG4gKiBgbmdPbkluaXRgIHNob3VsZCBiZSBzdWZmaWNpYW50bHkgZWFybHkgdG8gcmVnaXN0ZXIgaWNvbnMuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYFxuICogaW1wb3J0IHsgQWNjZXNzaWJpbGl0eTE2IH0gZnJvbSBcIkBjYXJib24vaWNvbnNcIjtcbiAqXG4gKiAvLyAuLi5cbiAqXG4gKiBjbGFzcyBNeUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gKiBcdGNvbnN0cnVjdG9yKHByb3RlY3RlZCBpY29uU2VydmljZTogSWNvblNlcnZpY2UpIHt9XG4gKlxuICogXHQvLyAuLi5cbiAqXG4gKiBcdG5nT25Jbml0KCkge1xuICogXHRcdHRoaXMuaWNvblNlcnZpY2UucmVnaXN0ZXIoQWNjZXNzaWJpbGl0eTE2KTtcbiAqIFx0fVxuICpcbiAqIFx0Ly8gLi4uXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBJZiBuZWVkZWQgaXQgaXMgcG9zc2libGUgdG8gcmVnaXN0ZXIgYW4gaWNvbiB1bmRlciBhIGRpZmZlcmVudCBuYW1lLCB2aWEgYHJlZ2lzdGVyQXNgLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgSWNvblNlcnZpY2Uge1xuXHRwcml2YXRlIGljb25DYWNoZTogSWNvbkNhY2hlID0gbmV3IEljb25NZW1vcnlDYWNoZSgpO1xuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYW4gYXJyYXkgb2YgaWNvbnMgYmFzZWQgb24gdGhlIG1ldGFkYXRhIHByb3ZpZGVkIGJ5IGBAY2FyYm9uL2Npb25zYFxuXHQgKi9cblx0cHVibGljIHJlZ2lzdGVyQWxsKGRlc2NyaXB0b3JzOiBvYmplY3RbXSkge1xuXHRcdGRlc2NyaXB0b3JzLmZvckVhY2goaWNvbiA9PiB0aGlzLnJlZ2lzdGVyKGljb24pKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYW4gaWNvbiBiYXNlZCBvbiB0aGUgbWV0YWRhdGEgcHJvdmlkZWQgYnkgYEBjYXJib24vaWNvbnNgXG5cdCAqL1xuXHRwdWJsaWMgcmVnaXN0ZXIoZGVzY3JpcHRvcjogb2JqZWN0KSB7XG5cdFx0Y29uc3QgeyBuYW1lIH0gPSBkZXNjcmlwdG9yIGFzIEljb25EZXNjcmlwdG9yO1xuXHRcdHRoaXMucmVnaXN0ZXJBcyhuYW1lLCBkZXNjcmlwdG9yKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYW4gaWNvbiBiYXNlZCBvbiBhIHVuaXFlIG5hbWUgYW5kIG1ldGFkYXRhIHByb3ZpZGVkIGJ5IGBAY2FyYm9uL2ljb25zYFxuXHQgKi9cblx0cHVibGljIHJlZ2lzdGVyQXMobmFtZTogc3RyaW5nLCBkZXNjcmlwdG9yOiBvYmplY3QpIHtcblx0XHRjb25zdCB7IHNpemUgfSA9IGRlc2NyaXB0b3IgYXMgSWNvbkRlc2NyaXB0b3I7XG5cdFx0dGhpcy5pY29uQ2FjaGUuc2V0KG5hbWUsIHNpemUudG9TdHJpbmcoKSwgZGVzY3JpcHRvcik7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBhbiBpY29uLCBjb252ZXJ0cyBpdCB0byBhIHN0cmluZywgYW5kIGNhY2hlcyB0aGUgcmVzdWx0XG5cdCAqL1xuXHRwdWJsaWMgZ2V0KG5hbWU6IHN0cmluZywgc2l6ZTogc3RyaW5nKTogSWNvbkRlc2NyaXB0b3Ige1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBpY29uID0gdGhpcy5pY29uQ2FjaGUuZ2V0KG5hbWUsIHNpemUudG9TdHJpbmcoKSkgYXMgSWNvbkRlc2NyaXB0b3I7XG5cdFx0XHRpZiAoIWljb24uc3ZnKSB7XG5cdFx0XHRcdGljb24uc3ZnID0gdG9TdHJpbmcoaWNvbik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaWNvbjtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDb25maWd1cmUgdmFyaW91cyBzZXJ2aWNlIHNldHRpbmdzIChjYWNoaW5nIHN0cmF0ZWd5IC4uLilcblx0ICovXG5cdHB1YmxpYyBjb25maWd1cmUob3B0aW9uczogeyBjYWNoZTogSWNvbkNhY2hlIH0pIHtcblx0XHR0aGlzLmljb25DYWNoZSA9IG9wdGlvbnMuY2FjaGU7XG5cdH1cbn1cbiJdfQ==