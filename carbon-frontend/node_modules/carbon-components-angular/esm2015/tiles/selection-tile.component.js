/**
 *
 * carbon-angular v0.0.0 | selection-tile.component.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Component, Input, Output, EventEmitter, ViewChild, HostListener } from "@angular/core";
import { I18n } from "carbon-components-angular/i18n";
export class SelectionTile {
    constructor(i18n) {
        this.i18n = i18n;
        /**
         * The unique id for the input.
         */
        this.id = `tile-${SelectionTile.tileCount}`;
        /**
         * Internal event used to notify the containing `TileGroup` of changes.
         */
        this.change = new EventEmitter();
        /**
         * Set by the containing `TileGroup`. Used for the `name` property on the input.
         */
        this.name = "tile-group-unbound";
        /**
         * Defines whether or not the `SelectionTile` supports selecting multiple tiles as opposed to single
         * tile selection.
         */
        this.multiple = true; // Set to true because of the way tile group sets it up.
        // If an initial selected value is set before input exists, we save
        // the value and check again when input exists in `AfterViewInit`.
        this._selected = null;
        SelectionTile.tileCount++;
    }
    /**
     * Updating the state of the input to match the state of the parameter passed in.
     * Set to `true` if this tile should be selected.
     */
    set selected(value) {
        // If an initial selected value is set before input exists, we save
        // the value and check again when input exists in `AfterViewInit`.
        this._selected = value ? true : null;
        if (this.input) {
            this.input.nativeElement.checked = this._selected;
        }
    }
    get selected() {
        return this.input ? this.input.nativeElement.checked : false;
    }
    ngAfterViewInit() {
        if (this.input) {
            setTimeout(() => {
                this.input.nativeElement.checked = this._selected;
            });
        }
    }
    keyboardInput(event) {
        if (event.key === "Enter" || event.key === "Spacebar" || event.key === " ") {
            this.selected = !this.selected;
            this.change.emit(event);
        }
    }
    onChange(event) {
        this.change.emit(event);
    }
}
SelectionTile.tileCount = 0;
SelectionTile.decorators = [
    { type: Component, args: [{
                selector: "ibm-selection-tile",
                template: `
		<label
			class="bx--tile bx--tile--selectable"
			tabindex="0"
			[for]="id"
			[ngClass]="{'bx--tile--is-selected' : selected}"
			[attr.aria-label]="i18n.get('TILES.TILE') | async">
			<input
				#input
				tabindex="-1"
				class="bx--tile-input"
				[id]="id"
				[type]="(multiple ? 'checkbox': 'radio')"
				[value]="value"
				[name]="name"
				(change)="onChange($event)"/>
			<div class="bx--tile__checkmark">
				<svg width="16" height="16" viewBox="0 0 16 16">
					<path d="M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16zm3.646-10.854L6.75 10.043 4.354 7.646l-.708.708 3.104 3.103 5.604-5.603-.708-.708z"
						fill-rule="evenodd"/>
				</svg>
			</div>
			<div class="bx--tile-content">
				<ng-content></ng-content>
			</div>
		</label>
	`
            }] }
];
/** @nocollapse */
SelectionTile.ctorParameters = () => [
    { type: I18n }
];
SelectionTile.propDecorators = {
    id: [{ type: Input }],
    selected: [{ type: Input }],
    value: [{ type: Input }],
    change: [{ type: Output }],
    input: [{ type: ViewChild, args: ["input", { static: true },] }],
    keyboardInput: [{ type: HostListener, args: ["keydown", ["$event"],] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0aW9uLXRpbGUuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci90aWxlcy8iLCJzb3VyY2VzIjpbInNlbGVjdGlvbi10aWxlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLFNBQVMsRUFDVCxZQUFZLEVBRVosTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBZ0N0RCxNQUFNLE9BQU8sYUFBYTtJQWlEekIsWUFBbUIsSUFBVTtRQUFWLFNBQUksR0FBSixJQUFJLENBQU07UUEvQzdCOztXQUVHO1FBQ00sT0FBRSxHQUFHLFFBQVEsYUFBYSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBcUJoRDs7V0FFRztRQUNPLFdBQU0sR0FBd0IsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUUzRDs7V0FFRztRQUNILFNBQUksR0FBRyxvQkFBb0IsQ0FBQztRQUM1Qjs7O1dBR0c7UUFDSCxhQUFRLEdBQUcsSUFBSSxDQUFDLENBQUMsd0RBQXdEO1FBTXpFLG1FQUFtRTtRQUNuRSxrRUFBa0U7UUFDeEQsY0FBUyxHQUFHLElBQUksQ0FBQztRQUcxQixhQUFhLENBQUMsU0FBUyxFQUFFLENBQUM7SUFDM0IsQ0FBQztJQTdDRDs7O09BR0c7SUFDSCxJQUFhLFFBQVEsQ0FBQyxLQUFjO1FBQ25DLG1FQUFtRTtRQUNuRSxrRUFBa0U7UUFDbEUsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1FBQ3JDLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNmLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO1NBQ2xEO0lBQ0YsQ0FBQztJQUVELElBQUksUUFBUTtRQUNYLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7SUFDOUQsQ0FBQztJQWdDRCxlQUFlO1FBQ2QsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ2YsVUFBVSxDQUFDLEdBQUcsRUFBRTtnQkFDZixJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztZQUNuRCxDQUFDLENBQUMsQ0FBQztTQUNIO0lBQ0YsQ0FBQztJQUdELGFBQWEsQ0FBQyxLQUFLO1FBQ2xCLElBQUksS0FBSyxDQUFDLEdBQUcsS0FBSyxPQUFPLElBQUksS0FBSyxDQUFDLEdBQUcsS0FBSyxVQUFVLElBQUksS0FBSyxDQUFDLEdBQUcsS0FBSyxHQUFHLEVBQUU7WUFDM0UsSUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7WUFDL0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDeEI7SUFDRixDQUFDO0lBRUQsUUFBUSxDQUFDLEtBQUs7UUFDYixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN6QixDQUFDOztBQXRFTSx1QkFBUyxHQUFHLENBQUMsQ0FBQzs7WUEvQnJCLFNBQVMsU0FBQztnQkFDVixRQUFRLEVBQUUsb0JBQW9CO2dCQUM5QixRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBMEJUO2FBQ0Q7Ozs7WUEvQlEsSUFBSTs7O2lCQXFDWCxLQUFLO3VCQUtMLEtBQUs7b0JBZUwsS0FBSztxQkFJTCxNQUFNO29CQWNOLFNBQVMsU0FBQyxPQUFPLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFOzRCQWtCbkMsWUFBWSxTQUFDLFNBQVMsRUFBRSxDQUFDLFFBQVEsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdENvbXBvbmVudCxcblx0SW5wdXQsXG5cdE91dHB1dCxcblx0RXZlbnRFbWl0dGVyLFxuXHRWaWV3Q2hpbGQsXG5cdEhvc3RMaXN0ZW5lcixcblx0QWZ0ZXJWaWV3SW5pdFxufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tIFwiQGFuZ3VsYXIvZm9ybXNcIjtcbmltcG9ydCB7IEkxOG4gfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9pMThuXCI7XG5cbkBDb21wb25lbnQoe1xuXHRzZWxlY3RvcjogXCJpYm0tc2VsZWN0aW9uLXRpbGVcIixcblx0dGVtcGxhdGU6IGBcblx0XHQ8bGFiZWxcblx0XHRcdGNsYXNzPVwiYngtLXRpbGUgYngtLXRpbGUtLXNlbGVjdGFibGVcIlxuXHRcdFx0dGFiaW5kZXg9XCIwXCJcblx0XHRcdFtmb3JdPVwiaWRcIlxuXHRcdFx0W25nQ2xhc3NdPVwieydieC0tdGlsZS0taXMtc2VsZWN0ZWQnIDogc2VsZWN0ZWR9XCJcblx0XHRcdFthdHRyLmFyaWEtbGFiZWxdPVwiaTE4bi5nZXQoJ1RJTEVTLlRJTEUnKSB8IGFzeW5jXCI+XG5cdFx0XHQ8aW5wdXRcblx0XHRcdFx0I2lucHV0XG5cdFx0XHRcdHRhYmluZGV4PVwiLTFcIlxuXHRcdFx0XHRjbGFzcz1cImJ4LS10aWxlLWlucHV0XCJcblx0XHRcdFx0W2lkXT1cImlkXCJcblx0XHRcdFx0W3R5cGVdPVwiKG11bHRpcGxlID8gJ2NoZWNrYm94JzogJ3JhZGlvJylcIlxuXHRcdFx0XHRbdmFsdWVdPVwidmFsdWVcIlxuXHRcdFx0XHRbbmFtZV09XCJuYW1lXCJcblx0XHRcdFx0KGNoYW5nZSk9XCJvbkNoYW5nZSgkZXZlbnQpXCIvPlxuXHRcdFx0PGRpdiBjbGFzcz1cImJ4LS10aWxlX19jaGVja21hcmtcIj5cblx0XHRcdFx0PHN2ZyB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCI+XG5cdFx0XHRcdFx0PHBhdGggZD1cIk04IDE2QTggOCAwIDEgMSA4IDBhOCA4IDAgMCAxIDAgMTZ6bTMuNjQ2LTEwLjg1NEw2Ljc1IDEwLjA0MyA0LjM1NCA3LjY0NmwtLjcwOC43MDggMy4xMDQgMy4xMDMgNS42MDQtNS42MDMtLjcwOC0uNzA4elwiXG5cdFx0XHRcdFx0XHRmaWxsLXJ1bGU9XCJldmVub2RkXCIvPlxuXHRcdFx0XHQ8L3N2Zz5cblx0XHRcdDwvZGl2PlxuXHRcdFx0PGRpdiBjbGFzcz1cImJ4LS10aWxlLWNvbnRlbnRcIj5cblx0XHRcdFx0PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9sYWJlbD5cblx0YFxufSlcbmV4cG9ydCBjbGFzcyBTZWxlY3Rpb25UaWxlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG5cdHN0YXRpYyB0aWxlQ291bnQgPSAwO1xuXHQvKipcblx0ICogVGhlIHVuaXF1ZSBpZCBmb3IgdGhlIGlucHV0LlxuXHQgKi9cblx0QElucHV0KCkgaWQgPSBgdGlsZS0ke1NlbGVjdGlvblRpbGUudGlsZUNvdW50fWA7XG5cdC8qKlxuXHQgKiBVcGRhdGluZyB0aGUgc3RhdGUgb2YgdGhlIGlucHV0IHRvIG1hdGNoIHRoZSBzdGF0ZSBvZiB0aGUgcGFyYW1ldGVyIHBhc3NlZCBpbi5cblx0ICogU2V0IHRvIGB0cnVlYCBpZiB0aGlzIHRpbGUgc2hvdWxkIGJlIHNlbGVjdGVkLlxuXHQgKi9cblx0QElucHV0KCkgc2V0IHNlbGVjdGVkKHZhbHVlOiBib29sZWFuKSB7XG5cdFx0Ly8gSWYgYW4gaW5pdGlhbCBzZWxlY3RlZCB2YWx1ZSBpcyBzZXQgYmVmb3JlIGlucHV0IGV4aXN0cywgd2Ugc2F2ZVxuXHRcdC8vIHRoZSB2YWx1ZSBhbmQgY2hlY2sgYWdhaW4gd2hlbiBpbnB1dCBleGlzdHMgaW4gYEFmdGVyVmlld0luaXRgLlxuXHRcdHRoaXMuX3NlbGVjdGVkID0gdmFsdWUgPyB0cnVlIDogbnVsbDtcblx0XHRpZiAodGhpcy5pbnB1dCkge1xuXHRcdFx0dGhpcy5pbnB1dC5uYXRpdmVFbGVtZW50LmNoZWNrZWQgPSB0aGlzLl9zZWxlY3RlZDtcblx0XHR9XG5cdH1cblxuXHRnZXQgc2VsZWN0ZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5wdXQgPyB0aGlzLmlucHV0Lm5hdGl2ZUVsZW1lbnQuY2hlY2tlZCA6IGZhbHNlO1xuXHR9XG5cdC8qKlxuXHQgKiBUaGUgdmFsdWUgZm9yIHRoZSB0aWxlLiBSZXR1cm5lZCB2aWEgYG5nTW9kZWxgIG9yIGBzZWxlY3RlZGAgZXZlbnQgb24gdGhlIGNvbnRhaW5pbmcgYFRpbGVHcm91cGAuXG5cdCAqL1xuXHRASW5wdXQoKSB2YWx1ZTogc3RyaW5nO1xuXHQvKipcblx0ICogSW50ZXJuYWwgZXZlbnQgdXNlZCB0byBub3RpZnkgdGhlIGNvbnRhaW5pbmcgYFRpbGVHcm91cGAgb2YgY2hhbmdlcy5cblx0ICovXG5cdEBPdXRwdXQoKSBjaGFuZ2U6IEV2ZW50RW1pdHRlcjxFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblx0LyoqXG5cdCAqIFNldCBieSB0aGUgY29udGFpbmluZyBgVGlsZUdyb3VwYC4gVXNlZCBmb3IgdGhlIGBuYW1lYCBwcm9wZXJ0eSBvbiB0aGUgaW5wdXQuXG5cdCAqL1xuXHRuYW1lID0gXCJ0aWxlLWdyb3VwLXVuYm91bmRcIjtcblx0LyoqXG5cdCAqIERlZmluZXMgd2hldGhlciBvciBub3QgdGhlIGBTZWxlY3Rpb25UaWxlYCBzdXBwb3J0cyBzZWxlY3RpbmcgbXVsdGlwbGUgdGlsZXMgYXMgb3Bwb3NlZCB0byBzaW5nbGVcblx0ICogdGlsZSBzZWxlY3Rpb24uXG5cdCAqL1xuXHRtdWx0aXBsZSA9IHRydWU7XHQvLyBTZXQgdG8gdHJ1ZSBiZWNhdXNlIG9mIHRoZSB3YXkgdGlsZSBncm91cCBzZXRzIGl0IHVwLlxuXHRcdFx0XHRcdFx0Ly8gSWYgaXQgaXMgZmlyc3QgdW5kZWZpbmVkIHRoZW4gc2V0IHRvIHRydWUsIHRoZSB0eXBlIHdpbGwgY2hhbmdlIGZyb20gcmFkaW8gdG8gY2hlY2tib3ggYW5kIGRlc2VsZWN0cyB0aGUgaW5wdXRzLlxuXG5cdC8vIEB0cy1pZ25vcmVcblx0QFZpZXdDaGlsZChcImlucHV0XCIsIHsgc3RhdGljOiB0cnVlIH0pIGlucHV0O1xuXG5cdC8vIElmIGFuIGluaXRpYWwgc2VsZWN0ZWQgdmFsdWUgaXMgc2V0IGJlZm9yZSBpbnB1dCBleGlzdHMsIHdlIHNhdmVcblx0Ly8gdGhlIHZhbHVlIGFuZCBjaGVjayBhZ2FpbiB3aGVuIGlucHV0IGV4aXN0cyBpbiBgQWZ0ZXJWaWV3SW5pdGAuXG5cdHByb3RlY3RlZCBfc2VsZWN0ZWQgPSBudWxsO1xuXG5cdGNvbnN0cnVjdG9yKHB1YmxpYyBpMThuOiBJMThuKSB7XG5cdFx0U2VsZWN0aW9uVGlsZS50aWxlQ291bnQrKztcblx0fVxuXG5cdG5nQWZ0ZXJWaWV3SW5pdCgpIHtcblx0XHRpZiAodGhpcy5pbnB1dCkge1xuXHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdHRoaXMuaW5wdXQubmF0aXZlRWxlbWVudC5jaGVja2VkID0gdGhpcy5fc2VsZWN0ZWQ7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRASG9zdExpc3RlbmVyKFwia2V5ZG93blwiLCBbXCIkZXZlbnRcIl0pXG5cdGtleWJvYXJkSW5wdXQoZXZlbnQpIHtcblx0XHRpZiAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIgfHwgZXZlbnQua2V5ID09PSBcIlNwYWNlYmFyXCIgfHwgZXZlbnQua2V5ID09PSBcIiBcIikge1xuXHRcdFx0dGhpcy5zZWxlY3RlZCA9ICF0aGlzLnNlbGVjdGVkO1xuXHRcdFx0dGhpcy5jaGFuZ2UuZW1pdChldmVudCk7XG5cdFx0fVxuXHR9XG5cblx0b25DaGFuZ2UoZXZlbnQpIHtcblx0XHR0aGlzLmNoYW5nZS5lbWl0KGV2ZW50KTtcblx0fVxufVxuXG5cbiJdfQ==