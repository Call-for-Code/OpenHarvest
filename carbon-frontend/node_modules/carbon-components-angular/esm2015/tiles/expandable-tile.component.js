/**
 *
 * carbon-angular v0.0.0 | expandable-tile.component.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Component, Input, ElementRef } from "@angular/core";
import { I18n } from "carbon-components-angular/i18n";
import { merge } from "carbon-components-angular/utils";
export class ExpandableTile {
    constructor(i18n, elementRef) {
        this.i18n = i18n;
        this.elementRef = elementRef;
        this.expanded = false;
        this.tileMaxHeight = 0;
        this.currentExpandedHeight = 0;
        this.element = this.elementRef.nativeElement;
        this.expand = this.i18n.getOverridable("TILES.EXPAND");
        this.collapse = this.i18n.getOverridable("TILES.COLLAPSE");
    }
    /**
     * Expects an object that contains some or all of:
     * ```
     * {
     *		"EXPAND": "Expand",
     *		"COLLAPSE": "Collapse",
     * }
     * ```
     */
    set translations(value) {
        const valueWithDefaults = merge(this.i18n.getMultiple("TILES"), value);
        this.expand.override(valueWithDefaults.EXPAND);
        this.collapse.override(valueWithDefaults.COLLAPSE);
    }
    ngAfterContentInit() {
        this.updateMaxHeight();
    }
    get expandedHeight() {
        const tile = this.element.querySelector(".bx--tile");
        const tilePadding = parseInt(getComputedStyle(tile).paddingBottom, 10) + parseInt(getComputedStyle(tile).paddingTop, 10);
        const expandedHeight = this.tileMaxHeight + tilePadding;
        if (!isNaN(expandedHeight)) {
            this.currentExpandedHeight = expandedHeight;
        }
        return this.currentExpandedHeight;
    }
    updateMaxHeight() {
        if (this.expanded) {
            this.tileMaxHeight = this.element.querySelector(".bx--tile-content").getBoundingClientRect().height;
        }
        else {
            this.tileMaxHeight = this.element.querySelector(".bx--tile-content__above-the-fold").getBoundingClientRect().height;
        }
    }
    onClick() {
        this.expanded = !this.expanded;
        this.updateMaxHeight();
    }
}
ExpandableTile.decorators = [
    { type: Component, args: [{
                selector: "ibm-expandable-tile",
                template: `
		<button
			class="bx--tile bx--tile--expandable"
			[ngClass]="{'bx--tile--is-expanded' : expanded}"
			[ngStyle]="{'max-height': expandedHeight + 'px'}"
			type="button"
			(click)="onClick()">
			<div class="bx--tile__chevron">
				<svg *ngIf="!expanded" width="12" height="7" viewBox="0 0 12 7" [attr.title]="expand.subject | async" role="img">
					<title>{{expand.subject | async}}</title>
					<path fill-rule="nonzero" d="M6.002 5.55L11.27 0l.726.685L6.003 7 0 .685.726 0z"/>
				</svg>
				<svg *ngIf="expanded" width="12" height="7" viewBox="0 0 12 7" [attr.title]="collapse.subject | async" role="img">
					<title>{{collapse.subject | async}}</title>
					<path fill-rule="nonzero" d="M6.002 5.55L11.27 0l.726.685L6.003 7 0 .685.726 0z"/>
				</svg>
			</div>
			<div class="bx--tile-content">
				<ng-content select=".bx--tile-content__above-the-fold"></ng-content>
				<ng-content select=".bx--tile-content__below-the-fold"></ng-content>
			</div>
		</button>
	`
            }] }
];
/** @nocollapse */
ExpandableTile.ctorParameters = () => [
    { type: I18n },
    { type: ElementRef }
];
ExpandableTile.propDecorators = {
    expanded: [{ type: Input }],
    translations: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwYW5kYWJsZS10aWxlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvdGlsZXMvIiwic291cmNlcyI6WyJleHBhbmRhYmxlLXRpbGUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTixTQUFTLEVBQ1QsS0FBSyxFQUNMLFVBQVUsRUFFVixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsSUFBSSxFQUFlLE1BQU0sZ0NBQWdDLENBQUM7QUFDbkUsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBaUN4RCxNQUFNLE9BQU8sY0FBYztJQXlCMUIsWUFBc0IsSUFBVSxFQUFZLFVBQXNCO1FBQTVDLFNBQUksR0FBSixJQUFJLENBQU07UUFBWSxlQUFVLEdBQVYsVUFBVSxDQUFZO1FBeEJ6RCxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBaUIxQixrQkFBYSxHQUFHLENBQUMsQ0FBQztRQUNsQiwwQkFBcUIsR0FBRyxDQUFDLENBQUM7UUFDMUIsWUFBTyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDO1FBRXhDLFdBQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUNsRCxhQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUVlLENBQUM7SUF2QnRFOzs7Ozs7OztPQVFHO0lBQ0gsSUFDSSxZQUFZLENBQUMsS0FBaUM7UUFDakQsTUFBTSxpQkFBaUIsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDdkUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDL0MsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQVdELGtCQUFrQjtRQUNqQixJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7SUFDeEIsQ0FBQztJQUVELElBQUksY0FBYztRQUNqQixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNyRCxNQUFNLFdBQVcsR0FDZCxRQUFRLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUMsYUFBYSxFQUFFLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDeEcsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLGFBQWEsR0FBRyxXQUFXLENBQUM7UUFDeEQsSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsRUFBRTtZQUMzQixJQUFJLENBQUMscUJBQXFCLEdBQUcsY0FBYyxDQUFDO1NBQzVDO1FBQ0QsT0FBTyxJQUFJLENBQUMscUJBQXFCLENBQUM7SUFDbkMsQ0FBQztJQUVELGVBQWU7UUFDZCxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDbEIsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLHFCQUFxQixFQUFFLENBQUMsTUFBTSxDQUFDO1NBQ3BHO2FBQU07WUFDTixJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLG1DQUFtQyxDQUFDLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxNQUFNLENBQUM7U0FDcEg7SUFDRixDQUFDO0lBRUQsT0FBTztRQUNOLElBQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQy9CLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztJQUN4QixDQUFDOzs7WUEvRUQsU0FBUyxTQUFDO2dCQUNWLFFBQVEsRUFBRSxxQkFBcUI7Z0JBQy9CLFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQXNCVDthQUNEOzs7O1lBakNRLElBQUk7WUFIWixVQUFVOzs7dUJBc0NULEtBQUs7MkJBVUwsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdENvbXBvbmVudCxcblx0SW5wdXQsXG5cdEVsZW1lbnRSZWYsXG5cdEFmdGVyQ29udGVudEluaXRcbn0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IEkxOG4sIE92ZXJyaWRhYmxlIH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvaTE4blwiO1xuaW1wb3J0IHsgbWVyZ2UgfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci91dGlsc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEV4cGFuZGFibGVUaWxlVHJhbnNsYXRpb25zIHtcblx0RVhQQU5EOiBzdHJpbmc7XG5cdENPTExBUFNFOiBzdHJpbmc7XG59XG5cbkBDb21wb25lbnQoe1xuXHRzZWxlY3RvcjogXCJpYm0tZXhwYW5kYWJsZS10aWxlXCIsXG5cdHRlbXBsYXRlOiBgXG5cdFx0PGJ1dHRvblxuXHRcdFx0Y2xhc3M9XCJieC0tdGlsZSBieC0tdGlsZS0tZXhwYW5kYWJsZVwiXG5cdFx0XHRbbmdDbGFzc109XCJ7J2J4LS10aWxlLS1pcy1leHBhbmRlZCcgOiBleHBhbmRlZH1cIlxuXHRcdFx0W25nU3R5bGVdPVwieydtYXgtaGVpZ2h0JzogZXhwYW5kZWRIZWlnaHQgKyAncHgnfVwiXG5cdFx0XHR0eXBlPVwiYnV0dG9uXCJcblx0XHRcdChjbGljayk9XCJvbkNsaWNrKClcIj5cblx0XHRcdDxkaXYgY2xhc3M9XCJieC0tdGlsZV9fY2hldnJvblwiPlxuXHRcdFx0XHQ8c3ZnICpuZ0lmPVwiIWV4cGFuZGVkXCIgd2lkdGg9XCIxMlwiIGhlaWdodD1cIjdcIiB2aWV3Qm94PVwiMCAwIDEyIDdcIiBbYXR0ci50aXRsZV09XCJleHBhbmQuc3ViamVjdCB8IGFzeW5jXCIgcm9sZT1cImltZ1wiPlxuXHRcdFx0XHRcdDx0aXRsZT57e2V4cGFuZC5zdWJqZWN0IHwgYXN5bmN9fTwvdGl0bGU+XG5cdFx0XHRcdFx0PHBhdGggZmlsbC1ydWxlPVwibm9uemVyb1wiIGQ9XCJNNi4wMDIgNS41NUwxMS4yNyAwbC43MjYuNjg1TDYuMDAzIDcgMCAuNjg1LjcyNiAwelwiLz5cblx0XHRcdFx0PC9zdmc+XG5cdFx0XHRcdDxzdmcgKm5nSWY9XCJleHBhbmRlZFwiIHdpZHRoPVwiMTJcIiBoZWlnaHQ9XCI3XCIgdmlld0JveD1cIjAgMCAxMiA3XCIgW2F0dHIudGl0bGVdPVwiY29sbGFwc2Uuc3ViamVjdCB8IGFzeW5jXCIgcm9sZT1cImltZ1wiPlxuXHRcdFx0XHRcdDx0aXRsZT57e2NvbGxhcHNlLnN1YmplY3QgfCBhc3luY319PC90aXRsZT5cblx0XHRcdFx0XHQ8cGF0aCBmaWxsLXJ1bGU9XCJub256ZXJvXCIgZD1cIk02LjAwMiA1LjU1TDExLjI3IDBsLjcyNi42ODVMNi4wMDMgNyAwIC42ODUuNzI2IDB6XCIvPlxuXHRcdFx0XHQ8L3N2Zz5cblx0XHRcdDwvZGl2PlxuXHRcdFx0PGRpdiBjbGFzcz1cImJ4LS10aWxlLWNvbnRlbnRcIj5cblx0XHRcdFx0PG5nLWNvbnRlbnQgc2VsZWN0PVwiLmJ4LS10aWxlLWNvbnRlbnRfX2Fib3ZlLXRoZS1mb2xkXCI+PC9uZy1jb250ZW50PlxuXHRcdFx0XHQ8bmctY29udGVudCBzZWxlY3Q9XCIuYngtLXRpbGUtY29udGVudF9fYmVsb3ctdGhlLWZvbGRcIj48L25nLWNvbnRlbnQ+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2J1dHRvbj5cblx0YFxufSlcbmV4cG9ydCBjbGFzcyBFeHBhbmRhYmxlVGlsZSBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQge1xuXHRASW5wdXQoKSBleHBhbmRlZCA9IGZhbHNlO1xuXHQvKipcblx0ICogRXhwZWN0cyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBzb21lIG9yIGFsbCBvZjpcblx0ICogYGBgXG5cdCAqIHtcblx0ICpcdFx0XCJFWFBBTkRcIjogXCJFeHBhbmRcIixcblx0ICpcdFx0XCJDT0xMQVBTRVwiOiBcIkNvbGxhcHNlXCIsXG5cdCAqIH1cblx0ICogYGBgXG5cdCAqL1xuXHRASW5wdXQoKVxuXHRzZXQgdHJhbnNsYXRpb25zKHZhbHVlOiBFeHBhbmRhYmxlVGlsZVRyYW5zbGF0aW9ucykge1xuXHRcdGNvbnN0IHZhbHVlV2l0aERlZmF1bHRzID0gbWVyZ2UodGhpcy5pMThuLmdldE11bHRpcGxlKFwiVElMRVNcIiksIHZhbHVlKTtcblx0XHR0aGlzLmV4cGFuZC5vdmVycmlkZSh2YWx1ZVdpdGhEZWZhdWx0cy5FWFBBTkQpO1xuXHRcdHRoaXMuY29sbGFwc2Uub3ZlcnJpZGUodmFsdWVXaXRoRGVmYXVsdHMuQ09MTEFQU0UpO1xuXHR9XG5cblx0dGlsZU1heEhlaWdodCA9IDA7XG5cdGN1cnJlbnRFeHBhbmRlZEhlaWdodCA9IDA7XG5cdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcblxuXHRleHBhbmQgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUSUxFUy5FWFBBTkRcIik7XG5cdGNvbGxhcHNlID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVElMRVMuQ09MTEFQU0VcIik7XG5cblx0Y29uc3RydWN0b3IocHJvdGVjdGVkIGkxOG46IEkxOG4sIHByb3RlY3RlZCBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7fVxuXG5cdG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcblx0XHR0aGlzLnVwZGF0ZU1heEhlaWdodCgpO1xuXHR9XG5cblx0Z2V0IGV4cGFuZGVkSGVpZ2h0KCkge1xuXHRcdGNvbnN0IHRpbGUgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcIi5ieC0tdGlsZVwiKTtcblx0XHRjb25zdCB0aWxlUGFkZGluZ1xuXHRcdFx0PSBwYXJzZUludChnZXRDb21wdXRlZFN0eWxlKHRpbGUpLnBhZGRpbmdCb3R0b20sIDEwKSArIHBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUodGlsZSkucGFkZGluZ1RvcCwgMTApO1xuXHRcdGNvbnN0IGV4cGFuZGVkSGVpZ2h0ID0gdGhpcy50aWxlTWF4SGVpZ2h0ICsgdGlsZVBhZGRpbmc7XG5cdFx0aWYgKCFpc05hTihleHBhbmRlZEhlaWdodCkpIHtcblx0XHRcdHRoaXMuY3VycmVudEV4cGFuZGVkSGVpZ2h0ID0gZXhwYW5kZWRIZWlnaHQ7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmN1cnJlbnRFeHBhbmRlZEhlaWdodDtcblx0fVxuXG5cdHVwZGF0ZU1heEhlaWdodCgpIHtcblx0XHRpZiAodGhpcy5leHBhbmRlZCkge1xuXHRcdFx0dGhpcy50aWxlTWF4SGVpZ2h0ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuYngtLXRpbGUtY29udGVudFwiKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudGlsZU1heEhlaWdodCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLmJ4LS10aWxlLWNvbnRlbnRfX2Fib3ZlLXRoZS1mb2xkXCIpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcblx0XHR9XG5cdH1cblxuXHRvbkNsaWNrKCkge1xuXHRcdHRoaXMuZXhwYW5kZWQgPSAhdGhpcy5leHBhbmRlZDtcblx0XHR0aGlzLnVwZGF0ZU1heEhlaWdodCgpO1xuXHR9XG59XG4iXX0=