/**
 *
 * carbon-angular v0.0.0 | table-model.class.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { EventEmitter } from "@angular/core";
import { TableHeaderItem } from "./table-header-item.class";
import { TableItem } from "./table-item.class";
import { Subject } from "rxjs";
/**
 * TableModel represents a data model for two-dimensional data. It's used for all things table
 * (table component, table toolbar, pagination, etc)
 *
 * TableModel manages its internal data integrity very well if you use the provided helper
 * functions for modifying rows and columns and assigning header and data in that order.
 *
 * It also provides direct access to the data so you can read and modify it.
 * If you change the structure of the data (by directly pushing into the arrays or otherwise),
 * keep in mind to keep the data structure intact.
 *
 * Header length and length of every line in the data should be equal.
 *
 * If they are not consistent, unexpected things will happen.
 *
 * Use the provided functions when in doubt.
 */
export class TableModel {
    constructor() {
        this.dataChange = new EventEmitter();
        this.rowsSelectedChange = new EventEmitter();
        this.rowsExpandedChange = new EventEmitter();
        /**
         * Gets emitted when `selectAll` is called. Emits false if all rows are deselected and true if
         * all rows are selected.
         */
        this.selectAllChange = new Subject();
        /**
         * Contains information about selection state of rows in the table.
         */
        this.rowsSelected = [];
        /**
         * Contains information about expanded state of rows in the table.
         */
        this.rowsExpanded = [];
        /**
         * Contains information about the context of the row.
         *
         * It affects styling of the row to reflect the context.
         *
         * string can be one of `"success" | "warning" | "info" | "error" | ""` and it's
         * empty or undefined by default
         */
        this.rowsContext = [];
        /**
         * Contains class name(s) of the row.
         *
         * It affects styling of the row to reflect the appended class name(s).
         *
         * It's empty or undefined by default
         */
        this.rowsClass = [];
        /**
         * Contains information about the header cells of the table.
         */
        this.header = [];
        /**
         * Tracks the current page.
         */
        this.currentPage = 1;
        /**
         * Length of page.
         */
        this.pageLength = 10;
        /**
         * Set to true when there is no more data to load in the table
         */
        this.isEnd = false;
        /**
         * Set to true when lazy loading to show loading indicator
         */
        this.isLoading = false;
        /**
         * Used in `data`
         */
        this._data = [[]];
        /**
         * The number of models instantiated, this is to make sure each table has a different
         * model count for unique id generation.
         */
        this.tableModelCount = 0;
        this.tableModelCount = TableModel.COUNT++;
    }
    /**
     * Sets data of the table.
     *
     * Make sure all rows are the same length to keep the column count accurate.
     */
    set data(newData) {
        if (!newData || (Array.isArray(newData) && newData.length === 0)) {
            newData = [[]];
        }
        this._data = newData;
        // init rowsSelected
        this.rowsSelected = new Array(this._data.length).fill(false);
        this.rowsExpanded = new Array(this._data.length).fill(false);
        // init rowsContext
        this.rowsContext = new Array(this._data.length);
        // init rowsClass
        this.rowsClass = new Array(this._data.length);
        // only create a fresh header if necessary (header doesn't exist or differs in length)
        if (this.header == null || (this.header.length !== this._data[0].length && this._data[0].length > 0)) {
            let header = new Array();
            for (let i = 0; i < this._data[0].length; i++) {
                header.push(new TableHeaderItem());
            }
            this.header = header;
        }
        this.dataChange.emit();
    }
    /**
     * Gets the full data.
     *
     * You can use it to alter individual `TableItem`s but if you need to change
     * table structure, use `addRow()` and/or `addColumn()`
     */
    get data() {
        return this._data;
    }
    /**
     * Manually set data length in case the data in the table doesn't
     * correctly reflect all the data that table is to display.
     *
     * Example: if you have multiple pages of data that table will display
     * but you're loading one at a time.
     *
     * Set to `null` to reset to default behavior.
     */
    set totalDataLength(length) {
        // if this function is called without a parameter we need to set to null to avoid having undefined != null
        this._totalDataLength = length || null;
    }
    /**
     * Total length of data that table has access to, or the amount manually set
     */
    get totalDataLength() {
        // if manually set data length
        if (this._totalDataLength !== null && this._totalDataLength >= 0) {
            return this._totalDataLength;
        }
        // if empty dataset
        if (this.data && this.data.length === 1 && this.data[0].length === 0) {
            return 0;
        }
        return this.data.length;
    }
    /**
     * Returns an id for the given column
     *
     * @param column the column to generate an id for
     * @param row the row of the header to generate an id for
     */
    getId(column, row = 0) {
        return `table-header-${row}-${column}-${this.tableModelCount}`;
    }
    /**
     * Returns the id of the header. Used to link the cells with headers (or headers with headers)
     *
     * @param column the column to start getting headers for
     * @param colSpan the number of columns to get headers for (defaults to 1)
     */
    getHeaderId(column, colSpan = 1) {
        if (column === "select" || column === "expand") {
            return this.getId(column);
        }
        let ids = [];
        for (let i = column; i >= 0; i--) {
            if (this.header[i]) {
                for (let j = 0; j < colSpan; j++) {
                    ids.push(this.getId(i + j));
                }
                break;
            }
        }
        return ids.join(" ");
    }
    /**
     * Finds closest header by trying the `column` and then working its way to the left
     *
     * @param column the target column
     */
    getHeader(column) {
        if (!this.header) {
            return null;
        }
        for (let i = column; i >= 0; i--) {
            const headerCell = this.header[i];
            if (headerCell) {
                return headerCell;
            }
        }
        return null;
    }
    /**
     * Returns how many rows is currently selected
     */
    selectedRowsCount() {
        let count = 0;
        if (this.rowsSelected) {
            this.rowsSelected.forEach(rowSelected => {
                if (rowSelected) {
                    count++;
                }
            });
        }
        return count;
    }
    /**
     * Returns how many rows is currently expanded
     */
    expandedRowsCount() {
        let count = 0;
        if (this.rowsExpanded) {
            this.rowsExpanded.forEach(rowExpanded => {
                if (rowExpanded) {
                    count++;
                }
            });
        }
        return count;
    }
    /**
     * Returns `index`th row of the table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    row(index) {
        return this.data[this.realRowIndex(index)];
    }
    /**
     * Adds a row to the `index`th row or appends to table if index not provided.
     *
     * If row is shorter than other rows or not provided, it will be padded with
     * empty `TableItem` elements.
     *
     * If row is longer than other rows, others will be extended to match so no data is lost.
     *
     * If called on an empty table with no parameters, it creates a 1x1 table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param [row]
     * @param [index]
     */
    addRow(row, index) {
        // if table empty create table with row
        if (!this.data || this.data.length === 0 || this.data[0].length === 0) {
            let newData = new Array();
            newData.push(row ? row : [new TableItem()]); // row or one empty one column row
            this.data = newData;
            return;
        }
        let realRow = row;
        const columnCount = this.data[0].length;
        if (row == null) {
            realRow = new Array();
            for (let i = 0; i < columnCount; i++) {
                realRow.push(new TableItem());
            }
        }
        if (realRow.length < columnCount) {
            // extend the length of realRow
            const difference = columnCount - realRow.length;
            for (let i = 0; i < difference; i++) {
                realRow.push(new TableItem());
            }
        }
        else if (realRow.length > columnCount) {
            // extend the length of header
            let difference = realRow.length - this.header.length;
            for (let j = 0; j < difference; j++) {
                this.header.push(new TableHeaderItem());
            }
            // extend the length of every other row
            for (let i = 0; i < this.data.length; i++) {
                let currentRow = this.data[i];
                difference = realRow.length - currentRow.length;
                for (let j = 0; j < difference; j++) {
                    currentRow.push(new TableItem());
                }
            }
        }
        if (index == null) {
            this.data.push(realRow);
            // update rowsSelected property for length
            this.rowsSelected.push(false);
            // update rowsExpanded property for length
            this.rowsExpanded.push(false);
            // update rowsContext property for length
            this.rowsContext.push(undefined);
            // update rowsClass property for length
            this.rowsClass.push(undefined);
        }
        else {
            const ri = this.realRowIndex(index);
            this.data.splice(ri, 0, realRow);
            // update rowsSelected property for length
            this.rowsSelected.splice(ri, 0, false);
            // update rowsExpanded property for length
            this.rowsExpanded.splice(ri, 0, false);
            // update rowsContext property for length
            this.rowsContext.splice(ri, 0, undefined);
            // update rowsClass property for length
            this.rowsClass.splice(ri, 0, undefined);
        }
        this.dataChange.emit();
    }
    /**
     * Deletes `index`th row.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    deleteRow(index) {
        const rri = this.realRowIndex(index);
        this.data.splice(rri, 1);
        this.rowsSelected.splice(rri, 1);
        this.rowsExpanded.splice(rri, 1);
        this.rowsContext.splice(rri, 1);
        this.rowsClass.splice(rri, 1);
        this.dataChange.emit();
    }
    hasExpandableRows() {
        return this.data.some(data => data.some(d => d && d.expandedData)); // checking for some in 2D array
    }
    isRowExpandable(index) {
        return this.data[index].some(d => d && d.expandedData);
    }
    isRowExpanded(index) {
        return this.rowsExpanded[index];
    }
    getRowContext(index) {
        return this.rowsContext[index];
    }
    /**
     * Returns `index`th column of the table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    column(index) {
        let column = new Array();
        const ri = this.realColumnIndex(index);
        const rc = this.data.length;
        for (let i = 0; i < rc; i++) {
            const row = this.data[i];
            column.push(row[ri]);
        }
        return column;
    }
    /**
     * Adds a column to the `index`th column or appends to table if index not provided.
     *
     * If column is shorter than other columns or not provided, it will be padded with
     * empty `TableItem` elements.
     *
     * If column is longer than other columns, others will be extended to match so no data is lost.
     *
     * If called on an empty table with no parameters, it creates a 1x1 table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param [column]
     * @param [index]
     */
    addColumn(column, index) {
        // if table empty create table with row
        if (!this.data || this.data.length === 0 || this.data[0].length === 0) {
            let newData = new Array();
            if (column == null) {
                newData.push([new TableItem()]);
            }
            else {
                for (let i = 0; i < column.length; i++) {
                    let item = column[i];
                    newData.push([item]);
                }
            }
            this.data = newData;
            return;
        }
        let rc = this.data.length; // row count
        let ci = this.realColumnIndex(index);
        // append missing rows
        for (let i = 0; column != null && i < column.length - rc; i++) {
            this.addRow();
        }
        rc = this.data.length;
        if (index == null) {
            // append to end
            for (let i = 0; i < rc; i++) {
                let row = this.data[i];
                row.push(column == null || column[i] == null ? new TableItem() : column[i]);
            }
            // update header if not already set by user
            if (this.header.length < this.data[0].length) {
                this.header.push(new TableHeaderItem());
            }
        }
        else {
            if (index >= this.data[0].length) {
                // if trying to append
                ci++;
            }
            // insert
            for (let i = 0; i < rc; i++) {
                let row = this.data[i];
                row.splice(ci, 0, column == null || column[i] == null ? new TableItem() : column[i]);
            }
            // update header if not already set by user
            if (this.header.length < this.data[0].length) {
                this.header.splice(ci, 0, new TableHeaderItem());
            }
        }
        this.dataChange.emit();
    }
    /**
     * Deletes `index`th column.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    deleteColumn(index) {
        const rci = this.realColumnIndex(index);
        const rowCount = this.data.length;
        for (let i = 0; i < rowCount; i++) {
            this.data[i].splice(rci, 1);
        }
        // update header if not already set by user
        if (this.header.length > this.data[0].length) {
            this.header.splice(rci, 1);
        }
        this.dataChange.emit();
    }
    moveColumn(indexFrom, indexTo) {
        const headerFrom = this.header[indexFrom];
        this.addColumn(this.column(indexFrom), indexTo);
        this.deleteColumn(indexFrom + (indexTo < indexFrom ? 1 : 0));
        this.header[indexTo + (indexTo > indexFrom ? -1 : 0)] = headerFrom;
    }
    /**
     * Sorts the data currently present in the model based on `compare()`
     *
     * Direction is set by `ascending` and `descending` properties of `TableHeaderItem`
     * in `index`th column.
     *
     * @param index The column based on which it's sorting
     */
    sort(index) {
        this.pushRowStateToModelData();
        this.data.sort((a, b) => (this.header[index].descending ? -1 : 1) * this.header[index].compare(a[index], b[index]));
        this.popRowStateFromModelData();
        this.header.forEach(column => column.sorted = false);
        this.header[index].sorted = true;
    }
    /**
     * Appends `rowsSelected` and `rowsExpanded` info to model data.
     *
     * When sorting rows, do this first so information about row selection
     * gets sorted with the other row info.
     *
     * Call `popRowSelectionFromModelData()` after sorting to make everything
     * right with the world again.
     */
    pushRowStateToModelData() {
        for (let i = 0; i < this.data.length; i++) {
            const rowSelectedMark = new TableItem();
            rowSelectedMark.data = this.rowsSelected[i];
            this.data[i].push(rowSelectedMark);
            const rowExpandedMark = new TableItem();
            rowExpandedMark.data = this.rowsExpanded[i];
            this.data[i].push(rowExpandedMark);
            const rowContext = new TableItem();
            rowContext.data = this.rowsContext[i];
            this.data[i].push(rowContext);
            const rowClass = new TableItem();
            rowClass.data = this.rowsClass[i];
            this.data[i].push(rowClass);
        }
    }
    /**
     * Restores `rowsSelected` from data pushed by `pushRowSelectionToModelData()`
     *
     * Call after sorting data (if you previously pushed to maintain selection order)
     * to make everything right with the world again.
     */
    popRowStateFromModelData() {
        for (let i = 0; i < this.data.length; i++) {
            this.rowsClass[i] = this.data[i].pop().data;
            this.rowsContext[i] = this.data[i].pop().data;
            this.rowsExpanded[i] = !!this.data[i].pop().data;
            this.rowsSelected[i] = !!this.data[i].pop().data;
        }
    }
    /**
     * Checks if row is filtered out.
     *
     * @param index
     * @returns true if any of the filters in header filters out the `index`th row
     */
    isRowFiltered(index) {
        const realIndex = this.realRowIndex(index);
        return this.header.some((item, i) => item && item.filter(this.row(realIndex)[i]));
    }
    /**
     * Select/deselect `index`th row based on value
     *
     * @param index index of the row to select
     * @param value state to set the row to. Defaults to `true`
     */
    selectRow(index, value = true) {
        if (this.isRowDisabled(index)) {
            return;
        }
        this.rowsSelected[index] = value;
        this.rowsSelectedChange.emit(index);
    }
    /**
     * Selects or deselects all rows in the model
     *
     * @param value state to set all rows to. Defaults to `true`
     */
    selectAll(value = true) {
        if (this.data.length >= 1) {
            for (let i = 0; i < this.rowsSelected.length; i++) {
                this.selectRow(i, value);
            }
        }
        this.selectAllChange.next(value);
    }
    isRowSelected(index) {
        return this.rowsSelected[index];
    }
    /**
     * Checks if row is disabled or not.
     */
    isRowDisabled(index) {
        const row = this.data[index];
        return !!row.disabled;
    }
    /**
     * Expands/Collapses `index`th row based on value
     *
     * @param index index of the row to expand or collapse
     * @param value expanded state of the row. `true` is expanded and `false` is collapsed
     */
    expandRow(index, value = true) {
        this.rowsExpanded[index] = value;
        this.rowsExpandedChange.emit(index);
    }
    /**
     * Gets the true index of a row based on it's relative position.
     * Like in Python, positive numbers start from the top and
     * negative numbers start from the bottom.
     *
     * @param index
     */
    realRowIndex(index) {
        return this.realIndex(index, this.data.length);
    }
    /**
     * Gets the true index of a column based on it's relative position.
     * Like in Python, positive numbers start from the top and
     * negative numbers start from the bottom.
     *
     * @param index
     */
    realColumnIndex(index) {
        return this.realIndex(index, this.data[0].length);
    }
    /**
     * Generic function to calculate the real index of something.
     * Used by `realRowIndex()` and `realColumnIndex()`
     *
     * @param index
     * @param length
     */
    realIndex(index, length) {
        if (index == null) {
            return length - 1;
        }
        else if (index >= 0) {
            return index >= length ? length - 1 : index;
        }
        else {
            return -index >= length ? 0 : length + index;
        }
    }
}
/**
 * The number of models instantiated, used for (among other things) unique id generation
 */
TableModel.COUNT = 0;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUtbW9kZWwuY2xhc3MuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL3RhYmxlLyIsInNvdXJjZXMiOlsidGFibGUtbW9kZWwuY2xhc3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNOLFlBQVksRUFDWixNQUFNLGVBQWUsQ0FBQztBQUd2QixPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDNUQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRS9DLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFJL0I7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkc7QUFDSCxNQUFNLE9BQU8sVUFBVTtJQWdLdEI7UUF4SEEsZUFBVSxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFDaEMsdUJBQWtCLEdBQUcsSUFBSSxZQUFZLEVBQVUsQ0FBQztRQUNoRCx1QkFBa0IsR0FBRyxJQUFJLFlBQVksRUFBVSxDQUFDO1FBQ2hEOzs7V0FHRztRQUNILG9CQUFlLEdBQUcsSUFBSSxPQUFPLEVBQVcsQ0FBQztRQVl6Qzs7V0FFRztRQUNILGlCQUFZLEdBQWMsRUFBRSxDQUFDO1FBRTdCOztXQUVHO1FBQ0gsaUJBQVksR0FBYyxFQUFFLENBQUM7UUFFN0I7Ozs7Ozs7V0FPRztRQUNILGdCQUFXLEdBQWEsRUFBRSxDQUFDO1FBRTNCOzs7Ozs7V0FNRztRQUNILGNBQVMsR0FBYSxFQUFFLENBQUM7UUFFekI7O1dBRUc7UUFDSCxXQUFNLEdBQXNCLEVBQUUsQ0FBQztRQUUvQjs7V0FFRztRQUNILGdCQUFXLEdBQUcsQ0FBQyxDQUFDO1FBRWhCOztXQUVHO1FBQ0gsZUFBVSxHQUFHLEVBQUUsQ0FBQztRQUVoQjs7V0FFRztRQUNILFVBQUssR0FBRyxLQUFLLENBQUM7UUFFZDs7V0FFRztRQUNILGNBQVMsR0FBRyxLQUFLLENBQUM7UUFzQ2xCOztXQUVHO1FBQ08s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LE1BQWM7UUFDaEQsSUFBSSxLQUFLLElBQUksSUFBSSxFQUFFO1lBQ2xCLE9BQU8sTUFBTSxHQUFHLENBQUMsQ0FBQztTQUNsQjthQUFNLElBQUksS0FBSyxJQUFJLENBQUMsRUFBRTtZQUN0QixPQUFPLEtBQUssSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztTQUM1QzthQUFNO1lBQ04sT0FBTyxDQUFDLEtBQUssSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztTQUM3QztJQUNGLENBQUM7O0FBcnBCRDs7R0FFRztBQUNjLGdCQUFLLEdBQUcsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0RXZlbnRFbWl0dGVyXG59IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5cbmltcG9ydCB7IFBhZ2luYXRpb25Nb2RlbCB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL3BhZ2luYXRpb25cIjtcbmltcG9ydCB7IFRhYmxlSGVhZGVySXRlbSB9IGZyb20gXCIuL3RhYmxlLWhlYWRlci1pdGVtLmNsYXNzXCI7XG5pbXBvcnQgeyBUYWJsZUl0ZW0gfSBmcm9tIFwiLi90YWJsZS1pdGVtLmNsYXNzXCI7XG5pbXBvcnQgeyBUYWJsZVJvdyB9IGZyb20gXCIuL3RhYmxlLXJvdy5jbGFzc1wiO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gXCJyeGpzXCI7XG5cbmV4cG9ydCB0eXBlIEhlYWRlclR5cGUgPSBudW1iZXIgfCBcInNlbGVjdFwiIHwgXCJleHBhbmRcIjtcblxuLyoqXG4gKiBUYWJsZU1vZGVsIHJlcHJlc2VudHMgYSBkYXRhIG1vZGVsIGZvciB0d28tZGltZW5zaW9uYWwgZGF0YS4gSXQncyB1c2VkIGZvciBhbGwgdGhpbmdzIHRhYmxlXG4gKiAodGFibGUgY29tcG9uZW50LCB0YWJsZSB0b29sYmFyLCBwYWdpbmF0aW9uLCBldGMpXG4gKlxuICogVGFibGVNb2RlbCBtYW5hZ2VzIGl0cyBpbnRlcm5hbCBkYXRhIGludGVncml0eSB2ZXJ5IHdlbGwgaWYgeW91IHVzZSB0aGUgcHJvdmlkZWQgaGVscGVyXG4gKiBmdW5jdGlvbnMgZm9yIG1vZGlmeWluZyByb3dzIGFuZCBjb2x1bW5zIGFuZCBhc3NpZ25pbmcgaGVhZGVyIGFuZCBkYXRhIGluIHRoYXQgb3JkZXIuXG4gKlxuICogSXQgYWxzbyBwcm92aWRlcyBkaXJlY3QgYWNjZXNzIHRvIHRoZSBkYXRhIHNvIHlvdSBjYW4gcmVhZCBhbmQgbW9kaWZ5IGl0LlxuICogSWYgeW91IGNoYW5nZSB0aGUgc3RydWN0dXJlIG9mIHRoZSBkYXRhIChieSBkaXJlY3RseSBwdXNoaW5nIGludG8gdGhlIGFycmF5cyBvciBvdGhlcndpc2UpLFxuICoga2VlcCBpbiBtaW5kIHRvIGtlZXAgdGhlIGRhdGEgc3RydWN0dXJlIGludGFjdC5cbiAqXG4gKiBIZWFkZXIgbGVuZ3RoIGFuZCBsZW5ndGggb2YgZXZlcnkgbGluZSBpbiB0aGUgZGF0YSBzaG91bGQgYmUgZXF1YWwuXG4gKlxuICogSWYgdGhleSBhcmUgbm90IGNvbnNpc3RlbnQsIHVuZXhwZWN0ZWQgdGhpbmdzIHdpbGwgaGFwcGVuLlxuICpcbiAqIFVzZSB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIHdoZW4gaW4gZG91YnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBUYWJsZU1vZGVsIGltcGxlbWVudHMgUGFnaW5hdGlvbk1vZGVsIHtcblx0LyoqXG5cdCAqIFRoZSBudW1iZXIgb2YgbW9kZWxzIGluc3RhbnRpYXRlZCwgdXNlZCBmb3IgKGFtb25nIG90aGVyIHRoaW5ncykgdW5pcXVlIGlkIGdlbmVyYXRpb25cblx0ICovXG5cdHByb3RlY3RlZCBzdGF0aWMgQ09VTlQgPSAwO1xuXG5cdC8qKlxuXHQgKiBTZXRzIGRhdGEgb2YgdGhlIHRhYmxlLlxuXHQgKlxuXHQgKiBNYWtlIHN1cmUgYWxsIHJvd3MgYXJlIHRoZSBzYW1lIGxlbmd0aCB0byBrZWVwIHRoZSBjb2x1bW4gY291bnQgYWNjdXJhdGUuXG5cdCAqL1xuXHRzZXQgZGF0YShuZXdEYXRhOiBUYWJsZUl0ZW1bXVtdKSB7XG5cdFx0aWYgKCFuZXdEYXRhIHx8IChBcnJheS5pc0FycmF5KG5ld0RhdGEpICYmIG5ld0RhdGEubGVuZ3RoID09PSAwKSApIHtcblx0XHRcdG5ld0RhdGEgPSBbW11dO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RhdGEgPSBuZXdEYXRhO1xuXG5cdFx0Ly8gaW5pdCByb3dzU2VsZWN0ZWRcblx0XHR0aGlzLnJvd3NTZWxlY3RlZCA9IG5ldyBBcnJheTxib29sZWFuPih0aGlzLl9kYXRhLmxlbmd0aCkuZmlsbChmYWxzZSk7XG5cdFx0dGhpcy5yb3dzRXhwYW5kZWQgPSBuZXcgQXJyYXk8Ym9vbGVhbj4odGhpcy5fZGF0YS5sZW5ndGgpLmZpbGwoZmFsc2UpO1xuXG5cdFx0Ly8gaW5pdCByb3dzQ29udGV4dFxuXHRcdHRoaXMucm93c0NvbnRleHQgPSBuZXcgQXJyYXk8c3RyaW5nPih0aGlzLl9kYXRhLmxlbmd0aCk7XG5cblx0XHQvLyBpbml0IHJvd3NDbGFzc1xuXHRcdHRoaXMucm93c0NsYXNzID0gbmV3IEFycmF5PHN0cmluZz4odGhpcy5fZGF0YS5sZW5ndGgpO1xuXG5cdFx0Ly8gb25seSBjcmVhdGUgYSBmcmVzaCBoZWFkZXIgaWYgbmVjZXNzYXJ5IChoZWFkZXIgZG9lc24ndCBleGlzdCBvciBkaWZmZXJzIGluIGxlbmd0aClcblx0XHRpZiAodGhpcy5oZWFkZXIgPT0gbnVsbCB8fCAodGhpcy5oZWFkZXIubGVuZ3RoICE9PSB0aGlzLl9kYXRhWzBdLmxlbmd0aCAmJiB0aGlzLl9kYXRhWzBdLmxlbmd0aCA+IDApKSB7XG5cdFx0XHRsZXQgaGVhZGVyID0gbmV3IEFycmF5PFRhYmxlSGVhZGVySXRlbT4oKTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZGF0YVswXS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRoZWFkZXIucHVzaChuZXcgVGFibGVIZWFkZXJJdGVtKCkpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5oZWFkZXIgPSBoZWFkZXI7XG5cdFx0fVxuXG5cdFx0dGhpcy5kYXRhQ2hhbmdlLmVtaXQoKTtcblx0fVxuXG5cdGRhdGFDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cdHJvd3NTZWxlY3RlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXHRyb3dzRXhwYW5kZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblx0LyoqXG5cdCAqIEdldHMgZW1pdHRlZCB3aGVuIGBzZWxlY3RBbGxgIGlzIGNhbGxlZC4gRW1pdHMgZmFsc2UgaWYgYWxsIHJvd3MgYXJlIGRlc2VsZWN0ZWQgYW5kIHRydWUgaWZcblx0ICogYWxsIHJvd3MgYXJlIHNlbGVjdGVkLlxuXHQgKi9cblx0c2VsZWN0QWxsQ2hhbmdlID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgZnVsbCBkYXRhLlxuXHQgKlxuXHQgKiBZb3UgY2FuIHVzZSBpdCB0byBhbHRlciBpbmRpdmlkdWFsIGBUYWJsZUl0ZW1gcyBidXQgaWYgeW91IG5lZWQgdG8gY2hhbmdlXG5cdCAqIHRhYmxlIHN0cnVjdHVyZSwgdXNlIGBhZGRSb3coKWAgYW5kL29yIGBhZGRDb2x1bW4oKWBcblx0ICovXG5cdGdldCBkYXRhKCkge1xuXHRcdHJldHVybiB0aGlzLl9kYXRhO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHNlbGVjdGlvbiBzdGF0ZSBvZiByb3dzIGluIHRoZSB0YWJsZS5cblx0ICovXG5cdHJvd3NTZWxlY3RlZDogYm9vbGVhbltdID0gW107XG5cblx0LyoqXG5cdCAqIENvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IGV4cGFuZGVkIHN0YXRlIG9mIHJvd3MgaW4gdGhlIHRhYmxlLlxuXHQgKi9cblx0cm93c0V4cGFuZGVkOiBib29sZWFuW10gPSBbXTtcblxuXHQvKipcblx0ICogQ29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNvbnRleHQgb2YgdGhlIHJvdy5cblx0ICpcblx0ICogSXQgYWZmZWN0cyBzdHlsaW5nIG9mIHRoZSByb3cgdG8gcmVmbGVjdCB0aGUgY29udGV4dC5cblx0ICpcblx0ICogc3RyaW5nIGNhbiBiZSBvbmUgb2YgYFwic3VjY2Vzc1wiIHwgXCJ3YXJuaW5nXCIgfCBcImluZm9cIiB8IFwiZXJyb3JcIiB8IFwiXCJgIGFuZCBpdCdzXG5cdCAqIGVtcHR5IG9yIHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdCAqL1xuXHRyb3dzQ29udGV4dDogc3RyaW5nW10gPSBbXTtcblxuXHQvKipcblx0ICogQ29udGFpbnMgY2xhc3MgbmFtZShzKSBvZiB0aGUgcm93LlxuXHQgKlxuXHQgKiBJdCBhZmZlY3RzIHN0eWxpbmcgb2YgdGhlIHJvdyB0byByZWZsZWN0IHRoZSBhcHBlbmRlZCBjbGFzcyBuYW1lKHMpLlxuXHQgKlxuXHQgKiBJdCdzIGVtcHR5IG9yIHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdCAqL1xuXHRyb3dzQ2xhc3M6IHN0cmluZ1tdID0gW107XG5cblx0LyoqXG5cdCAqIENvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBoZWFkZXIgY2VsbHMgb2YgdGhlIHRhYmxlLlxuXHQgKi9cblx0aGVhZGVyOiBUYWJsZUhlYWRlckl0ZW1bXSA9IFtdO1xuXG5cdC8qKlxuXHQgKiBUcmFja3MgdGhlIGN1cnJlbnQgcGFnZS5cblx0ICovXG5cdGN1cnJlbnRQYWdlID0gMTtcblxuXHQvKipcblx0ICogTGVuZ3RoIG9mIHBhZ2UuXG5cdCAqL1xuXHRwYWdlTGVuZ3RoID0gMTA7XG5cblx0LyoqXG5cdCAqIFNldCB0byB0cnVlIHdoZW4gdGhlcmUgaXMgbm8gbW9yZSBkYXRhIHRvIGxvYWQgaW4gdGhlIHRhYmxlXG5cdCAqL1xuXHRpc0VuZCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBTZXQgdG8gdHJ1ZSB3aGVuIGxhenkgbG9hZGluZyB0byBzaG93IGxvYWRpbmcgaW5kaWNhdG9yXG5cdCAqL1xuXHRpc0xvYWRpbmcgPSBmYWxzZTtcblxuXHQvKipcblx0ICogQWJzb2x1dGUgdG90YWwgbnVtYmVyIG9mIHJvd3Mgb2YgdGhlIHRhYmxlLlxuXHQgKi9cblx0cHJvdGVjdGVkIF90b3RhbERhdGFMZW5ndGg6IG51bWJlcjtcblxuXHQvKipcblx0ICogTWFudWFsbHkgc2V0IGRhdGEgbGVuZ3RoIGluIGNhc2UgdGhlIGRhdGEgaW4gdGhlIHRhYmxlIGRvZXNuJ3Rcblx0ICogY29ycmVjdGx5IHJlZmxlY3QgYWxsIHRoZSBkYXRhIHRoYXQgdGFibGUgaXMgdG8gZGlzcGxheS5cblx0ICpcblx0ICogRXhhbXBsZTogaWYgeW91IGhhdmUgbXVsdGlwbGUgcGFnZXMgb2YgZGF0YSB0aGF0IHRhYmxlIHdpbGwgZGlzcGxheVxuXHQgKiBidXQgeW91J3JlIGxvYWRpbmcgb25lIGF0IGEgdGltZS5cblx0ICpcblx0ICogU2V0IHRvIGBudWxsYCB0byByZXNldCB0byBkZWZhdWx0IGJlaGF2aW9yLlxuXHQgKi9cblx0c2V0IHRvdGFsRGF0YUxlbmd0aChsZW5ndGg6IG51bWJlcikge1xuXHRcdC8vIGlmIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGhvdXQgYSBwYXJhbWV0ZXIgd2UgbmVlZCB0byBzZXQgdG8gbnVsbCB0byBhdm9pZCBoYXZpbmcgdW5kZWZpbmVkICE9IG51bGxcblx0XHR0aGlzLl90b3RhbERhdGFMZW5ndGggPSBsZW5ndGggfHwgbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUb3RhbCBsZW5ndGggb2YgZGF0YSB0aGF0IHRhYmxlIGhhcyBhY2Nlc3MgdG8sIG9yIHRoZSBhbW91bnQgbWFudWFsbHkgc2V0XG5cdCAqL1xuXHRnZXQgdG90YWxEYXRhTGVuZ3RoKCkge1xuXHRcdC8vIGlmIG1hbnVhbGx5IHNldCBkYXRhIGxlbmd0aFxuXHRcdGlmICh0aGlzLl90b3RhbERhdGFMZW5ndGggIT09IG51bGwgJiYgdGhpcy5fdG90YWxEYXRhTGVuZ3RoID49IDApIHtcblx0XHRcdHJldHVybiB0aGlzLl90b3RhbERhdGFMZW5ndGg7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgZW1wdHkgZGF0YXNldFxuXHRcdGlmICh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmxlbmd0aCA9PT0gMSAmJiB0aGlzLmRhdGFbMF0ubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5kYXRhLmxlbmd0aDtcblx0fVxuXG5cdC8qKlxuXHQgKiBVc2VkIGluIGBkYXRhYFxuXHQgKi9cblx0cHJvdGVjdGVkIF9kYXRhOiBUYWJsZUl0ZW1bXVtdID0gW1tdXTtcblxuXHQvKipcblx0ICogVGhlIG51bWJlciBvZiBtb2RlbHMgaW5zdGFudGlhdGVkLCB0aGlzIGlzIHRvIG1ha2Ugc3VyZSBlYWNoIHRhYmxlIGhhcyBhIGRpZmZlcmVudFxuXHQgKiBtb2RlbCBjb3VudCBmb3IgdW5pcXVlIGlkIGdlbmVyYXRpb24uXG5cdCAqL1xuXHRwcm90ZWN0ZWQgdGFibGVNb2RlbENvdW50ID0gMDtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLnRhYmxlTW9kZWxDb3VudCA9IFRhYmxlTW9kZWwuQ09VTlQrKztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGlkIGZvciB0aGUgZ2l2ZW4gY29sdW1uXG5cdCAqXG5cdCAqIEBwYXJhbSBjb2x1bW4gdGhlIGNvbHVtbiB0byBnZW5lcmF0ZSBhbiBpZCBmb3Jcblx0ICogQHBhcmFtIHJvdyB0aGUgcm93IG9mIHRoZSBoZWFkZXIgdG8gZ2VuZXJhdGUgYW4gaWQgZm9yXG5cdCAqL1xuXHRnZXRJZChjb2x1bW46IEhlYWRlclR5cGUsIHJvdyA9IDApOiBzdHJpbmcge1xuXHRcdHJldHVybiBgdGFibGUtaGVhZGVyLSR7cm93fS0ke2NvbHVtbn0tJHt0aGlzLnRhYmxlTW9kZWxDb3VudH1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGlkIG9mIHRoZSBoZWFkZXIuIFVzZWQgdG8gbGluayB0aGUgY2VsbHMgd2l0aCBoZWFkZXJzIChvciBoZWFkZXJzIHdpdGggaGVhZGVycylcblx0ICpcblx0ICogQHBhcmFtIGNvbHVtbiB0aGUgY29sdW1uIHRvIHN0YXJ0IGdldHRpbmcgaGVhZGVycyBmb3Jcblx0ICogQHBhcmFtIGNvbFNwYW4gdGhlIG51bWJlciBvZiBjb2x1bW5zIHRvIGdldCBoZWFkZXJzIGZvciAoZGVmYXVsdHMgdG8gMSlcblx0ICovXG5cdGdldEhlYWRlcklkKGNvbHVtbjogSGVhZGVyVHlwZSwgY29sU3BhbiA9IDEpOiBzdHJpbmcge1xuXHRcdGlmIChjb2x1bW4gPT09IFwic2VsZWN0XCIgfHwgY29sdW1uID09PSBcImV4cGFuZFwiKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRJZChjb2x1bW4pO1xuXHRcdH1cblxuXHRcdGxldCBpZHMgPSBbXTtcblx0XHRmb3IgKGxldCBpID0gY29sdW1uOyBpID49IDA7IGktLSkge1xuXHRcdFx0aWYgKHRoaXMuaGVhZGVyW2ldKSB7XG5cdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgY29sU3BhbjsgaisrKSB7XG5cdFx0XHRcdFx0aWRzLnB1c2godGhpcy5nZXRJZChpICsgaikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBpZHMuam9pbihcIiBcIik7XG5cdH1cblxuXHQvKipcblx0ICogRmluZHMgY2xvc2VzdCBoZWFkZXIgYnkgdHJ5aW5nIHRoZSBgY29sdW1uYCBhbmQgdGhlbiB3b3JraW5nIGl0cyB3YXkgdG8gdGhlIGxlZnRcblx0ICpcblx0ICogQHBhcmFtIGNvbHVtbiB0aGUgdGFyZ2V0IGNvbHVtblxuXHQgKi9cblx0Z2V0SGVhZGVyKGNvbHVtbjogbnVtYmVyKTogVGFibGVIZWFkZXJJdGVtIHtcblx0XHRpZiAoIXRoaXMuaGVhZGVyKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRmb3IgKGxldCBpID0gY29sdW1uOyBpID49IDA7IGktLSkge1xuXHRcdFx0Y29uc3QgaGVhZGVyQ2VsbCA9IHRoaXMuaGVhZGVyW2ldO1xuXHRcdFx0aWYgKGhlYWRlckNlbGwpIHtcblx0XHRcdFx0cmV0dXJuIGhlYWRlckNlbGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBob3cgbWFueSByb3dzIGlzIGN1cnJlbnRseSBzZWxlY3RlZFxuXHQgKi9cblx0c2VsZWN0ZWRSb3dzQ291bnQoKTogbnVtYmVyIHtcblx0XHRsZXQgY291bnQgPSAwO1xuXHRcdGlmICh0aGlzLnJvd3NTZWxlY3RlZCkge1xuXHRcdFx0dGhpcy5yb3dzU2VsZWN0ZWQuZm9yRWFjaChyb3dTZWxlY3RlZCA9PiB7XG5cdFx0XHRcdGlmIChyb3dTZWxlY3RlZCkge1xuXHRcdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gY291bnQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBob3cgbWFueSByb3dzIGlzIGN1cnJlbnRseSBleHBhbmRlZFxuXHQgKi9cblx0ZXhwYW5kZWRSb3dzQ291bnQoKTogbnVtYmVyIHtcblx0XHRsZXQgY291bnQgPSAwO1xuXHRcdGlmICh0aGlzLnJvd3NFeHBhbmRlZCkge1xuXHRcdFx0dGhpcy5yb3dzRXhwYW5kZWQuZm9yRWFjaChyb3dFeHBhbmRlZCA9PiB7XG5cdFx0XHRcdGlmIChyb3dFeHBhbmRlZCkge1xuXHRcdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gY291bnQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgaW5kZXhgdGggcm93IG9mIHRoZSB0YWJsZS5cblx0ICpcblx0ICogTmVnYXRpdmUgaW5kZXggc3RhcnRzIGZyb20gdGhlIGVuZC4gLTEgYmVpbmcgdGhlIGxhc3QgZWxlbWVudC5cblx0ICpcblx0ICogQHBhcmFtIGluZGV4XG5cdCAqL1xuXHRyb3coaW5kZXg6IG51bWJlcik6IFRhYmxlSXRlbVtdIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhW3RoaXMucmVhbFJvd0luZGV4KGluZGV4KV07XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHJvdyB0byB0aGUgYGluZGV4YHRoIHJvdyBvciBhcHBlbmRzIHRvIHRhYmxlIGlmIGluZGV4IG5vdCBwcm92aWRlZC5cblx0ICpcblx0ICogSWYgcm93IGlzIHNob3J0ZXIgdGhhbiBvdGhlciByb3dzIG9yIG5vdCBwcm92aWRlZCwgaXQgd2lsbCBiZSBwYWRkZWQgd2l0aFxuXHQgKiBlbXB0eSBgVGFibGVJdGVtYCBlbGVtZW50cy5cblx0ICpcblx0ICogSWYgcm93IGlzIGxvbmdlciB0aGFuIG90aGVyIHJvd3MsIG90aGVycyB3aWxsIGJlIGV4dGVuZGVkIHRvIG1hdGNoIHNvIG5vIGRhdGEgaXMgbG9zdC5cblx0ICpcblx0ICogSWYgY2FsbGVkIG9uIGFuIGVtcHR5IHRhYmxlIHdpdGggbm8gcGFyYW1ldGVycywgaXQgY3JlYXRlcyBhIDF4MSB0YWJsZS5cblx0ICpcblx0ICogTmVnYXRpdmUgaW5kZXggc3RhcnRzIGZyb20gdGhlIGVuZC4gLTEgYmVpbmcgdGhlIGxhc3QgZWxlbWVudC5cblx0ICpcblx0ICogQHBhcmFtIFtyb3ddXG5cdCAqIEBwYXJhbSBbaW5kZXhdXG5cdCAqL1xuXHRhZGRSb3cocm93PzogVGFibGVJdGVtW10sIGluZGV4PzogbnVtYmVyKSB7XG5cdFx0Ly8gaWYgdGFibGUgZW1wdHkgY3JlYXRlIHRhYmxlIHdpdGggcm93XG5cdFx0aWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kYXRhLmxlbmd0aCA9PT0gMCB8fCB0aGlzLmRhdGFbMF0ubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRsZXQgbmV3RGF0YSA9IG5ldyBBcnJheTxBcnJheTxUYWJsZUl0ZW0+PigpO1xuXHRcdFx0bmV3RGF0YS5wdXNoKHJvdyA/IHJvdyA6IFtuZXcgVGFibGVJdGVtKCldKTsgIC8vIHJvdyBvciBvbmUgZW1wdHkgb25lIGNvbHVtbiByb3dcblx0XHRcdHRoaXMuZGF0YSA9IG5ld0RhdGE7XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsZXQgcmVhbFJvdyA9IHJvdztcblx0XHRjb25zdCBjb2x1bW5Db3VudCA9IHRoaXMuZGF0YVswXS5sZW5ndGg7XG5cblx0XHRpZiAocm93ID09IG51bGwpIHtcblx0XHRcdHJlYWxSb3cgPSBuZXcgQXJyYXk8VGFibGVJdGVtPigpO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG5cdFx0XHRcdHJlYWxSb3cucHVzaChuZXcgVGFibGVJdGVtKCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChyZWFsUm93Lmxlbmd0aCA8IGNvbHVtbkNvdW50KSB7XG5cdFx0XHQvLyBleHRlbmQgdGhlIGxlbmd0aCBvZiByZWFsUm93XG5cdFx0XHRjb25zdCBkaWZmZXJlbmNlID0gY29sdW1uQ291bnQgLSByZWFsUm93Lmxlbmd0aDtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZmVyZW5jZTsgaSsrKSB7XG5cdFx0XHRcdHJlYWxSb3cucHVzaChuZXcgVGFibGVJdGVtKCkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAocmVhbFJvdy5sZW5ndGggPiBjb2x1bW5Db3VudCkge1xuXHRcdFx0Ly8gZXh0ZW5kIHRoZSBsZW5ndGggb2YgaGVhZGVyXG5cdFx0XHRsZXQgZGlmZmVyZW5jZSA9IHJlYWxSb3cubGVuZ3RoIC0gdGhpcy5oZWFkZXIubGVuZ3RoO1xuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBkaWZmZXJlbmNlOyBqKyspIHtcblx0XHRcdFx0dGhpcy5oZWFkZXIucHVzaChuZXcgVGFibGVIZWFkZXJJdGVtKCkpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gZXh0ZW5kIHRoZSBsZW5ndGggb2YgZXZlcnkgb3RoZXIgcm93XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRsZXQgY3VycmVudFJvdyA9IHRoaXMuZGF0YVtpXTtcblx0XHRcdFx0ZGlmZmVyZW5jZSA9IHJlYWxSb3cubGVuZ3RoIC0gY3VycmVudFJvdy5sZW5ndGg7XG5cdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgZGlmZmVyZW5jZTsgaisrKSB7XG5cdFx0XHRcdFx0Y3VycmVudFJvdy5wdXNoKG5ldyBUYWJsZUl0ZW0oKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaW5kZXggPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5kYXRhLnB1c2gocmVhbFJvdyk7XG5cblx0XHRcdC8vIHVwZGF0ZSByb3dzU2VsZWN0ZWQgcHJvcGVydHkgZm9yIGxlbmd0aFxuXHRcdFx0dGhpcy5yb3dzU2VsZWN0ZWQucHVzaChmYWxzZSk7XG5cblx0XHRcdC8vIHVwZGF0ZSByb3dzRXhwYW5kZWQgcHJvcGVydHkgZm9yIGxlbmd0aFxuXHRcdFx0dGhpcy5yb3dzRXhwYW5kZWQucHVzaChmYWxzZSk7XG5cblx0XHRcdC8vIHVwZGF0ZSByb3dzQ29udGV4dCBwcm9wZXJ0eSBmb3IgbGVuZ3RoXG5cdFx0XHR0aGlzLnJvd3NDb250ZXh0LnB1c2godW5kZWZpbmVkKTtcblxuXHRcdFx0Ly8gdXBkYXRlIHJvd3NDbGFzcyBwcm9wZXJ0eSBmb3IgbGVuZ3RoXG5cdFx0XHR0aGlzLnJvd3NDbGFzcy5wdXNoKHVuZGVmaW5lZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IHJpID0gdGhpcy5yZWFsUm93SW5kZXgoaW5kZXgpO1xuXHRcdFx0dGhpcy5kYXRhLnNwbGljZShyaSwgMCwgcmVhbFJvdyk7XG5cblx0XHRcdC8vIHVwZGF0ZSByb3dzU2VsZWN0ZWQgcHJvcGVydHkgZm9yIGxlbmd0aFxuXHRcdFx0dGhpcy5yb3dzU2VsZWN0ZWQuc3BsaWNlKHJpLCAwLCBmYWxzZSk7XG5cblx0XHRcdC8vIHVwZGF0ZSByb3dzRXhwYW5kZWQgcHJvcGVydHkgZm9yIGxlbmd0aFxuXHRcdFx0dGhpcy5yb3dzRXhwYW5kZWQuc3BsaWNlKHJpLCAwLCBmYWxzZSk7XG5cblx0XHRcdC8vIHVwZGF0ZSByb3dzQ29udGV4dCBwcm9wZXJ0eSBmb3IgbGVuZ3RoXG5cdFx0XHR0aGlzLnJvd3NDb250ZXh0LnNwbGljZShyaSwgMCwgdW5kZWZpbmVkKTtcblxuXHRcdFx0Ly8gdXBkYXRlIHJvd3NDbGFzcyBwcm9wZXJ0eSBmb3IgbGVuZ3RoXG5cdFx0XHR0aGlzLnJvd3NDbGFzcy5zcGxpY2UocmksIDAsIHVuZGVmaW5lZCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5kYXRhQ2hhbmdlLmVtaXQoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWxldGVzIGBpbmRleGB0aCByb3cuXG5cdCAqXG5cdCAqIE5lZ2F0aXZlIGluZGV4IHN0YXJ0cyBmcm9tIHRoZSBlbmQuIC0xIGJlaW5nIHRoZSBsYXN0IGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSBpbmRleFxuXHQgKi9cblx0ZGVsZXRlUm93KGluZGV4OiBudW1iZXIpIHtcblx0XHRjb25zdCBycmkgPSB0aGlzLnJlYWxSb3dJbmRleChpbmRleCk7XG5cdFx0dGhpcy5kYXRhLnNwbGljZShycmksIDEpO1xuXHRcdHRoaXMucm93c1NlbGVjdGVkLnNwbGljZShycmksIDEpO1xuXHRcdHRoaXMucm93c0V4cGFuZGVkLnNwbGljZShycmksIDEpO1xuXHRcdHRoaXMucm93c0NvbnRleHQuc3BsaWNlKHJyaSwgMSk7XG5cdFx0dGhpcy5yb3dzQ2xhc3Muc3BsaWNlKHJyaSwgMSk7XG5cblx0XHR0aGlzLmRhdGFDaGFuZ2UuZW1pdCgpO1xuXHR9XG5cblx0aGFzRXhwYW5kYWJsZVJvd3MoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5zb21lKGRhdGEgPT4gZGF0YS5zb21lKGQgPT4gZCAmJiBkLmV4cGFuZGVkRGF0YSkpOyAvLyBjaGVja2luZyBmb3Igc29tZSBpbiAyRCBhcnJheVxuXHR9XG5cblx0aXNSb3dFeHBhbmRhYmxlKGluZGV4OiBudW1iZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhW2luZGV4XS5zb21lKGQgPT4gZCAmJiBkLmV4cGFuZGVkRGF0YSk7XG5cdH1cblxuXHRpc1Jvd0V4cGFuZGVkKGluZGV4OiBudW1iZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5yb3dzRXhwYW5kZWRbaW5kZXhdO1xuXHR9XG5cblx0Z2V0Um93Q29udGV4dChpbmRleDogbnVtYmVyKSB7XG5cdFx0cmV0dXJuIHRoaXMucm93c0NvbnRleHRbaW5kZXhdO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYGluZGV4YHRoIGNvbHVtbiBvZiB0aGUgdGFibGUuXG5cdCAqXG5cdCAqIE5lZ2F0aXZlIGluZGV4IHN0YXJ0cyBmcm9tIHRoZSBlbmQuIC0xIGJlaW5nIHRoZSBsYXN0IGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSBpbmRleFxuXHQgKi9cblx0Y29sdW1uKGluZGV4OiBudW1iZXIpOiBUYWJsZUl0ZW1bXSB7XG5cdFx0bGV0IGNvbHVtbiA9IG5ldyBBcnJheTxUYWJsZUl0ZW0+KCk7XG5cdFx0Y29uc3QgcmkgPSB0aGlzLnJlYWxDb2x1bW5JbmRleChpbmRleCk7XG5cdFx0Y29uc3QgcmMgPSB0aGlzLmRhdGEubGVuZ3RoO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByYzsgaSsrKSB7XG5cdFx0XHRjb25zdCByb3cgPSB0aGlzLmRhdGFbaV07XG5cdFx0XHRjb2x1bW4ucHVzaChyb3dbcmldKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29sdW1uO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBjb2x1bW4gdG8gdGhlIGBpbmRleGB0aCBjb2x1bW4gb3IgYXBwZW5kcyB0byB0YWJsZSBpZiBpbmRleCBub3QgcHJvdmlkZWQuXG5cdCAqXG5cdCAqIElmIGNvbHVtbiBpcyBzaG9ydGVyIHRoYW4gb3RoZXIgY29sdW1ucyBvciBub3QgcHJvdmlkZWQsIGl0IHdpbGwgYmUgcGFkZGVkIHdpdGhcblx0ICogZW1wdHkgYFRhYmxlSXRlbWAgZWxlbWVudHMuXG5cdCAqXG5cdCAqIElmIGNvbHVtbiBpcyBsb25nZXIgdGhhbiBvdGhlciBjb2x1bW5zLCBvdGhlcnMgd2lsbCBiZSBleHRlbmRlZCB0byBtYXRjaCBzbyBubyBkYXRhIGlzIGxvc3QuXG5cdCAqXG5cdCAqIElmIGNhbGxlZCBvbiBhbiBlbXB0eSB0YWJsZSB3aXRoIG5vIHBhcmFtZXRlcnMsIGl0IGNyZWF0ZXMgYSAxeDEgdGFibGUuXG5cdCAqXG5cdCAqIE5lZ2F0aXZlIGluZGV4IHN0YXJ0cyBmcm9tIHRoZSBlbmQuIC0xIGJlaW5nIHRoZSBsYXN0IGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSBbY29sdW1uXVxuXHQgKiBAcGFyYW0gW2luZGV4XVxuXHQgKi9cblx0YWRkQ29sdW1uKGNvbHVtbj86IFRhYmxlSXRlbVtdLCBpbmRleD86IG51bWJlcikge1xuXHRcdC8vIGlmIHRhYmxlIGVtcHR5IGNyZWF0ZSB0YWJsZSB3aXRoIHJvd1xuXHRcdGlmICghdGhpcy5kYXRhIHx8IHRoaXMuZGF0YS5sZW5ndGggPT09IDAgfHwgdGhpcy5kYXRhWzBdLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0bGV0IG5ld0RhdGEgPSBuZXcgQXJyYXk8QXJyYXk8VGFibGVJdGVtPj4oKTtcblx0XHRcdGlmIChjb2x1bW4gPT0gbnVsbCkge1xuXHRcdFx0XHRuZXdEYXRhLnB1c2goW25ldyBUYWJsZUl0ZW0oKV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRsZXQgaXRlbSA9IGNvbHVtbltpXTtcblx0XHRcdFx0XHRuZXdEYXRhLnB1c2goW2l0ZW1dKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5kYXRhID0gbmV3RGF0YTtcblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGxldCByYyA9IHRoaXMuZGF0YS5sZW5ndGg7ICAvLyByb3cgY291bnRcblx0XHRsZXQgY2kgPSB0aGlzLnJlYWxDb2x1bW5JbmRleChpbmRleCk7XG5cblx0XHQvLyBhcHBlbmQgbWlzc2luZyByb3dzXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGNvbHVtbiAhPSBudWxsICYmIGkgPCBjb2x1bW4ubGVuZ3RoIC0gcmM7IGkrKykge1xuXHRcdFx0dGhpcy5hZGRSb3coKTtcblx0XHR9XG5cdFx0cmMgPSB0aGlzLmRhdGEubGVuZ3RoO1xuXHRcdGlmIChpbmRleCA9PSBudWxsKSB7XG5cdFx0XHQvLyBhcHBlbmQgdG8gZW5kXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJjOyBpKyspIHtcblx0XHRcdFx0bGV0IHJvdyA9IHRoaXMuZGF0YVtpXTtcblx0XHRcdFx0cm93LnB1c2goY29sdW1uID09IG51bGwgfHwgY29sdW1uW2ldID09IG51bGwgPyBuZXcgVGFibGVJdGVtKCkgOiBjb2x1bW5baV0pO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdXBkYXRlIGhlYWRlciBpZiBub3QgYWxyZWFkeSBzZXQgYnkgdXNlclxuXHRcdFx0aWYgKHRoaXMuaGVhZGVyLmxlbmd0aCA8IHRoaXMuZGF0YVswXS5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5oZWFkZXIucHVzaChuZXcgVGFibGVIZWFkZXJJdGVtKCkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoaW5kZXggPj0gdGhpcy5kYXRhWzBdLmxlbmd0aCkge1xuXHRcdFx0XHQvLyBpZiB0cnlpbmcgdG8gYXBwZW5kXG5cdFx0XHRcdGNpKys7XG5cdFx0XHR9XG5cdFx0XHQvLyBpbnNlcnRcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcmM7IGkrKykge1xuXHRcdFx0XHRsZXQgcm93ID0gdGhpcy5kYXRhW2ldO1xuXHRcdFx0XHRyb3cuc3BsaWNlKGNpLCAwLCBjb2x1bW4gPT0gbnVsbCB8fCBjb2x1bW5baV0gPT0gbnVsbCA/IG5ldyBUYWJsZUl0ZW0oKSA6IGNvbHVtbltpXSk7XG5cdFx0XHR9XG5cdFx0XHQvLyB1cGRhdGUgaGVhZGVyIGlmIG5vdCBhbHJlYWR5IHNldCBieSB1c2VyXG5cdFx0XHRpZiAodGhpcy5oZWFkZXIubGVuZ3RoIDwgdGhpcy5kYXRhWzBdLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLmhlYWRlci5zcGxpY2UoY2ksIDAsIG5ldyBUYWJsZUhlYWRlckl0ZW0oKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5kYXRhQ2hhbmdlLmVtaXQoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWxldGVzIGBpbmRleGB0aCBjb2x1bW4uXG5cdCAqXG5cdCAqIE5lZ2F0aXZlIGluZGV4IHN0YXJ0cyBmcm9tIHRoZSBlbmQuIC0xIGJlaW5nIHRoZSBsYXN0IGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSBpbmRleFxuXHQgKi9cblx0ZGVsZXRlQ29sdW1uKGluZGV4OiBudW1iZXIpIHtcblx0XHRjb25zdCByY2kgPSB0aGlzLnJlYWxDb2x1bW5JbmRleChpbmRleCk7XG5cdFx0Y29uc3Qgcm93Q291bnQgPSB0aGlzLmRhdGEubGVuZ3RoO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q291bnQ7IGkrKykge1xuXHRcdFx0dGhpcy5kYXRhW2ldLnNwbGljZShyY2ksIDEpO1xuXHRcdH1cblx0XHQvLyB1cGRhdGUgaGVhZGVyIGlmIG5vdCBhbHJlYWR5IHNldCBieSB1c2VyXG5cdFx0aWYgKHRoaXMuaGVhZGVyLmxlbmd0aCA+IHRoaXMuZGF0YVswXS5sZW5ndGgpIHtcblx0XHRcdHRoaXMuaGVhZGVyLnNwbGljZShyY2ksIDEpO1xuXHRcdH1cblxuXHRcdHRoaXMuZGF0YUNoYW5nZS5lbWl0KCk7XG5cdH1cblxuXHRtb3ZlQ29sdW1uKGluZGV4RnJvbTogbnVtYmVyLCBpbmRleFRvOiBudW1iZXIpIHtcblx0XHRjb25zdCBoZWFkZXJGcm9tID0gdGhpcy5oZWFkZXJbaW5kZXhGcm9tXTtcblxuXHRcdHRoaXMuYWRkQ29sdW1uKHRoaXMuY29sdW1uKGluZGV4RnJvbSksIGluZGV4VG8pO1xuXHRcdHRoaXMuZGVsZXRlQ29sdW1uKGluZGV4RnJvbSArIChpbmRleFRvIDwgaW5kZXhGcm9tID8gMSA6IDApKTtcblxuXHRcdHRoaXMuaGVhZGVyW2luZGV4VG8gKyAoaW5kZXhUbyA+IGluZGV4RnJvbSA/IC0xIDogMCldID0gaGVhZGVyRnJvbTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTb3J0cyB0aGUgZGF0YSBjdXJyZW50bHkgcHJlc2VudCBpbiB0aGUgbW9kZWwgYmFzZWQgb24gYGNvbXBhcmUoKWBcblx0ICpcblx0ICogRGlyZWN0aW9uIGlzIHNldCBieSBgYXNjZW5kaW5nYCBhbmQgYGRlc2NlbmRpbmdgIHByb3BlcnRpZXMgb2YgYFRhYmxlSGVhZGVySXRlbWBcblx0ICogaW4gYGluZGV4YHRoIGNvbHVtbi5cblx0ICpcblx0ICogQHBhcmFtIGluZGV4IFRoZSBjb2x1bW4gYmFzZWQgb24gd2hpY2ggaXQncyBzb3J0aW5nXG5cdCAqL1xuXHRzb3J0KGluZGV4OiBudW1iZXIpIHtcblx0XHR0aGlzLnB1c2hSb3dTdGF0ZVRvTW9kZWxEYXRhKCk7XG5cdFx0dGhpcy5kYXRhLnNvcnQoKGEsIGIpID0+ICh0aGlzLmhlYWRlcltpbmRleF0uZGVzY2VuZGluZyA/IC0xIDogMSkgKiB0aGlzLmhlYWRlcltpbmRleF0uY29tcGFyZShhW2luZGV4XSwgYltpbmRleF0pKTtcblx0XHR0aGlzLnBvcFJvd1N0YXRlRnJvbU1vZGVsRGF0YSgpO1xuXHRcdHRoaXMuaGVhZGVyLmZvckVhY2goY29sdW1uID0+IGNvbHVtbi5zb3J0ZWQgPSBmYWxzZSk7XG5cdFx0dGhpcy5oZWFkZXJbaW5kZXhdLnNvcnRlZCA9IHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogQXBwZW5kcyBgcm93c1NlbGVjdGVkYCBhbmQgYHJvd3NFeHBhbmRlZGAgaW5mbyB0byBtb2RlbCBkYXRhLlxuXHQgKlxuXHQgKiBXaGVuIHNvcnRpbmcgcm93cywgZG8gdGhpcyBmaXJzdCBzbyBpbmZvcm1hdGlvbiBhYm91dCByb3cgc2VsZWN0aW9uXG5cdCAqIGdldHMgc29ydGVkIHdpdGggdGhlIG90aGVyIHJvdyBpbmZvLlxuXHQgKlxuXHQgKiBDYWxsIGBwb3BSb3dTZWxlY3Rpb25Gcm9tTW9kZWxEYXRhKClgIGFmdGVyIHNvcnRpbmcgdG8gbWFrZSBldmVyeXRoaW5nXG5cdCAqIHJpZ2h0IHdpdGggdGhlIHdvcmxkIGFnYWluLlxuXHQgKi9cblx0cHVzaFJvd1N0YXRlVG9Nb2RlbERhdGEoKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IHJvd1NlbGVjdGVkTWFyayA9IG5ldyBUYWJsZUl0ZW0oKTtcblx0XHRcdHJvd1NlbGVjdGVkTWFyay5kYXRhID0gdGhpcy5yb3dzU2VsZWN0ZWRbaV07XG5cdFx0XHR0aGlzLmRhdGFbaV0ucHVzaChyb3dTZWxlY3RlZE1hcmspO1xuXG5cdFx0XHRjb25zdCByb3dFeHBhbmRlZE1hcmsgPSBuZXcgVGFibGVJdGVtKCk7XG5cdFx0XHRyb3dFeHBhbmRlZE1hcmsuZGF0YSA9IHRoaXMucm93c0V4cGFuZGVkW2ldO1xuXHRcdFx0dGhpcy5kYXRhW2ldLnB1c2gocm93RXhwYW5kZWRNYXJrKTtcblxuXHRcdFx0Y29uc3Qgcm93Q29udGV4dCA9IG5ldyBUYWJsZUl0ZW0oKTtcblx0XHRcdHJvd0NvbnRleHQuZGF0YSA9IHRoaXMucm93c0NvbnRleHRbaV07XG5cdFx0XHR0aGlzLmRhdGFbaV0ucHVzaChyb3dDb250ZXh0KTtcblxuXHRcdFx0Y29uc3Qgcm93Q2xhc3MgPSBuZXcgVGFibGVJdGVtKCk7XG5cdFx0XHRyb3dDbGFzcy5kYXRhID0gdGhpcy5yb3dzQ2xhc3NbaV07XG5cdFx0XHR0aGlzLmRhdGFbaV0ucHVzaChyb3dDbGFzcyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlc3RvcmVzIGByb3dzU2VsZWN0ZWRgIGZyb20gZGF0YSBwdXNoZWQgYnkgYHB1c2hSb3dTZWxlY3Rpb25Ub01vZGVsRGF0YSgpYFxuXHQgKlxuXHQgKiBDYWxsIGFmdGVyIHNvcnRpbmcgZGF0YSAoaWYgeW91IHByZXZpb3VzbHkgcHVzaGVkIHRvIG1haW50YWluIHNlbGVjdGlvbiBvcmRlcilcblx0ICogdG8gbWFrZSBldmVyeXRoaW5nIHJpZ2h0IHdpdGggdGhlIHdvcmxkIGFnYWluLlxuXHQgKi9cblx0cG9wUm93U3RhdGVGcm9tTW9kZWxEYXRhKCkge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLnJvd3NDbGFzc1tpXSA9IHRoaXMuZGF0YVtpXS5wb3AoKS5kYXRhO1xuXHRcdFx0dGhpcy5yb3dzQ29udGV4dFtpXSA9IHRoaXMuZGF0YVtpXS5wb3AoKS5kYXRhO1xuXHRcdFx0dGhpcy5yb3dzRXhwYW5kZWRbaV0gPSAhIXRoaXMuZGF0YVtpXS5wb3AoKS5kYXRhO1xuXHRcdFx0dGhpcy5yb3dzU2VsZWN0ZWRbaV0gPSAhIXRoaXMuZGF0YVtpXS5wb3AoKS5kYXRhO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgcm93IGlzIGZpbHRlcmVkIG91dC5cblx0ICpcblx0ICogQHBhcmFtIGluZGV4XG5cdCAqIEByZXR1cm5zIHRydWUgaWYgYW55IG9mIHRoZSBmaWx0ZXJzIGluIGhlYWRlciBmaWx0ZXJzIG91dCB0aGUgYGluZGV4YHRoIHJvd1xuXHQgKi9cblx0aXNSb3dGaWx0ZXJlZChpbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XG5cdFx0Y29uc3QgcmVhbEluZGV4ID0gdGhpcy5yZWFsUm93SW5kZXgoaW5kZXgpO1xuXHRcdHJldHVybiB0aGlzLmhlYWRlci5zb21lKChpdGVtLCBpKSA9PiBpdGVtICYmIGl0ZW0uZmlsdGVyKHRoaXMucm93KHJlYWxJbmRleClbaV0pKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZWxlY3QvZGVzZWxlY3QgYGluZGV4YHRoIHJvdyBiYXNlZCBvbiB2YWx1ZVxuXHQgKlxuXHQgKiBAcGFyYW0gaW5kZXggaW5kZXggb2YgdGhlIHJvdyB0byBzZWxlY3Rcblx0ICogQHBhcmFtIHZhbHVlIHN0YXRlIHRvIHNldCB0aGUgcm93IHRvLiBEZWZhdWx0cyB0byBgdHJ1ZWBcblx0ICovXG5cdHNlbGVjdFJvdyhpbmRleDogbnVtYmVyLCB2YWx1ZSA9IHRydWUpIHtcblx0XHRpZiAodGhpcy5pc1Jvd0Rpc2FibGVkKGluZGV4KSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLnJvd3NTZWxlY3RlZFtpbmRleF0gPSB2YWx1ZTtcblx0XHR0aGlzLnJvd3NTZWxlY3RlZENoYW5nZS5lbWl0KGluZGV4KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZWxlY3RzIG9yIGRlc2VsZWN0cyBhbGwgcm93cyBpbiB0aGUgbW9kZWxcblx0ICpcblx0ICogQHBhcmFtIHZhbHVlIHN0YXRlIHRvIHNldCBhbGwgcm93cyB0by4gRGVmYXVsdHMgdG8gYHRydWVgXG5cdCAqL1xuXHRzZWxlY3RBbGwodmFsdWUgPSB0cnVlKSB7XG5cdFx0aWYgKHRoaXMuZGF0YS5sZW5ndGggPj0gMSkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3NTZWxlY3RlZC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLnNlbGVjdFJvdyhpLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuc2VsZWN0QWxsQ2hhbmdlLm5leHQodmFsdWUpO1xuXHR9XG5cblx0aXNSb3dTZWxlY3RlZChpbmRleDogbnVtYmVyKSB7XG5cdFx0cmV0dXJuIHRoaXMucm93c1NlbGVjdGVkW2luZGV4XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgcm93IGlzIGRpc2FibGVkIG9yIG5vdC5cblx0ICovXG5cdGlzUm93RGlzYWJsZWQoaW5kZXg6IG51bWJlcikge1xuXHRcdGNvbnN0IHJvdyA9IHRoaXMuZGF0YVtpbmRleF0gYXMgVGFibGVSb3c7XG5cdFx0cmV0dXJuICEhcm93LmRpc2FibGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4cGFuZHMvQ29sbGFwc2VzIGBpbmRleGB0aCByb3cgYmFzZWQgb24gdmFsdWVcblx0ICpcblx0ICogQHBhcmFtIGluZGV4IGluZGV4IG9mIHRoZSByb3cgdG8gZXhwYW5kIG9yIGNvbGxhcHNlXG5cdCAqIEBwYXJhbSB2YWx1ZSBleHBhbmRlZCBzdGF0ZSBvZiB0aGUgcm93LiBgdHJ1ZWAgaXMgZXhwYW5kZWQgYW5kIGBmYWxzZWAgaXMgY29sbGFwc2VkXG5cdCAqL1xuXHRleHBhbmRSb3coaW5kZXg6IG51bWJlciwgdmFsdWUgPSB0cnVlKSB7XG5cdFx0dGhpcy5yb3dzRXhwYW5kZWRbaW5kZXhdID0gdmFsdWU7XG5cdFx0dGhpcy5yb3dzRXhwYW5kZWRDaGFuZ2UuZW1pdChpbmRleCk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgdHJ1ZSBpbmRleCBvZiBhIHJvdyBiYXNlZCBvbiBpdCdzIHJlbGF0aXZlIHBvc2l0aW9uLlxuXHQgKiBMaWtlIGluIFB5dGhvbiwgcG9zaXRpdmUgbnVtYmVycyBzdGFydCBmcm9tIHRoZSB0b3AgYW5kXG5cdCAqIG5lZ2F0aXZlIG51bWJlcnMgc3RhcnQgZnJvbSB0aGUgYm90dG9tLlxuXHQgKlxuXHQgKiBAcGFyYW0gaW5kZXhcblx0ICovXG5cdHByb3RlY3RlZCByZWFsUm93SW5kZXgoaW5kZXg6IG51bWJlcik6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMucmVhbEluZGV4KGluZGV4LCB0aGlzLmRhdGEubGVuZ3RoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSB0cnVlIGluZGV4IG9mIGEgY29sdW1uIGJhc2VkIG9uIGl0J3MgcmVsYXRpdmUgcG9zaXRpb24uXG5cdCAqIExpa2UgaW4gUHl0aG9uLCBwb3NpdGl2ZSBudW1iZXJzIHN0YXJ0IGZyb20gdGhlIHRvcCBhbmRcblx0ICogbmVnYXRpdmUgbnVtYmVycyBzdGFydCBmcm9tIHRoZSBib3R0b20uXG5cdCAqXG5cdCAqIEBwYXJhbSBpbmRleFxuXHQgKi9cblx0cHJvdGVjdGVkIHJlYWxDb2x1bW5JbmRleChpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5yZWFsSW5kZXgoaW5kZXgsIHRoaXMuZGF0YVswXS5sZW5ndGgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyaWMgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHRoZSByZWFsIGluZGV4IG9mIHNvbWV0aGluZy5cblx0ICogVXNlZCBieSBgcmVhbFJvd0luZGV4KClgIGFuZCBgcmVhbENvbHVtbkluZGV4KClgXG5cdCAqXG5cdCAqIEBwYXJhbSBpbmRleFxuXHQgKiBAcGFyYW0gbGVuZ3RoXG5cdCAqL1xuXHRwcm90ZWN0ZWQgcmVhbEluZGV4KGluZGV4OiBudW1iZXIsIGxlbmd0aDogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRpZiAoaW5kZXggPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGxlbmd0aCAtIDE7XG5cdFx0fSBlbHNlIGlmIChpbmRleCA+PSAwKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXggPj0gbGVuZ3RoID8gbGVuZ3RoIC0gMSA6IGluZGV4O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gLWluZGV4ID49IGxlbmd0aCA/IDAgOiBsZW5ndGggKyBpbmRleDtcblx0XHR9XG5cdH1cbn1cbiJdfQ==