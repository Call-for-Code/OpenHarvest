/**
 *
 * carbon-angular v0.0.0 | table.component.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Component, ApplicationRef, Input, Output, EventEmitter, ElementRef, TemplateRef, HostBinding } from "@angular/core";
import { Subscription, fromEvent } from "rxjs";
import { TableModel } from "./table-model.class";
import { TableHeaderItem } from "./table-header-item.class";
import { TableItem } from "./table-item.class";
import { getFocusElementList, tabbableSelectorIgnoreTabIndex } from "carbon-components-angular/common";
import { I18n } from "carbon-components-angular/i18n";
import { merge } from "carbon-components-angular/utils";
import { DataGridInteractionModel } from "./data-grid-interaction-model.class";
import { TableDomAdapter } from "./table-adapter.class";
/**
 * Build your table with this component by extending things that differ from default.
 *
 * [See demo](../../?path=/story/table--basic)
 *
 * Instead of the usual write-your-own-html approach you had with `<table>`,
 * carbon table uses model-view-controller approach.
 *
 * Here, you create a view (with built-in controller) and provide it a model.
 * Changes you make to the model are reflected in the view. Provide same model you use
 * in the table to the `<ibm-pagination>` components.
 * They provide a different view over the same data.
 *
 * ## Basic usage
 *
 * ```html
 * <ibm-table [model]="model"></ibm-table>
 * ```
 *
 * ```typescript
 * public model = new TableModel();
 *
 * this.model.data = [
 * 	[new TableItem({data: "asdf"}), new TableItem({data: "qwer"})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "zwer"})],
 * 	[new TableItem({data: "bsdf"}), new TableItem({data: "swer"})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "twer"})]
 * ];
 * ```
 *
 * ## Customization
 *
 * If you have custom data in your table, you need a way to display it. You can do that
 * by providing a template to `TableItem`.
 *
 * ```html
 * <ng-template #customTableItemTemplate let-data="data">
 * 	<a [routerLink]="data.link">{{data.name}} {{data.surname}}</a>
 * </ng-template>
 * ```
 *
 * ```typescript
 * customTableItemTemplate: TemplateRef<any>;
 *
 * this.customModel.data = [
 * 	[new TableItem({data: "asdf"}), new TableItem({data: {name: "Lessy", link: "/table"}, template: this.customTableItemTemplate})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "swer"})],
 * 	[new TableItem({data: "bsdf"}), new TableItem({data: {name: "Alice", surname: "Bob"}, template: this.customTableItemTemplate})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "twer"})],
 * ];
 * ```
 *
 * ### Sorting and filtering
 *
 * In case you need custom sorting and/or filtering you should subclass `TableHeaderItem`
 * and override needed functions.
 *
 * ```typescript
 * class FilterableHeaderItem extends TableHeaderItem {
 * 	// custom filter function
 * 	filter(item: TableItem): boolean {
 * 		if (typeof item.data === "string" && item.data.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0 ||
 * 		item.data.name && item.data.name.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0 ||
 * 		item.data.surname && item.data.surname.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0) {
 * 			return false;
 * 		}
 * 		return true;
 * 	}
 *
 * 	set filterCount(n) {}
 * 	get filterCount() {
 * 		return (this.filterData && this.filterData.data && this.filterData.data.length > 0) ? 1 : 0;
 * 	}
 *
 * 	// used for custom sorting
 * 	compare(one: TableItem, two: TableItem) {
 * 		const stringOne = (one.data.name || one.data.surname || one.data).toLowerCase();
 * 		const stringTwo = (two.data.name || two.data.surname || two.data).toLowerCase();
 *
 * 		if (stringOne > stringTwo) {
 * 			return 1;
 * 		} else if (stringOne < stringTwo) {
 * 			return -1;
 * 		} else {
 * 			return 0;
 * 		}
 * 	}
 * }
 * ```
 *
 * If you want to do your sorting on the backend or query for sorted data as a result of user
 * clicking the table header, check table [`sort`](#sort) output documentation
 *
 * See `TableHeaderItem` class for more information.
 *
 * ## No data template
 *
 * When table has no data to show, it can show a message you provide it instead.
 *
 * ```html
 * <ibm-table [model]="model">No data.</ibm-table>
 * ```
 *
 * ... will show `No data.` message, but you can get creative and provide any template you want
 * to replace table's default `tbody`.
 *
 * ## Use pagination as table footer
 *
 * ```html
 * <ibm-pagination [model]="model" (selectPage)="selectPage($event)"></ibm-pagination>
 * ```
 *
 * `selectPage()` function should fetch the data from backend, create new `data`, apply it to `model.data`,
 * and update `model.currentPage`.
 *
 * If the data your server returns is a two dimensional array of objects, it would look something like this:
 *
 * ```typescript
 * selectPage(page) {
 * 	this.getPage(page).then((data: Array<Array<any>>) => {
 * 		// set the data and update page
 * 		this.model.data = this.prepareData(data);
 * 		this.model.currentPage = page;
 * 	});
 * }
 *
 * protected prepareData(data: Array<Array<any>>) {
 * 	// create new data from the service data
 * 	let newData = [];
 * 	data.forEach(dataRow => {
 * 		let row = [];
 * 		dataRow.forEach(dataElement => {
 * 			row.push(new TableItem({
 * 				data: dataElement,
 * 				template: typeof dataElement === "string" ? undefined : this.paginationTableItemTemplate
 * 				// your template can handle all the data types so you don't have to conditionally set it
 * 				// you can also set different templates for different columns based on index
 * 			}));
 * 		});
 * 		newData.push(row);
 * 	});
 * 	return newData;
 * }
 * ```
 *
 * <example-url>../../iframe.html?id=table--basic</example-url>
 */
export class Table {
    /**
     * Creates an instance of Table.
     */
    constructor(elementRef, applicationRef, i18n) {
        this.elementRef = elementRef;
        this.applicationRef = applicationRef;
        this.i18n = i18n;
        /**
         * Size of the table rows.
         */
        this.size = "md";
        /**
         * Set to `true` for a loading table.
         */
        this.skeleton = false;
        /**
         * Setting sortable to false will disable all headers including headers which are sortable. Is is
         * possible to set the sortable state on the header item to disable/enable sorting for only some headers.
         */
        this.sortable = true;
        this.noBorder = true;
        /**
         * Controls whether to show the selection checkboxes column or not.
         */
        this.showSelectionColumn = true;
        /**
         * Controls whether to enable multiple or single row selection.
         */
        this.enableSingleSelect = false;
        /**
         * Distance (in px) from the bottom that view has to reach before
         * `scrollLoad` event is emitted.
         */
        this.scrollLoadDistance = 0;
        /**
         * Set to `true` to enable users to resize columns.
         *
         * Works for columns with width set in pixels.
         *
         */
        this.columnsResizable = false;
        /**
         * Set to `true` to enable users to drag and drop columns.
         *
         * Changing the column order in table changes table model. Be aware of it when you add additional data
         * to the model.
         *
         */
        this.columnsDraggable = false;
        /**
         * Set to `false` to remove table rows (zebra) stripes.
         */
        this.striped = true;
        /**
         * Set to `true` to stick the header to the top of the table
         */
        this.stickyHeader = false;
        /**
         * Emits an index of the column that wants to be sorted.
         *
         * If no observers are provided (default), table will attempt to do a simple sort of the data loaded
         * into the model.
         *
         * If an observer is provided, table will not attempt any sorting of its own and it is up to the observer
         * to sort the table. This is what you typically want if you're using a backend query to get the sorted
         * data or want to sort data across multiple pages.
         *
         * Usage:
         *
         * ```typescript
         * @Component({
         * 	selector: "app-table",
         * 	template: `
         * 		<ibm-table
         * 			[model]="model"
         * 			(sort)="simpleSort($event)">
         * 			No data.
         * 		</ibm-table>
         * 	`
         * })
         * export class TableApp implements OnInit, OnChanges {
         * 	@Input() model = new TableModel();
         *
         * 	ngOnInit() {
         * 		this.model.header = [
         * 			new TableHeaderItem({ data: "Name" }),
         * 			new TableHeaderItem({ data: "hwer" })
         * 		];
         *
         * 		this.model.data = [
         * 			[new TableItem({ data: "Name 1" }), new TableItem({ data: "qwer" })],
         * 			[new TableItem({ data: "Name 3" }), new TableItem({ data: "zwer" })],
         * 			[new TableItem({ data: "Name 2" }), new TableItem({ data: "swer" })],
         * 			[new TableItem({ data: "Name 4" }), new TableItem({data: "twer"})],
         * 			[new TableItem({ data: "Name 5" }), new TableItem({data: "twer"})],
         * 			[new TableItem({ data: "Name 6" }), new TableItem({data: "twer"})]
         * 		];
         * 	}
         *
         * 	simpleSort(index: number) {
         * 		// this function does a simple sort, which is the default for the table and if that's
         * 		// all you want, you don't need to do this.
         *
         * 		// here you can query your backend and update the model.data based on the result
         * 		if (this.model.header[index].sorted) {
         * 			// if already sorted flip sorting direction
         * 			this.model.header[index].ascending = this.model.header[index].descending;
         * 		}
         * 		this.model.sort(index);
         * 	}
         * }
         * ```
         */
        this.sort = new EventEmitter();
        /**
         * Emits if all rows are selected.
         *
         * @param model
         */
        this.selectAll = new EventEmitter();
        /**
         * Emits if all rows are deselected.
         *
         * @param model
         */
        this.deselectAll = new EventEmitter();
        /**
         * Emits if a single row is selected.
         *
         * @param ({model: this.model, selectedRowIndex: index})
         */
        this.selectRow = new EventEmitter();
        /**
         * Emits if a single row is deselected.
         *
         * @param ({model: this.model, deselectedRowIndex: index})
         */
        this.deselectRow = new EventEmitter();
        /**
         * Emits if a row item excluding expandButtons, checkboxes, or radios is clicked.
         */
        this.rowClick = new EventEmitter();
        /**
         * Emits when table requires more data to be loaded.
         */
        this.scrollLoad = new EventEmitter();
        /**
         * Controls if all checkboxes are viewed as selected.
         */
        this.selectAllCheckbox = false;
        /**
         * Controls the indeterminate state of the header checkbox.
         */
        this.selectAllCheckboxSomeSelected = false;
        this.isColumnDragging = false;
        this.columnDraggedHoverIndex = -1;
        this.columnDraggedPosition = "";
        this._isDataGrid = false;
        // flag to prevent getters/setters from querying the view before it's fully instantiated
        this.isViewReady = false;
        this.subscriptions = new Subscription();
        this._expandButtonAriaLabel = this.i18n.getOverridable("TABLE.EXPAND_BUTTON");
        this._sortDescendingLabel = this.i18n.getOverridable("TABLE.SORT_DESCENDING");
        this._sortAscendingLabel = this.i18n.getOverridable("TABLE.SORT_ASCENDING");
        this._checkboxHeaderLabel = this.i18n.getOverridable("TABLE.CHECKBOX_HEADER");
        this._checkboxRowLabel = this.i18n.getOverridable("TABLE.CHECKBOX_ROW");
        this._endOfDataText = this.i18n.getOverridable("TABLE.END_OF_DATA");
        this._scrollTopText = this.i18n.getOverridable("TABLE.SCROLL_TOP");
        this._filterTitle = this.i18n.getOverridable("TABLE.FILTER");
    }
    /**
     * Creates a skeleton model with a row and column count specified by the user
     *
     * Example:
     *
     * ```typescript
     * this.model = Table.skeletonModel(5, 5);
     * ```
     */
    static skeletonModel(rowCount, columnCount) {
        const model = new TableModel();
        let header = new Array();
        let data = new Array();
        let row = new Array();
        for (let i = 0; i < columnCount; i++) {
            header.push(new TableHeaderItem());
            row.push(new TableItem());
        }
        for (let i = 0; i < rowCount - 1; i++) {
            data.push(row);
        }
        model.header = header;
        model.data = data;
        return model;
    }
    static setTabIndex(element, index) {
        const focusElementList = getFocusElementList(element, tabbableSelectorIgnoreTabIndex);
        if (element.firstElementChild && element.firstElementChild.classList.contains("bx--table-sort")) {
            focusElementList[1].tabIndex = index;
        }
        else if (focusElementList.length > 0) {
            focusElementList[0].tabIndex = index;
        }
        else {
            element.tabIndex = index;
        }
    }
    static focus(element) {
        const focusElementList = getFocusElementList(element, tabbableSelectorIgnoreTabIndex);
        if (element.firstElementChild && element.firstElementChild.classList.contains("bx--table-sort") && focusElementList.length > 1) {
            focusElementList[1].focus();
        }
        else if (focusElementList.length > 0) {
            focusElementList[0].focus();
        }
        else {
            element.focus();
        }
    }
    /**
     * `TableModel` with data the table is to display.
     */
    set model(m) {
        if (this._model) {
            this.subscriptions.unsubscribe();
            // Need to create a new subscription instance here because unsubscribing prevents any new subscriptions
            // from being added for some reason. When a new model is set, none of the subscriptions would exist.
            this.subscriptions = new Subscription();
        }
        this._model = m;
        const rowsChange = this._model.rowsSelectedChange.subscribe(() => this.updateSelectAllCheckbox());
        const dataChange = this._model.dataChange.subscribe(() => {
            if (this.isDataGrid) {
                this.resetTabIndex();
            }
            this.updateSelectAllCheckbox();
        });
        this.subscriptions.add(rowsChange);
        this.subscriptions.add(dataChange);
        if (this.isDataGrid) {
            const expandedChange = this._model.rowsExpandedChange.subscribe(() => {
                // Allows the expanded row to have a focus state when it exists in the DOM
                setTimeout(() => {
                    const expandedRows = this.elementRef.nativeElement.querySelectorAll(".bx--expandable-row:not(.bx--parent-row)");
                    Array.from(expandedRows).forEach(row => {
                        if (row.firstElementChild.tabIndex === undefined || row.firstElementChild.tabIndex !== -1) {
                            row.firstElementChild.tabIndex = -1;
                        }
                    });
                });
            });
            this.subscriptions.add(expandedChange);
        }
    }
    get model() {
        return this._model;
    }
    /**
     * Set to `true` for a data grid with keyboard interactions.
     */
    set isDataGrid(value) {
        this._isDataGrid = value;
        if (this.isViewReady) {
            if (value) {
                this.enableDataGridInteractions();
            }
            else {
                this.disableDataGridInteractions();
            }
        }
    }
    get isDataGrid() {
        return this._isDataGrid;
    }
    set expandButtonAriaLabel(value) {
        this._expandButtonAriaLabel.override(value);
    }
    get expandButtonAriaLabel() {
        return this._expandButtonAriaLabel.value;
    }
    set sortDescendingLabel(value) {
        this._sortDescendingLabel.override(value);
    }
    get sortDescendingLabel() {
        return this._sortDescendingLabel.value;
    }
    set sortAscendingLabel(value) {
        this._sortAscendingLabel.override(value);
    }
    get sortAscendingLabel() {
        return this._sortAscendingLabel.value;
    }
    /**
     * Expects an object that contains some or all of:
     * ```
     * {
     *		"FILTER": "Filter",
     *		"END_OF_DATA": "You've reached the end of your content",
     *		"SCROLL_TOP": "Scroll to top",
     *		"CHECKBOX_HEADER": "Select all rows",
     *		"CHECKBOX_ROW": "Select row"
     * }
     * ```
     */
    set translations(value) {
        const valueWithDefaults = merge(this.i18n.getMultiple("TABLE"), value);
        this._filterTitle.override(valueWithDefaults.FILTER);
        this._endOfDataText.override(valueWithDefaults.END_OF_DATA);
        this._scrollTopText.override(valueWithDefaults.SCROLL_TOP);
        this._checkboxHeaderLabel.override(valueWithDefaults.CHECKBOX_HEADER);
        this._checkboxRowLabel.override(valueWithDefaults.CHECKBOX_ROW);
    }
    get noData() {
        return !this.model.data ||
            this.model.data.length === 0 ||
            this.model.data.length === 1 && this.model.data[0].length === 0;
    }
    ngAfterViewInit() {
        this.isViewReady = true;
        if (this.isDataGrid) {
            this.enableDataGridInteractions();
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
        if (this.positionSubscription) {
            this.positionSubscription.unsubscribe();
        }
    }
    enableDataGridInteractions() {
        // if we have an `interactioModel` we've already enabled datagrid
        if (this.interactionModel) {
            return;
        }
        const table = this.elementRef.nativeElement.querySelector("table");
        const tableAdapter = new TableDomAdapter(table);
        const keydownEventStream = fromEvent(table, "keydown");
        const clickEventStream = fromEvent(table, "click");
        this.interactionModel = new DataGridInteractionModel(keydownEventStream, clickEventStream, tableAdapter);
        this.positionSubscription = this.interactionModel.position.subscribe(event => {
            const [currentRow, currentColumn] = event.current;
            const [previousRow, previousColumn] = event.previous;
            const currentElement = tableAdapter.getCell(currentRow, currentColumn);
            Table.setTabIndex(currentElement, 0);
            // if the model has just initialized don't focus or reset anything
            if (previousRow === -1 || previousColumn === -1) {
                return;
            }
            // Make the previous cell unfocusable (if it's not the current)
            if (previousRow !== currentRow || previousColumn !== currentColumn) {
                const previousElement = tableAdapter.getCell(previousRow, previousColumn);
                Table.setTabIndex(previousElement, -1);
            }
            Table.focus(currentElement);
        });
        // call this after assigning `this.interactionModel` since it depends on it
        this.resetTabIndex();
    }
    disableDataGridInteractions() {
        // unsubscribe first so we don't cause the focus to fly around
        if (this.positionSubscription) {
            this.positionSubscription.unsubscribe();
        }
        // undo tab indexing (also resets the model)
        this.resetTabIndex(0);
        // null out the model ref
        this.interactionModel = null;
    }
    onSelectAll() {
        this.model.selectAll(true);
        this.selectAll.emit(this.model);
    }
    onDeselectAll() {
        this.model.selectAll(false);
        this.deselectAll.emit(this.model);
    }
    onSelectRow(event) {
        // check for the existence of the selectedRowIndex property
        if (Object.keys(event).includes("selectedRowIndex")) {
            if (this.enableSingleSelect) {
                this.model.selectAll(false);
            }
            this.model.selectRow(event.selectedRowIndex, true);
            this.selectRow.emit(event);
        }
        else {
            this.model.selectRow(event.deselectedRowIndex, false);
            this.deselectRow.emit(event);
        }
    }
    onRowClick(index) {
        this.rowClick.emit(index);
    }
    updateSelectAllCheckbox() {
        const selectedRowsCount = this.model.selectedRowsCount();
        if (selectedRowsCount <= 0) {
            // reset select all checkbox if nothing selected
            this.selectAllCheckbox = false;
            this.selectAllCheckboxSomeSelected = false;
        }
        else if (selectedRowsCount < this.model.data.length) {
            this.selectAllCheckbox = true;
            this.selectAllCheckboxSomeSelected = true;
        }
        else {
            this.selectAllCheckbox = true;
            this.selectAllCheckboxSomeSelected = false;
        }
    }
    resetTabIndex(newTabIndex = -1) {
        // ensure the view is ready for the reset before we preform the actual reset
        setTimeout(() => {
            // reset all the tabIndexes we can find
            const focusElementList = getFocusElementList(this.elementRef.nativeElement, tabbableSelectorIgnoreTabIndex);
            if (focusElementList) {
                focusElementList.forEach(tabbable => {
                    tabbable.tabIndex = newTabIndex;
                });
            }
            // reset interaction model positions and tabIndexes
            if (this.interactionModel) {
                this.interactionModel.resetTabIndexes(newTabIndex);
            }
        });
    }
    columnResizeStart(event, column) {
        this.columnResizeWidth = parseInt(column.style.width, 10);
        this.columnResizeMouseX = event.clientX;
        event.preventDefault();
        this.mouseMoveSubscription = fromEvent(document.body, "mousemove").subscribe(event => {
            this.columnResizeProgress(event, column);
        });
        this.mouseUpSubscription = fromEvent(document.body, "mouseup").subscribe(event => {
            this.columnResizeEnd(event, column);
        });
    }
    columnResizeProgress(event, column) {
        const move = event.clientX - this.columnResizeMouseX;
        column.style.width = `${this.columnResizeWidth + move}px`;
    }
    columnResizeEnd(event, column) {
        this.mouseMoveSubscription.unsubscribe();
        this.mouseUpSubscription.unsubscribe();
    }
    /**
     * Triggered when the user scrolls on the `<tbody>` element.
     * Emits the `scrollLoad` event.
     */
    onScroll(event) {
        const distanceFromBottom = event.target.scrollHeight - event.target.clientHeight - event.target.scrollTop;
        if (distanceFromBottom <= this.scrollLoadDistance) {
            this.scrollLoad.emit(this.model);
        }
        else {
            this.model.isEnd = false;
        }
    }
    columnDragStart(event, columnIndex) {
        this.isColumnDragging = true;
        this.columnDraggedHoverIndex = columnIndex;
        event.dataTransfer.setData("columnIndex", JSON.stringify(columnIndex));
    }
    columnDragEnd(event, columnIndex) {
        this.isColumnDragging = false;
        this.columnDraggedHoverIndex = -1;
    }
    columnDragEnter(event, position, columnIndex) {
        this.columnDraggedPosition = position;
        this.columnDraggedHoverIndex = columnIndex;
    }
    columnDragLeave(event, position, columnIndex) {
        this.columnDraggedPosition = "";
    }
    columnDragover(event, position, columnIndex) {
        this.columnDraggedHoverIndex = columnIndex;
        this.columnDraggedPosition = position;
        // needed to tell browser to allow dropping
        event.preventDefault();
    }
    columnDrop(event, position, columnIndex) {
        this.isColumnDragging = false;
        this.columnDraggedHoverIndex = -1;
        this.columnDraggedPosition = "";
        this.model.moveColumn(parseInt(event.dataTransfer.getData("columnIndex"), 10), columnIndex + (position === "right" ? 1 : 0));
    }
    doSort(index) {
        if (this.sort.observers.length === 0) {
            // no sort provided so do the simple sort
            if (this.model.header[index].sorted) {
                // if already sorted flip sorting direction
                this.model.header[index].ascending = this.model.header[index].descending;
            }
            this.model.sort(index);
        }
        this.sort.emit(index);
    }
    /**
     * Triggered when the user scrolls on the `<tbody>` element.
     * Emits the `scrollLoad` event.
     */
    scrollToTop(event) {
        event.target.parentElement.parentElement.parentElement.parentElement.children[1].scrollTop = 0;
        this.model.isEnd = false;
    }
    getSelectionLabelValue(row) {
        if (!this.selectionLabelColumn) {
            return { value: this.i18n.get().TABLE.ROW };
        }
        return { value: row[this.selectionLabelColumn].data };
    }
    getExpandButtonAriaLabel() {
        return this._expandButtonAriaLabel.subject;
    }
    getSortDescendingLabel() {
        return this._sortDescendingLabel.subject;
    }
    getSortAscendingLabel() {
        return this._sortAscendingLabel.subject;
    }
    getCheckboxHeaderLabel() {
        return this._checkboxHeaderLabel.subject;
    }
    getCheckboxRowLabel() {
        return this._checkboxRowLabel.subject;
    }
    getEndOfDataText() {
        return this._endOfDataText.subject;
    }
    getScrollTopText() {
        return this._scrollTopText.subject;
    }
    getFilterTitle() {
        return this._filterTitle.subject;
    }
}
Table.decorators = [
    { type: Component, args: [{
                selector: "ibm-table",
                template: `
	<table
		ibmTable
		[sortable]="sortable"
		[noBorder]="noBorder"
		[ngClass]="{'bx--data-table--sticky-header': stickyHeader}"
		[size]="size"
		[striped]="striped"
		[skeleton]="skeleton">
		<thead
			ibmTableHead
			[sortable]="sortable"
			(deselectAll)="onDeselectAll()"
			(selectAll)="onSelectAll()"
			(sort)="doSort($event)"
			[checkboxHeaderLabel]="getCheckboxHeaderLabel()"
			[filterTitle]="getFilterTitle()"
			[model]="model"
			[size]="size"
			[selectAllCheckbox]="selectAllCheckbox"
			[selectAllCheckboxSomeSelected]="selectAllCheckboxSomeSelected"
			[showSelectionColumn]="showSelectionColumn"
			[enableSingleSelect]="enableSingleSelect"
			[skeleton]="skeleton"
			[sortAscendingLabel]="sortAscendingLabel"
			[sortDescendingLabel]="sortDescendingLabel"
			[stickyHeader]="stickyHeader">
		</thead>
		<tbody
			ibmTableBody
			(deselectRow)="onSelectRow($event)"
			(scroll)="onScroll($event)"
			(selectRow)="onSelectRow($event)"
			[checkboxRowLabel]="getCheckboxRowLabel()"
			[enableSingleSelect]="enableSingleSelect"
			(rowClick)="onRowClick($event)"
			[expandButtonAriaLabel]="expandButtonAriaLabel"
			[model]="model"
			[size]="size"
			[ngStyle]="{'overflow-y': 'scroll'}"
			[selectionLabelColumn]="selectionLabelColumn"
			[showSelectionColumn]="showSelectionColumn"
			[skeleton]="skeleton"
			*ngIf="!noData; else noDataTemplate">
		</tbody>
		<ng-template #noDataTemplate><ng-content></ng-content></ng-template>
		<tfoot>
			<ng-template
				[ngTemplateOutlet]="footerTemplate">
			</ng-template>
			<tr *ngIf="this.model.isLoading">
				<td class="table_loading-indicator">
					<div class="bx--loading bx--loading--small">
						<svg class="bx--loading__svg" viewBox="-75 -75 150 150">
							<circle class="bx--loading__stroke" cx="0" cy="0" r="37.5" />
						</svg>
					</div>
				</td>
			</tr>
			<tr *ngIf="this.model.isEnd">
				<td class="table_end-indicator">
					<h5>{{getEndOfDataText() | async}}</h5>
					<button (click)="scrollToTop($event)" class="btn--secondary-sm">
						{{getScrollTopText() | async}}
					</button>
				</td>
			</tr>
		</tfoot>
	</table>
	`
            }] }
];
/** @nocollapse */
Table.ctorParameters = () => [
    { type: ElementRef },
    { type: ApplicationRef },
    { type: I18n }
];
Table.propDecorators = {
    model: [{ type: Input }],
    size: [{ type: Input }],
    skeleton: [{ type: Input }],
    isDataGrid: [{ type: Input }],
    sortable: [{ type: Input }],
    noBorder: [{ type: Input }],
    showSelectionColumn: [{ type: Input }],
    enableSingleSelect: [{ type: Input }],
    scrollLoadDistance: [{ type: Input }],
    columnsResizable: [{ type: Input }],
    columnsDraggable: [{ type: Input }],
    expandButtonAriaLabel: [{ type: Input }],
    sortDescendingLabel: [{ type: Input }],
    sortAscendingLabel: [{ type: Input }],
    translations: [{ type: Input }],
    striped: [{ type: Input }],
    stickyHeader: [{ type: HostBinding, args: ["class.bx--data-table_inner-container",] }, { type: Input }],
    footerTemplate: [{ type: Input }],
    selectionLabelColumn: [{ type: Input }],
    sort: [{ type: Output }],
    selectAll: [{ type: Output }],
    deselectAll: [{ type: Output }],
    selectRow: [{ type: Output }],
    deselectRow: [{ type: Output }],
    rowClick: [{ type: Output }],
    scrollLoad: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci90YWJsZS8iLCJzb3VyY2VzIjpbInRhYmxlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULGNBQWMsRUFDZCxLQUFLLEVBQ0wsTUFBTSxFQUNOLFlBQVksRUFDWixVQUFVLEVBRVYsV0FBVyxFQUVYLFdBQVcsRUFDWCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBYyxNQUFNLE1BQU0sQ0FBQztBQUUzRCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDakQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQzVELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUUvQyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsOEJBQThCLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQztBQUN2RyxPQUFPLEVBQUUsSUFBSSxFQUFlLE1BQU0sZ0NBQWdDLENBQUM7QUFDbkUsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBQ3hELE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHFDQUFxQyxDQUFDO0FBQy9FLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUd4RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FrSkc7QUEwRUgsTUFBTSxPQUFPLEtBQUs7SUF1WGpCOztPQUVHO0lBQ0gsWUFDVyxVQUFzQixFQUN0QixjQUE4QixFQUM5QixJQUFV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QyxpQkFBaUIsQ0FBQyxPQUFPLENBQUM7SUFDdkMsQ0FBQztJQUVELGdCQUFnQjtRQUNmLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUM7SUFDcEMsQ0FBQztJQUVELGdCQUFnQjtRQUNmLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUM7SUFDcEMsQ0FBQztJQUVELGNBQWM7UUFDYixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDO0lBQ2xDLENBQUM7OztZQWxzQkQsU0FBUyxTQUFDO2dCQUNWLFFBQVEsRUFBRSxXQUFXO2dCQUNyQixRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQXFFVDthQUNEOzs7O1lBOU9BLFVBQVU7WUFKVixjQUFjO1lBaUJOLElBQUk7OztvQkF3UlgsS0FBSzttQkE2Q0wsS0FBSzt1QkFJTCxLQUFLO3lCQUlMLEtBQUs7dUJBZUwsS0FBSzt1QkFFTCxLQUFLO2tDQVNMLEtBQUs7aUNBS0wsS0FBSztpQ0FNTCxLQUFLOytCQVFMLEtBQUs7K0JBU0wsS0FBSztvQ0FFTCxLQUFLO2tDQU9MLEtBQUs7aUNBT0wsS0FBSzsyQkFvQkwsS0FBSztzQkFhTCxLQUFLOzJCQUtMLFdBQVcsU0FBQyxzQ0FBc0MsY0FBRyxLQUFLOzZCQUsxRCxLQUFLO21DQVlMLEtBQUs7bUJBMERMLE1BQU07d0JBT04sTUFBTTswQkFPTixNQUFNO3dCQU9OLE1BQU07MEJBT04sTUFBTTt1QkFLTixNQUFNO3lCQUtOLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRDb21wb25lbnQsXG5cdEFwcGxpY2F0aW9uUmVmLFxuXHRJbnB1dCxcblx0T3V0cHV0LFxuXHRFdmVudEVtaXR0ZXIsXG5cdEVsZW1lbnRSZWYsXG5cdEFmdGVyVmlld0luaXQsXG5cdFRlbXBsYXRlUmVmLFxuXHRPbkRlc3Ryb3ksXG5cdEhvc3RCaW5kaW5nXG59IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24sIGZyb21FdmVudCwgT2JzZXJ2YWJsZSB9IGZyb20gXCJyeGpzXCI7XG5cbmltcG9ydCB7IFRhYmxlTW9kZWwgfSBmcm9tIFwiLi90YWJsZS1tb2RlbC5jbGFzc1wiO1xuaW1wb3J0IHsgVGFibGVIZWFkZXJJdGVtIH0gZnJvbSBcIi4vdGFibGUtaGVhZGVyLWl0ZW0uY2xhc3NcIjtcbmltcG9ydCB7IFRhYmxlSXRlbSB9IGZyb20gXCIuL3RhYmxlLWl0ZW0uY2xhc3NcIjtcblxuaW1wb3J0IHsgZ2V0Rm9jdXNFbGVtZW50TGlzdCwgdGFiYmFibGVTZWxlY3Rvcklnbm9yZVRhYkluZGV4IH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvY29tbW9uXCI7XG5pbXBvcnQgeyBJMThuLCBPdmVycmlkYWJsZSB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2kxOG5cIjtcbmltcG9ydCB7IG1lcmdlIH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvdXRpbHNcIjtcbmltcG9ydCB7IERhdGFHcmlkSW50ZXJhY3Rpb25Nb2RlbCB9IGZyb20gXCIuL2RhdGEtZ3JpZC1pbnRlcmFjdGlvbi1tb2RlbC5jbGFzc1wiO1xuaW1wb3J0IHsgVGFibGVEb21BZGFwdGVyIH0gZnJvbSBcIi4vdGFibGUtYWRhcHRlci5jbGFzc1wiO1xuaW1wb3J0IHsgVGFibGVSb3dTaXplIH0gZnJvbSBcIi4vdGFibGUudHlwZXNcIjtcblxuLyoqXG4gKiBCdWlsZCB5b3VyIHRhYmxlIHdpdGggdGhpcyBjb21wb25lbnQgYnkgZXh0ZW5kaW5nIHRoaW5ncyB0aGF0IGRpZmZlciBmcm9tIGRlZmF1bHQuXG4gKlxuICogW1NlZSBkZW1vXSguLi8uLi8/cGF0aD0vc3RvcnkvdGFibGUtLWJhc2ljKVxuICpcbiAqIEluc3RlYWQgb2YgdGhlIHVzdWFsIHdyaXRlLXlvdXItb3duLWh0bWwgYXBwcm9hY2ggeW91IGhhZCB3aXRoIGA8dGFibGU+YCxcbiAqIGNhcmJvbiB0YWJsZSB1c2VzIG1vZGVsLXZpZXctY29udHJvbGxlciBhcHByb2FjaC5cbiAqXG4gKiBIZXJlLCB5b3UgY3JlYXRlIGEgdmlldyAod2l0aCBidWlsdC1pbiBjb250cm9sbGVyKSBhbmQgcHJvdmlkZSBpdCBhIG1vZGVsLlxuICogQ2hhbmdlcyB5b3UgbWFrZSB0byB0aGUgbW9kZWwgYXJlIHJlZmxlY3RlZCBpbiB0aGUgdmlldy4gUHJvdmlkZSBzYW1lIG1vZGVsIHlvdSB1c2VcbiAqIGluIHRoZSB0YWJsZSB0byB0aGUgYDxpYm0tcGFnaW5hdGlvbj5gIGNvbXBvbmVudHMuXG4gKiBUaGV5IHByb3ZpZGUgYSBkaWZmZXJlbnQgdmlldyBvdmVyIHRoZSBzYW1lIGRhdGEuXG4gKlxuICogIyMgQmFzaWMgdXNhZ2VcbiAqXG4gKiBgYGBodG1sXG4gKiA8aWJtLXRhYmxlIFttb2RlbF09XCJtb2RlbFwiPjwvaWJtLXRhYmxlPlxuICogYGBgXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogcHVibGljIG1vZGVsID0gbmV3IFRhYmxlTW9kZWwoKTtcbiAqXG4gKiB0aGlzLm1vZGVsLmRhdGEgPSBbXG4gKiBcdFtuZXcgVGFibGVJdGVtKHtkYXRhOiBcImFzZGZcIn0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiBcInF3ZXJcIn0pXSxcbiAqIFx0W25ldyBUYWJsZUl0ZW0oe2RhdGE6IFwiY3NkZlwifSksIG5ldyBUYWJsZUl0ZW0oe2RhdGE6IFwiendlclwifSldLFxuICogXHRbbmV3IFRhYmxlSXRlbSh7ZGF0YTogXCJic2RmXCJ9KSwgbmV3IFRhYmxlSXRlbSh7ZGF0YTogXCJzd2VyXCJ9KV0sXG4gKiBcdFtuZXcgVGFibGVJdGVtKHtkYXRhOiBcImNzZGZcIn0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiBcInR3ZXJcIn0pXVxuICogXTtcbiAqIGBgYFxuICpcbiAqICMjIEN1c3RvbWl6YXRpb25cbiAqXG4gKiBJZiB5b3UgaGF2ZSBjdXN0b20gZGF0YSBpbiB5b3VyIHRhYmxlLCB5b3UgbmVlZCBhIHdheSB0byBkaXNwbGF5IGl0LiBZb3UgY2FuIGRvIHRoYXRcbiAqIGJ5IHByb3ZpZGluZyBhIHRlbXBsYXRlIHRvIGBUYWJsZUl0ZW1gLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxuZy10ZW1wbGF0ZSAjY3VzdG9tVGFibGVJdGVtVGVtcGxhdGUgbGV0LWRhdGE9XCJkYXRhXCI+XG4gKiBcdDxhIFtyb3V0ZXJMaW5rXT1cImRhdGEubGlua1wiPnt7ZGF0YS5uYW1lfX0ge3tkYXRhLnN1cm5hbWV9fTwvYT5cbiAqIDwvbmctdGVtcGxhdGU+XG4gKiBgYGBcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjdXN0b21UYWJsZUl0ZW1UZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAqXG4gKiB0aGlzLmN1c3RvbU1vZGVsLmRhdGEgPSBbXG4gKiBcdFtuZXcgVGFibGVJdGVtKHtkYXRhOiBcImFzZGZcIn0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiB7bmFtZTogXCJMZXNzeVwiLCBsaW5rOiBcIi90YWJsZVwifSwgdGVtcGxhdGU6IHRoaXMuY3VzdG9tVGFibGVJdGVtVGVtcGxhdGV9KV0sXG4gKiBcdFtuZXcgVGFibGVJdGVtKHtkYXRhOiBcImNzZGZcIn0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiBcInN3ZXJcIn0pXSxcbiAqIFx0W25ldyBUYWJsZUl0ZW0oe2RhdGE6IFwiYnNkZlwifSksIG5ldyBUYWJsZUl0ZW0oe2RhdGE6IHtuYW1lOiBcIkFsaWNlXCIsIHN1cm5hbWU6IFwiQm9iXCJ9LCB0ZW1wbGF0ZTogdGhpcy5jdXN0b21UYWJsZUl0ZW1UZW1wbGF0ZX0pXSxcbiAqIFx0W25ldyBUYWJsZUl0ZW0oe2RhdGE6IFwiY3NkZlwifSksIG5ldyBUYWJsZUl0ZW0oe2RhdGE6IFwidHdlclwifSldLFxuICogXTtcbiAqIGBgYFxuICpcbiAqICMjIyBTb3J0aW5nIGFuZCBmaWx0ZXJpbmdcbiAqXG4gKiBJbiBjYXNlIHlvdSBuZWVkIGN1c3RvbSBzb3J0aW5nIGFuZC9vciBmaWx0ZXJpbmcgeW91IHNob3VsZCBzdWJjbGFzcyBgVGFibGVIZWFkZXJJdGVtYFxuICogYW5kIG92ZXJyaWRlIG5lZWRlZCBmdW5jdGlvbnMuXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY2xhc3MgRmlsdGVyYWJsZUhlYWRlckl0ZW0gZXh0ZW5kcyBUYWJsZUhlYWRlckl0ZW0ge1xuICogXHQvLyBjdXN0b20gZmlsdGVyIGZ1bmN0aW9uXG4gKiBcdGZpbHRlcihpdGVtOiBUYWJsZUl0ZW0pOiBib29sZWFuIHtcbiAqIFx0XHRpZiAodHlwZW9mIGl0ZW0uZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBpdGVtLmRhdGEudG9Mb3dlckNhc2UoKS5pbmRleE9mKHRoaXMuZmlsdGVyRGF0YS5kYXRhLnRvTG93ZXJDYXNlKCkpID49IDAgfHxcbiAqIFx0XHRpdGVtLmRhdGEubmFtZSAmJiBpdGVtLmRhdGEubmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YodGhpcy5maWx0ZXJEYXRhLmRhdGEudG9Mb3dlckNhc2UoKSkgPj0gMCB8fFxuICogXHRcdGl0ZW0uZGF0YS5zdXJuYW1lICYmIGl0ZW0uZGF0YS5zdXJuYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0aGlzLmZpbHRlckRhdGEuZGF0YS50b0xvd2VyQ2FzZSgpKSA+PSAwKSB7XG4gKiBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gKiBcdFx0fVxuICogXHRcdHJldHVybiB0cnVlO1xuICogXHR9XG4gKlxuICogXHRzZXQgZmlsdGVyQ291bnQobikge31cbiAqIFx0Z2V0IGZpbHRlckNvdW50KCkge1xuICogXHRcdHJldHVybiAodGhpcy5maWx0ZXJEYXRhICYmIHRoaXMuZmlsdGVyRGF0YS5kYXRhICYmIHRoaXMuZmlsdGVyRGF0YS5kYXRhLmxlbmd0aCA+IDApID8gMSA6IDA7XG4gKiBcdH1cbiAqXG4gKiBcdC8vIHVzZWQgZm9yIGN1c3RvbSBzb3J0aW5nXG4gKiBcdGNvbXBhcmUob25lOiBUYWJsZUl0ZW0sIHR3bzogVGFibGVJdGVtKSB7XG4gKiBcdFx0Y29uc3Qgc3RyaW5nT25lID0gKG9uZS5kYXRhLm5hbWUgfHwgb25lLmRhdGEuc3VybmFtZSB8fCBvbmUuZGF0YSkudG9Mb3dlckNhc2UoKTtcbiAqIFx0XHRjb25zdCBzdHJpbmdUd28gPSAodHdvLmRhdGEubmFtZSB8fCB0d28uZGF0YS5zdXJuYW1lIHx8IHR3by5kYXRhKS50b0xvd2VyQ2FzZSgpO1xuICpcbiAqIFx0XHRpZiAoc3RyaW5nT25lID4gc3RyaW5nVHdvKSB7XG4gKiBcdFx0XHRyZXR1cm4gMTtcbiAqIFx0XHR9IGVsc2UgaWYgKHN0cmluZ09uZSA8IHN0cmluZ1R3bykge1xuICogXHRcdFx0cmV0dXJuIC0xO1xuICogXHRcdH0gZWxzZSB7XG4gKiBcdFx0XHRyZXR1cm4gMDtcbiAqIFx0XHR9XG4gKiBcdH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIElmIHlvdSB3YW50IHRvIGRvIHlvdXIgc29ydGluZyBvbiB0aGUgYmFja2VuZCBvciBxdWVyeSBmb3Igc29ydGVkIGRhdGEgYXMgYSByZXN1bHQgb2YgdXNlclxuICogY2xpY2tpbmcgdGhlIHRhYmxlIGhlYWRlciwgY2hlY2sgdGFibGUgW2Bzb3J0YF0oI3NvcnQpIG91dHB1dCBkb2N1bWVudGF0aW9uXG4gKlxuICogU2VlIGBUYWJsZUhlYWRlckl0ZW1gIGNsYXNzIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqICMjIE5vIGRhdGEgdGVtcGxhdGVcbiAqXG4gKiBXaGVuIHRhYmxlIGhhcyBubyBkYXRhIHRvIHNob3csIGl0IGNhbiBzaG93IGEgbWVzc2FnZSB5b3UgcHJvdmlkZSBpdCBpbnN0ZWFkLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxpYm0tdGFibGUgW21vZGVsXT1cIm1vZGVsXCI+Tm8gZGF0YS48L2libS10YWJsZT5cbiAqIGBgYFxuICpcbiAqIC4uLiB3aWxsIHNob3cgYE5vIGRhdGEuYCBtZXNzYWdlLCBidXQgeW91IGNhbiBnZXQgY3JlYXRpdmUgYW5kIHByb3ZpZGUgYW55IHRlbXBsYXRlIHlvdSB3YW50XG4gKiB0byByZXBsYWNlIHRhYmxlJ3MgZGVmYXVsdCBgdGJvZHlgLlxuICpcbiAqICMjIFVzZSBwYWdpbmF0aW9uIGFzIHRhYmxlIGZvb3RlclxuICpcbiAqIGBgYGh0bWxcbiAqIDxpYm0tcGFnaW5hdGlvbiBbbW9kZWxdPVwibW9kZWxcIiAoc2VsZWN0UGFnZSk9XCJzZWxlY3RQYWdlKCRldmVudClcIj48L2libS1wYWdpbmF0aW9uPlxuICogYGBgXG4gKlxuICogYHNlbGVjdFBhZ2UoKWAgZnVuY3Rpb24gc2hvdWxkIGZldGNoIHRoZSBkYXRhIGZyb20gYmFja2VuZCwgY3JlYXRlIG5ldyBgZGF0YWAsIGFwcGx5IGl0IHRvIGBtb2RlbC5kYXRhYCxcbiAqIGFuZCB1cGRhdGUgYG1vZGVsLmN1cnJlbnRQYWdlYC5cbiAqXG4gKiBJZiB0aGUgZGF0YSB5b3VyIHNlcnZlciByZXR1cm5zIGlzIGEgdHdvIGRpbWVuc2lvbmFsIGFycmF5IG9mIG9iamVjdHMsIGl0IHdvdWxkIGxvb2sgc29tZXRoaW5nIGxpa2UgdGhpczpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBzZWxlY3RQYWdlKHBhZ2UpIHtcbiAqIFx0dGhpcy5nZXRQYWdlKHBhZ2UpLnRoZW4oKGRhdGE6IEFycmF5PEFycmF5PGFueT4+KSA9PiB7XG4gKiBcdFx0Ly8gc2V0IHRoZSBkYXRhIGFuZCB1cGRhdGUgcGFnZVxuICogXHRcdHRoaXMubW9kZWwuZGF0YSA9IHRoaXMucHJlcGFyZURhdGEoZGF0YSk7XG4gKiBcdFx0dGhpcy5tb2RlbC5jdXJyZW50UGFnZSA9IHBhZ2U7XG4gKiBcdH0pO1xuICogfVxuICpcbiAqIHByb3RlY3RlZCBwcmVwYXJlRGF0YShkYXRhOiBBcnJheTxBcnJheTxhbnk+Pikge1xuICogXHQvLyBjcmVhdGUgbmV3IGRhdGEgZnJvbSB0aGUgc2VydmljZSBkYXRhXG4gKiBcdGxldCBuZXdEYXRhID0gW107XG4gKiBcdGRhdGEuZm9yRWFjaChkYXRhUm93ID0+IHtcbiAqIFx0XHRsZXQgcm93ID0gW107XG4gKiBcdFx0ZGF0YVJvdy5mb3JFYWNoKGRhdGFFbGVtZW50ID0+IHtcbiAqIFx0XHRcdHJvdy5wdXNoKG5ldyBUYWJsZUl0ZW0oe1xuICogXHRcdFx0XHRkYXRhOiBkYXRhRWxlbWVudCxcbiAqIFx0XHRcdFx0dGVtcGxhdGU6IHR5cGVvZiBkYXRhRWxlbWVudCA9PT0gXCJzdHJpbmdcIiA/IHVuZGVmaW5lZCA6IHRoaXMucGFnaW5hdGlvblRhYmxlSXRlbVRlbXBsYXRlXG4gKiBcdFx0XHRcdC8vIHlvdXIgdGVtcGxhdGUgY2FuIGhhbmRsZSBhbGwgdGhlIGRhdGEgdHlwZXMgc28geW91IGRvbid0IGhhdmUgdG8gY29uZGl0aW9uYWxseSBzZXQgaXRcbiAqIFx0XHRcdFx0Ly8geW91IGNhbiBhbHNvIHNldCBkaWZmZXJlbnQgdGVtcGxhdGVzIGZvciBkaWZmZXJlbnQgY29sdW1ucyBiYXNlZCBvbiBpbmRleFxuICogXHRcdFx0fSkpO1xuICogXHRcdH0pO1xuICogXHRcdG5ld0RhdGEucHVzaChyb3cpO1xuICogXHR9KTtcbiAqIFx0cmV0dXJuIG5ld0RhdGE7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiA8ZXhhbXBsZS11cmw+Li4vLi4vaWZyYW1lLmh0bWw/aWQ9dGFibGUtLWJhc2ljPC9leGFtcGxlLXVybD5cbiAqL1xuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiBcImlibS10YWJsZVwiLFxuXHR0ZW1wbGF0ZTogYFxuXHQ8dGFibGVcblx0XHRpYm1UYWJsZVxuXHRcdFtzb3J0YWJsZV09XCJzb3J0YWJsZVwiXG5cdFx0W25vQm9yZGVyXT1cIm5vQm9yZGVyXCJcblx0XHRbbmdDbGFzc109XCJ7J2J4LS1kYXRhLXRhYmxlLS1zdGlja3ktaGVhZGVyJzogc3RpY2t5SGVhZGVyfVwiXG5cdFx0W3NpemVdPVwic2l6ZVwiXG5cdFx0W3N0cmlwZWRdPVwic3RyaXBlZFwiXG5cdFx0W3NrZWxldG9uXT1cInNrZWxldG9uXCI+XG5cdFx0PHRoZWFkXG5cdFx0XHRpYm1UYWJsZUhlYWRcblx0XHRcdFtzb3J0YWJsZV09XCJzb3J0YWJsZVwiXG5cdFx0XHQoZGVzZWxlY3RBbGwpPVwib25EZXNlbGVjdEFsbCgpXCJcblx0XHRcdChzZWxlY3RBbGwpPVwib25TZWxlY3RBbGwoKVwiXG5cdFx0XHQoc29ydCk9XCJkb1NvcnQoJGV2ZW50KVwiXG5cdFx0XHRbY2hlY2tib3hIZWFkZXJMYWJlbF09XCJnZXRDaGVja2JveEhlYWRlckxhYmVsKClcIlxuXHRcdFx0W2ZpbHRlclRpdGxlXT1cImdldEZpbHRlclRpdGxlKClcIlxuXHRcdFx0W21vZGVsXT1cIm1vZGVsXCJcblx0XHRcdFtzaXplXT1cInNpemVcIlxuXHRcdFx0W3NlbGVjdEFsbENoZWNrYm94XT1cInNlbGVjdEFsbENoZWNrYm94XCJcblx0XHRcdFtzZWxlY3RBbGxDaGVja2JveFNvbWVTZWxlY3RlZF09XCJzZWxlY3RBbGxDaGVja2JveFNvbWVTZWxlY3RlZFwiXG5cdFx0XHRbc2hvd1NlbGVjdGlvbkNvbHVtbl09XCJzaG93U2VsZWN0aW9uQ29sdW1uXCJcblx0XHRcdFtlbmFibGVTaW5nbGVTZWxlY3RdPVwiZW5hYmxlU2luZ2xlU2VsZWN0XCJcblx0XHRcdFtza2VsZXRvbl09XCJza2VsZXRvblwiXG5cdFx0XHRbc29ydEFzY2VuZGluZ0xhYmVsXT1cInNvcnRBc2NlbmRpbmdMYWJlbFwiXG5cdFx0XHRbc29ydERlc2NlbmRpbmdMYWJlbF09XCJzb3J0RGVzY2VuZGluZ0xhYmVsXCJcblx0XHRcdFtzdGlja3lIZWFkZXJdPVwic3RpY2t5SGVhZGVyXCI+XG5cdFx0PC90aGVhZD5cblx0XHQ8dGJvZHlcblx0XHRcdGlibVRhYmxlQm9keVxuXHRcdFx0KGRlc2VsZWN0Um93KT1cIm9uU2VsZWN0Um93KCRldmVudClcIlxuXHRcdFx0KHNjcm9sbCk9XCJvblNjcm9sbCgkZXZlbnQpXCJcblx0XHRcdChzZWxlY3RSb3cpPVwib25TZWxlY3RSb3coJGV2ZW50KVwiXG5cdFx0XHRbY2hlY2tib3hSb3dMYWJlbF09XCJnZXRDaGVja2JveFJvd0xhYmVsKClcIlxuXHRcdFx0W2VuYWJsZVNpbmdsZVNlbGVjdF09XCJlbmFibGVTaW5nbGVTZWxlY3RcIlxuXHRcdFx0KHJvd0NsaWNrKT1cIm9uUm93Q2xpY2soJGV2ZW50KVwiXG5cdFx0XHRbZXhwYW5kQnV0dG9uQXJpYUxhYmVsXT1cImV4cGFuZEJ1dHRvbkFyaWFMYWJlbFwiXG5cdFx0XHRbbW9kZWxdPVwibW9kZWxcIlxuXHRcdFx0W3NpemVdPVwic2l6ZVwiXG5cdFx0XHRbbmdTdHlsZV09XCJ7J292ZXJmbG93LXknOiAnc2Nyb2xsJ31cIlxuXHRcdFx0W3NlbGVjdGlvbkxhYmVsQ29sdW1uXT1cInNlbGVjdGlvbkxhYmVsQ29sdW1uXCJcblx0XHRcdFtzaG93U2VsZWN0aW9uQ29sdW1uXT1cInNob3dTZWxlY3Rpb25Db2x1bW5cIlxuXHRcdFx0W3NrZWxldG9uXT1cInNrZWxldG9uXCJcblx0XHRcdCpuZ0lmPVwiIW5vRGF0YTsgZWxzZSBub0RhdGFUZW1wbGF0ZVwiPlxuXHRcdDwvdGJvZHk+XG5cdFx0PG5nLXRlbXBsYXRlICNub0RhdGFUZW1wbGF0ZT48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9uZy10ZW1wbGF0ZT5cblx0XHQ8dGZvb3Q+XG5cdFx0XHQ8bmctdGVtcGxhdGVcblx0XHRcdFx0W25nVGVtcGxhdGVPdXRsZXRdPVwiZm9vdGVyVGVtcGxhdGVcIj5cblx0XHRcdDwvbmctdGVtcGxhdGU+XG5cdFx0XHQ8dHIgKm5nSWY9XCJ0aGlzLm1vZGVsLmlzTG9hZGluZ1wiPlxuXHRcdFx0XHQ8dGQgY2xhc3M9XCJ0YWJsZV9sb2FkaW5nLWluZGljYXRvclwiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJieC0tbG9hZGluZyBieC0tbG9hZGluZy0tc21hbGxcIj5cblx0XHRcdFx0XHRcdDxzdmcgY2xhc3M9XCJieC0tbG9hZGluZ19fc3ZnXCIgdmlld0JveD1cIi03NSAtNzUgMTUwIDE1MFwiPlxuXHRcdFx0XHRcdFx0XHQ8Y2lyY2xlIGNsYXNzPVwiYngtLWxvYWRpbmdfX3N0cm9rZVwiIGN4PVwiMFwiIGN5PVwiMFwiIHI9XCIzNy41XCIgLz5cblx0XHRcdFx0XHRcdDwvc3ZnPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L3RkPlxuXHRcdFx0PC90cj5cblx0XHRcdDx0ciAqbmdJZj1cInRoaXMubW9kZWwuaXNFbmRcIj5cblx0XHRcdFx0PHRkIGNsYXNzPVwidGFibGVfZW5kLWluZGljYXRvclwiPlxuXHRcdFx0XHRcdDxoNT57e2dldEVuZE9mRGF0YVRleHQoKSB8IGFzeW5jfX08L2g1PlxuXHRcdFx0XHRcdDxidXR0b24gKGNsaWNrKT1cInNjcm9sbFRvVG9wKCRldmVudClcIiBjbGFzcz1cImJ0bi0tc2Vjb25kYXJ5LXNtXCI+XG5cdFx0XHRcdFx0XHR7e2dldFNjcm9sbFRvcFRleHQoKSB8IGFzeW5jfX1cblx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0PC90ZD5cblx0XHRcdDwvdHI+XG5cdFx0PC90Zm9vdD5cblx0PC90YWJsZT5cblx0YFxufSlcbmV4cG9ydCBjbGFzcyBUYWJsZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc2tlbGV0b24gbW9kZWwgd2l0aCBhIHJvdyBhbmQgY29sdW1uIGNvdW50IHNwZWNpZmllZCBieSB0aGUgdXNlclxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKlxuXHQgKiBgYGB0eXBlc2NyaXB0XG5cdCAqIHRoaXMubW9kZWwgPSBUYWJsZS5za2VsZXRvbk1vZGVsKDUsIDUpO1xuXHQgKiBgYGBcblx0ICovXG5cdHN0YXRpYyBza2VsZXRvbk1vZGVsKHJvd0NvdW50OiBudW1iZXIsIGNvbHVtbkNvdW50OiBudW1iZXIpIHtcblx0XHRjb25zdCBtb2RlbCA9IG5ldyBUYWJsZU1vZGVsKCk7XG5cdFx0bGV0IGhlYWRlciA9IG5ldyBBcnJheTxUYWJsZUhlYWRlckl0ZW0+KCk7XG5cdFx0bGV0IGRhdGEgPSBuZXcgQXJyYXk8QXJyYXk8VGFibGVJdGVtPj4oKTtcblx0XHRsZXQgcm93ID0gbmV3IEFycmF5PFRhYmxlSXRlbT4oKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuXHRcdFx0aGVhZGVyLnB1c2gobmV3IFRhYmxlSGVhZGVySXRlbSgpKTtcblx0XHRcdHJvdy5wdXNoKG5ldyBUYWJsZUl0ZW0oKSk7XG5cdFx0fVxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q291bnQgLSAxOyBpKyspIHtcblx0XHRcdGRhdGEucHVzaChyb3cpO1xuXHRcdH1cblxuXHRcdG1vZGVsLmhlYWRlciA9IGhlYWRlcjtcblx0XHRtb2RlbC5kYXRhID0gZGF0YTtcblx0XHRyZXR1cm4gbW9kZWw7XG5cdH1cblxuXHRzdGF0aWMgc2V0VGFiSW5kZXgoZWxlbWVudDogSFRNTEVsZW1lbnQsIGluZGV4OiAtMSB8IDApIHtcblx0XHRjb25zdCBmb2N1c0VsZW1lbnRMaXN0ID0gZ2V0Rm9jdXNFbGVtZW50TGlzdChlbGVtZW50LCB0YWJiYWJsZVNlbGVjdG9ySWdub3JlVGFiSW5kZXgpO1xuXHRcdGlmIChlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkICYmIGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYngtLXRhYmxlLXNvcnRcIikpIHtcblx0XHRcdGZvY3VzRWxlbWVudExpc3RbMV0udGFiSW5kZXggPSBpbmRleDtcblx0XHR9IGVsc2UgaWYgKGZvY3VzRWxlbWVudExpc3QubGVuZ3RoID4gMCkge1xuXHRcdFx0Zm9jdXNFbGVtZW50TGlzdFswXS50YWJJbmRleCA9IGluZGV4O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtZW50LnRhYkluZGV4ID0gaW5kZXg7XG5cdFx0fVxuXHR9XG5cblx0c3RhdGljIGZvY3VzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG5cdFx0Y29uc3QgZm9jdXNFbGVtZW50TGlzdCA9IGdldEZvY3VzRWxlbWVudExpc3QoZWxlbWVudCwgdGFiYmFibGVTZWxlY3Rvcklnbm9yZVRhYkluZGV4KTtcblx0XHRpZiAoZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCAmJiBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkLmNsYXNzTGlzdC5jb250YWlucyhcImJ4LS10YWJsZS1zb3J0XCIpICYmIGZvY3VzRWxlbWVudExpc3QubGVuZ3RoID4gMSkge1xuXHRcdFx0Zm9jdXNFbGVtZW50TGlzdFsxXS5mb2N1cygpO1xuXHRcdH0gZWxzZSBpZiAoZm9jdXNFbGVtZW50TGlzdC5sZW5ndGggPiAwKSB7XG5cdFx0XHRmb2N1c0VsZW1lbnRMaXN0WzBdLmZvY3VzKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW1lbnQuZm9jdXMoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogYFRhYmxlTW9kZWxgIHdpdGggZGF0YSB0aGUgdGFibGUgaXMgdG8gZGlzcGxheS5cblx0ICovXG5cdEBJbnB1dCgpXG5cdHNldCBtb2RlbChtOiBUYWJsZU1vZGVsKSB7XG5cdFx0aWYgKHRoaXMuX21vZGVsKSB7XG5cdFx0XHR0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcblx0XHRcdC8vIE5lZWQgdG8gY3JlYXRlIGEgbmV3IHN1YnNjcmlwdGlvbiBpbnN0YW5jZSBoZXJlIGJlY2F1c2UgdW5zdWJzY3JpYmluZyBwcmV2ZW50cyBhbnkgbmV3IHN1YnNjcmlwdGlvbnNcblx0XHRcdC8vIGZyb20gYmVpbmcgYWRkZWQgZm9yIHNvbWUgcmVhc29uLiBXaGVuIGEgbmV3IG1vZGVsIGlzIHNldCwgbm9uZSBvZiB0aGUgc3Vic2NyaXB0aW9ucyB3b3VsZCBleGlzdC5cblx0XHRcdHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLl9tb2RlbCA9IG07XG5cblx0XHRjb25zdCByb3dzQ2hhbmdlID0gdGhpcy5fbW9kZWwucm93c1NlbGVjdGVkQ2hhbmdlLnN1YnNjcmliZSgoKSA9PiB0aGlzLnVwZGF0ZVNlbGVjdEFsbENoZWNrYm94KCkpO1xuXHRcdGNvbnN0IGRhdGFDaGFuZ2UgPSB0aGlzLl9tb2RlbC5kYXRhQ2hhbmdlLnN1YnNjcmliZSgoKSA9PiB7XG5cdFx0XHRpZiAodGhpcy5pc0RhdGFHcmlkKSB7XG5cdFx0XHRcdHRoaXMucmVzZXRUYWJJbmRleCgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy51cGRhdGVTZWxlY3RBbGxDaGVja2JveCgpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5zdWJzY3JpcHRpb25zLmFkZChyb3dzQ2hhbmdlKTtcblx0XHR0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKGRhdGFDaGFuZ2UpO1xuXG5cdFx0aWYgKHRoaXMuaXNEYXRhR3JpZCkge1xuXHRcdFx0Y29uc3QgZXhwYW5kZWRDaGFuZ2UgPSB0aGlzLl9tb2RlbC5yb3dzRXhwYW5kZWRDaGFuZ2Uuc3Vic2NyaWJlKCgpID0+IHtcblx0XHRcdFx0Ly8gQWxsb3dzIHRoZSBleHBhbmRlZCByb3cgdG8gaGF2ZSBhIGZvY3VzIHN0YXRlIHdoZW4gaXQgZXhpc3RzIGluIHRoZSBET01cblx0XHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgZXhwYW5kZWRSb3dzID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5ieC0tZXhwYW5kYWJsZS1yb3c6bm90KC5ieC0tcGFyZW50LXJvdylcIik7XG5cdFx0XHRcdFx0QXJyYXkuZnJvbTxhbnk+KGV4cGFuZGVkUm93cykuZm9yRWFjaChyb3cgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKHJvdy5maXJzdEVsZW1lbnRDaGlsZC50YWJJbmRleCA9PT0gdW5kZWZpbmVkIHx8IHJvdy5maXJzdEVsZW1lbnRDaGlsZC50YWJJbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0cm93LmZpcnN0RWxlbWVudENoaWxkLnRhYkluZGV4ID0gLTE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKGV4cGFuZGVkQ2hhbmdlKTtcblx0XHR9XG5cdH1cblxuXHRnZXQgbW9kZWwoKTogVGFibGVNb2RlbCB7XG5cdFx0cmV0dXJuIHRoaXMuX21vZGVsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNpemUgb2YgdGhlIHRhYmxlIHJvd3MuXG5cdCAqL1xuXHRASW5wdXQoKSBzaXplOiBUYWJsZVJvd1NpemUgPSBcIm1kXCI7XG5cdC8qKlxuXHQgKiBTZXQgdG8gYHRydWVgIGZvciBhIGxvYWRpbmcgdGFibGUuXG5cdCAqL1xuXHRASW5wdXQoKSBza2VsZXRvbiA9IGZhbHNlO1xuXHQvKipcblx0ICogU2V0IHRvIGB0cnVlYCBmb3IgYSBkYXRhIGdyaWQgd2l0aCBrZXlib2FyZCBpbnRlcmFjdGlvbnMuXG5cdCAqL1xuXHRASW5wdXQoKSBzZXQgaXNEYXRhR3JpZCh2YWx1ZTogYm9vbGVhbikge1xuXHRcdHRoaXMuX2lzRGF0YUdyaWQgPSB2YWx1ZTtcblx0XHRpZiAodGhpcy5pc1ZpZXdSZWFkeSkge1xuXHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdHRoaXMuZW5hYmxlRGF0YUdyaWRJbnRlcmFjdGlvbnMoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZGlzYWJsZURhdGFHcmlkSW50ZXJhY3Rpb25zKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHRpbmcgc29ydGFibGUgdG8gZmFsc2Ugd2lsbCBkaXNhYmxlIGFsbCBoZWFkZXJzIGluY2x1ZGluZyBoZWFkZXJzIHdoaWNoIGFyZSBzb3J0YWJsZS4gSXMgaXNcblx0ICogcG9zc2libGUgdG8gc2V0IHRoZSBzb3J0YWJsZSBzdGF0ZSBvbiB0aGUgaGVhZGVyIGl0ZW0gdG8gZGlzYWJsZS9lbmFibGUgc29ydGluZyBmb3Igb25seSBzb21lIGhlYWRlcnMuXG5cdCAqL1xuXHRASW5wdXQoKSBzb3J0YWJsZSA9IHRydWU7XG5cblx0QElucHV0KCkgbm9Cb3JkZXIgPSB0cnVlO1xuXG5cdGdldCBpc0RhdGFHcmlkKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLl9pc0RhdGFHcmlkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnRyb2xzIHdoZXRoZXIgdG8gc2hvdyB0aGUgc2VsZWN0aW9uIGNoZWNrYm94ZXMgY29sdW1uIG9yIG5vdC5cblx0ICovXG5cdEBJbnB1dCgpIHNob3dTZWxlY3Rpb25Db2x1bW4gPSB0cnVlO1xuXG5cdC8qKlxuXHQgKiBDb250cm9scyB3aGV0aGVyIHRvIGVuYWJsZSBtdWx0aXBsZSBvciBzaW5nbGUgcm93IHNlbGVjdGlvbi5cblx0ICovXG5cdEBJbnB1dCgpIGVuYWJsZVNpbmdsZVNlbGVjdCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBEaXN0YW5jZSAoaW4gcHgpIGZyb20gdGhlIGJvdHRvbSB0aGF0IHZpZXcgaGFzIHRvIHJlYWNoIGJlZm9yZVxuXHQgKiBgc2Nyb2xsTG9hZGAgZXZlbnQgaXMgZW1pdHRlZC5cblx0ICovXG5cdEBJbnB1dCgpIHNjcm9sbExvYWREaXN0YW5jZSA9IDA7XG5cblx0LyoqXG5cdCAqIFNldCB0byBgdHJ1ZWAgdG8gZW5hYmxlIHVzZXJzIHRvIHJlc2l6ZSBjb2x1bW5zLlxuXHQgKlxuXHQgKiBXb3JrcyBmb3IgY29sdW1ucyB3aXRoIHdpZHRoIHNldCBpbiBwaXhlbHMuXG5cdCAqXG5cdCAqL1xuXHRASW5wdXQoKSBjb2x1bW5zUmVzaXphYmxlID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIFNldCB0byBgdHJ1ZWAgdG8gZW5hYmxlIHVzZXJzIHRvIGRyYWcgYW5kIGRyb3AgY29sdW1ucy5cblx0ICpcblx0ICogQ2hhbmdpbmcgdGhlIGNvbHVtbiBvcmRlciBpbiB0YWJsZSBjaGFuZ2VzIHRhYmxlIG1vZGVsLiBCZSBhd2FyZSBvZiBpdCB3aGVuIHlvdSBhZGQgYWRkaXRpb25hbCBkYXRhXG5cdCAqIHRvIHRoZSBtb2RlbC5cblx0ICpcblx0ICovXG5cdEBJbnB1dCgpIGNvbHVtbnNEcmFnZ2FibGUgPSBmYWxzZTtcblxuXHRASW5wdXQoKVxuXHRzZXQgZXhwYW5kQnV0dG9uQXJpYUxhYmVsKHZhbHVlOiBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz4pIHtcblx0XHR0aGlzLl9leHBhbmRCdXR0b25BcmlhTGFiZWwub3ZlcnJpZGUodmFsdWUpO1xuXHR9XG5cdGdldCBleHBhbmRCdXR0b25BcmlhTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2V4cGFuZEJ1dHRvbkFyaWFMYWJlbC52YWx1ZTtcblx0fVxuXHRASW5wdXQoKVxuXHRzZXQgc29ydERlc2NlbmRpbmdMYWJlbCh2YWx1ZTogc3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+KSB7XG5cdFx0dGhpcy5fc29ydERlc2NlbmRpbmdMYWJlbC5vdmVycmlkZSh2YWx1ZSk7XG5cdH1cblx0Z2V0IHNvcnREZXNjZW5kaW5nTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NvcnREZXNjZW5kaW5nTGFiZWwudmFsdWU7XG5cdH1cblx0QElucHV0KClcblx0c2V0IHNvcnRBc2NlbmRpbmdMYWJlbCh2YWx1ZTogc3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+KSB7XG5cdFx0dGhpcy5fc29ydEFzY2VuZGluZ0xhYmVsLm92ZXJyaWRlKHZhbHVlKTtcblx0fVxuXHRnZXQgc29ydEFzY2VuZGluZ0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLl9zb3J0QXNjZW5kaW5nTGFiZWwudmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogRXhwZWN0cyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBzb21lIG9yIGFsbCBvZjpcblx0ICogYGBgXG5cdCAqIHtcblx0ICpcdFx0XCJGSUxURVJcIjogXCJGaWx0ZXJcIixcblx0ICpcdFx0XCJFTkRfT0ZfREFUQVwiOiBcIllvdSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgeW91ciBjb250ZW50XCIsXG5cdCAqXHRcdFwiU0NST0xMX1RPUFwiOiBcIlNjcm9sbCB0byB0b3BcIixcblx0ICpcdFx0XCJDSEVDS0JPWF9IRUFERVJcIjogXCJTZWxlY3QgYWxsIHJvd3NcIixcblx0ICpcdFx0XCJDSEVDS0JPWF9ST1dcIjogXCJTZWxlY3Qgcm93XCJcblx0ICogfVxuXHQgKiBgYGBcblx0ICovXG5cdEBJbnB1dCgpXG5cdHNldCB0cmFuc2xhdGlvbnMgKHZhbHVlKSB7XG5cdFx0Y29uc3QgdmFsdWVXaXRoRGVmYXVsdHMgPSBtZXJnZSh0aGlzLmkxOG4uZ2V0TXVsdGlwbGUoXCJUQUJMRVwiKSwgdmFsdWUpO1xuXHRcdHRoaXMuX2ZpbHRlclRpdGxlLm92ZXJyaWRlKHZhbHVlV2l0aERlZmF1bHRzLkZJTFRFUik7XG5cdFx0dGhpcy5fZW5kT2ZEYXRhVGV4dC5vdmVycmlkZSh2YWx1ZVdpdGhEZWZhdWx0cy5FTkRfT0ZfREFUQSk7XG5cdFx0dGhpcy5fc2Nyb2xsVG9wVGV4dC5vdmVycmlkZSh2YWx1ZVdpdGhEZWZhdWx0cy5TQ1JPTExfVE9QKTtcblx0XHR0aGlzLl9jaGVja2JveEhlYWRlckxhYmVsLm92ZXJyaWRlKHZhbHVlV2l0aERlZmF1bHRzLkNIRUNLQk9YX0hFQURFUik7XG5cdFx0dGhpcy5fY2hlY2tib3hSb3dMYWJlbC5vdmVycmlkZSh2YWx1ZVdpdGhEZWZhdWx0cy5DSEVDS0JPWF9ST1cpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldCB0byBgZmFsc2VgIHRvIHJlbW92ZSB0YWJsZSByb3dzICh6ZWJyYSkgc3RyaXBlcy5cblx0ICovXG5cdEBJbnB1dCgpIHN0cmlwZWQgPSB0cnVlO1xuXG5cdC8qKlxuXHQgKiBTZXQgdG8gYHRydWVgIHRvIHN0aWNrIHRoZSBoZWFkZXIgdG8gdGhlIHRvcCBvZiB0aGUgdGFibGVcblx0ICovXG5cdEBIb3N0QmluZGluZyhcImNsYXNzLmJ4LS1kYXRhLXRhYmxlX2lubmVyLWNvbnRhaW5lclwiKSBASW5wdXQoKSBzdGlja3lIZWFkZXIgPSBmYWxzZTtcblxuXHQvKipcblx0ICogU2V0IGZvb3RlciB0ZW1wbGF0ZSB0byBjdXN0b21pemUgd2hhdCBpcyBkaXNwbGF5ZWQgaW4gdGhlIHRmb290IHNlY3Rpb24gb2YgdGhlIHRhYmxlXG5cdCAqL1xuXHRASW5wdXQoKSBmb290ZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuXHQvKipcblx0ICogVXNlZCB0byBwb3B1bGF0ZSB0aGUgcm93IHNlbGVjdGlvbiBjaGVja2JveCBsYWJlbCB3aXRoIGEgdXNlZnVsIHZhbHVlIGlmIHNldC5cblx0ICpcblx0ICogRXhhbXBsZTpcblx0ICogYGBgXG5cdCAqIDxpYm0tdGFibGUgW3NlbGVjdGlvbkxhYmVsQ29sdW1uXT1cIjBcIj48L2libS10YWJsZT5cblx0ICogPCEtLSByZXN1bHRzIGluIGFyaWEtbGFiZWw9XCJTZWxlY3QgZmlyc3QgY29sdW1uIHZhbHVlXCJcblx0ICogKHdoZXJlIFwiZmlyc3QgY29sdW1uIHZhbHVlXCIgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBjb2x1bW4gaW4gdGhlIHJvdyAtLT5cblx0ICogYGBgXG5cdCAqL1xuXHRASW5wdXQoKSBzZWxlY3Rpb25MYWJlbENvbHVtbjogbnVtYmVyO1xuXG5cdC8qKlxuXHQgKiBFbWl0cyBhbiBpbmRleCBvZiB0aGUgY29sdW1uIHRoYXQgd2FudHMgdG8gYmUgc29ydGVkLlxuXHQgKlxuXHQgKiBJZiBubyBvYnNlcnZlcnMgYXJlIHByb3ZpZGVkIChkZWZhdWx0KSwgdGFibGUgd2lsbCBhdHRlbXB0IHRvIGRvIGEgc2ltcGxlIHNvcnQgb2YgdGhlIGRhdGEgbG9hZGVkXG5cdCAqIGludG8gdGhlIG1vZGVsLlxuXHQgKlxuXHQgKiBJZiBhbiBvYnNlcnZlciBpcyBwcm92aWRlZCwgdGFibGUgd2lsbCBub3QgYXR0ZW1wdCBhbnkgc29ydGluZyBvZiBpdHMgb3duIGFuZCBpdCBpcyB1cCB0byB0aGUgb2JzZXJ2ZXJcblx0ICogdG8gc29ydCB0aGUgdGFibGUuIFRoaXMgaXMgd2hhdCB5b3UgdHlwaWNhbGx5IHdhbnQgaWYgeW91J3JlIHVzaW5nIGEgYmFja2VuZCBxdWVyeSB0byBnZXQgdGhlIHNvcnRlZFxuXHQgKiBkYXRhIG9yIHdhbnQgdG8gc29ydCBkYXRhIGFjcm9zcyBtdWx0aXBsZSBwYWdlcy5cblx0ICpcblx0ICogVXNhZ2U6XG5cdCAqXG5cdCAqIGBgYHR5cGVzY3JpcHRcblx0ICogQENvbXBvbmVudCh7XG5cdCAqIFx0c2VsZWN0b3I6IFwiYXBwLXRhYmxlXCIsXG5cdCAqIFx0dGVtcGxhdGU6IGBcblx0ICogXHRcdDxpYm0tdGFibGVcblx0ICogXHRcdFx0W21vZGVsXT1cIm1vZGVsXCJcblx0ICogXHRcdFx0KHNvcnQpPVwic2ltcGxlU29ydCgkZXZlbnQpXCI+XG5cdCAqIFx0XHRcdE5vIGRhdGEuXG5cdCAqIFx0XHQ8L2libS10YWJsZT5cblx0ICogXHRgXG5cdCAqIH0pXG5cdCAqIGV4cG9ydCBjbGFzcyBUYWJsZUFwcCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzIHtcblx0ICogXHRASW5wdXQoKSBtb2RlbCA9IG5ldyBUYWJsZU1vZGVsKCk7XG5cdCAqXG5cdCAqIFx0bmdPbkluaXQoKSB7XG5cdCAqIFx0XHR0aGlzLm1vZGVsLmhlYWRlciA9IFtcblx0ICogXHRcdFx0bmV3IFRhYmxlSGVhZGVySXRlbSh7IGRhdGE6IFwiTmFtZVwiIH0pLFxuXHQgKiBcdFx0XHRuZXcgVGFibGVIZWFkZXJJdGVtKHsgZGF0YTogXCJod2VyXCIgfSlcblx0ICogXHRcdF07XG5cdCAqXG5cdCAqIFx0XHR0aGlzLm1vZGVsLmRhdGEgPSBbXG5cdCAqIFx0XHRcdFtuZXcgVGFibGVJdGVtKHsgZGF0YTogXCJOYW1lIDFcIiB9KSwgbmV3IFRhYmxlSXRlbSh7IGRhdGE6IFwicXdlclwiIH0pXSxcblx0ICogXHRcdFx0W25ldyBUYWJsZUl0ZW0oeyBkYXRhOiBcIk5hbWUgM1wiIH0pLCBuZXcgVGFibGVJdGVtKHsgZGF0YTogXCJ6d2VyXCIgfSldLFxuXHQgKiBcdFx0XHRbbmV3IFRhYmxlSXRlbSh7IGRhdGE6IFwiTmFtZSAyXCIgfSksIG5ldyBUYWJsZUl0ZW0oeyBkYXRhOiBcInN3ZXJcIiB9KV0sXG5cdCAqIFx0XHRcdFtuZXcgVGFibGVJdGVtKHsgZGF0YTogXCJOYW1lIDRcIiB9KSwgbmV3IFRhYmxlSXRlbSh7ZGF0YTogXCJ0d2VyXCJ9KV0sXG5cdCAqIFx0XHRcdFtuZXcgVGFibGVJdGVtKHsgZGF0YTogXCJOYW1lIDVcIiB9KSwgbmV3IFRhYmxlSXRlbSh7ZGF0YTogXCJ0d2VyXCJ9KV0sXG5cdCAqIFx0XHRcdFtuZXcgVGFibGVJdGVtKHsgZGF0YTogXCJOYW1lIDZcIiB9KSwgbmV3IFRhYmxlSXRlbSh7ZGF0YTogXCJ0d2VyXCJ9KV1cblx0ICogXHRcdF07XG5cdCAqIFx0fVxuXHQgKlxuXHQgKiBcdHNpbXBsZVNvcnQoaW5kZXg6IG51bWJlcikge1xuXHQgKiBcdFx0Ly8gdGhpcyBmdW5jdGlvbiBkb2VzIGEgc2ltcGxlIHNvcnQsIHdoaWNoIGlzIHRoZSBkZWZhdWx0IGZvciB0aGUgdGFibGUgYW5kIGlmIHRoYXQnc1xuXHQgKiBcdFx0Ly8gYWxsIHlvdSB3YW50LCB5b3UgZG9uJ3QgbmVlZCB0byBkbyB0aGlzLlxuXHQgKlxuXHQgKiBcdFx0Ly8gaGVyZSB5b3UgY2FuIHF1ZXJ5IHlvdXIgYmFja2VuZCBhbmQgdXBkYXRlIHRoZSBtb2RlbC5kYXRhIGJhc2VkIG9uIHRoZSByZXN1bHRcblx0ICogXHRcdGlmICh0aGlzLm1vZGVsLmhlYWRlcltpbmRleF0uc29ydGVkKSB7XG5cdCAqIFx0XHRcdC8vIGlmIGFscmVhZHkgc29ydGVkIGZsaXAgc29ydGluZyBkaXJlY3Rpb25cblx0ICogXHRcdFx0dGhpcy5tb2RlbC5oZWFkZXJbaW5kZXhdLmFzY2VuZGluZyA9IHRoaXMubW9kZWwuaGVhZGVyW2luZGV4XS5kZXNjZW5kaW5nO1xuXHQgKiBcdFx0fVxuXHQgKiBcdFx0dGhpcy5tb2RlbC5zb3J0KGluZGV4KTtcblx0ICogXHR9XG5cdCAqIH1cblx0ICogYGBgXG5cdCAqL1xuXHRAT3V0cHV0KCkgc29ydCA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG5cdC8qKlxuXHQgKiBFbWl0cyBpZiBhbGwgcm93cyBhcmUgc2VsZWN0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSBtb2RlbFxuXHQgKi9cblx0QE91dHB1dCgpIHNlbGVjdEFsbCA9IG5ldyBFdmVudEVtaXR0ZXI8T2JqZWN0PigpO1xuXG5cdC8qKlxuXHQgKiBFbWl0cyBpZiBhbGwgcm93cyBhcmUgZGVzZWxlY3RlZC5cblx0ICpcblx0ICogQHBhcmFtIG1vZGVsXG5cdCAqL1xuXHRAT3V0cHV0KCkgZGVzZWxlY3RBbGwgPSBuZXcgRXZlbnRFbWl0dGVyPE9iamVjdD4oKTtcblxuXHQvKipcblx0ICogRW1pdHMgaWYgYSBzaW5nbGUgcm93IGlzIHNlbGVjdGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0gKHttb2RlbDogdGhpcy5tb2RlbCwgc2VsZWN0ZWRSb3dJbmRleDogaW5kZXh9KVxuXHQgKi9cblx0QE91dHB1dCgpIHNlbGVjdFJvdyA9IG5ldyBFdmVudEVtaXR0ZXI8T2JqZWN0PigpO1xuXG5cdC8qKlxuXHQgKiBFbWl0cyBpZiBhIHNpbmdsZSByb3cgaXMgZGVzZWxlY3RlZC5cblx0ICpcblx0ICogQHBhcmFtICh7bW9kZWw6IHRoaXMubW9kZWwsIGRlc2VsZWN0ZWRSb3dJbmRleDogaW5kZXh9KVxuXHQgKi9cblx0QE91dHB1dCgpIGRlc2VsZWN0Um93ID0gbmV3IEV2ZW50RW1pdHRlcjxPYmplY3Q+KCk7XG5cblx0LyoqXG5cdCAqIEVtaXRzIGlmIGEgcm93IGl0ZW0gZXhjbHVkaW5nIGV4cGFuZEJ1dHRvbnMsIGNoZWNrYm94ZXMsIG9yIHJhZGlvcyBpcyBjbGlja2VkLlxuXHQgKi9cblx0QE91dHB1dCgpIHJvd0NsaWNrID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cblx0LyoqXG5cdCAqIEVtaXRzIHdoZW4gdGFibGUgcmVxdWlyZXMgbW9yZSBkYXRhIHRvIGJlIGxvYWRlZC5cblx0ICovXG5cdEBPdXRwdXQoKSBzY3JvbGxMb2FkID0gbmV3IEV2ZW50RW1pdHRlcjxUYWJsZU1vZGVsPigpO1xuXG5cdC8qKlxuXHQgKiBDb250cm9scyBpZiBhbGwgY2hlY2tib3hlcyBhcmUgdmlld2VkIGFzIHNlbGVjdGVkLlxuXHQgKi9cblx0c2VsZWN0QWxsQ2hlY2tib3ggPSBmYWxzZTtcblxuXHQvKipcblx0ICogQ29udHJvbHMgdGhlIGluZGV0ZXJtaW5hdGUgc3RhdGUgb2YgdGhlIGhlYWRlciBjaGVja2JveC5cblx0ICovXG5cdHNlbGVjdEFsbENoZWNrYm94U29tZVNlbGVjdGVkID0gZmFsc2U7XG5cblx0Z2V0IG5vRGF0YSgpIHtcblx0XHRyZXR1cm4gIXRoaXMubW9kZWwuZGF0YSB8fFxuXHRcdFx0dGhpcy5tb2RlbC5kYXRhLmxlbmd0aCA9PT0gMCB8fFxuXHRcdFx0dGhpcy5tb2RlbC5kYXRhLmxlbmd0aCA9PT0gMSAmJiB0aGlzLm1vZGVsLmRhdGFbMF0ubGVuZ3RoID09PSAwO1xuXHR9XG5cblx0cHVibGljIGlzQ29sdW1uRHJhZ2dpbmcgPSBmYWxzZTtcblx0cHVibGljIGNvbHVtbkRyYWdnZWRIb3ZlckluZGV4ID0gLTE7XG5cdHB1YmxpYyBjb2x1bW5EcmFnZ2VkUG9zaXRpb24gPSBcIlwiO1xuXG5cdHByb3RlY3RlZCBfbW9kZWw6IFRhYmxlTW9kZWw7XG5cdHByb3RlY3RlZCBfaXNEYXRhR3JpZCA9IGZhbHNlO1xuXHQvLyBmbGFnIHRvIHByZXZlbnQgZ2V0dGVycy9zZXR0ZXJzIGZyb20gcXVlcnlpbmcgdGhlIHZpZXcgYmVmb3JlIGl0J3MgZnVsbHkgaW5zdGFudGlhdGVkXG5cdHByb3RlY3RlZCBpc1ZpZXdSZWFkeSA9IGZhbHNlO1xuXG5cdHByb3RlY3RlZCBzdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXHRwcm90ZWN0ZWQgcG9zaXRpb25TdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuXHRwcm90ZWN0ZWQgaW50ZXJhY3Rpb25Nb2RlbDogRGF0YUdyaWRJbnRlcmFjdGlvbk1vZGVsO1xuXHRwcm90ZWN0ZWQgaW50ZXJhY3Rpb25Qb3NpdGlvblN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG5cdHByb3RlY3RlZCBfZXhwYW5kQnV0dG9uQXJpYUxhYmVsICA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlRBQkxFLkVYUEFORF9CVVRUT05cIik7XG5cdHByb3RlY3RlZCBfc29ydERlc2NlbmRpbmdMYWJlbCA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlRBQkxFLlNPUlRfREVTQ0VORElOR1wiKTtcblx0cHJvdGVjdGVkIF9zb3J0QXNjZW5kaW5nTGFiZWwgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUQUJMRS5TT1JUX0FTQ0VORElOR1wiKTtcblx0cHJvdGVjdGVkIF9jaGVja2JveEhlYWRlckxhYmVsID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuQ0hFQ0tCT1hfSEVBREVSXCIpO1xuXHRwcm90ZWN0ZWQgX2NoZWNrYm94Um93TGFiZWwgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUQUJMRS5DSEVDS0JPWF9ST1dcIik7XG5cdHByb3RlY3RlZCBfZW5kT2ZEYXRhVGV4dCA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlRBQkxFLkVORF9PRl9EQVRBXCIpO1xuXHRwcm90ZWN0ZWQgX3Njcm9sbFRvcFRleHQgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUQUJMRS5TQ1JPTExfVE9QXCIpO1xuXHRwcm90ZWN0ZWQgX2ZpbHRlclRpdGxlID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuRklMVEVSXCIpO1xuXG5cdHByb3RlY3RlZCBjb2x1bW5SZXNpemVXaWR0aDogbnVtYmVyO1xuXHRwcm90ZWN0ZWQgY29sdW1uUmVzaXplTW91c2VYOiBudW1iZXI7XG5cdHByb3RlY3RlZCBtb3VzZU1vdmVTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblx0cHJvdGVjdGVkIG1vdXNlVXBTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBUYWJsZS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKFxuXHRcdHByb3RlY3RlZCBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuXHRcdHByb3RlY3RlZCBhcHBsaWNhdGlvblJlZjogQXBwbGljYXRpb25SZWYsXG5cdFx0cHJvdGVjdGVkIGkxOG46IEkxOG5cblx0KSB7fVxuXG5cdG5nQWZ0ZXJWaWV3SW5pdCgpIHtcblx0XHR0aGlzLmlzVmlld1JlYWR5ID0gdHJ1ZTtcblx0XHRpZiAodGhpcy5pc0RhdGFHcmlkKSB7XG5cdFx0XHR0aGlzLmVuYWJsZURhdGFHcmlkSW50ZXJhY3Rpb25zKCk7XG5cdFx0fVxuXHR9XG5cblx0bmdPbkRlc3Ryb3koKSB7XG5cdFx0dGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG5cdFx0aWYgKHRoaXMucG9zaXRpb25TdWJzY3JpcHRpb24pIHtcblx0XHRcdHRoaXMucG9zaXRpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcblx0XHR9XG5cdH1cblxuXHRlbmFibGVEYXRhR3JpZEludGVyYWN0aW9ucygpIHtcblx0XHQvLyBpZiB3ZSBoYXZlIGFuIGBpbnRlcmFjdGlvTW9kZWxgIHdlJ3ZlIGFscmVhZHkgZW5hYmxlZCBkYXRhZ3JpZFxuXHRcdGlmICh0aGlzLmludGVyYWN0aW9uTW9kZWwpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Y29uc3QgdGFibGUgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKFwidGFibGVcIikgYXMgSFRNTFRhYmxlRWxlbWVudDtcblx0XHRjb25zdCB0YWJsZUFkYXB0ZXIgPSBuZXcgVGFibGVEb21BZGFwdGVyKHRhYmxlKTtcblx0XHRjb25zdCBrZXlkb3duRXZlbnRTdHJlYW0gPSBmcm9tRXZlbnQ8S2V5Ym9hcmRFdmVudD4odGFibGUsIFwia2V5ZG93blwiKTtcblx0XHRjb25zdCBjbGlja0V2ZW50U3RyZWFtID0gZnJvbUV2ZW50PE1vdXNlRXZlbnQ+KHRhYmxlLCBcImNsaWNrXCIpO1xuXHRcdHRoaXMuaW50ZXJhY3Rpb25Nb2RlbCA9IG5ldyBEYXRhR3JpZEludGVyYWN0aW9uTW9kZWwoa2V5ZG93bkV2ZW50U3RyZWFtLCBjbGlja0V2ZW50U3RyZWFtLCB0YWJsZUFkYXB0ZXIpO1xuXHRcdHRoaXMucG9zaXRpb25TdWJzY3JpcHRpb24gPSB0aGlzLmludGVyYWN0aW9uTW9kZWwucG9zaXRpb24uc3Vic2NyaWJlKGV2ZW50ID0+IHtcblx0XHRcdGNvbnN0IFtjdXJyZW50Um93LCBjdXJyZW50Q29sdW1uXSA9IGV2ZW50LmN1cnJlbnQ7XG5cdFx0XHRjb25zdCBbcHJldmlvdXNSb3csIHByZXZpb3VzQ29sdW1uXSA9IGV2ZW50LnByZXZpb3VzO1xuXG5cdFx0XHRjb25zdCBjdXJyZW50RWxlbWVudCA9IHRhYmxlQWRhcHRlci5nZXRDZWxsKGN1cnJlbnRSb3csIGN1cnJlbnRDb2x1bW4pO1xuXHRcdFx0VGFibGUuc2V0VGFiSW5kZXgoY3VycmVudEVsZW1lbnQsIDApO1xuXG5cdFx0XHQvLyBpZiB0aGUgbW9kZWwgaGFzIGp1c3QgaW5pdGlhbGl6ZWQgZG9uJ3QgZm9jdXMgb3IgcmVzZXQgYW55dGhpbmdcblx0XHRcdGlmIChwcmV2aW91c1JvdyA9PT0gLTEgfHwgcHJldmlvdXNDb2x1bW4gPT09IC0xKSB7IHJldHVybjsgfVxuXHRcdFx0Ly8gTWFrZSB0aGUgcHJldmlvdXMgY2VsbCB1bmZvY3VzYWJsZSAoaWYgaXQncyBub3QgdGhlIGN1cnJlbnQpXG5cdFx0XHRpZiAocHJldmlvdXNSb3cgIT09IGN1cnJlbnRSb3cgfHwgcHJldmlvdXNDb2x1bW4gIT09IGN1cnJlbnRDb2x1bW4pIHtcblx0XHRcdFx0Y29uc3QgcHJldmlvdXNFbGVtZW50ID0gdGFibGVBZGFwdGVyLmdldENlbGwocHJldmlvdXNSb3csIHByZXZpb3VzQ29sdW1uKTtcblx0XHRcdFx0VGFibGUuc2V0VGFiSW5kZXgocHJldmlvdXNFbGVtZW50LCAtMSk7XG5cdFx0XHR9XG5cdFx0XHRUYWJsZS5mb2N1cyhjdXJyZW50RWxlbWVudCk7XG5cdFx0fSk7XG5cdFx0Ly8gY2FsbCB0aGlzIGFmdGVyIGFzc2lnbmluZyBgdGhpcy5pbnRlcmFjdGlvbk1vZGVsYCBzaW5jZSBpdCBkZXBlbmRzIG9uIGl0XG5cdFx0dGhpcy5yZXNldFRhYkluZGV4KCk7XG5cdH1cblxuXHRkaXNhYmxlRGF0YUdyaWRJbnRlcmFjdGlvbnMoKSB7XG5cdFx0Ly8gdW5zdWJzY3JpYmUgZmlyc3Qgc28gd2UgZG9uJ3QgY2F1c2UgdGhlIGZvY3VzIHRvIGZseSBhcm91bmRcblx0XHRpZiAodGhpcy5wb3NpdGlvblN1YnNjcmlwdGlvbikge1xuXHRcdFx0dGhpcy5wb3NpdGlvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuXHRcdH1cblx0XHQvLyB1bmRvIHRhYiBpbmRleGluZyAoYWxzbyByZXNldHMgdGhlIG1vZGVsKVxuXHRcdHRoaXMucmVzZXRUYWJJbmRleCgwKTtcblx0XHQvLyBudWxsIG91dCB0aGUgbW9kZWwgcmVmXG5cdFx0dGhpcy5pbnRlcmFjdGlvbk1vZGVsID0gbnVsbDtcblx0fVxuXG5cdG9uU2VsZWN0QWxsKCkge1xuXHRcdHRoaXMubW9kZWwuc2VsZWN0QWxsKHRydWUpO1xuXHRcdHRoaXMuc2VsZWN0QWxsLmVtaXQodGhpcy5tb2RlbCk7XG5cdH1cblxuXHRvbkRlc2VsZWN0QWxsKCkge1xuXHRcdHRoaXMubW9kZWwuc2VsZWN0QWxsKGZhbHNlKTtcblx0XHR0aGlzLmRlc2VsZWN0QWxsLmVtaXQodGhpcy5tb2RlbCk7XG5cdH1cblxuXHRvblNlbGVjdFJvdyhldmVudCkge1xuXHRcdC8vIGNoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIHRoZSBzZWxlY3RlZFJvd0luZGV4IHByb3BlcnR5XG5cdFx0aWYgKE9iamVjdC5rZXlzKGV2ZW50KS5pbmNsdWRlcyhcInNlbGVjdGVkUm93SW5kZXhcIikpIHtcblx0XHRcdGlmICh0aGlzLmVuYWJsZVNpbmdsZVNlbGVjdCkge1xuXHRcdFx0XHR0aGlzLm1vZGVsLnNlbGVjdEFsbChmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLm1vZGVsLnNlbGVjdFJvdyhldmVudC5zZWxlY3RlZFJvd0luZGV4LCB0cnVlKTtcblx0XHRcdHRoaXMuc2VsZWN0Um93LmVtaXQoZXZlbnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm1vZGVsLnNlbGVjdFJvdyhldmVudC5kZXNlbGVjdGVkUm93SW5kZXgsIGZhbHNlKTtcblx0XHRcdHRoaXMuZGVzZWxlY3RSb3cuZW1pdChldmVudCk7XG5cdFx0fVxuXHR9XG5cblx0b25Sb3dDbGljayhpbmRleDogbnVtYmVyKSB7XG5cdFx0dGhpcy5yb3dDbGljay5lbWl0KGluZGV4KTtcblx0fVxuXG5cdHVwZGF0ZVNlbGVjdEFsbENoZWNrYm94KCkge1xuXHRcdGNvbnN0IHNlbGVjdGVkUm93c0NvdW50ID0gdGhpcy5tb2RlbC5zZWxlY3RlZFJvd3NDb3VudCgpO1xuXG5cdFx0aWYgKHNlbGVjdGVkUm93c0NvdW50IDw9IDApIHtcblx0XHRcdC8vIHJlc2V0IHNlbGVjdCBhbGwgY2hlY2tib3ggaWYgbm90aGluZyBzZWxlY3RlZFxuXHRcdFx0dGhpcy5zZWxlY3RBbGxDaGVja2JveCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5zZWxlY3RBbGxDaGVja2JveFNvbWVTZWxlY3RlZCA9IGZhbHNlO1xuXHRcdH0gZWxzZSBpZiAoc2VsZWN0ZWRSb3dzQ291bnQgPCB0aGlzLm1vZGVsLmRhdGEubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLnNlbGVjdEFsbENoZWNrYm94ID0gdHJ1ZTtcblx0XHRcdHRoaXMuc2VsZWN0QWxsQ2hlY2tib3hTb21lU2VsZWN0ZWQgPSB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNlbGVjdEFsbENoZWNrYm94ID0gdHJ1ZTtcblx0XHRcdHRoaXMuc2VsZWN0QWxsQ2hlY2tib3hTb21lU2VsZWN0ZWQgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRyZXNldFRhYkluZGV4KG5ld1RhYkluZGV4ID0gLTEpIHtcblx0XHQvLyBlbnN1cmUgdGhlIHZpZXcgaXMgcmVhZHkgZm9yIHRoZSByZXNldCBiZWZvcmUgd2UgcHJlZm9ybSB0aGUgYWN0dWFsIHJlc2V0XG5cdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHQvLyByZXNldCBhbGwgdGhlIHRhYkluZGV4ZXMgd2UgY2FuIGZpbmRcblx0XHRcdGNvbnN0IGZvY3VzRWxlbWVudExpc3QgPSBnZXRGb2N1c0VsZW1lbnRMaXN0KHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCB0YWJiYWJsZVNlbGVjdG9ySWdub3JlVGFiSW5kZXgpO1xuXHRcdFx0aWYgKGZvY3VzRWxlbWVudExpc3QpIHtcblx0XHRcdFx0Zm9jdXNFbGVtZW50TGlzdC5mb3JFYWNoKHRhYmJhYmxlID0+IHtcblx0XHRcdFx0XHR0YWJiYWJsZS50YWJJbmRleCA9IG5ld1RhYkluZGV4O1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdC8vIHJlc2V0IGludGVyYWN0aW9uIG1vZGVsIHBvc2l0aW9ucyBhbmQgdGFiSW5kZXhlc1xuXHRcdFx0aWYgKHRoaXMuaW50ZXJhY3Rpb25Nb2RlbCkge1xuXHRcdFx0XHR0aGlzLmludGVyYWN0aW9uTW9kZWwucmVzZXRUYWJJbmRleGVzKG5ld1RhYkluZGV4KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdGNvbHVtblJlc2l6ZVN0YXJ0KGV2ZW50LCBjb2x1bW4pIHtcblx0XHR0aGlzLmNvbHVtblJlc2l6ZVdpZHRoID0gcGFyc2VJbnQoY29sdW1uLnN0eWxlLndpZHRoLCAxMCk7XG5cdFx0dGhpcy5jb2x1bW5SZXNpemVNb3VzZVggPSBldmVudC5jbGllbnRYO1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHR0aGlzLm1vdXNlTW92ZVN1YnNjcmlwdGlvbiA9IGZyb21FdmVudChkb2N1bWVudC5ib2R5LCBcIm1vdXNlbW92ZVwiKS5zdWJzY3JpYmUoZXZlbnQgPT4ge1xuXHRcdFx0dGhpcy5jb2x1bW5SZXNpemVQcm9ncmVzcyhldmVudCwgY29sdW1uKTtcblx0XHR9KTtcblx0XHR0aGlzLm1vdXNlVXBTdWJzY3JpcHRpb24gPSBmcm9tRXZlbnQoZG9jdW1lbnQuYm9keSwgXCJtb3VzZXVwXCIpLnN1YnNjcmliZShldmVudCA9PiB7XG5cdFx0XHR0aGlzLmNvbHVtblJlc2l6ZUVuZChldmVudCwgY29sdW1uKTtcblx0XHR9KTtcblx0fVxuXG5cdGNvbHVtblJlc2l6ZVByb2dyZXNzKGV2ZW50LCBjb2x1bW4pIHtcblx0XHRjb25zdCBtb3ZlID0gZXZlbnQuY2xpZW50WCAtIHRoaXMuY29sdW1uUmVzaXplTW91c2VYO1xuXHRcdGNvbHVtbi5zdHlsZS53aWR0aCA9IGAke3RoaXMuY29sdW1uUmVzaXplV2lkdGggKyBtb3ZlfXB4YDtcblx0fVxuXG5cdGNvbHVtblJlc2l6ZUVuZChldmVudCwgY29sdW1uKSB7XG5cdFx0dGhpcy5tb3VzZU1vdmVTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcblx0XHR0aGlzLm1vdXNlVXBTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBzY3JvbGxzIG9uIHRoZSBgPHRib2R5PmAgZWxlbWVudC5cblx0ICogRW1pdHMgdGhlIGBzY3JvbGxMb2FkYCBldmVudC5cblx0ICovXG5cdG9uU2Nyb2xsKGV2ZW50KSB7XG5cdFx0Y29uc3QgZGlzdGFuY2VGcm9tQm90dG9tID0gZXZlbnQudGFyZ2V0LnNjcm9sbEhlaWdodCAtIGV2ZW50LnRhcmdldC5jbGllbnRIZWlnaHQgLSBldmVudC50YXJnZXQuc2Nyb2xsVG9wO1xuXG5cdFx0aWYgKGRpc3RhbmNlRnJvbUJvdHRvbSA8PSB0aGlzLnNjcm9sbExvYWREaXN0YW5jZSkge1xuXHRcdFx0dGhpcy5zY3JvbGxMb2FkLmVtaXQodGhpcy5tb2RlbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubW9kZWwuaXNFbmQgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRjb2x1bW5EcmFnU3RhcnQoZXZlbnQsIGNvbHVtbkluZGV4KSB7XG5cdFx0dGhpcy5pc0NvbHVtbkRyYWdnaW5nID0gdHJ1ZTtcblx0XHR0aGlzLmNvbHVtbkRyYWdnZWRIb3ZlckluZGV4ID0gY29sdW1uSW5kZXg7XG5cdFx0ZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJjb2x1bW5JbmRleFwiLCBKU09OLnN0cmluZ2lmeShjb2x1bW5JbmRleCkpO1xuXHR9XG5cblx0Y29sdW1uRHJhZ0VuZChldmVudCwgY29sdW1uSW5kZXgpIHtcblx0XHR0aGlzLmlzQ29sdW1uRHJhZ2dpbmcgPSBmYWxzZTtcblx0XHR0aGlzLmNvbHVtbkRyYWdnZWRIb3ZlckluZGV4ID0gLTE7XG5cdH1cblxuXHRjb2x1bW5EcmFnRW50ZXIoZXZlbnQsIHBvc2l0aW9uLCBjb2x1bW5JbmRleCkge1xuXHRcdHRoaXMuY29sdW1uRHJhZ2dlZFBvc2l0aW9uID0gcG9zaXRpb247XG5cdFx0dGhpcy5jb2x1bW5EcmFnZ2VkSG92ZXJJbmRleCA9IGNvbHVtbkluZGV4O1xuXHR9XG5cblx0Y29sdW1uRHJhZ0xlYXZlKGV2ZW50LCBwb3NpdGlvbiwgY29sdW1uSW5kZXgpIHtcblx0XHR0aGlzLmNvbHVtbkRyYWdnZWRQb3NpdGlvbiA9IFwiXCI7XG5cdH1cblxuXHRjb2x1bW5EcmFnb3ZlcihldmVudCwgcG9zaXRpb24sIGNvbHVtbkluZGV4KSB7XG5cdFx0dGhpcy5jb2x1bW5EcmFnZ2VkSG92ZXJJbmRleCA9IGNvbHVtbkluZGV4O1xuXHRcdHRoaXMuY29sdW1uRHJhZ2dlZFBvc2l0aW9uID0gcG9zaXRpb247XG5cblx0XHQvLyBuZWVkZWQgdG8gdGVsbCBicm93c2VyIHRvIGFsbG93IGRyb3BwaW5nXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0fVxuXG5cdGNvbHVtbkRyb3AoZXZlbnQsIHBvc2l0aW9uLCBjb2x1bW5JbmRleCkge1xuXHRcdHRoaXMuaXNDb2x1bW5EcmFnZ2luZyA9IGZhbHNlO1xuXHRcdHRoaXMuY29sdW1uRHJhZ2dlZEhvdmVySW5kZXggPSAtMTtcblx0XHR0aGlzLmNvbHVtbkRyYWdnZWRQb3NpdGlvbiA9IFwiXCI7XG5cblx0XHR0aGlzLm1vZGVsLm1vdmVDb2x1bW4oXG5cdFx0XHRwYXJzZUludChldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcImNvbHVtbkluZGV4XCIpLCAxMCksXG5cdFx0XHRjb2x1bW5JbmRleCArIChwb3NpdGlvbiA9PT0gXCJyaWdodFwiID8gMSA6IDApXG5cdFx0KTtcblx0fVxuXG5cdGRvU29ydChpbmRleDogbnVtYmVyKSB7XG5cdFx0aWYgKHRoaXMuc29ydC5vYnNlcnZlcnMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHQvLyBubyBzb3J0IHByb3ZpZGVkIHNvIGRvIHRoZSBzaW1wbGUgc29ydFxuXHRcdFx0aWYgKHRoaXMubW9kZWwuaGVhZGVyW2luZGV4XS5zb3J0ZWQpIHtcblx0XHRcdFx0Ly8gaWYgYWxyZWFkeSBzb3J0ZWQgZmxpcCBzb3J0aW5nIGRpcmVjdGlvblxuXHRcdFx0XHR0aGlzLm1vZGVsLmhlYWRlcltpbmRleF0uYXNjZW5kaW5nID0gdGhpcy5tb2RlbC5oZWFkZXJbaW5kZXhdLmRlc2NlbmRpbmc7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLm1vZGVsLnNvcnQoaW5kZXgpO1xuXHRcdH1cblxuXHRcdHRoaXMuc29ydC5lbWl0KGluZGV4KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBzY3JvbGxzIG9uIHRoZSBgPHRib2R5PmAgZWxlbWVudC5cblx0ICogRW1pdHMgdGhlIGBzY3JvbGxMb2FkYCBldmVudC5cblx0ICovXG5cdHNjcm9sbFRvVG9wKGV2ZW50KSB7XG5cdFx0ZXZlbnQudGFyZ2V0LnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQuY2hpbGRyZW5bMV0uc2Nyb2xsVG9wID0gMDtcblx0XHR0aGlzLm1vZGVsLmlzRW5kID0gZmFsc2U7XG5cdH1cblxuXHRnZXRTZWxlY3Rpb25MYWJlbFZhbHVlKHJvdzogVGFibGVJdGVtW10pIHtcblx0XHRpZiAoIXRoaXMuc2VsZWN0aW9uTGFiZWxDb2x1bW4pIHtcblx0XHRcdHJldHVybiB7IHZhbHVlOiB0aGlzLmkxOG4uZ2V0KCkuVEFCTEUuUk9XIH07XG5cdFx0fVxuXHRcdHJldHVybiB7IHZhbHVlOiByb3dbdGhpcy5zZWxlY3Rpb25MYWJlbENvbHVtbl0uZGF0YSB9O1xuXHR9XG5cblx0Z2V0RXhwYW5kQnV0dG9uQXJpYUxhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLl9leHBhbmRCdXR0b25BcmlhTGFiZWwuc3ViamVjdDtcblx0fVxuXHRnZXRTb3J0RGVzY2VuZGluZ0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLl9zb3J0RGVzY2VuZGluZ0xhYmVsLnN1YmplY3Q7XG5cdH1cblx0Z2V0U29ydEFzY2VuZGluZ0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLl9zb3J0QXNjZW5kaW5nTGFiZWwuc3ViamVjdDtcblx0fVxuXG5cdGdldENoZWNrYm94SGVhZGVyTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoZWNrYm94SGVhZGVyTGFiZWwuc3ViamVjdDtcblx0fVxuXG5cdGdldENoZWNrYm94Um93TGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoZWNrYm94Um93TGFiZWwuc3ViamVjdDtcblx0fVxuXG5cdGdldEVuZE9mRGF0YVRleHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2VuZE9mRGF0YVRleHQuc3ViamVjdDtcblx0fVxuXG5cdGdldFNjcm9sbFRvcFRleHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Njcm9sbFRvcFRleHQuc3ViamVjdDtcblx0fVxuXG5cdGdldEZpbHRlclRpdGxlKCkge1xuXHRcdHJldHVybiB0aGlzLl9maWx0ZXJUaXRsZS5zdWJqZWN0O1xuXHR9XG59XG4iXX0=