/**
 *
 * carbon-angular v0.0.0 | table-head-cell.component.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Component, Input, Output, EventEmitter, HostBinding } from "@angular/core";
import { I18n } from "carbon-components-angular/i18n";
import { map } from "rxjs/operators";
import { TableHeaderItem } from "../table-header-item.class";
export class TableHeadCell {
    constructor(i18n) {
        this.i18n = i18n;
        this.skeleton = false;
        this.sortable = true;
        /**
         * Notifies that the column should be sorted
         */
        this.sort = new EventEmitter();
        this.theadAction = false;
        this._sortDescendingLabel = this.i18n.getOverridable("TABLE.SORT_DESCENDING");
        this._sortAscendingLabel = this.i18n.getOverridable("TABLE.SORT_ASCENDING");
        this._filterTitle = this.i18n.getOverridable("TABLE.FILTER");
    }
    set sortDescendingLabel(value) {
        this._sortDescendingLabel.override(value);
    }
    get sortDescendingLabel() {
        return this._sortDescendingLabel.value;
    }
    set sortAscendingLabel(value) {
        this._sortAscendingLabel.override(value);
    }
    get sortAscendingLabel() {
        return this._sortAscendingLabel.value;
    }
    set filterTitle(value) {
        this._filterTitle.override(value);
    }
    get filterTitle() {
        return this._filterTitle.value;
    }
    ngOnChanges() {
        // Since it's not an input, and it touches the view, we're using `ngOnChanges`
        // `get`ters have caused issues in the past with the view updating outside of change detection
        this.theadAction = !!this.column.filterTemplate || this.sort.observers.length > 0;
    }
    getSortDescendingLabel() {
        return this._sortDescendingLabel.subject.pipe(this.sortLabelMap());
    }
    getSortAscendingLabel() {
        return this._sortAscendingLabel.subject.pipe(this.sortLabelMap());
    }
    getFilterTitle() {
        return this._filterTitle.subject;
    }
    onClick() {
        if (!this.skeleton) {
            this.sort.emit();
        }
    }
    sortLabelMap() {
        return map((str) => {
            if (this.column.ariaSortLabel) {
                return this.column.ariaSortLabel;
            }
            if (this.column.formatSortLabel) {
                return this.column.formatSortLabel(str, this.column.ariaSortLabel);
            }
            return `${this.column.data} - ${str}`;
        });
    }
}
TableHeadCell.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line: component-selector
                selector: "[ibmTableHeadCell]",
                template: `
		<button
			class="bx--table-sort"
			*ngIf="sortable && this.sort.observers.length > 0 && column.sortable"
			[attr.aria-label]="(column.sorted && column.ascending ? getSortDescendingLabel() : getSortAscendingLabel()) | async"
			aria-live="polite"
			[ngClass]="{
				'bx--table-sort--active': column.sorted,
				'bx--table-sort--ascending': column.ascending
			}"
			(click)="onClick()">
			<span
				class="bx--table-sort__flex"
				[title]="column.data"
				tabindex="-1">
				<div *ngIf="!skeleton && !column.template" ibmTableHeadCellLabel>
					{{column.data}}
				</div>
				<ng-template
					*ngIf="!skeleton && column.template"
					[ngTemplateOutlet]="column.template"
					[ngTemplateOutletContext]="{data: column.data}">
				</ng-template>
				<svg
					*ngIf="!skeleton"
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					style="will-change: transform;"
					xmlns="http://www.w3.org/2000/svg"
					class="bx--table-sort__icon"
					width="16"
					height="16"
					viewBox="0 0 16 16"
					aria-hidden="true">
					<path d="M12.3 9.3l-3.8 3.8V1h-1v12.1L3.7 9.3 3 10l5 5 5-5z"></path>
				</svg>
				<svg
					*ngIf="!skeleton"
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					style="will-change: transform;"
					xmlns="http://www.w3.org/2000/svg"
					class="bx--table-sort__icon-unsorted"
					width="16"
					height="16"
					viewBox="0 0 16 16"
					aria-hidden="true">
					<path d="M13.8 10.3L12 12.1V2h-1v10.1l-1.8-1.8-.7.7 3 3 3-3zM4.5 2l-3 3 .7.7L4 3.9V14h1V3.9l1.8 1.8.7-.7z"></path>
				</svg>
			</span>
		</button>
		<div
			class="bx--table-header-label"
			*ngIf="!skeleton && this.sort.observers.length === 0 || (this.sort.observers.length > 0 && !column.sortable) || !sortable">
			<span *ngIf="!column.template" [title]="column.data">{{column.data}}</span>
			<ng-template
				[ngTemplateOutlet]="column.template" [ngTemplateOutletContext]="{data: column.data}">
			</ng-template>
		</div>
		<button
			[ngClass]="{'active': column.filterCount > 0}"
			*ngIf="column.filterTemplate"
			type="button"
			aria-expanded="false"
			aria-haspopup="true"
			[ibmTooltip]="column.filterTemplate"
			trigger="click"
			[title]="getFilterTitle() | async"
			placement="bottom,top"
			[data]="column.filterData">
			<svg
				xmlns="http://www.w3.org/2000/svg"
				class="icon--sm"
				width="16"
				height="16"
				viewBox="0 0 16 16">
				<path d="M0 0v3l6 8v5h4v-5l6-8V0H0zm9 10.7V15H7v-4.3L1.3 3h13.5L9 10.7z"/>
			</svg>
			<span *ngIf="column.filterCount > 0">
				{{column.filterCount}}
			</span>
		</button>
	`
            }] }
];
/** @nocollapse */
TableHeadCell.ctorParameters = () => [
    { type: I18n }
];
TableHeadCell.propDecorators = {
    column: [{ type: Input }],
    skeleton: [{ type: Input }],
    sortable: [{ type: Input }],
    sortDescendingLabel: [{ type: Input }],
    sortAscendingLabel: [{ type: Input }],
    filterTitle: [{ type: Input }],
    sort: [{ type: Output }],
    theadAction: [{ type: HostBinding, args: ["class.thead_action",] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUtaGVhZC1jZWxsLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvdGFibGUvIiwic291cmNlcyI6WyJoZWFkL3RhYmxlLWhlYWQtY2VsbC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNOLFNBQVMsRUFDVCxLQUFLLEVBQ0wsTUFBTSxFQUNOLFlBQVksRUFDWixXQUFXLEVBRVgsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLElBQUksRUFBZSxNQUFNLGdDQUFnQyxDQUFDO0FBQ25FLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNyQyxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUF5RjdELE1BQU0sT0FBTyxhQUFhO0lBNkN6QixZQUFzQixJQUFVO1FBQVYsU0FBSSxHQUFKLElBQUksQ0FBTTtRQTFDdkIsYUFBUSxHQUFHLEtBQUssQ0FBQztRQUVqQixhQUFRLEdBQUcsSUFBSSxDQUFDO1FBNkJ6Qjs7V0FFRztRQUNPLFNBQUksR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBRUQsZ0JBQVcsR0FBRyxLQUFLLENBQUM7UUFFN0MseUJBQW9CLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsdUJBQXVCLENBQUMsQ0FBQztRQUN6RSx3QkFBbUIsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1FBQ3ZFLGlCQUFZLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLENBQUM7SUFFOUIsQ0FBQztJQXRDckMsSUFDSSxtQkFBbUIsQ0FBQyxLQUFrQztRQUN6RCxJQUFJLENBQUMsb0JBQW9CLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFRCxJQUFJLG1CQUFtQjtRQUN0QixPQUFPLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLENBQUM7SUFDeEMsQ0FBQztJQUVELElBQ0ksa0JBQWtCLENBQUMsS0FBa0M7UUFDeEQsSUFBSSxDQUFDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRUQsSUFBSSxrQkFBa0I7UUFDckIsT0FBTyxJQUFJLENBQUMsbUJBQW1CLENBQUMsS0FBSyxDQUFDO0lBQ3ZDLENBQUM7SUFFRCxJQUNJLFdBQVcsQ0FBQyxLQUFrQztRQUNqRCxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNuQyxDQUFDO0lBRUQsSUFBSSxXQUFXO1FBQ2QsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQztJQUNoQyxDQUFDO0lBZUQsV0FBVztRQUNWLDhFQUE4RTtRQUM5RSw4RkFBOEY7UUFDOUYsSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztJQUNuRixDQUFDO0lBRUQsc0JBQXNCO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUM7SUFDcEUsQ0FBQztJQUVELHFCQUFxQjtRQUNwQixPQUFPLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDO0lBQ25FLENBQUM7SUFFRCxjQUFjO1FBQ2IsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQztJQUNsQyxDQUFDO0lBRUQsT0FBTztRQUNOLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ25CLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7U0FDakI7SUFDRixDQUFDO0lBRVMsWUFBWTtRQUNyQixPQUFPLEdBQUcsQ0FBQyxDQUFDLEdBQVcsRUFBRSxFQUFFO1lBQzFCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLEVBQUU7Z0JBQzlCLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUM7YUFDakM7WUFDRCxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxFQUFFO2dCQUNoQyxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDO2FBQ25FO1lBQ0QsT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDO1FBQ3ZDLENBQUMsQ0FBQyxDQUFDO0lBQ0osQ0FBQzs7O1lBeEtELFNBQVMsU0FBQztnQkFDViwrQ0FBK0M7Z0JBQy9DLFFBQVEsRUFBRSxvQkFBb0I7Z0JBQzlCLFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQWtGVDthQUNEOzs7O1lBMUZRLElBQUk7OztxQkE0RlgsS0FBSzt1QkFFTCxLQUFLO3VCQUVMLEtBQUs7a0NBRUwsS0FBSztpQ0FTTCxLQUFLOzBCQVNMLEtBQUs7bUJBWUwsTUFBTTswQkFFTixXQUFXLFNBQUMsb0JBQW9CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0Q29tcG9uZW50LFxuXHRJbnB1dCxcblx0T3V0cHV0LFxuXHRFdmVudEVtaXR0ZXIsXG5cdEhvc3RCaW5kaW5nLFxuXHRPbkNoYW5nZXNcbn0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IE9ic2VydmFibGUsIE9wZXJhdG9yRnVuY3Rpb24gfSBmcm9tIFwicnhqc1wiO1xuaW1wb3J0IHsgSTE4biwgT3ZlcnJpZGFibGUgfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9pMThuXCI7XG5pbXBvcnQgeyBtYXAgfSBmcm9tIFwicnhqcy9vcGVyYXRvcnNcIjtcbmltcG9ydCB7IFRhYmxlSGVhZGVySXRlbSB9IGZyb20gXCIuLi90YWJsZS1oZWFkZXItaXRlbS5jbGFzc1wiO1xuXG5AQ29tcG9uZW50KHtcblx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBjb21wb25lbnQtc2VsZWN0b3Jcblx0c2VsZWN0b3I6IFwiW2libVRhYmxlSGVhZENlbGxdXCIsXG5cdHRlbXBsYXRlOiBgXG5cdFx0PGJ1dHRvblxuXHRcdFx0Y2xhc3M9XCJieC0tdGFibGUtc29ydFwiXG5cdFx0XHQqbmdJZj1cInNvcnRhYmxlICYmIHRoaXMuc29ydC5vYnNlcnZlcnMubGVuZ3RoID4gMCAmJiBjb2x1bW4uc29ydGFibGVcIlxuXHRcdFx0W2F0dHIuYXJpYS1sYWJlbF09XCIoY29sdW1uLnNvcnRlZCAmJiBjb2x1bW4uYXNjZW5kaW5nID8gZ2V0U29ydERlc2NlbmRpbmdMYWJlbCgpIDogZ2V0U29ydEFzY2VuZGluZ0xhYmVsKCkpIHwgYXN5bmNcIlxuXHRcdFx0YXJpYS1saXZlPVwicG9saXRlXCJcblx0XHRcdFtuZ0NsYXNzXT1cIntcblx0XHRcdFx0J2J4LS10YWJsZS1zb3J0LS1hY3RpdmUnOiBjb2x1bW4uc29ydGVkLFxuXHRcdFx0XHQnYngtLXRhYmxlLXNvcnQtLWFzY2VuZGluZyc6IGNvbHVtbi5hc2NlbmRpbmdcblx0XHRcdH1cIlxuXHRcdFx0KGNsaWNrKT1cIm9uQ2xpY2soKVwiPlxuXHRcdFx0PHNwYW5cblx0XHRcdFx0Y2xhc3M9XCJieC0tdGFibGUtc29ydF9fZmxleFwiXG5cdFx0XHRcdFt0aXRsZV09XCJjb2x1bW4uZGF0YVwiXG5cdFx0XHRcdHRhYmluZGV4PVwiLTFcIj5cblx0XHRcdFx0PGRpdiAqbmdJZj1cIiFza2VsZXRvbiAmJiAhY29sdW1uLnRlbXBsYXRlXCIgaWJtVGFibGVIZWFkQ2VsbExhYmVsPlxuXHRcdFx0XHRcdHt7Y29sdW1uLmRhdGF9fVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PG5nLXRlbXBsYXRlXG5cdFx0XHRcdFx0Km5nSWY9XCIhc2tlbGV0b24gJiYgY29sdW1uLnRlbXBsYXRlXCJcblx0XHRcdFx0XHRbbmdUZW1wbGF0ZU91dGxldF09XCJjb2x1bW4udGVtcGxhdGVcIlxuXHRcdFx0XHRcdFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7ZGF0YTogY29sdW1uLmRhdGF9XCI+XG5cdFx0XHRcdDwvbmctdGVtcGxhdGU+XG5cdFx0XHRcdDxzdmdcblx0XHRcdFx0XHQqbmdJZj1cIiFza2VsZXRvblwiXG5cdFx0XHRcdFx0Zm9jdXNhYmxlPVwiZmFsc2VcIlxuXHRcdFx0XHRcdHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWlkWU1pZCBtZWV0XCJcblx0XHRcdFx0XHRzdHlsZT1cIndpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XCJcblx0XHRcdFx0XHR4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcblx0XHRcdFx0XHRjbGFzcz1cImJ4LS10YWJsZS1zb3J0X19pY29uXCJcblx0XHRcdFx0XHR3aWR0aD1cIjE2XCJcblx0XHRcdFx0XHRoZWlnaHQ9XCIxNlwiXG5cdFx0XHRcdFx0dmlld0JveD1cIjAgMCAxNiAxNlwiXG5cdFx0XHRcdFx0YXJpYS1oaWRkZW49XCJ0cnVlXCI+XG5cdFx0XHRcdFx0PHBhdGggZD1cIk0xMi4zIDkuM2wtMy44IDMuOFYxaC0xdjEyLjFMMy43IDkuMyAzIDEwbDUgNSA1LTV6XCI+PC9wYXRoPlxuXHRcdFx0XHQ8L3N2Zz5cblx0XHRcdFx0PHN2Z1xuXHRcdFx0XHRcdCpuZ0lmPVwiIXNrZWxldG9uXCJcblx0XHRcdFx0XHRmb2N1c2FibGU9XCJmYWxzZVwiXG5cdFx0XHRcdFx0cHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaWRZTWlkIG1lZXRcIlxuXHRcdFx0XHRcdHN0eWxlPVwid2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcIlxuXHRcdFx0XHRcdHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuXHRcdFx0XHRcdGNsYXNzPVwiYngtLXRhYmxlLXNvcnRfX2ljb24tdW5zb3J0ZWRcIlxuXHRcdFx0XHRcdHdpZHRoPVwiMTZcIlxuXHRcdFx0XHRcdGhlaWdodD1cIjE2XCJcblx0XHRcdFx0XHR2aWV3Qm94PVwiMCAwIDE2IDE2XCJcblx0XHRcdFx0XHRhcmlhLWhpZGRlbj1cInRydWVcIj5cblx0XHRcdFx0XHQ8cGF0aCBkPVwiTTEzLjggMTAuM0wxMiAxMi4xVjJoLTF2MTAuMWwtMS44LTEuOC0uNy43IDMgMyAzLTN6TTQuNSAybC0zIDMgLjcuN0w0IDMuOVYxNGgxVjMuOWwxLjggMS44LjctLjd6XCI+PC9wYXRoPlxuXHRcdFx0XHQ8L3N2Zz5cblx0XHRcdDwvc3Bhbj5cblx0XHQ8L2J1dHRvbj5cblx0XHQ8ZGl2XG5cdFx0XHRjbGFzcz1cImJ4LS10YWJsZS1oZWFkZXItbGFiZWxcIlxuXHRcdFx0Km5nSWY9XCIhc2tlbGV0b24gJiYgdGhpcy5zb3J0Lm9ic2VydmVycy5sZW5ndGggPT09IDAgfHwgKHRoaXMuc29ydC5vYnNlcnZlcnMubGVuZ3RoID4gMCAmJiAhY29sdW1uLnNvcnRhYmxlKSB8fCAhc29ydGFibGVcIj5cblx0XHRcdDxzcGFuICpuZ0lmPVwiIWNvbHVtbi50ZW1wbGF0ZVwiIFt0aXRsZV09XCJjb2x1bW4uZGF0YVwiPnt7Y29sdW1uLmRhdGF9fTwvc3Bhbj5cblx0XHRcdDxuZy10ZW1wbGF0ZVxuXHRcdFx0XHRbbmdUZW1wbGF0ZU91dGxldF09XCJjb2x1bW4udGVtcGxhdGVcIiBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwie2RhdGE6IGNvbHVtbi5kYXRhfVwiPlxuXHRcdFx0PC9uZy10ZW1wbGF0ZT5cblx0XHQ8L2Rpdj5cblx0XHQ8YnV0dG9uXG5cdFx0XHRbbmdDbGFzc109XCJ7J2FjdGl2ZSc6IGNvbHVtbi5maWx0ZXJDb3VudCA+IDB9XCJcblx0XHRcdCpuZ0lmPVwiY29sdW1uLmZpbHRlclRlbXBsYXRlXCJcblx0XHRcdHR5cGU9XCJidXR0b25cIlxuXHRcdFx0YXJpYS1leHBhbmRlZD1cImZhbHNlXCJcblx0XHRcdGFyaWEtaGFzcG9wdXA9XCJ0cnVlXCJcblx0XHRcdFtpYm1Ub29sdGlwXT1cImNvbHVtbi5maWx0ZXJUZW1wbGF0ZVwiXG5cdFx0XHR0cmlnZ2VyPVwiY2xpY2tcIlxuXHRcdFx0W3RpdGxlXT1cImdldEZpbHRlclRpdGxlKCkgfCBhc3luY1wiXG5cdFx0XHRwbGFjZW1lbnQ9XCJib3R0b20sdG9wXCJcblx0XHRcdFtkYXRhXT1cImNvbHVtbi5maWx0ZXJEYXRhXCI+XG5cdFx0XHQ8c3ZnXG5cdFx0XHRcdHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuXHRcdFx0XHRjbGFzcz1cImljb24tLXNtXCJcblx0XHRcdFx0d2lkdGg9XCIxNlwiXG5cdFx0XHRcdGhlaWdodD1cIjE2XCJcblx0XHRcdFx0dmlld0JveD1cIjAgMCAxNiAxNlwiPlxuXHRcdFx0XHQ8cGF0aCBkPVwiTTAgMHYzbDYgOHY1aDR2LTVsNi04VjBIMHptOSAxMC43VjE1SDd2LTQuM0wxLjMgM2gxMy41TDkgMTAuN3pcIi8+XG5cdFx0XHQ8L3N2Zz5cblx0XHRcdDxzcGFuICpuZ0lmPVwiY29sdW1uLmZpbHRlckNvdW50ID4gMFwiPlxuXHRcdFx0XHR7e2NvbHVtbi5maWx0ZXJDb3VudH19XG5cdFx0XHQ8L3NwYW4+XG5cdFx0PC9idXR0b24+XG5cdGBcbn0pXG5leHBvcnQgY2xhc3MgVGFibGVIZWFkQ2VsbCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG5cdEBJbnB1dCgpIGNvbHVtbjogVGFibGVIZWFkZXJJdGVtO1xuXG5cdEBJbnB1dCgpIHNrZWxldG9uID0gZmFsc2U7XG5cblx0QElucHV0KCkgc29ydGFibGUgPSB0cnVlO1xuXG5cdEBJbnB1dCgpXG5cdHNldCBzb3J0RGVzY2VuZGluZ0xhYmVsKHZhbHVlOiBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz4pIHtcblx0XHR0aGlzLl9zb3J0RGVzY2VuZGluZ0xhYmVsLm92ZXJyaWRlKHZhbHVlKTtcblx0fVxuXG5cdGdldCBzb3J0RGVzY2VuZGluZ0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLl9zb3J0RGVzY2VuZGluZ0xhYmVsLnZhbHVlO1xuXHR9XG5cblx0QElucHV0KClcblx0c2V0IHNvcnRBc2NlbmRpbmdMYWJlbCh2YWx1ZTogc3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+KSB7XG5cdFx0dGhpcy5fc29ydEFzY2VuZGluZ0xhYmVsLm92ZXJyaWRlKHZhbHVlKTtcblx0fVxuXG5cdGdldCBzb3J0QXNjZW5kaW5nTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NvcnRBc2NlbmRpbmdMYWJlbC52YWx1ZTtcblx0fVxuXG5cdEBJbnB1dCgpXG5cdHNldCBmaWx0ZXJUaXRsZSh2YWx1ZTogc3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+KSB7XG5cdFx0dGhpcy5fZmlsdGVyVGl0bGUub3ZlcnJpZGUodmFsdWUpO1xuXHR9XG5cblx0Z2V0IGZpbHRlclRpdGxlKCkge1xuXHRcdHJldHVybiB0aGlzLl9maWx0ZXJUaXRsZS52YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBOb3RpZmllcyB0aGF0IHRoZSBjb2x1bW4gc2hvdWxkIGJlIHNvcnRlZFxuXHQgKi9cblx0QE91dHB1dCgpIHNvcnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblx0QEhvc3RCaW5kaW5nKFwiY2xhc3MudGhlYWRfYWN0aW9uXCIpIHRoZWFkQWN0aW9uID0gZmFsc2U7XG5cblx0cHJvdGVjdGVkIF9zb3J0RGVzY2VuZGluZ0xhYmVsID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuU09SVF9ERVNDRU5ESU5HXCIpO1xuXHRwcm90ZWN0ZWQgX3NvcnRBc2NlbmRpbmdMYWJlbCA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlRBQkxFLlNPUlRfQVNDRU5ESU5HXCIpO1xuXHRwcm90ZWN0ZWQgX2ZpbHRlclRpdGxlID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuRklMVEVSXCIpO1xuXG5cdGNvbnN0cnVjdG9yKHByb3RlY3RlZCBpMThuOiBJMThuKSB7IH1cblxuXHRuZ09uQ2hhbmdlcygpIHtcblx0XHQvLyBTaW5jZSBpdCdzIG5vdCBhbiBpbnB1dCwgYW5kIGl0IHRvdWNoZXMgdGhlIHZpZXcsIHdlJ3JlIHVzaW5nIGBuZ09uQ2hhbmdlc2Bcblx0XHQvLyBgZ2V0YHRlcnMgaGF2ZSBjYXVzZWQgaXNzdWVzIGluIHRoZSBwYXN0IHdpdGggdGhlIHZpZXcgdXBkYXRpbmcgb3V0c2lkZSBvZiBjaGFuZ2UgZGV0ZWN0aW9uXG5cdFx0dGhpcy50aGVhZEFjdGlvbiA9ICEhdGhpcy5jb2x1bW4uZmlsdGVyVGVtcGxhdGUgfHwgdGhpcy5zb3J0Lm9ic2VydmVycy5sZW5ndGggPiAwO1xuXHR9XG5cblx0Z2V0U29ydERlc2NlbmRpbmdMYWJlbCgpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuXHRcdHJldHVybiB0aGlzLl9zb3J0RGVzY2VuZGluZ0xhYmVsLnN1YmplY3QucGlwZSh0aGlzLnNvcnRMYWJlbE1hcCgpKTtcblx0fVxuXG5cdGdldFNvcnRBc2NlbmRpbmdMYWJlbCgpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuXHRcdHJldHVybiB0aGlzLl9zb3J0QXNjZW5kaW5nTGFiZWwuc3ViamVjdC5waXBlKHRoaXMuc29ydExhYmVsTWFwKCkpO1xuXHR9XG5cblx0Z2V0RmlsdGVyVGl0bGUoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcblx0XHRyZXR1cm4gdGhpcy5fZmlsdGVyVGl0bGUuc3ViamVjdDtcblx0fVxuXG5cdG9uQ2xpY2soKSB7XG5cdFx0aWYgKCF0aGlzLnNrZWxldG9uKSB7XG5cdFx0XHR0aGlzLnNvcnQuZW1pdCgpO1xuXHRcdH1cblx0fVxuXG5cdHByb3RlY3RlZCBzb3J0TGFiZWxNYXAoKTogT3BlcmF0b3JGdW5jdGlvbjxzdHJpbmcsIHN0cmluZz4ge1xuXHRcdHJldHVybiBtYXAoKHN0cjogc3RyaW5nKSA9PiB7XG5cdFx0XHRpZiAodGhpcy5jb2x1bW4uYXJpYVNvcnRMYWJlbCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb2x1bW4uYXJpYVNvcnRMYWJlbDtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLmNvbHVtbi5mb3JtYXRTb3J0TGFiZWwpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29sdW1uLmZvcm1hdFNvcnRMYWJlbChzdHIsIHRoaXMuY29sdW1uLmFyaWFTb3J0TGFiZWwpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGAke3RoaXMuY29sdW1uLmRhdGF9IC0gJHtzdHJ9YDtcblx0XHR9KTtcblx0fVxufVxuIl19