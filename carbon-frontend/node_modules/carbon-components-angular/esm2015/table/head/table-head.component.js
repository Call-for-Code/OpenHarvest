/**
 *
 * carbon-angular v0.0.0 | table-head.component.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Component, Input, Output, EventEmitter } from "@angular/core";
import { TableModel } from "../table-model.class";
import { getScrollbarWidth } from "carbon-components-angular/utils";
import { I18n } from "carbon-components-angular/i18n";
/**
 * A subcomponent that creates the thead of the table
 *
 * ## Basic usage
 *
 * ```html
 * 	<thead ibmTableHead [model]="model"></thead>
 * ```
 */
export class TableHead {
    constructor(i18n) {
        this.i18n = i18n;
        this.showSelectionColumn = true;
        this.enableSingleSelect = false;
        this.selectAllCheckboxSomeSelected = false;
        this.selectAllCheckbox = false;
        this.skeleton = false;
        this.stickyHeader = false;
        /**
         * Setting sortable to false will disable all headers including headers which are sortable. Is is
         * possible to set the sortable state on the header item to disable/enable sorting for only some headers.
         */
        this.sortable = true;
        /**
         * Size of the table rows.
         */
        this.size = "md";
        /**
         * Emits an index of the column that wants to be sorted.
         */
        this.sort = new EventEmitter();
        /**
         * Emits if all rows are selected.
         *
         * @param model
         */
        this.selectAll = new EventEmitter();
        /**
         * Emits if all rows are deselected.
         *
         * @param model
         */
        this.deselectAll = new EventEmitter();
        this.scrollbarWidth = 0;
        this._checkboxHeaderLabel = this.i18n.getOverridable("TABLE.CHECKBOX_HEADER");
        this._sortDescendingLabel = this.i18n.getOverridable("TABLE.SORT_DESCENDING");
        this._sortAscendingLabel = this.i18n.getOverridable("TABLE.SORT_ASCENDING");
        this._filterTitle = this.i18n.getOverridable("TABLE.FILTER");
    }
    set checkboxHeaderLabel(value) {
        this._checkboxHeaderLabel.override(value);
    }
    get checkboxHeaderLabel() {
        return this._checkboxHeaderLabel.value;
    }
    set sortDescendingLabel(value) {
        this._sortDescendingLabel.override(value);
    }
    get sortDescendingLabel() {
        return this._sortDescendingLabel.value;
    }
    set sortAscendingLabel(value) {
        this._sortAscendingLabel.override(value);
    }
    get sortAscendingLabel() {
        return this._sortAscendingLabel.value;
    }
    set filterTitle(value) {
        this._filterTitle.override(value);
    }
    get filterTitle() {
        return this._filterTitle.value;
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.scrollbarWidth = getScrollbarWidth();
        });
    }
    onSelectAllCheckboxChange() {
        if (!this.selectAllCheckbox && !this.selectAllCheckboxSomeSelected) {
            this.selectAll.emit(this.model);
        }
        else {
            this.deselectAll.emit(this.model);
        }
    }
    getCheckboxHeaderLabel() {
        return this._checkboxHeaderLabel.subject;
    }
    getSortDescendingLabel() {
        return this._sortDescendingLabel.subject;
    }
    getSortAscendingLabel() {
        return this._sortAscendingLabel.subject;
    }
    getFilterTitle() {
        return this._filterTitle.subject;
    }
}
TableHead.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: "[ibmTableHead]",
                template: `
	<ng-container *ngIf="model">
		<tr>
			<th
				ibmTableHeadExpand
				*ngIf="model.hasExpandableRows()"
				scope="col"
				[ngClass]="{'bx--table-expand-v2': stickyHeader}"
				[id]="model.getId('expand')">
			</th>
			<th
				*ngIf="!skeleton && showSelectionColumn && enableSingleSelect"
				scope="col"
				style="width: 0;"
				[id]="model.getId('select')">
				<!-- add width 0; since the carbon styles don't seem to constrain this headers width -->
			</th>
			<th
				ibmTableHeadCheckbox
				*ngIf="!skeleton && showSelectionColumn && !enableSingleSelect"
				scope="col"
				[checked]="selectAllCheckbox"
				[indeterminate]="selectAllCheckboxSomeSelected"
				[ariaLabel]="getCheckboxHeaderLabel()"
				[size]="size"
				[skeleton]="skeleton"
				[name]="model.getHeaderId('select')"
				(change)="onSelectAllCheckboxChange()"
				[id]="model.getId('select')">
			</th>
			<ng-container *ngFor="let column of model.header; let i = index">
				<th
					*ngIf="column && column.visible"
					[ngStyle]="column.style"
					ibmTableHeadCell
					scope="col"
					[class]="column.className"
					[sortable]="sortable"
					[skeleton]="skeleton"
					[id]="model.getId(i)"
					[column]="column"
					[skeleton]="skeleton"
					[filterTitle]="getFilterTitle()"
					[attr.colspan]="column.colSpan"
					[attr.rowspan]="column.rowSpan"
					(sort)="sort.emit(i)">
				</th>
			</ng-container>
			<th *ngIf="!skeleton && stickyHeader && scrollbarWidth"
				scope="col"
				[ngStyle]="{'width': scrollbarWidth + 'px', 'padding': 0, 'border': 0}">
				<!--
					Scrollbar pushes body to the left so this header column is added to push
					the title bar the same amount and keep the header and body columns aligned.
				-->
			</th>
		</tr>
	</ng-container>
	<ng-content></ng-content>
	`,
                styles: [`
		.bx--table-expand-v2 {
			padding-left: 2.5rem;
		}
	`]
            }] }
];
/** @nocollapse */
TableHead.ctorParameters = () => [
    { type: I18n }
];
TableHead.propDecorators = {
    model: [{ type: Input }],
    showSelectionColumn: [{ type: Input }],
    enableSingleSelect: [{ type: Input }],
    selectAllCheckboxSomeSelected: [{ type: Input }],
    selectAllCheckbox: [{ type: Input }],
    skeleton: [{ type: Input }],
    stickyHeader: [{ type: Input }],
    sortable: [{ type: Input }],
    size: [{ type: Input }],
    checkboxHeaderLabel: [{ type: Input }],
    sortDescendingLabel: [{ type: Input }],
    sortAscendingLabel: [{ type: Input }],
    filterTitle: [{ type: Input }],
    sort: [{ type: Output }],
    selectAll: [{ type: Output }],
    deselectAll: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUtaGVhZC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL3RhYmxlLyIsInNvdXJjZXMiOlsiaGVhZC90YWJsZS1oZWFkLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUVaLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNsRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUNwRSxPQUFPLEVBQUUsSUFBSSxFQUFlLE1BQU0sZ0NBQWdDLENBQUM7QUFJbkU7Ozs7Ozs7O0dBUUc7QUFzRUgsTUFBTSxPQUFPLFNBQVM7SUFzRnJCLFlBQXNCLElBQVU7UUFBVixTQUFJLEdBQUosSUFBSSxDQUFNO1FBbkZ2Qix3QkFBbUIsR0FBRyxJQUFJLENBQUM7UUFFM0IsdUJBQWtCLEdBQUcsS0FBSyxDQUFDO1FBRTNCLGtDQUE2QixHQUFHLEtBQUssQ0FBQztRQUV0QyxzQkFBaUIsR0FBRyxLQUFLLENBQUM7UUFFMUIsYUFBUSxHQUFHLEtBQUssQ0FBQztRQUVqQixpQkFBWSxHQUFHLEtBQUssQ0FBQztRQUU5Qjs7O1dBR0c7UUFDTSxhQUFRLEdBQUcsSUFBSSxDQUFDO1FBRXpCOztXQUVHO1FBQ00sU0FBSSxHQUFpQixJQUFJLENBQUM7UUFzQ25DOztXQUVHO1FBQ08sU0FBSSxHQUFHLElBQUksWUFBWSxFQUFVLENBQUM7UUFDNUM7Ozs7V0FJRztRQUNPLGNBQVMsR0FBRyxJQUFJLFlBQVksRUFBYyxDQUFDO1FBQ3JEOzs7O1dBSUc7UUFDTyxnQkFBVyxHQUFHLElBQUksWUFBWSxFQUFjLENBQUM7UUFFaEQsbUJBQWMsR0FBRyxDQUFDLENBQUM7UUFFaEIseUJBQW9CLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FB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TixNQUFNOzBCQU1OLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRDb21wb25lbnQsXG5cdElucHV0LFxuXHRPdXRwdXQsXG5cdEV2ZW50RW1pdHRlcixcblx0QWZ0ZXJWaWV3SW5pdFxufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuXG5pbXBvcnQgeyBUYWJsZU1vZGVsIH0gZnJvbSBcIi4uL3RhYmxlLW1vZGVsLmNsYXNzXCI7XG5pbXBvcnQgeyBnZXRTY3JvbGxiYXJXaWR0aCB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL3V0aWxzXCI7XG5pbXBvcnQgeyBJMThuLCBPdmVycmlkYWJsZSB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2kxOG5cIjtcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tIFwicnhqc1wiO1xuaW1wb3J0IHsgVGFibGVSb3dTaXplIH0gZnJvbSBcIi4uL3RhYmxlLnR5cGVzXCI7XG5cbi8qKlxuICogQSBzdWJjb21wb25lbnQgdGhhdCBjcmVhdGVzIHRoZSB0aGVhZCBvZiB0aGUgdGFibGVcbiAqXG4gKiAjIyBCYXNpYyB1c2FnZVxuICpcbiAqIGBgYGh0bWxcbiAqIFx0PHRoZWFkIGlibVRhYmxlSGVhZCBbbW9kZWxdPVwibW9kZWxcIj48L3RoZWFkPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuXHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6Y29tcG9uZW50LXNlbGVjdG9yXG5cdHNlbGVjdG9yOiBcIltpYm1UYWJsZUhlYWRdXCIsXG5cdHRlbXBsYXRlOiBgXG5cdDxuZy1jb250YWluZXIgKm5nSWY9XCJtb2RlbFwiPlxuXHRcdDx0cj5cblx0XHRcdDx0aFxuXHRcdFx0XHRpYm1UYWJsZUhlYWRFeHBhbmRcblx0XHRcdFx0Km5nSWY9XCJtb2RlbC5oYXNFeHBhbmRhYmxlUm93cygpXCJcblx0XHRcdFx0c2NvcGU9XCJjb2xcIlxuXHRcdFx0XHRbbmdDbGFzc109XCJ7J2J4LS10YWJsZS1leHBhbmQtdjInOiBzdGlja3lIZWFkZXJ9XCJcblx0XHRcdFx0W2lkXT1cIm1vZGVsLmdldElkKCdleHBhbmQnKVwiPlxuXHRcdFx0PC90aD5cblx0XHRcdDx0aFxuXHRcdFx0XHQqbmdJZj1cIiFza2VsZXRvbiAmJiBzaG93U2VsZWN0aW9uQ29sdW1uICYmIGVuYWJsZVNpbmdsZVNlbGVjdFwiXG5cdFx0XHRcdHNjb3BlPVwiY29sXCJcblx0XHRcdFx0c3R5bGU9XCJ3aWR0aDogMDtcIlxuXHRcdFx0XHRbaWRdPVwibW9kZWwuZ2V0SWQoJ3NlbGVjdCcpXCI+XG5cdFx0XHRcdDwhLS0gYWRkIHdpZHRoIDA7IHNpbmNlIHRoZSBjYXJib24gc3R5bGVzIGRvbid0IHNlZW0gdG8gY29uc3RyYWluIHRoaXMgaGVhZGVycyB3aWR0aCAtLT5cblx0XHRcdDwvdGg+XG5cdFx0XHQ8dGhcblx0XHRcdFx0aWJtVGFibGVIZWFkQ2hlY2tib3hcblx0XHRcdFx0Km5nSWY9XCIhc2tlbGV0b24gJiYgc2hvd1NlbGVjdGlvbkNvbHVtbiAmJiAhZW5hYmxlU2luZ2xlU2VsZWN0XCJcblx0XHRcdFx0c2NvcGU9XCJjb2xcIlxuXHRcdFx0XHRbY2hlY2tlZF09XCJzZWxlY3RBbGxDaGVja2JveFwiXG5cdFx0XHRcdFtpbmRldGVybWluYXRlXT1cInNlbGVjdEFsbENoZWNrYm94U29tZVNlbGVjdGVkXCJcblx0XHRcdFx0W2FyaWFMYWJlbF09XCJnZXRDaGVja2JveEhlYWRlckxhYmVsKClcIlxuXHRcdFx0XHRbc2l6ZV09XCJzaXplXCJcblx0XHRcdFx0W3NrZWxldG9uXT1cInNrZWxldG9uXCJcblx0XHRcdFx0W25hbWVdPVwibW9kZWwuZ2V0SGVhZGVySWQoJ3NlbGVjdCcpXCJcblx0XHRcdFx0KGNoYW5nZSk9XCJvblNlbGVjdEFsbENoZWNrYm94Q2hhbmdlKClcIlxuXHRcdFx0XHRbaWRdPVwibW9kZWwuZ2V0SWQoJ3NlbGVjdCcpXCI+XG5cdFx0XHQ8L3RoPlxuXHRcdFx0PG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIG1vZGVsLmhlYWRlcjsgbGV0IGkgPSBpbmRleFwiPlxuXHRcdFx0XHQ8dGhcblx0XHRcdFx0XHQqbmdJZj1cImNvbHVtbiAmJiBjb2x1bW4udmlzaWJsZVwiXG5cdFx0XHRcdFx0W25nU3R5bGVdPVwiY29sdW1uLnN0eWxlXCJcblx0XHRcdFx0XHRpYm1UYWJsZUhlYWRDZWxsXG5cdFx0XHRcdFx0c2NvcGU9XCJjb2xcIlxuXHRcdFx0XHRcdFtjbGFzc109XCJjb2x1bW4uY2xhc3NOYW1lXCJcblx0XHRcdFx0XHRbc29ydGFibGVdPVwic29ydGFibGVcIlxuXHRcdFx0XHRcdFtza2VsZXRvbl09XCJza2VsZXRvblwiXG5cdFx0XHRcdFx0W2lkXT1cIm1vZGVsLmdldElkKGkpXCJcblx0XHRcdFx0XHRbY29sdW1uXT1cImNvbHVtblwiXG5cdFx0XHRcdFx0W3NrZWxldG9uXT1cInNrZWxldG9uXCJcblx0XHRcdFx0XHRbZmlsdGVyVGl0bGVdPVwiZ2V0RmlsdGVyVGl0bGUoKVwiXG5cdFx0XHRcdFx0W2F0dHIuY29sc3Bhbl09XCJjb2x1bW4uY29sU3BhblwiXG5cdFx0XHRcdFx0W2F0dHIucm93c3Bhbl09XCJjb2x1bW4ucm93U3BhblwiXG5cdFx0XHRcdFx0KHNvcnQpPVwic29ydC5lbWl0KGkpXCI+XG5cdFx0XHRcdDwvdGg+XG5cdFx0XHQ8L25nLWNvbnRhaW5lcj5cblx0XHRcdDx0aCAqbmdJZj1cIiFza2VsZXRvbiAmJiBzdGlja3lIZWFkZXIgJiYgc2Nyb2xsYmFyV2lkdGhcIlxuXHRcdFx0XHRzY29wZT1cImNvbFwiXG5cdFx0XHRcdFtuZ1N0eWxlXT1cInsnd2lkdGgnOiBzY3JvbGxiYXJXaWR0aCArICdweCcsICdwYWRkaW5nJzogMCwgJ2JvcmRlcic6IDB9XCI+XG5cdFx0XHRcdDwhLS1cblx0XHRcdFx0XHRTY3JvbGxiYXIgcHVzaGVzIGJvZHkgdG8gdGhlIGxlZnQgc28gdGhpcyBoZWFkZXIgY29sdW1uIGlzIGFkZGVkIHRvIHB1c2hcblx0XHRcdFx0XHR0aGUgdGl0bGUgYmFyIHRoZSBzYW1lIGFtb3VudCBhbmQga2VlcCB0aGUgaGVhZGVyIGFuZCBib2R5IGNvbHVtbnMgYWxpZ25lZC5cblx0XHRcdFx0LS0+XG5cdFx0XHQ8L3RoPlxuXHRcdDwvdHI+XG5cdDwvbmctY29udGFpbmVyPlxuXHQ8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG5cdGAsXG5cdHN0eWxlczogW2Bcblx0XHQuYngtLXRhYmxlLWV4cGFuZC12MiB7XG5cdFx0XHRwYWRkaW5nLWxlZnQ6IDIuNXJlbTtcblx0XHR9XG5cdGBdXG59KVxuZXhwb3J0IGNsYXNzIFRhYmxlSGVhZCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xuXHRASW5wdXQoKSBtb2RlbDogVGFibGVNb2RlbDtcblxuXHRASW5wdXQoKSBzaG93U2VsZWN0aW9uQ29sdW1uID0gdHJ1ZTtcblxuXHRASW5wdXQoKSBlbmFibGVTaW5nbGVTZWxlY3QgPSBmYWxzZTtcblxuXHRASW5wdXQoKSBzZWxlY3RBbGxDaGVja2JveFNvbWVTZWxlY3RlZCA9IGZhbHNlO1xuXG5cdEBJbnB1dCgpIHNlbGVjdEFsbENoZWNrYm94ID0gZmFsc2U7XG5cblx0QElucHV0KCkgc2tlbGV0b24gPSBmYWxzZTtcblxuXHRASW5wdXQoKSBzdGlja3lIZWFkZXIgPSBmYWxzZTtcblxuXHQvKipcblx0ICogU2V0dGluZyBzb3J0YWJsZSB0byBmYWxzZSB3aWxsIGRpc2FibGUgYWxsIGhlYWRlcnMgaW5jbHVkaW5nIGhlYWRlcnMgd2hpY2ggYXJlIHNvcnRhYmxlLiBJcyBpc1xuXHQgKiBwb3NzaWJsZSB0byBzZXQgdGhlIHNvcnRhYmxlIHN0YXRlIG9uIHRoZSBoZWFkZXIgaXRlbSB0byBkaXNhYmxlL2VuYWJsZSBzb3J0aW5nIGZvciBvbmx5IHNvbWUgaGVhZGVycy5cblx0ICovXG5cdEBJbnB1dCgpIHNvcnRhYmxlID0gdHJ1ZTtcblxuXHQvKipcblx0ICogU2l6ZSBvZiB0aGUgdGFibGUgcm93cy5cblx0ICovXG5cdEBJbnB1dCgpIHNpemU6IFRhYmxlUm93U2l6ZSA9IFwibWRcIjtcblxuXHRASW5wdXQoKVxuXHRzZXQgY2hlY2tib3hIZWFkZXJMYWJlbCh2YWx1ZTogc3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+KSB7XG5cdFx0dGhpcy5fY2hlY2tib3hIZWFkZXJMYWJlbC5vdmVycmlkZSh2YWx1ZSk7XG5cdH1cblxuXHRnZXQgY2hlY2tib3hIZWFkZXJMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hlY2tib3hIZWFkZXJMYWJlbC52YWx1ZTtcblx0fVxuXG5cdEBJbnB1dCgpXG5cdHNldCBzb3J0RGVzY2VuZGluZ0xhYmVsKHZhbHVlOiBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz4pIHtcblx0XHR0aGlzLl9zb3J0RGVzY2VuZGluZ0xhYmVsLm92ZXJyaWRlKHZhbHVlKTtcblx0fVxuXG5cdGdldCBzb3J0RGVzY2VuZGluZ0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLl9zb3J0RGVzY2VuZGluZ0xhYmVsLnZhbHVlO1xuXHR9XG5cblx0QElucHV0KClcblx0c2V0IHNvcnRBc2NlbmRpbmdMYWJlbCh2YWx1ZTogc3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+KSB7XG5cdFx0dGhpcy5fc29ydEFzY2VuZGluZ0xhYmVsLm92ZXJyaWRlKHZhbHVlKTtcblx0fVxuXG5cdGdldCBzb3J0QXNjZW5kaW5nTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NvcnRBc2NlbmRpbmdMYWJlbC52YWx1ZTtcblx0fVxuXG5cdEBJbnB1dCgpXG5cdHNldCBmaWx0ZXJUaXRsZSh2YWx1ZTogc3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+KSB7XG5cdFx0dGhpcy5fZmlsdGVyVGl0bGUub3ZlcnJpZGUodmFsdWUpO1xuXHR9XG5cblx0Z2V0IGZpbHRlclRpdGxlKCkge1xuXHRcdHJldHVybiB0aGlzLl9maWx0ZXJUaXRsZS52YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbWl0cyBhbiBpbmRleCBvZiB0aGUgY29sdW1uIHRoYXQgd2FudHMgdG8gYmUgc29ydGVkLlxuXHQgKi9cblx0QE91dHB1dCgpIHNvcnQgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblx0LyoqXG5cdCAqIEVtaXRzIGlmIGFsbCByb3dzIGFyZSBzZWxlY3RlZC5cblx0ICpcblx0ICogQHBhcmFtIG1vZGVsXG5cdCAqL1xuXHRAT3V0cHV0KCkgc2VsZWN0QWxsID0gbmV3IEV2ZW50RW1pdHRlcjxUYWJsZU1vZGVsPigpO1xuXHQvKipcblx0ICogRW1pdHMgaWYgYWxsIHJvd3MgYXJlIGRlc2VsZWN0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSBtb2RlbFxuXHQgKi9cblx0QE91dHB1dCgpIGRlc2VsZWN0QWxsID0gbmV3IEV2ZW50RW1pdHRlcjxUYWJsZU1vZGVsPigpO1xuXG5cdHB1YmxpYyBzY3JvbGxiYXJXaWR0aCA9IDA7XG5cblx0cHJvdGVjdGVkIF9jaGVja2JveEhlYWRlckxhYmVsID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuQ0hFQ0tCT1hfSEVBREVSXCIpO1xuXHRwcm90ZWN0ZWQgX3NvcnREZXNjZW5kaW5nTGFiZWwgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUQUJMRS5TT1JUX0RFU0NFTkRJTkdcIik7XG5cdHByb3RlY3RlZCBfc29ydEFzY2VuZGluZ0xhYmVsID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuU09SVF9BU0NFTkRJTkdcIik7XG5cdHByb3RlY3RlZCBfZmlsdGVyVGl0bGUgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUQUJMRS5GSUxURVJcIik7XG5cblx0Y29uc3RydWN0b3IocHJvdGVjdGVkIGkxOG46IEkxOG4pIHt9XG5cblx0bmdBZnRlclZpZXdJbml0KCkge1xuXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0dGhpcy5zY3JvbGxiYXJXaWR0aCA9IGdldFNjcm9sbGJhcldpZHRoKCk7XG5cdFx0fSk7XG5cdH1cblxuXHRvblNlbGVjdEFsbENoZWNrYm94Q2hhbmdlKCkge1xuXHRcdGlmICghdGhpcy5zZWxlY3RBbGxDaGVja2JveCAmJiAhdGhpcy5zZWxlY3RBbGxDaGVja2JveFNvbWVTZWxlY3RlZCkge1xuXHRcdFx0dGhpcy5zZWxlY3RBbGwuZW1pdCh0aGlzLm1vZGVsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5kZXNlbGVjdEFsbC5lbWl0KHRoaXMubW9kZWwpO1xuXHRcdH1cblx0fVxuXG5cdGdldENoZWNrYm94SGVhZGVyTGFiZWwoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcblx0XHRyZXR1cm4gdGhpcy5fY2hlY2tib3hIZWFkZXJMYWJlbC5zdWJqZWN0O1xuXHR9XG5cblx0Z2V0U29ydERlc2NlbmRpbmdMYWJlbCgpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuXHRcdHJldHVybiB0aGlzLl9zb3J0RGVzY2VuZGluZ0xhYmVsLnN1YmplY3Q7XG5cdH1cblxuXHRnZXRTb3J0QXNjZW5kaW5nTGFiZWwoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcblx0XHRyZXR1cm4gdGhpcy5fc29ydEFzY2VuZGluZ0xhYmVsLnN1YmplY3Q7XG5cdH1cblxuXHRnZXRGaWx0ZXJUaXRsZSgpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuXHRcdHJldHVybiB0aGlzLl9maWx0ZXJUaXRsZS5zdWJqZWN0O1xuXHR9XG59XG4iXX0=