/**
 *
 * carbon-angular v0.0.0 | table-body.component.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Component, Input, EventEmitter, Output } from "@angular/core";
import { TableModel } from "../table-model.class";
import { I18n } from "carbon-components-angular/i18n";
export class TableBody {
    constructor(i18n) {
        this.i18n = i18n;
        /**
         * Controls whether to enable multiple or single row selection.
         */
        this.enableSingleSelect = false;
        /**
         * Controls whether to show the selection checkboxes column or not.
         */
        this.showSelectionColumn = true;
        /**
         * Size of the table rows.
         */
        this.size = "md";
        this.skeleton = false;
        /**
         * Emits if a single row is selected.
         *
         * @param ({model: this.model, selectedRowIndex: index})
         */
        this.selectRow = new EventEmitter();
        /**
         * Emits if a single row is deselected.
         *
         * @param ({model: this.model, deselectedRowIndex: index})
         */
        this.deselectRow = new EventEmitter();
        /**
         * Emits if a row item excluding expandButtons, checkboxes, or radios is clicked.
         */
        this.rowClick = new EventEmitter();
        this._checkboxRowLabel = this.i18n.getOverridable("TABLE.CHECKBOX_ROW");
        this._expandButtonAriaLabel = this.i18n.getOverridable("TABLE.EXPAND_BUTTON");
    }
    set expandButtonAriaLabel(value) {
        this._expandButtonAriaLabel.override(value);
    }
    get expandButtonAriaLabel() {
        return this._expandButtonAriaLabel.value;
    }
    set checkboxRowLabel(value) {
        this._checkboxRowLabel.override(value);
    }
    get checkboxRowLabel() {
        return this._checkboxRowLabel.value;
    }
    /**
     * Triggered when a single row is clicked.
     * Updates the header checkbox state.
     * Emits the `selectRow` or `deselectRow` event.
     */
    onRowCheckboxChange(index) {
        if (this.model.isRowSelected(index)) {
            this.deselectRow.emit({ model: this.model, deselectedRowIndex: index });
        }
        else {
            this.selectRow.emit({ model: this.model, selectedRowIndex: index });
        }
    }
    onRowClick(index) {
        this.rowClick.emit(index);
    }
    getCheckboxRowLabel() {
        return this._checkboxRowLabel.subject;
    }
    getExpandButtonAriaLabel() {
        return this._expandButtonAriaLabel.subject;
    }
    firstExpandedDataInRow(row) {
        const found = row.find(d => d.expandedData);
        if (found) {
            return found.expandedData;
        }
        return found;
    }
    shouldExpandAsTable(row) {
        return row.some(d => d.expandAsTable);
    }
}
TableBody.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line: component-selector
                selector: "[ibmTableBody]",
                template: `
		<ng-container *ngIf="model">
			<ng-container *ngFor="let row of model.data; let i = index">
				<tr
					ibmTableRow
					[model]="model"
					[row]="row"
					[size]="size"
					[selected]="model.isRowSelected(i)"
					[expandable]="model.isRowExpandable(i)"
					[expanded]="model.isRowExpanded(i)"
					[checkboxLabel]="getCheckboxRowLabel()"
					[expandButtonAriaLabel]="getExpandButtonAriaLabel()"
					[showSelectionColumn]="showSelectionColumn"
					[enableSingleSelect]="enableSingleSelect"
					[skeleton]="skeleton"
					(selectRow)="onRowCheckboxChange(i)"
					(deselectRow)="onRowCheckboxChange(i)"
					(expandRow)="model.expandRow(i, !model.isRowExpanded(i))"
					(rowClick)="onRowClick(i)"
					*ngIf="!model.isRowFiltered(i)"
					[class]="(model.rowsClass[i] ? model.rowsClass[i] : null)"
					[ngClass]="{
						'tbody_row--success': !model.isRowSelected(i) && model.getRowContext(i) === 'success',
						'tbody_row--warning': !model.isRowSelected(i) && model.getRowContext(i) === 'warning',
						'tbody_row--info': !model.isRowSelected(i) && model.getRowContext(i) === 'info',
						'tbody_row--error': !model.isRowSelected(i) && model.getRowContext(i) === 'error'
					}">
				</tr>
				<ng-container *ngIf="model.isRowExpanded(i) && !model.isRowFiltered(i)">
					<tr
						*ngIf="!shouldExpandAsTable(row); else expandAsTableTemplate"
						ibmTableExpandedRow
						ibmExpandedRowHover
						[row]="row"
						[expanded]="model.isRowExpanded(i)"
						[skeleton]="skeleton">
					</tr>
					<ng-template #expandAsTableTemplate>
						<tr
							*ngFor="let expandedDataRow of firstExpandedDataInRow(row)"
							ibmTableRow
							[model]="model"
							[showSelectionColumnCheckbox]="false"
							[showSelectionColumn]="showSelectionColumn"
							[row]="expandedDataRow"
							[size]="size"
							[skeleton]="skeleton">
						</tr>
					</ng-template>
				</ng-container>
			</ng-container>
		</ng-container>
		<ng-content></ng-content>
	`
            }] }
];
/** @nocollapse */
TableBody.ctorParameters = () => [
    { type: I18n }
];
TableBody.propDecorators = {
    model: [{ type: Input }],
    enableSingleSelect: [{ type: Input }],
    expandButtonAriaLabel: [{ type: Input }],
    checkboxRowLabel: [{ type: Input }],
    showSelectionColumn: [{ type: Input }],
    size: [{ type: Input }],
    selectionLabelColumn: [{ type: Input }],
    skeleton: [{ type: Input }],
    selectRow: [{ type: Output }],
    deselectRow: [{ type: Output }],
    rowClick: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUtYm9keS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL3RhYmxlLyIsInNvdXJjZXMiOlsiYm9keS90YWJsZS1ib2R5LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxZQUFZLEVBQ1osTUFBTSxFQUNOLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNsRCxPQUFPLEVBQUUsSUFBSSxFQUFlLE1BQU0sZ0NBQWdDLENBQUM7QUErRG5FLE1BQU0sT0FBTyxTQUFTO0lBd0VyQixZQUFzQixJQUFVO1FBQVYsU0FBSSxHQUFKLElBQUksQ0FBTTtRQXJFaEM7O1dBRUc7UUFDTSx1QkFBa0IsR0FBRyxLQUFLLENBQUM7UUFvQnBDOztXQUVHO1FBQ00sd0JBQW1CLEdBQUcsSUFBSSxDQUFDO1FBRXBDOztXQUVHO1FBQ00sU0FBSSxHQUFpQixJQUFJLENBQUM7UUFjMUIsYUFBUSxHQUFHLEtBQUssQ0FBQztRQUUxQjs7OztXQUlHO1FBQ08sY0FBUyxHQUFHLElBQUksWUFBWSxFQUFVLENBQUM7UUFFakQ7Ozs7V0FJRztRQUNPLGdCQUFXLEdBQUcsSUFBSSxZQUFZLEVBQVUsQ0FBQztRQUVuRDs7V0FFRztRQUNPLGFBQVEsR0FBRyxJQUFJLFlBQVksRUFBVSxDQUFDO1FBRXRDLHNCQUFpQixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLG9CQUFvQixDQUFDLENBQUM7UUFDbkUsMkJBQXNCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMscUJBQXFCLENBQUMsQ0FBQztJQUUvQyxDQUFDO0lBaEVyQyxJQUNJLHFCQUFxQixDQUFDLEtBQWtDO1FBQzNELElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVELElBQUkscUJBQXFCO1FBQ3hCLE9BQU8sSUFBSSxDQUFDLHNCQUFzQixDQUFDLEtBQUssQ0FBQztJQUMxQyxDQUFDO0lBRUQsSUFDSSxnQkFBZ0IsQ0FBQyxLQUFrQztRQUN0RCxJQUFJLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRCxJQUFJLGdCQUFnQjtRQUNuQixPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUM7SUFDckMsQ0FBQztJQWtERDs7OztPQUlHO0lBQ0gsbUJBQW1CLENBQUMsS0FBYTtRQUNoQyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3BDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsa0JBQWtCLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztTQUN4RTthQUFNO1lBQ04sSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxnQkFBZ0IsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO1NBQ3BFO0lBQ0YsQ0FBQztJQUVELFVBQVUsQ0FBQyxLQUFhO1FBQ3ZCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRCxtQkFBbUI7UUFDbEIsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDO0lBQ3ZDLENBQUM7SUFFRCx3QkFBd0I7UUFDdkIsT0FBTyxJQUFJLENBQUMsc0JBQXNCLENBQUMsT0FBTyxDQUFDO0lBQzVDLENBQUM7SUFFRCxzQkFBc0IsQ0FBQyxHQUFHO1FBQ3pCLE1BQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDNUMsSUFBSSxLQUFLLEVBQUU7WUFDVixPQUFPLEtBQUssQ0FBQyxZQUFZLENBQUM7U0FDMUI7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNkLENBQUM7SUFFRCxtQkFBbUIsQ0FBQyxHQUFHO1FBQ3RCLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUN2QyxDQUFDOzs7WUF4S0QsU0FBUyxTQUFDO2dCQUNWLCtDQUErQztnQkFDL0MsUUFBUSxFQUFFLGdCQUFnQjtnQkFDMUIsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFzRFQ7YUFDRDs7OztZQTlEUSxJQUFJOzs7b0JBZ0VYLEtBQUs7aUNBS0wsS0FBSztvQ0FFTCxLQUFLOytCQVNMLEtBQUs7a0NBWUwsS0FBSzttQkFLTCxLQUFLO21DQVlMLEtBQUs7dUJBRUwsS0FBSzt3QkFPTCxNQUFNOzBCQU9OLE1BQU07dUJBS04sTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdENvbXBvbmVudCxcblx0SW5wdXQsXG5cdEV2ZW50RW1pdHRlcixcblx0T3V0cHV0XG59IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBUYWJsZU1vZGVsIH0gZnJvbSBcIi4uL3RhYmxlLW1vZGVsLmNsYXNzXCI7XG5pbXBvcnQgeyBJMThuLCBPdmVycmlkYWJsZSB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2kxOG5cIjtcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tIFwicnhqc1wiO1xuaW1wb3J0IHsgVGFibGVSb3dTaXplIH0gZnJvbSBcIi4uL3RhYmxlLnR5cGVzXCI7XG5cbkBDb21wb25lbnQoe1xuXHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGNvbXBvbmVudC1zZWxlY3RvclxuXHRzZWxlY3RvcjogXCJbaWJtVGFibGVCb2R5XVwiLFxuXHR0ZW1wbGF0ZTogYFxuXHRcdDxuZy1jb250YWluZXIgKm5nSWY9XCJtb2RlbFwiPlxuXHRcdFx0PG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgcm93IG9mIG1vZGVsLmRhdGE7IGxldCBpID0gaW5kZXhcIj5cblx0XHRcdFx0PHRyXG5cdFx0XHRcdFx0aWJtVGFibGVSb3dcblx0XHRcdFx0XHRbbW9kZWxdPVwibW9kZWxcIlxuXHRcdFx0XHRcdFtyb3ddPVwicm93XCJcblx0XHRcdFx0XHRbc2l6ZV09XCJzaXplXCJcblx0XHRcdFx0XHRbc2VsZWN0ZWRdPVwibW9kZWwuaXNSb3dTZWxlY3RlZChpKVwiXG5cdFx0XHRcdFx0W2V4cGFuZGFibGVdPVwibW9kZWwuaXNSb3dFeHBhbmRhYmxlKGkpXCJcblx0XHRcdFx0XHRbZXhwYW5kZWRdPVwibW9kZWwuaXNSb3dFeHBhbmRlZChpKVwiXG5cdFx0XHRcdFx0W2NoZWNrYm94TGFiZWxdPVwiZ2V0Q2hlY2tib3hSb3dMYWJlbCgpXCJcblx0XHRcdFx0XHRbZXhwYW5kQnV0dG9uQXJpYUxhYmVsXT1cImdldEV4cGFuZEJ1dHRvbkFyaWFMYWJlbCgpXCJcblx0XHRcdFx0XHRbc2hvd1NlbGVjdGlvbkNvbHVtbl09XCJzaG93U2VsZWN0aW9uQ29sdW1uXCJcblx0XHRcdFx0XHRbZW5hYmxlU2luZ2xlU2VsZWN0XT1cImVuYWJsZVNpbmdsZVNlbGVjdFwiXG5cdFx0XHRcdFx0W3NrZWxldG9uXT1cInNrZWxldG9uXCJcblx0XHRcdFx0XHQoc2VsZWN0Um93KT1cIm9uUm93Q2hlY2tib3hDaGFuZ2UoaSlcIlxuXHRcdFx0XHRcdChkZXNlbGVjdFJvdyk9XCJvblJvd0NoZWNrYm94Q2hhbmdlKGkpXCJcblx0XHRcdFx0XHQoZXhwYW5kUm93KT1cIm1vZGVsLmV4cGFuZFJvdyhpLCAhbW9kZWwuaXNSb3dFeHBhbmRlZChpKSlcIlxuXHRcdFx0XHRcdChyb3dDbGljayk9XCJvblJvd0NsaWNrKGkpXCJcblx0XHRcdFx0XHQqbmdJZj1cIiFtb2RlbC5pc1Jvd0ZpbHRlcmVkKGkpXCJcblx0XHRcdFx0XHRbY2xhc3NdPVwiKG1vZGVsLnJvd3NDbGFzc1tpXSA/IG1vZGVsLnJvd3NDbGFzc1tpXSA6IG51bGwpXCJcblx0XHRcdFx0XHRbbmdDbGFzc109XCJ7XG5cdFx0XHRcdFx0XHQndGJvZHlfcm93LS1zdWNjZXNzJzogIW1vZGVsLmlzUm93U2VsZWN0ZWQoaSkgJiYgbW9kZWwuZ2V0Um93Q29udGV4dChpKSA9PT0gJ3N1Y2Nlc3MnLFxuXHRcdFx0XHRcdFx0J3Rib2R5X3Jvdy0td2FybmluZyc6ICFtb2RlbC5pc1Jvd1NlbGVjdGVkKGkpICYmIG1vZGVsLmdldFJvd0NvbnRleHQoaSkgPT09ICd3YXJuaW5nJyxcblx0XHRcdFx0XHRcdCd0Ym9keV9yb3ctLWluZm8nOiAhbW9kZWwuaXNSb3dTZWxlY3RlZChpKSAmJiBtb2RlbC5nZXRSb3dDb250ZXh0KGkpID09PSAnaW5mbycsXG5cdFx0XHRcdFx0XHQndGJvZHlfcm93LS1lcnJvcic6ICFtb2RlbC5pc1Jvd1NlbGVjdGVkKGkpICYmIG1vZGVsLmdldFJvd0NvbnRleHQoaSkgPT09ICdlcnJvcidcblx0XHRcdFx0XHR9XCI+XG5cdFx0XHRcdDwvdHI+XG5cdFx0XHRcdDxuZy1jb250YWluZXIgKm5nSWY9XCJtb2RlbC5pc1Jvd0V4cGFuZGVkKGkpICYmICFtb2RlbC5pc1Jvd0ZpbHRlcmVkKGkpXCI+XG5cdFx0XHRcdFx0PHRyXG5cdFx0XHRcdFx0XHQqbmdJZj1cIiFzaG91bGRFeHBhbmRBc1RhYmxlKHJvdyk7IGVsc2UgZXhwYW5kQXNUYWJsZVRlbXBsYXRlXCJcblx0XHRcdFx0XHRcdGlibVRhYmxlRXhwYW5kZWRSb3dcblx0XHRcdFx0XHRcdGlibUV4cGFuZGVkUm93SG92ZXJcblx0XHRcdFx0XHRcdFtyb3ddPVwicm93XCJcblx0XHRcdFx0XHRcdFtleHBhbmRlZF09XCJtb2RlbC5pc1Jvd0V4cGFuZGVkKGkpXCJcblx0XHRcdFx0XHRcdFtza2VsZXRvbl09XCJza2VsZXRvblwiPlxuXHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0PG5nLXRlbXBsYXRlICNleHBhbmRBc1RhYmxlVGVtcGxhdGU+XG5cdFx0XHRcdFx0XHQ8dHJcblx0XHRcdFx0XHRcdFx0Km5nRm9yPVwibGV0IGV4cGFuZGVkRGF0YVJvdyBvZiBmaXJzdEV4cGFuZGVkRGF0YUluUm93KHJvdylcIlxuXHRcdFx0XHRcdFx0XHRpYm1UYWJsZVJvd1xuXHRcdFx0XHRcdFx0XHRbbW9kZWxdPVwibW9kZWxcIlxuXHRcdFx0XHRcdFx0XHRbc2hvd1NlbGVjdGlvbkNvbHVtbkNoZWNrYm94XT1cImZhbHNlXCJcblx0XHRcdFx0XHRcdFx0W3Nob3dTZWxlY3Rpb25Db2x1bW5dPVwic2hvd1NlbGVjdGlvbkNvbHVtblwiXG5cdFx0XHRcdFx0XHRcdFtyb3ddPVwiZXhwYW5kZWREYXRhUm93XCJcblx0XHRcdFx0XHRcdFx0W3NpemVdPVwic2l6ZVwiXG5cdFx0XHRcdFx0XHRcdFtza2VsZXRvbl09XCJza2VsZXRvblwiPlxuXHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHQ8L25nLXRlbXBsYXRlPlxuXHRcdFx0XHQ8L25nLWNvbnRhaW5lcj5cblx0XHRcdDwvbmctY29udGFpbmVyPlxuXHRcdDwvbmctY29udGFpbmVyPlxuXHRcdDxuZy1jb250ZW50PjwvbmctY29udGVudD5cblx0YFxufSlcbmV4cG9ydCBjbGFzcyBUYWJsZUJvZHkge1xuXHRASW5wdXQoKSBtb2RlbDogVGFibGVNb2RlbDtcblxuXHQvKipcblx0ICogQ29udHJvbHMgd2hldGhlciB0byBlbmFibGUgbXVsdGlwbGUgb3Igc2luZ2xlIHJvdyBzZWxlY3Rpb24uXG5cdCAqL1xuXHRASW5wdXQoKSBlbmFibGVTaW5nbGVTZWxlY3QgPSBmYWxzZTtcblxuXHRASW5wdXQoKVxuXHRzZXQgZXhwYW5kQnV0dG9uQXJpYUxhYmVsKHZhbHVlOiBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz4pIHtcblx0XHR0aGlzLl9leHBhbmRCdXR0b25BcmlhTGFiZWwub3ZlcnJpZGUodmFsdWUpO1xuXHR9XG5cblx0Z2V0IGV4cGFuZEJ1dHRvbkFyaWFMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZXhwYW5kQnV0dG9uQXJpYUxhYmVsLnZhbHVlO1xuXHR9XG5cblx0QElucHV0KClcblx0c2V0IGNoZWNrYm94Um93TGFiZWwodmFsdWU6IHN0cmluZyB8IE9ic2VydmFibGU8c3RyaW5nPikge1xuXHRcdHRoaXMuX2NoZWNrYm94Um93TGFiZWwub3ZlcnJpZGUodmFsdWUpO1xuXHR9XG5cblx0Z2V0IGNoZWNrYm94Um93TGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoZWNrYm94Um93TGFiZWwudmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogQ29udHJvbHMgd2hldGhlciB0byBzaG93IHRoZSBzZWxlY3Rpb24gY2hlY2tib3hlcyBjb2x1bW4gb3Igbm90LlxuXHQgKi9cblx0QElucHV0KCkgc2hvd1NlbGVjdGlvbkNvbHVtbiA9IHRydWU7XG5cblx0LyoqXG5cdCAqIFNpemUgb2YgdGhlIHRhYmxlIHJvd3MuXG5cdCAqL1xuXHRASW5wdXQoKSBzaXplOiBUYWJsZVJvd1NpemUgPSBcIm1kXCI7XG5cblx0LyoqXG5cdCAqIFVzZWQgdG8gcG9wdWxhdGUgdGhlIHJvdyBzZWxlY3Rpb24gY2hlY2tib3ggbGFiZWwgd2l0aCBhIHVzZWZ1bCB2YWx1ZSBpZiBzZXQuXG5cdCAqXG5cdCAqIEV4YW1wbGU6XG5cdCAqIGBgYFxuXHQgKiA8aWJtLXRhYmxlIFtzZWxlY3Rpb25MYWJlbENvbHVtbl09XCIwXCI+PC9pYm0tdGFibGU+XG5cdCAqIDwhLS0gcmVzdWx0cyBpbiBhcmlhLWxhYmVsPVwiU2VsZWN0IGZpcnN0IGNvbHVtbiB2YWx1ZVwiXG5cdCAqICh3aGVyZSBcImZpcnN0IGNvbHVtbiB2YWx1ZVwiIGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgY29sdW1uIGluIHRoZSByb3cgLS0+XG5cdCAqIGBgYFxuXHQgKi9cblx0QElucHV0KCkgc2VsZWN0aW9uTGFiZWxDb2x1bW46IG51bWJlcjtcblxuXHRASW5wdXQoKSBza2VsZXRvbiA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBFbWl0cyBpZiBhIHNpbmdsZSByb3cgaXMgc2VsZWN0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSAoe21vZGVsOiB0aGlzLm1vZGVsLCBzZWxlY3RlZFJvd0luZGV4OiBpbmRleH0pXG5cdCAqL1xuXHRAT3V0cHV0KCkgc2VsZWN0Um93ID0gbmV3IEV2ZW50RW1pdHRlcjxPYmplY3Q+KCk7XG5cblx0LyoqXG5cdCAqIEVtaXRzIGlmIGEgc2luZ2xlIHJvdyBpcyBkZXNlbGVjdGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0gKHttb2RlbDogdGhpcy5tb2RlbCwgZGVzZWxlY3RlZFJvd0luZGV4OiBpbmRleH0pXG5cdCAqL1xuXHRAT3V0cHV0KCkgZGVzZWxlY3RSb3cgPSBuZXcgRXZlbnRFbWl0dGVyPE9iamVjdD4oKTtcblxuXHQvKipcblx0ICogRW1pdHMgaWYgYSByb3cgaXRlbSBleGNsdWRpbmcgZXhwYW5kQnV0dG9ucywgY2hlY2tib3hlcywgb3IgcmFkaW9zIGlzIGNsaWNrZWQuXG5cdCAqL1xuXHRAT3V0cHV0KCkgcm93Q2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuXHRwcm90ZWN0ZWQgX2NoZWNrYm94Um93TGFiZWwgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUQUJMRS5DSEVDS0JPWF9ST1dcIik7XG5cdHByb3RlY3RlZCBfZXhwYW5kQnV0dG9uQXJpYUxhYmVsID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuRVhQQU5EX0JVVFRPTlwiKTtcblxuXHRjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgaTE4bjogSTE4bikgeyB9XG5cblx0LyoqXG5cdCAqIFRyaWdnZXJlZCB3aGVuIGEgc2luZ2xlIHJvdyBpcyBjbGlja2VkLlxuXHQgKiBVcGRhdGVzIHRoZSBoZWFkZXIgY2hlY2tib3ggc3RhdGUuXG5cdCAqIEVtaXRzIHRoZSBgc2VsZWN0Um93YCBvciBgZGVzZWxlY3RSb3dgIGV2ZW50LlxuXHQgKi9cblx0b25Sb3dDaGVja2JveENoYW5nZShpbmRleDogbnVtYmVyKSB7XG5cdFx0aWYgKHRoaXMubW9kZWwuaXNSb3dTZWxlY3RlZChpbmRleCkpIHtcblx0XHRcdHRoaXMuZGVzZWxlY3RSb3cuZW1pdCh7IG1vZGVsOiB0aGlzLm1vZGVsLCBkZXNlbGVjdGVkUm93SW5kZXg6IGluZGV4IH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNlbGVjdFJvdy5lbWl0KHsgbW9kZWw6IHRoaXMubW9kZWwsIHNlbGVjdGVkUm93SW5kZXg6IGluZGV4IH0pO1xuXHRcdH1cblx0fVxuXG5cdG9uUm93Q2xpY2soaW5kZXg6IG51bWJlcikge1xuXHRcdHRoaXMucm93Q2xpY2suZW1pdChpbmRleCk7XG5cdH1cblxuXHRnZXRDaGVja2JveFJvd0xhYmVsKCk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoZWNrYm94Um93TGFiZWwuc3ViamVjdDtcblx0fVxuXG5cdGdldEV4cGFuZEJ1dHRvbkFyaWFMYWJlbCgpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuXHRcdHJldHVybiB0aGlzLl9leHBhbmRCdXR0b25BcmlhTGFiZWwuc3ViamVjdDtcblx0fVxuXG5cdGZpcnN0RXhwYW5kZWREYXRhSW5Sb3cocm93KSB7XG5cdFx0Y29uc3QgZm91bmQgPSByb3cuZmluZChkID0+IGQuZXhwYW5kZWREYXRhKTtcblx0XHRpZiAoZm91bmQpIHtcblx0XHRcdHJldHVybiBmb3VuZC5leHBhbmRlZERhdGE7XG5cdFx0fVxuXHRcdHJldHVybiBmb3VuZDtcblx0fVxuXG5cdHNob3VsZEV4cGFuZEFzVGFibGUocm93KSB7XG5cdFx0cmV0dXJuIHJvdy5zb21lKGQgPT4gZC5leHBhbmRBc1RhYmxlKTtcblx0fVxufVxuIl19