/**
 *
 * carbon-angular v0.0.0 | pagination-nav.component.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { PaginationModel } from "../pagination-model.class";
import { Component, Input, Output, EventEmitter } from "@angular/core";
import { I18n } from "carbon-components-angular/i18n";
import { ExperimentalService } from "carbon-components-angular/experimental";
import { merge } from "carbon-components-angular/utils";
import { range } from "carbon-components-angular/common";
/**
 * Use pagination when you have multiple pages of data to handle.
 *
 * [See demo](../../?path=/story/pagination-nav--basic)
 *
 * ```html
 * <ibm-pagination-nav [model]="model" (selectPage)="selectPage($event)"></ibm-pagination-nav>
 * ```
 *
 * In your `selectPage()` method set the `model.currentPage` to selected page, _after_
 * you load the page.
 *
 * ```typescript
 * selectPage(page) {
 * 	// ... your code to load the page goes here
 *
 * 	this.model.currentPage = page;
 *
 * 	// ... anything you want to do after page selection changes goes here
 * }
 * ```
 *
 * <example-url>../../iframe.html?id=pagination-nav--basic</example-url>
 */
export class PaginationNav {
    constructor(i18n, experimental) {
        this.i18n = i18n;
        this.experimental = experimental;
        /**
         * Set to `true` to disable the backward/forward buttons.
         */
        this.disabled = false;
        /**
         * Number of items to show in pagination. Minimum is 4.
         */
        this.numOfItemsToShow = 4;
        /**
         * Emits the new page number.
         *
         * You should tie into this and update `model.currentPage` once the fresh
         * data is finally loaded.
         */
        this.selectPage = new EventEmitter();
        this.nextItemText = this.i18n.getOverridable("PAGINATION.NEXT");
        this.previousItemText = this.i18n.getOverridable("PAGINATION.PREVIOUS");
        PaginationNav.paginationCounter++;
    }
    /**
     * Expects an object that contains some or all of:
     * ```
     * {
     *		"NEXT": "Next",
     *		"PREVIOUS": "Previous",
     * }
     * ```
     */
    set translations(value) {
        const valueWithDefaults = merge(this.i18n.getMultiple("PAGINATION"), value);
        this.nextItemText.override(valueWithDefaults.NEXT);
        this.previousItemText.override(valueWithDefaults.PREVIOUS);
    }
    get totalNumbersArray() {
        return range(this.totalDataLength + 1, 1);
    }
    get currentPage() {
        return this.model.currentPage;
    }
    set currentPage(value) {
        value = Number(value);
        // emits the value to allow the user to update current page
        // in the model once the page is loaded
        this.selectPage.emit(value);
    }
    get totalDataLength() {
        return this.model.totalDataLength;
    }
    get startOffset() {
        return this.numOfItemsToShow <= 4 && this.currentPage > 1 ? 0 : 1;
    }
    get frontCuts() {
        const cuts = this.getCuts();
        return cuts.front;
    }
    get backCuts() {
        const cuts = this.getCuts();
        return cuts.back;
    }
    get leftArrowDisabled() {
        return this.disabled || this.currentPage === 1;
    }
    get rightArrowDisabled() {
        return this.disabled || this.currentPage === this.totalDataLength;
    }
    handleOverflowSelection(page) {
        if (typeof page === "number") {
            this.currentPage = page;
        }
    }
    jumpToNext() {
        this.currentPage = this.currentPage < this.totalDataLength ? this.currentPage + 1 : this.totalDataLength;
    }
    jumpToPrevious() {
        this.currentPage = this.currentPage > 1 ? this.currentPage - 1 : 1;
    }
    getPages() {
        if (this.totalDataLength <= 1) {
            return null;
        }
        const cuts = this.getCuts();
        return this.totalNumbersArray.slice(this.startOffset + cuts.front, (1 + cuts.back) * -1);
    }
    getCuts(splitPoint = null) {
        const page = this.currentPage - 1;
        const totalItems = this.totalDataLength;
        const itemsThatFit = this.numOfItemsToShow;
        if (itemsThatFit >= totalItems) {
            return {
                front: 0,
                back: 0
            };
        }
        const split = splitPoint || Math.ceil(itemsThatFit / 2) - 1;
        let frontHidden = page + 1 - split;
        let backHidden = totalItems - page - (itemsThatFit - split) + 1;
        if (frontHidden <= 1) {
            backHidden -= frontHidden <= 0 ? Math.abs(frontHidden) + 1 : 0;
            frontHidden = 0;
        }
        if (backHidden <= 1) {
            frontHidden -= backHidden <= 0 ? Math.abs(backHidden) + 1 : 0;
            backHidden = 0;
        }
        return {
            front: frontHidden,
            back: backHidden
        };
    }
}
PaginationNav.paginationCounter = 0;
PaginationNav.decorators = [
    { type: Component, args: [{
                selector: "ibm-pagination-nav",
                template: `
	<div>
		<div class="bx--pagination-nav">
			<ul class="bx--pagination-nav__list">
				<li class="bx--pagination-nav__list-item">
					<button
						class="bx--btn bx--btn--ghost bx--pagination-nav-previous
						bx--btn--icon-only bx--tooltip__trigger bx--tooltip--a11y bx--tooltip--bottom bx--tooltip--align-center"
						[disabled]="leftArrowDisabled"
						(click)="jumpToPrevious()">
						<span class="bx--assistive-text">{{previousItemText.subject | async}}</span>
						<svg
							ibmIcon="caret--left"
							size="16"
							style="display: inherit"
							class="bx--btn__icon">
						</svg>
					</button>
				</li>
				<ibm-pagination-nav-item
					*ngIf="this.numOfItemsToShow >= 5 || (this.numOfItemsToShow <= 4 && currentPage <= 1)"
					page="1"
					(click)="currentPage = 1"
					[isActive]="currentPage == 1">
				</ibm-pagination-nav-item>
				<ibm-pagination-overflow
					*ngIf="frontCuts"
					[count]="frontCuts"
					[fromIndex]="startOffset"
					(change)="handleOverflowSelection($event)">
				</ibm-pagination-overflow>
				<ibm-pagination-nav-item
					*ngFor="let page of getPages();"
					[page]="page"
					(click)="currentPage = page"
					[isActive]="currentPage == page">
				</ibm-pagination-nav-item>
				<ibm-pagination-overflow
					*ngIf="backCuts"
					[count]="backCuts"
					[fromIndex]="totalNumbersArray.length - backCuts - 1"
					(change)="handleOverflowSelection($event)">
				</ibm-pagination-overflow>
				<ibm-pagination-nav-item
					*ngIf="totalDataLength > 1"
					[page]="totalNumbersArray.length"
					(click)="currentPage = totalNumbersArray.length"
					[isActive]="currentPage == totalNumbersArray.length">
				</ibm-pagination-nav-item>
				<li class="bx--pagination-nav__list-item">
					<button
						class="bx--btn bx--btn--ghost bx--pagination-nav-next
						bx--btn--icon-only bx--tooltip__trigger bx--tooltip--a11y bx--tooltip--bottom bx--tooltip--align-center"
						[disabled]="rightArrowDisabled"
						(click)="jumpToNext()">
						<span class="bx--assistive-text">{{nextItemText.subject | async}}</span>
						<svg
							ibmIcon="caret--right"
							size="16"
							style="display: inherit"
							class="bx--btn__icon">
						</svg>
					</button>
				</li>
			</ul>
		</div>
	</div>
	`
            }] }
];
/** @nocollapse */
PaginationNav.ctorParameters = () => [
    { type: I18n },
    { type: ExperimentalService }
];
PaginationNav.propDecorators = {
    model: [{ type: Input }],
    disabled: [{ type: Input }],
    numOfItemsToShow: [{ type: Input }],
    translations: [{ type: Input }],
    selectPage: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFnaW5hdGlvbi1uYXYuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9wYWdpbmF0aW9uLyIsInNvdXJjZXMiOlsicGFnaW5hdGlvbi1uYXYvcGFnaW5hdGlvbi1uYXYuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUM1RCxPQUFPLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxJQUFJLEVBQWUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUNuRSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx3Q0FBd0MsQ0FBQztBQUM3RSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDeEQsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBT3pEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXVCRztBQXdFSCxNQUFNLE9BQU8sYUFBYTtJQW1GekIsWUFBc0IsSUFBVSxFQUFZLFlBQWlDO1FBQXZELFNBQUksR0FBSixJQUFJLENBQU07UUFBWSxpQkFBWSxHQUFaLFlBQVksQ0FBcUI7UUE3RTdFOztXQUVHO1FBQ00sYUFBUSxHQUFHLEtBQUssQ0FBQztRQUMxQjs7V0FFRztRQUNNLHFCQUFnQixHQUFHLENBQUMsQ0FBQztRQWtCOUI7Ozs7O1dBS0c7UUFDTyxlQUFVLEdBQUcsSUFBSSxZQUFZLEVBQVUsQ0FBQztRQTJDbEQsaUJBQVksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBQzNELHFCQUFnQixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLHFCQUFxQixDQUFDLENBQUM7UUFHbEUsYUFBYSxDQUFDLGlCQUFpQixFQUFFLENB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QztTQUNmO1FBQ0QsT0FBTztZQUNOLEtBQUssRUFBRSxXQUFXO1lBQ2xCLElBQUksRUFBRSxVQUFVO1NBQ2hCLENBQUM7SUFDSCxDQUFDOztBQXZJTSwrQkFBaUIsR0FBRyxDQUFDLENBQUM7O1lBeEU3QixTQUFTLFNBQUM7Z0JBQ1YsUUFBUSxFQUFFLG9CQUFvQjtnQkFDOUIsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBbUVUO2FBQ0Q7Ozs7WUF4R1EsSUFBSTtZQUNKLG1CQUFtQjs7O29CQTZHMUIsS0FBSzt1QkFJTCxLQUFLOytCQUlMLEtBQUs7MkJBV0wsS0FBSzt5QkFhTCxNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFnaW5hdGlvbk1vZGVsIH0gZnJvbSBcIi4uL3BhZ2luYXRpb24tbW9kZWwuY2xhc3NcIjtcbmltcG9ydCB7XG5cdENvbXBvbmVudCxcblx0SW5wdXQsXG5cdE91dHB1dCxcblx0RXZlbnRFbWl0dGVyXG59IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5cbmltcG9ydCB7IEkxOG4sIE92ZXJyaWRhYmxlIH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvaTE4blwiO1xuaW1wb3J0IHsgRXhwZXJpbWVudGFsU2VydmljZSB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2V4cGVyaW1lbnRhbFwiO1xuaW1wb3J0IHsgbWVyZ2UgfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci91dGlsc1wiO1xuaW1wb3J0IHsgcmFuZ2UgfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9jb21tb25cIjtcblxuZXhwb3J0IGludGVyZmFjZSBQYWdpbmF0aW9uTmF2VHJhbnNsYXRpb25zIHtcblx0TkVYVDogc3RyaW5nO1xuXHRQUkVWSU9VUzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFVzZSBwYWdpbmF0aW9uIHdoZW4geW91IGhhdmUgbXVsdGlwbGUgcGFnZXMgb2YgZGF0YSB0byBoYW5kbGUuXG4gKlxuICogW1NlZSBkZW1vXSguLi8uLi8/cGF0aD0vc3RvcnkvcGFnaW5hdGlvbi1uYXYtLWJhc2ljKVxuICpcbiAqIGBgYGh0bWxcbiAqIDxpYm0tcGFnaW5hdGlvbi1uYXYgW21vZGVsXT1cIm1vZGVsXCIgKHNlbGVjdFBhZ2UpPVwic2VsZWN0UGFnZSgkZXZlbnQpXCI+PC9pYm0tcGFnaW5hdGlvbi1uYXY+XG4gKiBgYGBcbiAqXG4gKiBJbiB5b3VyIGBzZWxlY3RQYWdlKClgIG1ldGhvZCBzZXQgdGhlIGBtb2RlbC5jdXJyZW50UGFnZWAgdG8gc2VsZWN0ZWQgcGFnZSwgX2FmdGVyX1xuICogeW91IGxvYWQgdGhlIHBhZ2UuXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogc2VsZWN0UGFnZShwYWdlKSB7XG4gKiBcdC8vIC4uLiB5b3VyIGNvZGUgdG8gbG9hZCB0aGUgcGFnZSBnb2VzIGhlcmVcbiAqXG4gKiBcdHRoaXMubW9kZWwuY3VycmVudFBhZ2UgPSBwYWdlO1xuICpcbiAqIFx0Ly8gLi4uIGFueXRoaW5nIHlvdSB3YW50IHRvIGRvIGFmdGVyIHBhZ2Ugc2VsZWN0aW9uIGNoYW5nZXMgZ29lcyBoZXJlXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiA8ZXhhbXBsZS11cmw+Li4vLi4vaWZyYW1lLmh0bWw/aWQ9cGFnaW5hdGlvbi1uYXYtLWJhc2ljPC9leGFtcGxlLXVybD5cbiAqL1xuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiBcImlibS1wYWdpbmF0aW9uLW5hdlwiLFxuXHR0ZW1wbGF0ZTogYFxuXHQ8ZGl2PlxuXHRcdDxkaXYgY2xhc3M9XCJieC0tcGFnaW5hdGlvbi1uYXZcIj5cblx0XHRcdDx1bCBjbGFzcz1cImJ4LS1wYWdpbmF0aW9uLW5hdl9fbGlzdFwiPlxuXHRcdFx0XHQ8bGkgY2xhc3M9XCJieC0tcGFnaW5hdGlvbi1uYXZfX2xpc3QtaXRlbVwiPlxuXHRcdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRcdGNsYXNzPVwiYngtLWJ0biBieC0tYnRuLS1naG9zdCBieC0tcGFnaW5hdGlvbi1uYXYtcHJldmlvdXNcblx0XHRcdFx0XHRcdGJ4LS1idG4tLWljb24tb25seSBieC0tdG9vbHRpcF9fdHJpZ2dlciBieC0tdG9vbHRpcC0tYTExeSBieC0tdG9vbHRpcC0tYm90dG9tIGJ4LS10b29sdGlwLS1hbGlnbi1jZW50ZXJcIlxuXHRcdFx0XHRcdFx0W2Rpc2FibGVkXT1cImxlZnRBcnJvd0Rpc2FibGVkXCJcblx0XHRcdFx0XHRcdChjbGljayk9XCJqdW1wVG9QcmV2aW91cygpXCI+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImJ4LS1hc3Npc3RpdmUtdGV4dFwiPnt7cHJldmlvdXNJdGVtVGV4dC5zdWJqZWN0IHwgYXN5bmN9fTwvc3Bhbj5cblx0XHRcdFx0XHRcdDxzdmdcblx0XHRcdFx0XHRcdFx0aWJtSWNvbj1cImNhcmV0LS1sZWZ0XCJcblx0XHRcdFx0XHRcdFx0c2l6ZT1cIjE2XCJcblx0XHRcdFx0XHRcdFx0c3R5bGU9XCJkaXNwbGF5OiBpbmhlcml0XCJcblx0XHRcdFx0XHRcdFx0Y2xhc3M9XCJieC0tYnRuX19pY29uXCI+XG5cdFx0XHRcdFx0XHQ8L3N2Zz5cblx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0PC9saT5cblx0XHRcdFx0PGlibS1wYWdpbmF0aW9uLW5hdi1pdGVtXG5cdFx0XHRcdFx0Km5nSWY9XCJ0aGlzLm51bU9mSXRlbXNUb1Nob3cgPj0gNSB8fCAodGhpcy5udW1PZkl0ZW1zVG9TaG93IDw9IDQgJiYgY3VycmVudFBhZ2UgPD0gMSlcIlxuXHRcdFx0XHRcdHBhZ2U9XCIxXCJcblx0XHRcdFx0XHQoY2xpY2spPVwiY3VycmVudFBhZ2UgPSAxXCJcblx0XHRcdFx0XHRbaXNBY3RpdmVdPVwiY3VycmVudFBhZ2UgPT0gMVwiPlxuXHRcdFx0XHQ8L2libS1wYWdpbmF0aW9uLW5hdi1pdGVtPlxuXHRcdFx0XHQ8aWJtLXBhZ2luYXRpb24tb3ZlcmZsb3dcblx0XHRcdFx0XHQqbmdJZj1cImZyb250Q3V0c1wiXG5cdFx0XHRcdFx0W2NvdW50XT1cImZyb250Q3V0c1wiXG5cdFx0XHRcdFx0W2Zyb21JbmRleF09XCJzdGFydE9mZnNldFwiXG5cdFx0XHRcdFx0KGNoYW5nZSk9XCJoYW5kbGVPdmVyZmxvd1NlbGVjdGlvbigkZXZlbnQpXCI+XG5cdFx0XHRcdDwvaWJtLXBhZ2luYXRpb24tb3ZlcmZsb3c+XG5cdFx0XHRcdDxpYm0tcGFnaW5hdGlvbi1uYXYtaXRlbVxuXHRcdFx0XHRcdCpuZ0Zvcj1cImxldCBwYWdlIG9mIGdldFBhZ2VzKCk7XCJcblx0XHRcdFx0XHRbcGFnZV09XCJwYWdlXCJcblx0XHRcdFx0XHQoY2xpY2spPVwiY3VycmVudFBhZ2UgPSBwYWdlXCJcblx0XHRcdFx0XHRbaXNBY3RpdmVdPVwiY3VycmVudFBhZ2UgPT0gcGFnZVwiPlxuXHRcdFx0XHQ8L2libS1wYWdpbmF0aW9uLW5hdi1pdGVtPlxuXHRcdFx0XHQ8aWJtLXBhZ2luYXRpb24tb3ZlcmZsb3dcblx0XHRcdFx0XHQqbmdJZj1cImJhY2tDdXRzXCJcblx0XHRcdFx0XHRbY291bnRdPVwiYmFja0N1dHNcIlxuXHRcdFx0XHRcdFtmcm9tSW5kZXhdPVwidG90YWxOdW1iZXJzQXJyYXkubGVuZ3RoIC0gYmFja0N1dHMgLSAxXCJcblx0XHRcdFx0XHQoY2hhbmdlKT1cImhhbmRsZU92ZXJmbG93U2VsZWN0aW9uKCRldmVudClcIj5cblx0XHRcdFx0PC9pYm0tcGFnaW5hdGlvbi1vdmVyZmxvdz5cblx0XHRcdFx0PGlibS1wYWdpbmF0aW9uLW5hdi1pdGVtXG5cdFx0XHRcdFx0Km5nSWY9XCJ0b3RhbERhdGFMZW5ndGggPiAxXCJcblx0XHRcdFx0XHRbcGFnZV09XCJ0b3RhbE51bWJlcnNBcnJheS5sZW5ndGhcIlxuXHRcdFx0XHRcdChjbGljayk9XCJjdXJyZW50UGFnZSA9IHRvdGFsTnVtYmVyc0FycmF5Lmxlbmd0aFwiXG5cdFx0XHRcdFx0W2lzQWN0aXZlXT1cImN1cnJlbnRQYWdlID09IHRvdGFsTnVtYmVyc0FycmF5Lmxlbmd0aFwiPlxuXHRcdFx0XHQ8L2libS1wYWdpbmF0aW9uLW5hdi1pdGVtPlxuXHRcdFx0XHQ8bGkgY2xhc3M9XCJieC0tcGFnaW5hdGlvbi1uYXZfX2xpc3QtaXRlbVwiPlxuXHRcdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRcdGNsYXNzPVwiYngtLWJ0biBieC0tYnRuLS1naG9zdCBieC0tcGFnaW5hdGlvbi1uYXYtbmV4dFxuXHRcdFx0XHRcdFx0YngtLWJ0bi0taWNvbi1vbmx5IGJ4LS10b29sdGlwX190cmlnZ2VyIGJ4LS10b29sdGlwLS1hMTF5IGJ4LS10b29sdGlwLS1ib3R0b20gYngtLXRvb2x0aXAtLWFsaWduLWNlbnRlclwiXG5cdFx0XHRcdFx0XHRbZGlzYWJsZWRdPVwicmlnaHRBcnJvd0Rpc2FibGVkXCJcblx0XHRcdFx0XHRcdChjbGljayk9XCJqdW1wVG9OZXh0KClcIj5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiYngtLWFzc2lzdGl2ZS10ZXh0XCI+e3tuZXh0SXRlbVRleHQuc3ViamVjdCB8IGFzeW5jfX08L3NwYW4+XG5cdFx0XHRcdFx0XHQ8c3ZnXG5cdFx0XHRcdFx0XHRcdGlibUljb249XCJjYXJldC0tcmlnaHRcIlxuXHRcdFx0XHRcdFx0XHRzaXplPVwiMTZcIlxuXHRcdFx0XHRcdFx0XHRzdHlsZT1cImRpc3BsYXk6IGluaGVyaXRcIlxuXHRcdFx0XHRcdFx0XHRjbGFzcz1cImJ4LS1idG5fX2ljb25cIj5cblx0XHRcdFx0XHRcdDwvc3ZnPlxuXHRcdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHQ8L2xpPlxuXHRcdFx0PC91bD5cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG5cdGBcbn0pXG5leHBvcnQgY2xhc3MgUGFnaW5hdGlvbk5hdiB7XG5cdHN0YXRpYyBwYWdpbmF0aW9uQ291bnRlciA9IDA7XG5cdC8qKlxuXHQgKiBgUGFnaW5hdGlvbk5hdk1vZGVsYCB3aXRoIHRoZSBpbmZvcm1hdGlvbiBhYm91dCBwYWdlcyB5b3UncmUgY29udHJvbGxpbmcuXG5cdCAqL1xuXHRASW5wdXQoKSBtb2RlbDogUGFnaW5hdGlvbk1vZGVsO1xuXHQvKipcbiBcdCAqIFNldCB0byBgdHJ1ZWAgdG8gZGlzYWJsZSB0aGUgYmFja3dhcmQvZm9yd2FyZCBidXR0b25zLlxuXHQgKi9cblx0QElucHV0KCkgZGlzYWJsZWQgPSBmYWxzZTtcblx0LyoqXG5cdCAqIE51bWJlciBvZiBpdGVtcyB0byBzaG93IGluIHBhZ2luYXRpb24uIE1pbmltdW0gaXMgNC5cblx0ICovXG5cdEBJbnB1dCgpIG51bU9mSXRlbXNUb1Nob3cgPSA0O1xuXG5cdC8qKlxuXHQgKiBFeHBlY3RzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHNvbWUgb3IgYWxsIG9mOlxuXHQgKiBgYGBcblx0ICoge1xuXHQgKlx0XHRcIk5FWFRcIjogXCJOZXh0XCIsXG5cdCAqXHRcdFwiUFJFVklPVVNcIjogXCJQcmV2aW91c1wiLFxuXHQgKiB9XG5cdCAqIGBgYFxuXHQgKi9cblx0QElucHV0KClcblx0c2V0IHRyYW5zbGF0aW9ucyAodmFsdWU6IFBhZ2luYXRpb25OYXZUcmFuc2xhdGlvbnMpIHtcblx0XHRjb25zdCB2YWx1ZVdpdGhEZWZhdWx0cyA9IG1lcmdlKHRoaXMuaTE4bi5nZXRNdWx0aXBsZShcIlBBR0lOQVRJT05cIiksIHZhbHVlKTtcblx0XHR0aGlzLm5leHRJdGVtVGV4dC5vdmVycmlkZSh2YWx1ZVdpdGhEZWZhdWx0cy5ORVhUKTtcblx0XHR0aGlzLnByZXZpb3VzSXRlbVRleHQub3ZlcnJpZGUodmFsdWVXaXRoRGVmYXVsdHMuUFJFVklPVVMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVtaXRzIHRoZSBuZXcgcGFnZSBudW1iZXIuXG5cdCAqXG5cdCAqIFlvdSBzaG91bGQgdGllIGludG8gdGhpcyBhbmQgdXBkYXRlIGBtb2RlbC5jdXJyZW50UGFnZWAgb25jZSB0aGUgZnJlc2hcblx0ICogZGF0YSBpcyBmaW5hbGx5IGxvYWRlZC5cblx0ICovXG5cdEBPdXRwdXQoKSBzZWxlY3RQYWdlID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cblx0Z2V0IHRvdGFsTnVtYmVyc0FycmF5KCkge1xuXHRcdHJldHVybiByYW5nZSh0aGlzLnRvdGFsRGF0YUxlbmd0aCArIDEsIDEpO1xuXHR9XG5cblx0Z2V0IGN1cnJlbnRQYWdlKCkge1xuXHRcdHJldHVybiB0aGlzLm1vZGVsLmN1cnJlbnRQYWdlO1xuXHR9XG5cblx0c2V0IGN1cnJlbnRQYWdlKHZhbHVlKSB7XG5cdFx0dmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXHRcdC8vIGVtaXRzIHRoZSB2YWx1ZSB0byBhbGxvdyB0aGUgdXNlciB0byB1cGRhdGUgY3VycmVudCBwYWdlXG5cdFx0Ly8gaW4gdGhlIG1vZGVsIG9uY2UgdGhlIHBhZ2UgaXMgbG9hZGVkXG5cdFx0dGhpcy5zZWxlY3RQYWdlLmVtaXQodmFsdWUpO1xuXHR9XG5cblx0Z2V0IHRvdGFsRGF0YUxlbmd0aCgpIHtcblx0XHRyZXR1cm4gdGhpcy5tb2RlbC50b3RhbERhdGFMZW5ndGg7XG5cdH1cblxuXHRnZXQgc3RhcnRPZmZzZXQoKSB7XG5cdFx0cmV0dXJuIHRoaXMubnVtT2ZJdGVtc1RvU2hvdyA8PSA0ICYmIHRoaXMuY3VycmVudFBhZ2UgPiAxID8gMCA6IDE7XG5cdH1cblxuXHRnZXQgZnJvbnRDdXRzKCkge1xuXHRcdGNvbnN0IGN1dHMgPSB0aGlzLmdldEN1dHMoKTtcblx0XHRyZXR1cm4gY3V0cy5mcm9udDtcblx0fVxuXG5cdGdldCBiYWNrQ3V0cygpIHtcblx0XHRjb25zdCBjdXRzID0gdGhpcy5nZXRDdXRzKCk7XG5cdFx0cmV0dXJuIGN1dHMuYmFjaztcblx0fVxuXG5cdGdldCBsZWZ0QXJyb3dEaXNhYmxlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5kaXNhYmxlZCB8fCB0aGlzLmN1cnJlbnRQYWdlID09PSAxO1xuXHR9XG5cblx0Z2V0IHJpZ2h0QXJyb3dEaXNhYmxlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5kaXNhYmxlZCB8fCB0aGlzLmN1cnJlbnRQYWdlID09PSB0aGlzLnRvdGFsRGF0YUxlbmd0aDtcblx0fVxuXG5cdG5leHRJdGVtVGV4dCA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlBBR0lOQVRJT04uTkVYVFwiKTtcblx0cHJldmlvdXNJdGVtVGV4dCA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlBBR0lOQVRJT04uUFJFVklPVVNcIik7XG5cblx0Y29uc3RydWN0b3IocHJvdGVjdGVkIGkxOG46IEkxOG4sIHByb3RlY3RlZCBleHBlcmltZW50YWw6IEV4cGVyaW1lbnRhbFNlcnZpY2UpIHtcblx0XHRQYWdpbmF0aW9uTmF2LnBhZ2luYXRpb25Db3VudGVyKys7XG5cdH1cblxuXHRoYW5kbGVPdmVyZmxvd1NlbGVjdGlvbihwYWdlKSB7XG5cdFx0aWYgKHR5cGVvZiBwYWdlID09PSBcIm51bWJlclwiKSB7XG5cdFx0XHR0aGlzLmN1cnJlbnRQYWdlID0gcGFnZTtcblx0XHR9XG5cdH1cblxuXHRwdWJsaWMganVtcFRvTmV4dCgpIHtcblx0XHR0aGlzLmN1cnJlbnRQYWdlID0gdGhpcy5jdXJyZW50UGFnZSA8IHRoaXMudG90YWxEYXRhTGVuZ3RoID8gdGhpcy5jdXJyZW50UGFnZSArIDEgOiB0aGlzLnRvdGFsRGF0YUxlbmd0aDtcblx0fVxuXG5cdHB1YmxpYyBqdW1wVG9QcmV2aW91cygpIHtcblx0XHR0aGlzLmN1cnJlbnRQYWdlID0gdGhpcy5jdXJyZW50UGFnZSA+IDEgPyB0aGlzLmN1cnJlbnRQYWdlIC0gMSA6IDE7XG5cdH1cblxuXHRwdWJsaWMgZ2V0UGFnZXMoKSB7XG5cdFx0aWYgKHRoaXMudG90YWxEYXRhTGVuZ3RoIDw9IDEpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRjb25zdCBjdXRzID0gdGhpcy5nZXRDdXRzKCk7XG5cdFx0cmV0dXJuIHRoaXMudG90YWxOdW1iZXJzQXJyYXkuc2xpY2UodGhpcy5zdGFydE9mZnNldCArIGN1dHMuZnJvbnQsICgxICsgY3V0cy5iYWNrKSAqIC0xKTtcblx0fVxuXG5cdHByaXZhdGUgZ2V0Q3V0cyhzcGxpdFBvaW50ID0gbnVsbCkge1xuXHRcdGNvbnN0IHBhZ2UgPSB0aGlzLmN1cnJlbnRQYWdlIC0gMTtcblx0XHRjb25zdCB0b3RhbEl0ZW1zID0gdGhpcy50b3RhbERhdGFMZW5ndGg7XG5cdFx0Y29uc3QgaXRlbXNUaGF0Rml0ID0gdGhpcy5udW1PZkl0ZW1zVG9TaG93O1xuXG5cdFx0aWYgKGl0ZW1zVGhhdEZpdCA+PSB0b3RhbEl0ZW1zKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRmcm9udDogMCxcblx0XHRcdFx0YmFjazogMFxuXHRcdFx0fTtcblx0XHR9XG5cdFx0Y29uc3Qgc3BsaXQgPSBzcGxpdFBvaW50IHx8IE1hdGguY2VpbChpdGVtc1RoYXRGaXQgLyAyKSAtIDE7XG5cdFx0bGV0IGZyb250SGlkZGVuID0gcGFnZSArIDEgLSBzcGxpdDtcblx0XHRsZXQgYmFja0hpZGRlbiA9IHRvdGFsSXRlbXMgLSBwYWdlIC0gKGl0ZW1zVGhhdEZpdCAtIHNwbGl0KSArIDE7XG5cblx0XHRpZiAoZnJvbnRIaWRkZW4gPD0gMSkge1xuXHRcdFx0YmFja0hpZGRlbiAtPSBmcm9udEhpZGRlbiA8PSAwID8gTWF0aC5hYnMoZnJvbnRIaWRkZW4pICsgMSA6IDA7XG5cdFx0XHRmcm9udEhpZGRlbiA9IDA7XG5cdFx0fVxuXHRcdGlmIChiYWNrSGlkZGVuIDw9IDEpIHtcblx0XHRcdGZyb250SGlkZGVuIC09IGJhY2tIaWRkZW4gPD0gMCA/IE1hdGguYWJzKGJhY2tIaWRkZW4pICsgMSA6IDA7XG5cdFx0XHRiYWNrSGlkZGVuID0gMDtcblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdGZyb250OiBmcm9udEhpZGRlbixcblx0XHRcdGJhY2s6IGJhY2tIaWRkZW5cblx0XHR9O1xuXHR9XG59XG4iXX0=