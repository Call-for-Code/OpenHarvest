/**
 *
 * carbon-angular v0.0.0 | scroll.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { map } from "rxjs/operators";
import { fromEvent, merge } from "rxjs";
/**
 * Checks if a given element is scrollable.
 * If the element has an overflow set as part of its computed style it can scroll.
 * @param element the element to check scrollability
 */
export const isScrollableElement = (element) => {
    const computedStyle = getComputedStyle(element);
    return (computedStyle.overflow === "auto" ||
        computedStyle.overflow === "scroll" ||
        computedStyle["overflow-y"] === "auto" ||
        computedStyle["overflow-y"] === "scroll" ||
        computedStyle["overflow-x"] === "auto" ||
        computedStyle["overflow-x"] === "scroll");
};
/**
 * Checks if an element is visible within a container
 * @param element the element to check
 * @param container the container to check
 */
export const isVisibleInContainer = (element, container) => {
    const elementRect = element.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    // If there exists `height: 100%` on the `html` or `body` tag of an application,
    // it causes the calculation to return true if you need to scroll before the element is seen.
    // In that case we calculate its visibility based on the window viewport.
    if (container.tagName === "BODY" || container.tagName === "HTML") {
        // This checks if element is within the top, bottom, left and right of viewport, ie. if the element is visible in
        // the screen. This also takes into account partial visibility of an element.
        const isAboveViewport = elementRect.top < 0 && (elementRect.top + element.clientHeight) < 0;
        const isLeftOfViewport = elementRect.left < 0;
        const isBelowViewport = (elementRect.bottom - element.clientHeight) > (window.innerHeight || document.documentElement.clientHeight);
        const isRightOfViewport = elementRect.right > (window.innerWidth || document.documentElement.clientWidth);
        const isVisibleInViewport = !(isAboveViewport || isBelowViewport || isLeftOfViewport || isRightOfViewport);
        return isVisibleInViewport;
    }
    return (
    // This also accounts for partial visibility. It will still return true if the element is partially visible inside the container.
    (elementRect.bottom - element.clientHeight) <= (containerRect.bottom + (container.offsetHeight - container.clientHeight) / 2) &&
        elementRect.top >= (-element.clientHeight));
};
export const getScrollableParents = (node) => {
    const elements = [document.body];
    while (node.parentElement && node !== document.body) {
        if (isScrollableElement(node)) {
            elements.push(node);
        }
        node = node.parentElement;
    }
    return elements;
};
export const hasScrollableParents = (node) => {
    while (node.parentElement && node !== document.body) {
        if (isScrollableElement(node)) {
            return true;
        }
        node = node.parentElement;
    }
    return false;
};
/**
 * Returns an observable that emits whenever any scrollable parent element scrolls
 *
 * @param node root element to start finding scrolling parents from
 */
export const scrollableParentsObservable = (node) => {
    const windowScroll = fromEvent(window, "scroll", { passive: true }).pipe(map(event => (
    // update the event target to be something useful. In this case `body` is a sensible replacement
    Object.assign({}, event, { target: document.body }))));
    let observables = [windowScroll];
    // walk the parents and subscribe to all the scroll events we can
    while (node.parentElement && node !== document.body) {
        if (isScrollableElement(node)) {
            observables.push(fromEvent(node, "scroll", { passive: true }));
        }
        node = node.parentElement;
    }
    return merge(...observables);
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Nyb2xsLmpzIiwic291cmNlUm9vdCI6Im5nOi8vY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci91dGlscy8iLCJzb3VyY2VzIjpbInNjcm9sbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDckMsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFHcEQ7Ozs7R0FJRztBQUNILE1BQU0sQ0FBQyxNQUFNLG1CQUFtQixHQUFHLENBQUMsT0FBb0IsRUFBRSxFQUFFO0lBQzNELE1BQU0sYUFBYSxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ2hELE9BQU8sQ0FDTixhQUFhLENBQUMsUUFBUSxLQUFLLE1BQU07UUFDakMsYUFBYSxDQUFDLFFBQVEsS0FBSyxRQUFRO1FBQ25DLGFBQWEsQ0FBQyxZQUFZLENBQUMsS0FBSyxNQUFNO1FBQ3RDLGFBQWEsQ0FBQyxZQUFZLENBQUMsS0FBSyxRQUFRO1FBQ3hDLGFBQWEsQ0FBQyxZQUFZLENBQUMsS0FBSyxNQUFNO1FBQ3RDLGFBQWEsQ0FBQyxZQUFZLENBQUMsS0FBSyxRQUFRLENBQ3hDLENBQUM7QUFDSCxDQUFDLENBQUM7QUFFRjs7OztHQUlHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sb0JBQW9CLEdBQUcsQ0FBQyxPQUFvQixFQUFFLFNBQXNCLEVBQUUsRUFBRTtJQUNwRixNQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMscUJBQXFCLEVBQUUsQ0FBQztJQUNwRCxNQUFNLGFBQWEsR0FBRyxTQUFTLENBQUMscUJBQXFCLEVBQUUsQ0FBQztJQUN4RCxnRkFBZ0Y7SUFDaEYsNkZBQTZGO0lBQzdGLHlFQUF5RTtJQUN6RSxJQUFJLFNBQVMsQ0FBQyxPQUFPLEtBQUssTUFBTSxJQUFJLFNBQVMsQ0FBQyxPQUFPLEtBQUssTUFBTSxFQUFFO1FBQ2pFLGlIQUFpSDtRQUNqSCw2RUFBNkU7UUFDN0UsTUFB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QVcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQy9EO1FBQ0QsSUFBSSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUM7S0FDMUI7SUFFRCxPQUFPLEtBQUssQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDO0FBQzlCLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1hcCB9IGZyb20gXCJyeGpzL29wZXJhdG9yc1wiO1xuaW1wb3J0IHsgZnJvbUV2ZW50LCBtZXJnZSwgT2JzZXJ2YWJsZSB9IGZyb20gXCJyeGpzXCI7XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBlbGVtZW50IGlzIHNjcm9sbGFibGUuXG4gKiBJZiB0aGUgZWxlbWVudCBoYXMgYW4gb3ZlcmZsb3cgc2V0IGFzIHBhcnQgb2YgaXRzIGNvbXB1dGVkIHN0eWxlIGl0IGNhbiBzY3JvbGwuXG4gKiBAcGFyYW0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBjaGVjayBzY3JvbGxhYmlsaXR5XG4gKi9cbmV4cG9ydCBjb25zdCBpc1Njcm9sbGFibGVFbGVtZW50ID0gKGVsZW1lbnQ6IEhUTUxFbGVtZW50KSA9PiB7XG5cdGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXHRyZXR1cm4gKFxuXHRcdGNvbXB1dGVkU3R5bGUub3ZlcmZsb3cgPT09IFwiYXV0b1wiIHx8XG5cdFx0Y29tcHV0ZWRTdHlsZS5vdmVyZmxvdyA9PT0gXCJzY3JvbGxcIiB8fFxuXHRcdGNvbXB1dGVkU3R5bGVbXCJvdmVyZmxvdy15XCJdID09PSBcImF1dG9cIiB8fFxuXHRcdGNvbXB1dGVkU3R5bGVbXCJvdmVyZmxvdy15XCJdID09PSBcInNjcm9sbFwiIHx8XG5cdFx0Y29tcHV0ZWRTdHlsZVtcIm92ZXJmbG93LXhcIl0gPT09IFwiYXV0b1wiIHx8XG5cdFx0Y29tcHV0ZWRTdHlsZVtcIm92ZXJmbG93LXhcIl0gPT09IFwic2Nyb2xsXCJcblx0KTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGVsZW1lbnQgaXMgdmlzaWJsZSB3aXRoaW4gYSBjb250YWluZXJcbiAqIEBwYXJhbSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcGFyYW0gY29udGFpbmVyIHRoZSBjb250YWluZXIgdG8gY2hlY2tcbiAqL1xuZXhwb3J0IGNvbnN0IGlzVmlzaWJsZUluQ29udGFpbmVyID0gKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBjb250YWluZXI6IEhUTUxFbGVtZW50KSA9PiB7XG5cdGNvbnN0IGVsZW1lbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0Y29uc3QgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0Ly8gSWYgdGhlcmUgZXhpc3RzIGBoZWlnaHQ6IDEwMCVgIG9uIHRoZSBgaHRtbGAgb3IgYGJvZHlgIHRhZyBvZiBhbiBhcHBsaWNhdGlvbixcblx0Ly8gaXQgY2F1c2VzIHRoZSBjYWxjdWxhdGlvbiB0byByZXR1cm4gdHJ1ZSBpZiB5b3UgbmVlZCB0byBzY3JvbGwgYmVmb3JlIHRoZSBlbGVtZW50IGlzIHNlZW4uXG5cdC8vIEluIHRoYXQgY2FzZSB3ZSBjYWxjdWxhdGUgaXRzIHZpc2liaWxpdHkgYmFzZWQgb24gdGhlIHdpbmRvdyB2aWV3cG9ydC5cblx0aWYgKGNvbnRhaW5lci50YWdOYW1lID09PSBcIkJPRFlcIiB8fCBjb250YWluZXIudGFnTmFtZSA9PT0gXCJIVE1MXCIpIHtcblx0XHQvLyBUaGlzIGNoZWNrcyBpZiBlbGVtZW50IGlzIHdpdGhpbiB0aGUgdG9wLCBib3R0b20sIGxlZnQgYW5kIHJpZ2h0IG9mIHZpZXdwb3J0LCBpZS4gaWYgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpblxuXHRcdC8vIHRoZSBzY3JlZW4uIFRoaXMgYWxzbyB0YWtlcyBpbnRvIGFjY291bnQgcGFydGlhbCB2aXNpYmlsaXR5IG9mIGFuIGVsZW1lbnQuXG5cdFx0Y29uc3QgaXNBYm92ZVZpZXdwb3J0ID0gZWxlbWVudFJlY3QudG9wIDwgMCAmJiAoZWxlbWVudFJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQpIDwgMDtcblx0XHRjb25zdCBpc0xlZnRPZlZpZXdwb3J0ID0gZWxlbWVudFJlY3QubGVmdCA8IDA7XG5cdFx0Y29uc3QgaXNCZWxvd1ZpZXdwb3J0ID1cblx0XHRcdChlbGVtZW50UmVjdC5ib3R0b20gLSBlbGVtZW50LmNsaWVudEhlaWdodCkgPiAod2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpO1xuXHRcdGNvbnN0IGlzUmlnaHRPZlZpZXdwb3J0ID0gZWxlbWVudFJlY3QucmlnaHQgPiAod2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKTtcblxuXHRcdGNvbnN0IGlzVmlzaWJsZUluVmlld3BvcnQgPSAhKGlzQWJvdmVWaWV3cG9ydCB8fCBpc0JlbG93Vmlld3BvcnQgfHwgaXNMZWZ0T2ZWaWV3cG9ydCB8fCBpc1JpZ2h0T2ZWaWV3cG9ydCk7XG5cblx0XHRyZXR1cm4gaXNWaXNpYmxlSW5WaWV3cG9ydDtcblx0fVxuXHRyZXR1cm4gKFxuXHRcdC8vIFRoaXMgYWxzbyBhY2NvdW50cyBmb3IgcGFydGlhbCB2aXNpYmlsaXR5LiBJdCB3aWxsIHN0aWxsIHJldHVybiB0cnVlIGlmIHRoZSBlbGVtZW50IGlzIHBhcnRpYWxseSB2aXNpYmxlIGluc2lkZSB0aGUgY29udGFpbmVyLlxuXHRcdChlbGVtZW50UmVjdC5ib3R0b20gLSBlbGVtZW50LmNsaWVudEhlaWdodCkgPD0gKGNvbnRhaW5lclJlY3QuYm90dG9tICsgKGNvbnRhaW5lci5vZmZzZXRIZWlnaHQgLSBjb250YWluZXIuY2xpZW50SGVpZ2h0KSAvIDIpICYmXG5cdFx0ZWxlbWVudFJlY3QudG9wID49ICgtIGVsZW1lbnQuY2xpZW50SGVpZ2h0KVxuXHQpO1xufTtcblxuXG5leHBvcnQgY29uc3QgZ2V0U2Nyb2xsYWJsZVBhcmVudHMgPSAobm9kZTogSFRNTEVsZW1lbnQpID0+IHtcblx0Y29uc3QgZWxlbWVudHMgPSBbZG9jdW1lbnQuYm9keV07XG5cdHdoaWxlIChub2RlLnBhcmVudEVsZW1lbnQgJiYgbm9kZSAhPT0gZG9jdW1lbnQuYm9keSkge1xuXHRcdGlmIChpc1Njcm9sbGFibGVFbGVtZW50KG5vZGUpKSB7XG5cdFx0XHRlbGVtZW50cy5wdXNoKG5vZGUpO1xuXHRcdH1cblx0XHRub2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuXHR9XG5cdHJldHVybiBlbGVtZW50cztcbn07XG5cbmV4cG9ydCBjb25zdCBoYXNTY3JvbGxhYmxlUGFyZW50cyA9IChub2RlOiBIVE1MRWxlbWVudCkgPT4ge1xuXHR3aGlsZSAobm9kZS5wYXJlbnRFbGVtZW50ICYmIG5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHtcblx0XHRpZiAoaXNTY3JvbGxhYmxlRWxlbWVudChub2RlKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdG5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgdGhhdCBlbWl0cyB3aGVuZXZlciBhbnkgc2Nyb2xsYWJsZSBwYXJlbnQgZWxlbWVudCBzY3JvbGxzXG4gKlxuICogQHBhcmFtIG5vZGUgcm9vdCBlbGVtZW50IHRvIHN0YXJ0IGZpbmRpbmcgc2Nyb2xsaW5nIHBhcmVudHMgZnJvbVxuICovXG5leHBvcnQgY29uc3Qgc2Nyb2xsYWJsZVBhcmVudHNPYnNlcnZhYmxlID0gKG5vZGU6IEhUTUxFbGVtZW50KTogT2JzZXJ2YWJsZTxFdmVudD4gPT4ge1xuXHRjb25zdCB3aW5kb3dTY3JvbGwgPSBmcm9tRXZlbnQod2luZG93LCBcInNjcm9sbFwiLCB7IHBhc3NpdmU6IHRydWUgfSkucGlwZShtYXAoZXZlbnQgPT4gKFxuXHRcdC8vIHVwZGF0ZSB0aGUgZXZlbnQgdGFyZ2V0IHRvIGJlIHNvbWV0aGluZyB1c2VmdWwuIEluIHRoaXMgY2FzZSBgYm9keWAgaXMgYSBzZW5zaWJsZSByZXBsYWNlbWVudFxuXHRcdE9iamVjdC5hc3NpZ24oe30sIGV2ZW50LCB7IHRhcmdldDogZG9jdW1lbnQuYm9keSB9KSBhcyBFdmVudFxuXHQpKSk7XG5cdGxldCBvYnNlcnZhYmxlcyA9IFt3aW5kb3dTY3JvbGxdO1xuXHQvLyB3YWxrIHRoZSBwYXJlbnRzIGFuZCBzdWJzY3JpYmUgdG8gYWxsIHRoZSBzY3JvbGwgZXZlbnRzIHdlIGNhblxuXHR3aGlsZSAobm9kZS5wYXJlbnRFbGVtZW50ICYmIG5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHtcblx0XHRpZiAoaXNTY3JvbGxhYmxlRWxlbWVudChub2RlKSkge1xuXHRcdFx0b2JzZXJ2YWJsZXMucHVzaChmcm9tRXZlbnQobm9kZSwgXCJzY3JvbGxcIiwgeyBwYXNzaXZlOiB0cnVlIH0pKTtcblx0XHR9XG5cdFx0bm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcblx0fVxuXG5cdHJldHVybiBtZXJnZSguLi5vYnNlcnZhYmxlcyk7XG59O1xuIl19