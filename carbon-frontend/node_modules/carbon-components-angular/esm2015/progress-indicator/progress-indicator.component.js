/**
 *
 * carbon-angular v0.0.0 | progress-indicator.component.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Component, Input, Output, EventEmitter } from "@angular/core";
import { ExperimentalService } from "carbon-components-angular/experimental";
/**
 * [See demo](../../?path=/story/progress-indicator--basic)
 *
 * <example-url>../../iframe.html?id=progress-indicator--basic</example-url>
 */
export class ProgressIndicator {
    constructor(experimental) {
        this.experimental = experimental;
        this.stepSelected = new EventEmitter();
        this.orientation = "horizontal";
        this.skeleton = false;
        this.spacing = "default";
    }
    static skeletonSteps(stepCount) {
        const steps = [];
        for (let i = 0; i < stepCount; i++) {
            steps.push({ "state": ["incomplete"] });
        }
        return steps;
    }
    get current() {
        return this.steps.findIndex(step => step.state.includes("current"));
    }
    set current(current) {
        this._current = current;
    }
    ngOnChanges(changes) {
        if (changes.steps || changes.current) {
            this.setProgressIndicatorStates();
        }
    }
    setProgressIndicatorStates() {
        if (this.steps === undefined) {
            return;
        }
        if (this._current === undefined || this._current < 0) {
            for (let i = 0; i < this.steps.length; i++) {
                this.steps[i].state[0] = "incomplete";
            }
            return;
        }
        if (this._current > this.steps.length - 1) {
            for (let i = 0; i < this.steps.length; i++) {
                this.steps[i].state[0] = "complete";
            }
            return;
        }
        this.steps[this._current].state[0] = "current";
        for (let i = 0; i < this._current; i++) {
            this.steps[i].state[0] = "complete";
        }
        for (let i = this._current + 1; i < this.steps.length; i++) {
            this.steps[i].state[0] = "incomplete";
        }
    }
}
ProgressIndicator.decorators = [
    { type: Component, args: [{
                selector: "ibm-progress-indicator",
                template: `
	<ul
		data-progress
		data-progress-current
		class="bx--progress"
		[ngClass]="{
			'bx--skeleton': skeleton,
			'bx--progress--vertical': (orientation === 'vertical'),
			'bx--progress--space-equal': spacing === 'equal' && orientation !== 'vertical'
		}">
		<li
			class="bx--progress-step bx--progress-step--{{step.state[0]}}"
			*ngFor="let step of steps; let i = index"
			[ngClass]="{'bx--progress-step--disabled' : step.disabled}">
			<div class="bx--progress-step-button bx--progress-step-button--unclickable" role="button" tabindex="-1">
				<svg ibmIcon="checkmark--outline" size="16" *ngIf="step.state.includes('complete')"></svg>
				<svg *ngIf="step.state.includes('current')">
					<path d="M 7, 7 m -7, 0 a 7,7 0 1,0 14,0 a 7,7 0 1,0 -14,0" ></path>
				</svg>
				<svg *ngIf="step.state.includes('incomplete')">
					<path
						d="M8 1C4.1 1 1 4.1 1 8s3.1 7 7 7 7-3.1 7-7-3.1-7-7-7zm0 13c-3.3 0-6-2.7-6-6s2.7-6 6-6 6 2.7 6 6-2.7 6-6 6z">
					</path>
				</svg>
				<svg ibmIcon="warning" size="16" *ngIf="step.state.includes('error')" class="bx--progress__warning"></svg>
				<p
					class="bx--progress-label"
					*ngIf="step.tooltip"
					[ibmTooltip]="step.tooltip.content"
					[trigger]="step.tooltip.trigger"
					[placement]="step.tooltip.placement"
					[title]="step.tooltip.title"
					[gap]="step.tooltip.gap"
					[appendInline]="step.tooltip.appendInline"
					[data]="step.tooltip.data"
					(click)="stepSelected.emit({ step: step, index: i })">
					{{step.text}}
				</p>
				<p class="bx--progress-label" *ngIf="!step.tooltip" (click)="stepSelected.emit({ step: step, index: i })">{{step.text}}</p>
				<p *ngIf="step.optionalText" class="bx--progress-optional">{{step.optionalText}}</p>
				<span class="bx--progress-line"></span>
			</div>
		</li>
	</ul>
	`
            }] }
];
/** @nocollapse */
ProgressIndicator.ctorParameters = () => [
    { type: ExperimentalService }
];
ProgressIndicator.propDecorators = {
    stepSelected: [{ type: Output }],
    steps: [{ type: Input }],
    orientation: [{ type: Input }],
    skeleton: [{ type: Input }],
    spacing: [{ type: Input }],
    current: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3MtaW5kaWNhdG9yLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvcHJvZ3Jlc3MtaW5kaWNhdG9yLyIsInNvdXJjZXMiOlsicHJvZ3Jlc3MtaW5kaWNhdG9yLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBRzdFOzs7O0dBSUc7QUFpREgsTUFBTSxPQUFPLGlCQUFpQjtJQXlCN0IsWUFBc0IsWUFBaUM7UUFBakMsaUJBQVksR0FBWixZQUFZLENBQXFCO1FBZjdDLGlCQUFZLEdBQUcsSUFBSSxZQUFZLEVBQWlDLENBQUM7UUFHbEUsZ0JBQVcsR0FBOEIsWUFBWSxDQUFDO1FBQ3RELGFBQVEsR0FBRyxLQUFLLENBQUM7UUFDakIsWUFBTyxHQUF3QixTQUFTLENBQUM7SUFVUSxDQUFDO0lBeEIzRCxNQUFNLENBQUMsYUFBYSxDQUFDLFNBQWlCO1FBQ3JDLE1BQU0sS0FBSyxHQUFHLEVBQUUsQ0FBQztRQUNqQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ25DLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBQyxPQUFPLEVBQUUsQ0FBQyxZQUFZLENBQUMsRUFBQyxDQUFDLENBQUM7U0FDdEM7UUFFRCxPQUFPLEtBQUssQ0FBQztJQUNkLENBQUM7SUFTRCxJQUFhLE9BQU87UUFDbkIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7SUFDckUsQ0FBQztJQUNELElBQUksT0FBTyxDQUFDLE9BQWU7UUFDMUIsSUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUM7SUFDekIsQ0FBQztJQUtELFdBQVcsQ0FBQyxPQUFzQjtRQUNqQyxJQUFJLE9BQU8sQ0FBQyxLQUFLLElBQUksT0FBTyxDQUFDLE9BQU8sRUFBRTtZQUNyQyxJQUFJLENBQUMsMEJBQTBCLEVBQUUsQ0FBQztTQUNsQztJQUNGLENBQUM7SUFFTywwQkFBMEI7UUFDakMsSUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLFNBQVMsRUFBRTtZQUM3QixPQUFPO1NBQ1A7UUFFRCxJQUFJLElBQUksQ0FBQyxRQUFRLEtBQUssU0FBUyxJQUFJLElBQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxFQUFFO1lBQ3JELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDM0MsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsWUFBWSxDQUFDO2FBQ3RDO1lBQ0QsT0FBTztTQUNQO1FBRUQsSUFBSSxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUMxQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQzNDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQzthQUNwQztZQUNELE9BQU87U0FDUDtRQUNELElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUM7UUFDL0MsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDdkMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDO1NBQ3BDO1FBQ0QsS0FBSyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDM0QsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsWUFBWSxDQUFDO1NBQ3RDO0lBQ0YsQ0FBQzs7O1lBMUdELFNBQVMsU0FBQztnQkFDVixRQUFRLEVBQUUsd0JBQXdCO2dCQUNsQyxRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBNENUO2FBQ0Q7Ozs7WUF2RFEsbUJBQW1COzs7MkJBa0UxQixNQUFNO29CQUVOLEtBQUs7MEJBQ0wsS0FBSzt1QkFDTCxLQUFLO3NCQUNMLEtBQUs7c0JBRUwsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdENvbXBvbmVudCxcblx0SW5wdXQsXG5cdE91dHB1dCxcblx0RXZlbnRFbWl0dGVyLCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXNcbn0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IEV4cGVyaW1lbnRhbFNlcnZpY2UgfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9leHBlcmltZW50YWxcIjtcbmltcG9ydCB7IFN0ZXAgfSBmcm9tIFwiLi9wcm9ncmVzcy1pbmRpY2F0b3Itc3RlcC5pbnRlcmZhY2VcIjtcblxuLyoqXG4gKiBbU2VlIGRlbW9dKC4uLy4uLz9wYXRoPS9zdG9yeS9wcm9ncmVzcy1pbmRpY2F0b3ItLWJhc2ljKVxuICpcbiAqIDxleGFtcGxlLXVybD4uLi8uLi9pZnJhbWUuaHRtbD9pZD1wcm9ncmVzcy1pbmRpY2F0b3ItLWJhc2ljPC9leGFtcGxlLXVybD5cbiAqL1xuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiBcImlibS1wcm9ncmVzcy1pbmRpY2F0b3JcIixcblx0dGVtcGxhdGU6IGBcblx0PHVsXG5cdFx0ZGF0YS1wcm9ncmVzc1xuXHRcdGRhdGEtcHJvZ3Jlc3MtY3VycmVudFxuXHRcdGNsYXNzPVwiYngtLXByb2dyZXNzXCJcblx0XHRbbmdDbGFzc109XCJ7XG5cdFx0XHQnYngtLXNrZWxldG9uJzogc2tlbGV0b24sXG5cdFx0XHQnYngtLXByb2dyZXNzLS12ZXJ0aWNhbCc6IChvcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyksXG5cdFx0XHQnYngtLXByb2dyZXNzLS1zcGFjZS1lcXVhbCc6IHNwYWNpbmcgPT09ICdlcXVhbCcgJiYgb3JpZW50YXRpb24gIT09ICd2ZXJ0aWNhbCdcblx0XHR9XCI+XG5cdFx0PGxpXG5cdFx0XHRjbGFzcz1cImJ4LS1wcm9ncmVzcy1zdGVwIGJ4LS1wcm9ncmVzcy1zdGVwLS17e3N0ZXAuc3RhdGVbMF19fVwiXG5cdFx0XHQqbmdGb3I9XCJsZXQgc3RlcCBvZiBzdGVwczsgbGV0IGkgPSBpbmRleFwiXG5cdFx0XHRbbmdDbGFzc109XCJ7J2J4LS1wcm9ncmVzcy1zdGVwLS1kaXNhYmxlZCcgOiBzdGVwLmRpc2FibGVkfVwiPlxuXHRcdFx0PGRpdiBjbGFzcz1cImJ4LS1wcm9ncmVzcy1zdGVwLWJ1dHRvbiBieC0tcHJvZ3Jlc3Mtc3RlcC1idXR0b24tLXVuY2xpY2thYmxlXCIgcm9sZT1cImJ1dHRvblwiIHRhYmluZGV4PVwiLTFcIj5cblx0XHRcdFx0PHN2ZyBpYm1JY29uPVwiY2hlY2ttYXJrLS1vdXRsaW5lXCIgc2l6ZT1cIjE2XCIgKm5nSWY9XCJzdGVwLnN0YXRlLmluY2x1ZGVzKCdjb21wbGV0ZScpXCI+PC9zdmc+XG5cdFx0XHRcdDxzdmcgKm5nSWY9XCJzdGVwLnN0YXRlLmluY2x1ZGVzKCdjdXJyZW50JylcIj5cblx0XHRcdFx0XHQ8cGF0aCBkPVwiTSA3LCA3IG0gLTcsIDAgYSA3LDcgMCAxLDAgMTQsMCBhIDcsNyAwIDEsMCAtMTQsMFwiID48L3BhdGg+XG5cdFx0XHRcdDwvc3ZnPlxuXHRcdFx0XHQ8c3ZnICpuZ0lmPVwic3RlcC5zdGF0ZS5pbmNsdWRlcygnaW5jb21wbGV0ZScpXCI+XG5cdFx0XHRcdFx0PHBhdGhcblx0XHRcdFx0XHRcdGQ9XCJNOCAxQzQuMSAxIDEgNC4xIDEgOHMzLjEgNyA3IDcgNy0zLjEgNy03LTMuMS03LTctN3ptMCAxM2MtMy4zIDAtNi0yLjctNi02czIuNy02IDYtNiA2IDIuNyA2IDYtMi43IDYtNiA2elwiPlxuXHRcdFx0XHRcdDwvcGF0aD5cblx0XHRcdFx0PC9zdmc+XG5cdFx0XHRcdDxzdmcgaWJtSWNvbj1cIndhcm5pbmdcIiBzaXplPVwiMTZcIiAqbmdJZj1cInN0ZXAuc3RhdGUuaW5jbHVkZXMoJ2Vycm9yJylcIiBjbGFzcz1cImJ4LS1wcm9ncmVzc19fd2FybmluZ1wiPjwvc3ZnPlxuXHRcdFx0XHQ8cFxuXHRcdFx0XHRcdGNsYXNzPVwiYngtLXByb2dyZXNzLWxhYmVsXCJcblx0XHRcdFx0XHQqbmdJZj1cInN0ZXAudG9vbHRpcFwiXG5cdFx0XHRcdFx0W2libVRvb2x0aXBdPVwic3RlcC50b29sdGlwLmNvbnRlbnRcIlxuXHRcdFx0XHRcdFt0cmlnZ2VyXT1cInN0ZXAudG9vbHRpcC50cmlnZ2VyXCJcblx0XHRcdFx0XHRbcGxhY2VtZW50XT1cInN0ZXAudG9vbHRpcC5wbGFjZW1lbnRcIlxuXHRcdFx0XHRcdFt0aXRsZV09XCJzdGVwLnRvb2x0aXAudGl0bGVcIlxuXHRcdFx0XHRcdFtnYXBdPVwic3RlcC50b29sdGlwLmdhcFwiXG5cdFx0XHRcdFx0W2FwcGVuZElubGluZV09XCJzdGVwLnRvb2x0aXAuYXBwZW5kSW5saW5lXCJcblx0XHRcdFx0XHRbZGF0YV09XCJzdGVwLnRvb2x0aXAuZGF0YVwiXG5cdFx0XHRcdFx0KGNsaWNrKT1cInN0ZXBTZWxlY3RlZC5lbWl0KHsgc3RlcDogc3RlcCwgaW5kZXg6IGkgfSlcIj5cblx0XHRcdFx0XHR7e3N0ZXAudGV4dH19XG5cdFx0XHRcdDwvcD5cblx0XHRcdFx0PHAgY2xhc3M9XCJieC0tcHJvZ3Jlc3MtbGFiZWxcIiAqbmdJZj1cIiFzdGVwLnRvb2x0aXBcIiAoY2xpY2spPVwic3RlcFNlbGVjdGVkLmVtaXQoeyBzdGVwOiBzdGVwLCBpbmRleDogaSB9KVwiPnt7c3RlcC50ZXh0fX08L3A+XG5cdFx0XHRcdDxwICpuZ0lmPVwic3RlcC5vcHRpb25hbFRleHRcIiBjbGFzcz1cImJ4LS1wcm9ncmVzcy1vcHRpb25hbFwiPnt7c3RlcC5vcHRpb25hbFRleHR9fTwvcD5cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJieC0tcHJvZ3Jlc3MtbGluZVwiPjwvc3Bhbj5cblx0XHRcdDwvZGl2PlxuXHRcdDwvbGk+XG5cdDwvdWw+XG5cdGBcbn0pXG5leHBvcnQgY2xhc3MgUHJvZ3Jlc3NJbmRpY2F0b3IgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuXHRzdGF0aWMgc2tlbGV0b25TdGVwcyhzdGVwQ291bnQ6IG51bWJlcikge1xuXHRcdGNvbnN0IHN0ZXBzID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdGVwQ291bnQ7IGkrKykge1xuXHRcdFx0c3RlcHMucHVzaCh7XCJzdGF0ZVwiOiBbXCJpbmNvbXBsZXRlXCJdfSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0ZXBzO1xuXHR9XG5cblx0QE91dHB1dCgpIHN0ZXBTZWxlY3RlZCA9IG5ldyBFdmVudEVtaXR0ZXI8eyBzdGVwOiBTdGVwLCBpbmRleDogbnVtYmVyIH0+KCk7XG5cblx0QElucHV0KCkgc3RlcHM6IEFycmF5PFN0ZXA+O1xuXHRASW5wdXQoKSBvcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCIgPSBcImhvcml6b250YWxcIjtcblx0QElucHV0KCkgc2tlbGV0b24gPSBmYWxzZTtcblx0QElucHV0KCkgc3BhY2luZzogXCJkZWZhdWx0XCIgfCBcImVxdWFsXCIgPSBcImRlZmF1bHRcIjtcblxuXHRASW5wdXQoKSBnZXQgY3VycmVudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5zdGVwcy5maW5kSW5kZXgoc3RlcCA9PiBzdGVwLnN0YXRlLmluY2x1ZGVzKFwiY3VycmVudFwiKSk7XG5cdH1cblx0c2V0IGN1cnJlbnQoY3VycmVudDogbnVtYmVyKSB7XG5cdFx0dGhpcy5fY3VycmVudCA9IGN1cnJlbnQ7XG5cdH1cblx0cHJpdmF0ZSBfY3VycmVudDogbnVtYmVyO1xuXG5cdGNvbnN0cnVjdG9yKHByb3RlY3RlZCBleHBlcmltZW50YWw6IEV4cGVyaW1lbnRhbFNlcnZpY2UpIHt9XG5cblx0bmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuXHRcdGlmIChjaGFuZ2VzLnN0ZXBzIHx8IGNoYW5nZXMuY3VycmVudCkge1xuXHRcdFx0dGhpcy5zZXRQcm9ncmVzc0luZGljYXRvclN0YXRlcygpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgc2V0UHJvZ3Jlc3NJbmRpY2F0b3JTdGF0ZXMoKSB7XG5cdFx0aWYgKHRoaXMuc3RlcHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9jdXJyZW50ID09PSB1bmRlZmluZWQgfHwgdGhpcy5fY3VycmVudCA8IDApIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGVwcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLnN0ZXBzW2ldLnN0YXRlWzBdID0gXCJpbmNvbXBsZXRlXCI7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX2N1cnJlbnQgPiB0aGlzLnN0ZXBzLmxlbmd0aCAtIDEpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGVwcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLnN0ZXBzW2ldLnN0YXRlWzBdID0gXCJjb21wbGV0ZVwiO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLnN0ZXBzW3RoaXMuX2N1cnJlbnRdLnN0YXRlWzBdID0gXCJjdXJyZW50XCI7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9jdXJyZW50OyBpKyspIHtcblx0XHRcdHRoaXMuc3RlcHNbaV0uc3RhdGVbMF0gPSBcImNvbXBsZXRlXCI7XG5cdFx0fVxuXHRcdGZvciAobGV0IGkgPSB0aGlzLl9jdXJyZW50ICsgMTsgaSA8IHRoaXMuc3RlcHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMuc3RlcHNbaV0uc3RhdGVbMF0gPSBcImluY29tcGxldGVcIjtcblx0XHR9XG5cdH1cbn1cbiJdfQ==