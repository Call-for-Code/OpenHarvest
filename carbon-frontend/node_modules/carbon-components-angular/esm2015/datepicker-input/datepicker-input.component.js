/**
 *
 * carbon-angular v0.0.0 | datepicker-input.component.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Component, Input, Output, EventEmitter, ElementRef, TemplateRef, ViewChild } from "@angular/core";
import { NG_VALUE_ACCESSOR } from "@angular/forms";
export class DatePickerInput {
    constructor(elementRef) {
        this.elementRef = elementRef;
        /**
         * Select a calendar type for the `model`.
         * Internal purposes only.
         */
        this.type = "simple";
        this.id = `datepicker-${DatePickerInput.datePickerCount++}`;
        this.hasIcon = false;
        this.placeholder = "mm/dd/yyyy";
        this.pattern = "^\\d{1,2}/\\d{1,2}/\\d{4}$";
        this.valueChange = new EventEmitter();
        this.theme = "dark";
        this.disabled = false;
        this.invalid = false;
        this.skeleton = false;
        this.value = "";
        this.size = "md";
        this.onTouched = () => { };
        this.propagateChange = (_) => { };
    }
    onChange(event) {
        this.value = event.target.value;
        this.valueChange.emit(this.value);
        this.propagateChange(this.value);
        this.onTouched();
    }
    writeValue(value) {
        this.value = value;
    }
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    isTemplate(value) {
        return value instanceof TemplateRef;
    }
}
DatePickerInput.datePickerCount = 0;
DatePickerInput.decorators = [
    { type: Component, args: [{
                selector: "ibm-date-picker-input",
                template: `
	<div class="bx--form-item">
		<div class="bx--date-picker"
			[ngClass]="{
				'bx--date-picker--simple' : type === 'simple',
				'bx--date-picker--single' : type === 'single',
				'bx--date-picker--range' : type === 'range',
				'bx--date-picker--light' : theme === 'light',
				'bx--skeleton' : skeleton
			}">
			<div class="bx--date-picker-container">
				<label *ngIf="label" [for]="id" class="bx--label">
					<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
					<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
				</label>
				<div class="bx--date-picker-input__wrapper"
					[ngClass]="{
						'bx--date-picker-input__wrapper--invalid': invalid
					}">
					<input
						#input
						*ngIf="!skeleton"
						autocomplete="off"
						type="text"
						class="bx--date-picker__input"
						[ngClass]="{
							'bx--date-picker__input--sm': size === 'sm',
							'bx--date-picker__input--xl': size === 'xl'
						}"
						[attr.data-invalid]="invalid ? true : undefined"
						[value]="value"
						[pattern]="pattern"
						[placeholder]="placeholder"
						[id]= "id"
						[disabled]="disabled"
						(change)="onChange($event)"/>
						<svg *ngIf="type !== 'simple'" ibmIcon="calendar" size="16" class="bx--date-picker__icon"></svg>
				</div>
				<div *ngIf="invalid" class="bx--form-requirement">
					<ng-container *ngIf="!isTemplate(invalidText)">{{invalidText}}</ng-container>
					<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
				</div>
			</div>
		</div>
</div>
	`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: DatePickerInput,
                        multi: true
                    }
                ]
            }] }
];
/** @nocollapse */
DatePickerInput.ctorParameters = () => [
    { type: ElementRef }
];
DatePickerInput.propDecorators = {
    type: [{ type: Input }],
    id: [{ type: Input }],
    hasIcon: [{ type: Input }],
    label: [{ type: Input }],
    placeholder: [{ type: Input }],
    pattern: [{ type: Input }],
    valueChange: [{ type: Output }],
    theme: [{ type: Input }],
    disabled: [{ type: Input }],
    invalid: [{ type: Input }],
    invalidText: [{ type: Input }],
    skeleton: [{ type: Input }],
    value: [{ type: Input }],
    size: [{ type: Input }],
    input: [{ type: ViewChild, args: ["input", { static: false },] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci1pbnB1dC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2RhdGVwaWNrZXItaW5wdXQvIiwic291cmNlcyI6WyJkYXRlcGlja2VyLWlucHV0LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLFVBQVUsRUFDVixXQUFXLEVBQ1gsU0FBUyxFQUNULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBMERuRCxNQUFNLE9BQU8sZUFBZTtJQXFDM0IsWUFBc0IsVUFBc0I7UUFBdEIsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQW5DNUM7OztXQUdHO1FBQ00sU0FBSSxHQUFrQyxRQUFRLENBQUM7UUFFL0MsT0FBRSxHQUFHLGNBQWMsZUFBZSxDQUFDLGVBQWUsRUFBRSxFQUFFLENBQUM7UUFFdkQsWUFBTyxHQUFHLEtBQUssQ0FBQztRQUloQixnQkFBVyxHQUFHLFlBQVksQ0FBQztRQUUzQixZQUFPLEdBQUcsNEJBQTRCLENBQUM7UUFFdEMsZ0JBQVcsR0FBeUIsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUV4RCxVQUFLLEdBQXFCLE1BQU0sQ0FBQztRQUVqQyxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBRWpCLFlBQU8sR0FBRyxLQUFLLENBQUM7UUFJaEIsYUFBUSxHQUFHLEtBQUssQ0FBQztRQUVqQixVQUFLLEdBQUcsRUFBRSxDQUFDO1FBRVgsU0FBSSxHQUF1QixJQUFJLENBQUM7UUEwQnpDLGNBQVMsR0FBYyxHQUFHLEVBQUUsR0FBRSxDQUFDLENBQUM7UUFFaEMsb0JBQWUsR0FBRyxDQUFDLENBQU0sRUFBRSxFQUFFLEdBQUUsQ0FBQyxDQUFDO0lBdkJjLENBQUM7SUFFaEQsUUFBUSxDQUFDLEtBQUs7UUFDYixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO1FBQ2hDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNsQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNqQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7SUFDbEIsQ0FBQztJQUVNLFVBQVUsQ0FBQyxLQUFVO1FBQzNCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBQ3BCLENBQUM7SUFFTSxnQkFBZ0IsQ0FBQyxFQUFPO1FBQzlCLElBQUksQ0FBQyxlQUFlLEdBQUcsRUFBRSxDQUFDO0lBQzNCLENBQUM7SUFFTSxpQkFBaUIsQ0FBQyxFQUFPO1FBQy9CLElBQUksQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDO0lBQ3JCLENBQUM7SUFNTSxVQUFVLENBQUMsS0FBSztRQUN0QixPQUFPLEtBQUssWUFBWSxXQUFXLENBQUM7SUFDckMsQ0FBQzs7QUEvRGMsK0JBQWUsR0FBRyxDQUFDLENBQUM7O1lBekRuQyxTQUFTLFNBQUM7Z0JBQ1YsUUFBUSxFQUFFLHVCQUF1QjtnQkFDakMsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUE2Q1Q7Z0JBQ0QsU0FBUyxFQUFFO29CQUNWO3dCQUNDLE9BQU8sRUFBRSxpQkFBaUI7d0JBQzFCLFdBQVcsRUFBRSxlQUFlO3dCQUM1QixLQUFLLEVBQUUsSUFBSTtxQkFDWDtpQkFDRDthQUNEOzs7O1lBN0RBLFVBQVU7OzttQkFvRVQsS0FBSztpQkFFTCxLQUFLO3NCQUVMLEtBQUs7b0JBRUwsS0FBSzswQkFFTCxLQUFLO3NCQUVMLEtBQUs7MEJBRUwsTUFBTTtvQkFFTixLQUFLO3VCQUVMLEtBQUs7c0JBRUwsS0FBSzswQkFFTCxLQUFLO3VCQUVMLEtBQUs7b0JBRUwsS0FBSzttQkFFTCxLQUFLO29CQUdMLFNBQVMsU0FBQyxPQUFPLEVBQUUsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0Q29tcG9uZW50LFxuXHRJbnB1dCxcblx0T3V0cHV0LFxuXHRFdmVudEVtaXR0ZXIsXG5cdEVsZW1lbnRSZWYsXG5cdFRlbXBsYXRlUmVmLFxuXHRWaWV3Q2hpbGRcbn0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSBcIkBhbmd1bGFyL2Zvcm1zXCI7XG5cbkBDb21wb25lbnQoe1xuXHRzZWxlY3RvcjogXCJpYm0tZGF0ZS1waWNrZXItaW5wdXRcIixcblx0dGVtcGxhdGU6IGBcblx0PGRpdiBjbGFzcz1cImJ4LS1mb3JtLWl0ZW1cIj5cblx0XHQ8ZGl2IGNsYXNzPVwiYngtLWRhdGUtcGlja2VyXCJcblx0XHRcdFtuZ0NsYXNzXT1cIntcblx0XHRcdFx0J2J4LS1kYXRlLXBpY2tlci0tc2ltcGxlJyA6IHR5cGUgPT09ICdzaW1wbGUnLFxuXHRcdFx0XHQnYngtLWRhdGUtcGlja2VyLS1zaW5nbGUnIDogdHlwZSA9PT0gJ3NpbmdsZScsXG5cdFx0XHRcdCdieC0tZGF0ZS1waWNrZXItLXJhbmdlJyA6IHR5cGUgPT09ICdyYW5nZScsXG5cdFx0XHRcdCdieC0tZGF0ZS1waWNrZXItLWxpZ2h0JyA6IHRoZW1lID09PSAnbGlnaHQnLFxuXHRcdFx0XHQnYngtLXNrZWxldG9uJyA6IHNrZWxldG9uXG5cdFx0XHR9XCI+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwiYngtLWRhdGUtcGlja2VyLWNvbnRhaW5lclwiPlxuXHRcdFx0XHQ8bGFiZWwgKm5nSWY9XCJsYWJlbFwiIFtmb3JdPVwiaWRcIiBjbGFzcz1cImJ4LS1sYWJlbFwiPlxuXHRcdFx0XHRcdDxuZy1jb250YWluZXIgKm5nSWY9XCIhaXNUZW1wbGF0ZShsYWJlbClcIj57e2xhYmVsfX08L25nLWNvbnRhaW5lcj5cblx0XHRcdFx0XHQ8bmctdGVtcGxhdGUgKm5nSWY9XCJpc1RlbXBsYXRlKGxhYmVsKVwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImxhYmVsXCI+PC9uZy10ZW1wbGF0ZT5cblx0XHRcdFx0PC9sYWJlbD5cblx0XHRcdFx0PGRpdiBjbGFzcz1cImJ4LS1kYXRlLXBpY2tlci1pbnB1dF9fd3JhcHBlclwiXG5cdFx0XHRcdFx0W25nQ2xhc3NdPVwie1xuXHRcdFx0XHRcdFx0J2J4LS1kYXRlLXBpY2tlci1pbnB1dF9fd3JhcHBlci0taW52YWxpZCc6IGludmFsaWRcblx0XHRcdFx0XHR9XCI+XG5cdFx0XHRcdFx0PGlucHV0XG5cdFx0XHRcdFx0XHQjaW5wdXRcblx0XHRcdFx0XHRcdCpuZ0lmPVwiIXNrZWxldG9uXCJcblx0XHRcdFx0XHRcdGF1dG9jb21wbGV0ZT1cIm9mZlwiXG5cdFx0XHRcdFx0XHR0eXBlPVwidGV4dFwiXG5cdFx0XHRcdFx0XHRjbGFzcz1cImJ4LS1kYXRlLXBpY2tlcl9faW5wdXRcIlxuXHRcdFx0XHRcdFx0W25nQ2xhc3NdPVwie1xuXHRcdFx0XHRcdFx0XHQnYngtLWRhdGUtcGlja2VyX19pbnB1dC0tc20nOiBzaXplID09PSAnc20nLFxuXHRcdFx0XHRcdFx0XHQnYngtLWRhdGUtcGlja2VyX19pbnB1dC0teGwnOiBzaXplID09PSAneGwnXG5cdFx0XHRcdFx0XHR9XCJcblx0XHRcdFx0XHRcdFthdHRyLmRhdGEtaW52YWxpZF09XCJpbnZhbGlkID8gdHJ1ZSA6IHVuZGVmaW5lZFwiXG5cdFx0XHRcdFx0XHRbdmFsdWVdPVwidmFsdWVcIlxuXHRcdFx0XHRcdFx0W3BhdHRlcm5dPVwicGF0dGVyblwiXG5cdFx0XHRcdFx0XHRbcGxhY2Vob2xkZXJdPVwicGxhY2Vob2xkZXJcIlxuXHRcdFx0XHRcdFx0W2lkXT0gXCJpZFwiXG5cdFx0XHRcdFx0XHRbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuXHRcdFx0XHRcdFx0KGNoYW5nZSk9XCJvbkNoYW5nZSgkZXZlbnQpXCIvPlxuXHRcdFx0XHRcdFx0PHN2ZyAqbmdJZj1cInR5cGUgIT09ICdzaW1wbGUnXCIgaWJtSWNvbj1cImNhbGVuZGFyXCIgc2l6ZT1cIjE2XCIgY2xhc3M9XCJieC0tZGF0ZS1waWNrZXJfX2ljb25cIj48L3N2Zz5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDxkaXYgKm5nSWY9XCJpbnZhbGlkXCIgY2xhc3M9XCJieC0tZm9ybS1yZXF1aXJlbWVudFwiPlxuXHRcdFx0XHRcdDxuZy1jb250YWluZXIgKm5nSWY9XCIhaXNUZW1wbGF0ZShpbnZhbGlkVGV4dClcIj57e2ludmFsaWRUZXh0fX08L25nLWNvbnRhaW5lcj5cblx0XHRcdFx0XHQ8bmctdGVtcGxhdGUgKm5nSWY9XCJpc1RlbXBsYXRlKGludmFsaWRUZXh0KVwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImludmFsaWRUZXh0XCI+PC9uZy10ZW1wbGF0ZT5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj5cbjwvZGl2PlxuXHRgLFxuXHRwcm92aWRlcnM6IFtcblx0XHR7XG5cdFx0XHRwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcblx0XHRcdHVzZUV4aXN0aW5nOiBEYXRlUGlja2VySW5wdXQsXG5cdFx0XHRtdWx0aTogdHJ1ZVxuXHRcdH1cblx0XVxufSlcbmV4cG9ydCBjbGFzcyBEYXRlUGlja2VySW5wdXQge1xuXHRwcml2YXRlIHN0YXRpYyBkYXRlUGlja2VyQ291bnQgPSAwO1xuXHQvKipcblx0ICogU2VsZWN0IGEgY2FsZW5kYXIgdHlwZSBmb3IgdGhlIGBtb2RlbGAuXG5cdCAqIEludGVybmFsIHB1cnBvc2VzIG9ubHkuXG5cdCAqL1xuXHRASW5wdXQoKSB0eXBlOiBcInNpbXBsZVwiIHwgXCJzaW5nbGVcIiB8IFwicmFuZ2VcIiA9IFwic2ltcGxlXCI7XG5cblx0QElucHV0KCkgaWQgPSBgZGF0ZXBpY2tlci0ke0RhdGVQaWNrZXJJbnB1dC5kYXRlUGlja2VyQ291bnQrK31gO1xuXG5cdEBJbnB1dCgpIGhhc0ljb24gPSBmYWxzZTtcblxuXHRASW5wdXQoKSBsYWJlbDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55PjtcblxuXHRASW5wdXQoKSBwbGFjZWhvbGRlciA9IFwibW0vZGQveXl5eVwiO1xuXG5cdEBJbnB1dCgpIHBhdHRlcm4gPSBcIl5cXFxcZHsxLDJ9L1xcXFxkezEsMn0vXFxcXGR7NH0kXCI7XG5cblx0QE91dHB1dCgpIHZhbHVlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8c3RyaW5nPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXHRASW5wdXQoKSB0aGVtZTogXCJsaWdodFwiIHwgXCJkYXJrXCIgPSBcImRhcmtcIjtcblxuXHRASW5wdXQoKSBkaXNhYmxlZCA9IGZhbHNlO1xuXG5cdEBJbnB1dCgpIGludmFsaWQgPSBmYWxzZTtcblxuXHRASW5wdXQoKSBpbnZhbGlkVGV4dDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55PjtcblxuXHRASW5wdXQoKSBza2VsZXRvbiA9IGZhbHNlO1xuXG5cdEBJbnB1dCgpIHZhbHVlID0gXCJcIjtcblxuXHRASW5wdXQoKSBzaXplOiBcInNtXCIgfCBcIm1kXCIgfCBcInhsXCIgPSBcIm1kXCI7XG5cblx0Ly8gQHRzLWlnbm9yZVxuXHRAVmlld0NoaWxkKFwiaW5wdXRcIiwgeyBzdGF0aWM6IGZhbHNlIH0pIGlucHV0OiBFbGVtZW50UmVmO1xuXG5cdGNvbnN0cnVjdG9yKHByb3RlY3RlZCBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7fVxuXG5cdG9uQ2hhbmdlKGV2ZW50KSB7XG5cdFx0dGhpcy52YWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcblx0XHR0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodGhpcy52YWx1ZSk7XG5cdFx0dGhpcy5wcm9wYWdhdGVDaGFuZ2UodGhpcy52YWx1ZSk7XG5cdFx0dGhpcy5vblRvdWNoZWQoKTtcblx0fVxuXG5cdHB1YmxpYyB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpIHtcblx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdH1cblxuXHRwdWJsaWMgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KSB7XG5cdFx0dGhpcy5wcm9wYWdhdGVDaGFuZ2UgPSBmbjtcblx0fVxuXG5cdHB1YmxpYyByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KSB7XG5cdFx0dGhpcy5vblRvdWNoZWQgPSBmbjtcblx0fVxuXG5cdG9uVG91Y2hlZDogKCkgPT4gYW55ID0gKCkgPT4ge307XG5cblx0cHJvcGFnYXRlQ2hhbmdlID0gKF86IGFueSkgPT4ge307XG5cblx0cHVibGljIGlzVGVtcGxhdGUodmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlZjtcblx0fVxufVxuIl19