/**
 *
 * carbon-angular v0.0.0 | abstract-dropdown-view.class.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Input, Output, EventEmitter, Directive } from "@angular/core";
/**
 * A component that intends to be used within `Dropdown` must provide an implementation that extends this base class.
 * It also must provide the base class in the `@Component` meta-data.
 * ex: `providers: [{provide: AbstractDropdownView, useExisting: forwardRef(() => MyDropdownView)}]`
 */
var AbstractDropdownView = /** @class */ (function () {
    function AbstractDropdownView() {
        /**
         * Specifies whether or not the `DropdownList` supports selecting multiple items as opposed to single
         * item selection.
         */
        this.type = "single";
        /**
         * Specifies the render size of the items within the `AbstractDropdownView`.
         *
         * @deprecated since v4
         */
        this.size = "md";
    }
    Object.defineProperty(AbstractDropdownView.prototype, "items", {
        get: function () { return; },
        /**
         * The items to be displayed in the list within the `AbstractDropDownView`.
         */
        set: function (value) { },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the `ListItem` that is subsequent to the selected item in the `DropdownList`.
     */
    AbstractDropdownView.prototype.getNextItem = function () { return; };
    /**
     * Returns a boolean if the currently selected item is preceded by another
     */
    AbstractDropdownView.prototype.hasNextElement = function () { return; };
    /**
     * Returns the `HTMLElement` for the item that is subsequent to the selected item.
     */
    AbstractDropdownView.prototype.getNextElement = function () { return; };
    /**
     * Returns the `ListItem` that precedes the selected item within `DropdownList`.
     */
    AbstractDropdownView.prototype.getPrevItem = function () { return; };
    /**
     * Returns a boolean if the currently selected item is followed by another
     */
    AbstractDropdownView.prototype.hasPrevElement = function () { return; };
    /**
     * Returns the `HTMLElement` for the item that precedes the selected item.
     */
    AbstractDropdownView.prototype.getPrevElement = function () { return; };
    /**
     * Returns the selected leaf level item(s) within the `DropdownList`.
     */
    AbstractDropdownView.prototype.getSelected = function () { return; };
    /**
     * Returns the `ListItem` that is selected within `DropdownList`.
     */
    AbstractDropdownView.prototype.getCurrentItem = function () { return; };
    /**
     * Returns the `HTMLElement` for the item that is selected within the `DropdownList`.
     */
    AbstractDropdownView.prototype.getCurrentElement = function () { return; };
    /**
     * Guaranteed to return the current items as an Array.
     */
    AbstractDropdownView.prototype.getListItems = function () { return; };
    /**
     * Transforms array input list of items to the correct state by updating the selected item(s).
     */
    AbstractDropdownView.prototype.propagateSelected = function (value) { };
    /**
     *
     * @param value value to filter the list by
     */
    AbstractDropdownView.prototype.filterBy = function (value) { };
    /**
     * Initializes focus in the list
     * In most cases this just calls `getCurrentElement().focus()`
     */
    AbstractDropdownView.prototype.initFocus = function () { };
    /**
     * Subscribe the function passed to an internal observable that will resolve once the items are ready
     */
    AbstractDropdownView.prototype.onItemsReady = function (subcription) { };
    /**
     * Reorder selected items bringing them to the top of the list
     */
    AbstractDropdownView.prototype.reorderSelected = function (moveFocus) { };
    AbstractDropdownView.decorators = [
        { type: Directive, args: [{ selector: "[ibmAbstractDropdownView]" },] }
    ];
    AbstractDropdownView.propDecorators = {
        items: [{ type: Input }],
        select: [{ type: Output }],
        blurIntent: [{ type: Output }]
    };
    return AbstractDropdownView;
}());
export { AbstractDropdownView };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWJzdHJhY3QtZHJvcGRvd24tdmlldy5jbGFzcy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvZHJvcGRvd24vIiwic291cmNlcyI6WyJhYnN0cmFjdC1kcm9wZG93bi12aWV3LmNsYXNzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTixLQUFLLEVBQ0wsTUFBTSxFQUNOLFlBQVksRUFDWixTQUFTLEVBQ1QsTUFBTSxlQUFlLENBQUM7QUFLdkI7Ozs7R0FJRztBQUNIO0lBQUE7UUF1QkM7OztXQUdHO1FBQ0ksU0FBSSxHQUF1QixRQUFRLENBQUM7UUFDM0M7Ozs7V0FJRztRQUNJLFNBQUksR0FBdUIsSUFBSSxDQUFDO0lBK0R4QyxDQUFDO0lBM0ZBLHNCQUFhLHVDQUFLO2FBRWxCLGNBQTZELE9BQU8sQ0FBQyxDQUFDO1FBTHRFOztXQUVHO2FBQ0gsVUFBbUIsS0FBb0QsSUFBSSxDQUFDOzs7T0FBQTtJQTZCNUU7O09BRUc7SUFDSCwwQ0FBVyxHQUFYLGNBQTBCLE9BQU8sQ0FBQyxDQUFDO0lBQ25DOztPQUVHO0lBQ0gsNkNBQWMsR0FBZCxjQUE0QixPQUFPLENBQUMsQ0FBQztJQUNyQzs7T0FFRztJQUNILDZDQUFjLEdBQWQsY0FBZ0MsT0FBTyxDQUFDLENBQUM7SUFDekM7O09BRUc7SUFDSCwwQ0FBVyxHQUFYLGNBQTBCLE9BQU8sQ0FBQyxDQUFDO0lBQ25DOztPQUVHO0lBQ0gsNkNBQWMsR0FBZCxjQUE0QixPQUFPLENBQUMsQ0FBQztJQUNyQzs7T0FFRztJQUNILDZDQUFjLEdBQWQsY0FBZ0MsT0FBTyxDQUFDLENBQUM7SUFDekM7O09BRUc7SUFDSCwwQ0FBVyxHQUFYLGNBQTRCLE9BQU8sQ0FBQyxDQUFDO0lBQ3JDOztPQUVHO0lBQ0gsNkNBQWMsR0FBZCxjQUE2QixPQUFPLENBQUMsQ0FBQztJQUN0Qzs7T0FFRztJQUNILGdEQUFpQixHQUFqQixjQUFtQyxPQUFPLENBQUMsQ0FBQztJQUM1Qzs7T0FFRztJQUNILDJDQUFZLEdBQVosY0FBa0MsT0FBTyxDQUFDLENBQUM7SUFDM0M7O09BRUc7SUFDSCxnREFBaUIsR0FBakIsVUFBa0IsS0FBc0IsSUFBUyxDQUFDO0lBQ2xEOzs7T0FHRztJQUNILHVDQUFRLEdBQVIsVUFBUyxLQUFhLElBQVMsQ0FBQztJQUNoQzs7O09BR0c7SUFDSCx3Q0FBUyxHQUFULGNBQW1CLENBQUM7SUFDcEI7O09BRUc7SUFDSCwyQ0FBWSxHQUFaLFVBQWEsV0FBdUIsSUFBUyxDQUFDO0lBQzlDOztPQUVHO0lBQ0gsOENBQWUsR0FBZixVQUFnQixTQUFtQixJQUFTLENBQUM7O2dCQS9GN0MsU0FBUyxTQUFDLEVBQUUsUUFBUSxFQUFFLDJCQUEyQixFQUFFOzs7d0JBS2xELEtBQUs7eUJBTUwsTUFBTTs2QkFXTixNQUFNOztJQTBFUiwyQkFBQztDQUFBLEFBaEdELElBZ0dDO1NBL0ZZLG9CQUFvQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdElucHV0LFxuXHRPdXRwdXQsXG5cdEV2ZW50RW1pdHRlcixcblx0RGlyZWN0aXZlXG59IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBMaXN0SXRlbSB9IGZyb20gXCIuL2xpc3QtaXRlbS5pbnRlcmZhY2VcIjtcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tIFwicnhqc1wiO1xuXG5cbi8qKlxuICogQSBjb21wb25lbnQgdGhhdCBpbnRlbmRzIHRvIGJlIHVzZWQgd2l0aGluIGBEcm9wZG93bmAgbXVzdCBwcm92aWRlIGFuIGltcGxlbWVudGF0aW9uIHRoYXQgZXh0ZW5kcyB0aGlzIGJhc2UgY2xhc3MuXG4gKiBJdCBhbHNvIG11c3QgcHJvdmlkZSB0aGUgYmFzZSBjbGFzcyBpbiB0aGUgYEBDb21wb25lbnRgIG1ldGEtZGF0YS5cbiAqIGV4OiBgcHJvdmlkZXJzOiBbe3Byb3ZpZGU6IEFic3RyYWN0RHJvcGRvd25WaWV3LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNeURyb3Bkb3duVmlldyl9XWBcbiAqL1xuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiBcIltpYm1BYnN0cmFjdERyb3Bkb3duVmlld11cIiB9KVxuZXhwb3J0IGNsYXNzIEFic3RyYWN0RHJvcGRvd25WaWV3IHtcblx0LyoqXG5cdCAqIFRoZSBpdGVtcyB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGxpc3Qgd2l0aGluIHRoZSBgQWJzdHJhY3REcm9wRG93blZpZXdgLlxuXHQgKi9cblx0QElucHV0KCkgc2V0IGl0ZW1zKHZhbHVlOiBBcnJheTxMaXN0SXRlbT4gfCBPYnNlcnZhYmxlPEFycmF5PExpc3RJdGVtPj4pIHsgfVxuXG5cdGdldCBpdGVtcygpOiBBcnJheTxMaXN0SXRlbT4gfCBPYnNlcnZhYmxlPEFycmF5PExpc3RJdGVtPj4geyByZXR1cm47IH1cblx0LyoqXG5cdCAqIEVtaXRzIHNlbGVjdGlvbiBldmVudHMgdG8gY29udHJvbGxpbmcgY2xhc3Nlc1xuXHQgKi9cblx0QE91dHB1dCgpIHNlbGVjdDogRXZlbnRFbWl0dGVyPHtpdGVtOiBMaXN0SXRlbSB9IHwgTGlzdEl0ZW1bXT47XG5cdC8qKlxuXHQgKiBFdmVudCB0byBzdWdnZXN0IGEgYmx1ciBvbiB0aGUgdmlldy5cblx0ICogRW1pdHMgX2FmdGVyXyB0aGUgZmlyc3QvbGFzdCBpdGVtIGhhcyBiZWVuIGZvY3VzZWQuXG5cdCAqIGV4LlxuXHQgKiBBcnJvd1VwIC0+IGZvY3VzIGZpcnN0IGl0ZW1cblx0ICogQXJyb3dVcCAtPiBlbWl0IGV2ZW50XG5cdCAqXG5cdCAqIEl0J3MgcmVjb21tZW5kZWQgdGhhdCB0aGUgaW1wbGVtZW50aW5nIHZpZXcgaW5jbHVkZSBhIHNwZWNpZmljIHR5cGUgdW5pb24gb2YgcG9zc2libGUgYmx1cnNcblx0ICogZXguIGBAT3V0cHV0KCkgYmx1ckludGVudCA9IG5ldyBFdmVudEVtaXR0ZXI8XCJ0b3BcIiB8IFwiYm90dG9tXCI+KCk7YFxuXHQgKi9cblx0QE91dHB1dCgpIGJsdXJJbnRlbnQ6IEV2ZW50RW1pdHRlcjxhbnk+O1xuXHQvKipcblx0ICogU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoZSBgRHJvcGRvd25MaXN0YCBzdXBwb3J0cyBzZWxlY3RpbmcgbXVsdGlwbGUgaXRlbXMgYXMgb3Bwb3NlZCB0byBzaW5nbGVcblx0ICogaXRlbSBzZWxlY3Rpb24uXG5cdCAqL1xuXHRwdWJsaWMgdHlwZTogXCJzaW5nbGVcIiB8IFwibXVsdGlcIiA9IFwic2luZ2xlXCI7XG5cdC8qKlxuXHQgKiBTcGVjaWZpZXMgdGhlIHJlbmRlciBzaXplIG9mIHRoZSBpdGVtcyB3aXRoaW4gdGhlIGBBYnN0cmFjdERyb3Bkb3duVmlld2AuXG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHY0XG5cdCAqL1xuXHRwdWJsaWMgc2l6ZTogXCJzbVwiIHwgXCJtZFwiIHwgXCJ4bFwiID0gXCJtZFwiO1xuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYExpc3RJdGVtYCB0aGF0IGlzIHN1YnNlcXVlbnQgdG8gdGhlIHNlbGVjdGVkIGl0ZW0gaW4gdGhlIGBEcm9wZG93bkxpc3RgLlxuXHQgKi9cblx0Z2V0TmV4dEl0ZW0oKTogTGlzdEl0ZW0geyByZXR1cm47IH1cblx0LyoqXG5cdCAqIFJldHVybnMgYSBib29sZWFuIGlmIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbSBpcyBwcmVjZWRlZCBieSBhbm90aGVyXG5cdCAqL1xuXHRoYXNOZXh0RWxlbWVudCgpOiBib29sZWFuIHsgcmV0dXJuOyB9XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIGZvciB0aGUgaXRlbSB0aGF0IGlzIHN1YnNlcXVlbnQgdG8gdGhlIHNlbGVjdGVkIGl0ZW0uXG5cdCAqL1xuXHRnZXROZXh0RWxlbWVudCgpOiBIVE1MRWxlbWVudCB7IHJldHVybjsgfVxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYExpc3RJdGVtYCB0aGF0IHByZWNlZGVzIHRoZSBzZWxlY3RlZCBpdGVtIHdpdGhpbiBgRHJvcGRvd25MaXN0YC5cblx0ICovXG5cdGdldFByZXZJdGVtKCk6IExpc3RJdGVtIHsgcmV0dXJuOyB9XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgYm9vbGVhbiBpZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW0gaXMgZm9sbG93ZWQgYnkgYW5vdGhlclxuXHQgKi9cblx0aGFzUHJldkVsZW1lbnQoKTogYm9vbGVhbiB7IHJldHVybjsgfVxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCBmb3IgdGhlIGl0ZW0gdGhhdCBwcmVjZWRlcyB0aGUgc2VsZWN0ZWQgaXRlbS5cblx0ICovXG5cdGdldFByZXZFbGVtZW50KCk6IEhUTUxFbGVtZW50IHsgcmV0dXJuOyB9XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzZWxlY3RlZCBsZWFmIGxldmVsIGl0ZW0ocykgd2l0aGluIHRoZSBgRHJvcGRvd25MaXN0YC5cblx0ICovXG5cdGdldFNlbGVjdGVkKCk6IExpc3RJdGVtW10geyByZXR1cm47IH1cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGBMaXN0SXRlbWAgdGhhdCBpcyBzZWxlY3RlZCB3aXRoaW4gYERyb3Bkb3duTGlzdGAuXG5cdCAqL1xuXHRnZXRDdXJyZW50SXRlbSgpOiBMaXN0SXRlbSB7IHJldHVybjsgfVxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCBmb3IgdGhlIGl0ZW0gdGhhdCBpcyBzZWxlY3RlZCB3aXRoaW4gdGhlIGBEcm9wZG93bkxpc3RgLlxuXHQgKi9cblx0Z2V0Q3VycmVudEVsZW1lbnQoKTogSFRNTEVsZW1lbnQgeyByZXR1cm47IH1cblx0LyoqXG5cdCAqIEd1YXJhbnRlZWQgdG8gcmV0dXJuIHRoZSBjdXJyZW50IGl0ZW1zIGFzIGFuIEFycmF5LlxuXHQgKi9cblx0Z2V0TGlzdEl0ZW1zKCk6IEFycmF5PExpc3RJdGVtPiB7IHJldHVybjsgfVxuXHQvKipcblx0ICogVHJhbnNmb3JtcyBhcnJheSBpbnB1dCBsaXN0IG9mIGl0ZW1zIHRvIHRoZSBjb3JyZWN0IHN0YXRlIGJ5IHVwZGF0aW5nIHRoZSBzZWxlY3RlZCBpdGVtKHMpLlxuXHQgKi9cblx0cHJvcGFnYXRlU2VsZWN0ZWQodmFsdWU6IEFycmF5PExpc3RJdGVtPik6IHZvaWQge31cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSB0byBmaWx0ZXIgdGhlIGxpc3QgYnlcblx0ICovXG5cdGZpbHRlckJ5KHZhbHVlOiBzdHJpbmcpOiB2b2lkIHt9XG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyBmb2N1cyBpbiB0aGUgbGlzdFxuXHQgKiBJbiBtb3N0IGNhc2VzIHRoaXMganVzdCBjYWxscyBgZ2V0Q3VycmVudEVsZW1lbnQoKS5mb2N1cygpYFxuXHQgKi9cblx0aW5pdEZvY3VzKCk6IHZvaWQge31cblx0LyoqXG5cdCAqIFN1YnNjcmliZSB0aGUgZnVuY3Rpb24gcGFzc2VkIHRvIGFuIGludGVybmFsIG9ic2VydmFibGUgdGhhdCB3aWxsIHJlc29sdmUgb25jZSB0aGUgaXRlbXMgYXJlIHJlYWR5XG5cdCAqL1xuXHRvbkl0ZW1zUmVhZHkoc3ViY3JpcHRpb246ICgpID0+IHZvaWQpOiB2b2lkIHt9XG5cdC8qKlxuXHQgKiBSZW9yZGVyIHNlbGVjdGVkIGl0ZW1zIGJyaW5naW5nIHRoZW0gdG8gdGhlIHRvcCBvZiB0aGUgbGlzdFxuXHQgKi9cblx0cmVvcmRlclNlbGVjdGVkKG1vdmVGb2N1cz86IGJvb2xlYW4pOiB2b2lkIHt9XG59XG4iXX0=