/**
 *
 * carbon-angular v0.0.0 | dialog.component.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import * as tslib_1 from "tslib";
import { Component, Input, Output, EventEmitter, ElementRef, ViewChild, HostListener, Optional } from "@angular/core";
import { Subscription } from "rxjs";
// the AbsolutePosition is required to import the declaration correctly
import Position, { position } from "@carbon/utils-position";
import { cycleTabs, getFocusElementList } from "carbon-components-angular/common";
import { CloseReasons } from "./dialog-config.interface";
import { AnimationFrameService, ElementService } from "carbon-components-angular/utils";
/**
 * Implements a `Dialog` that can be positioned anywhere on the page.
 * Used to implement a popover or tooltip.
 */
var Dialog = /** @class */ (function () {
    /**
     * Creates an instance of `Dialog`.
     * @param elementRef
     * @param elementService
     */
    function Dialog(elementRef, elementService, animationFrameService) {
        if (animationFrameService === void 0) { animationFrameService = null; }
        var _this = this;
        this.elementRef = elementRef;
        this.elementService = elementService;
        this.animationFrameService = animationFrameService;
        /**
         * Emits event that handles the closing of a `Dialog` object.
         */
        this.close = new EventEmitter();
        /**
         * Stores the data received from `dialogConfig`.
         */
        this.data = {};
        this.visibilitySubscription = new Subscription();
        this.animationFrameSubscription = new Subscription();
        /**
         * Handles offsetting the `Dialog` item based on the defined position
         * to not obscure the content beneath.
         */
        this.addGap = {
            "left": function (pos) { return position.addOffset(pos, 0, -_this.dialogConfig.gap); },
            "right": function (pos) { return position.addOffset(pos, 0, _this.dialogConfig.gap); },
            "top": function (pos) { return position.addOffset(pos, -_this.dialogConfig.gap); },
            "bottom": function (pos) { return position.addOffset(pos, _this.dialogConfig.gap); },
            "left-bottom": function (pos) { return position.addOffset(pos, 0, -_this.dialogConfig.gap); },
            "right-bottom": function (pos) { return position.addOffset(pos, 0, _this.dialogConfig.gap); }
        };
        /**
         * Extra placements. Child classes can add to this for use in `placeDialog`.
         */
        this.placements = {};
    }
    /**
     * Initialize the `Dialog`, set the placement and gap, and add a `Subscription` to resize events.
     */
    Dialog.prototype.ngOnInit = function () {
        this.placement = this.dialogConfig.placement.split(",")[0];
        this.data = this.dialogConfig.data;
        // run any additional initialization code that consuming classes may have
        this.onDialogInit();
    };
    /**
     * After the DOM is ready, focus is set and dialog is placed
     * in respect to the parent element.
     */
    Dialog.prototype.ngAfterViewInit = function () {
        var _this = this;
        var e_1, _a;
        var dialogElement = this.dialog.nativeElement;
        // split the wrapper class list and apply separately to avoid IE
        // 1. throwing an error due to assigning a readonly property (classList)
        // 2. throwing a SyntaxError due to passing an empty string to `add`
        if (this.dialogConfig.wrapperClass) {
            try {
                for (var _b = tslib_1.__values(this.dialogConfig.wrapperClass.split(" ")), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var extraClass = _c.value;
                    dialogElement.classList.add(extraClass);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        // only focus the dialog if there are focusable elements within the dialog
        if (getFocusElementList(this.dialog.nativeElement).length > 0) {
            dialogElement.focus();
        }
        var parentElement = this.dialogConfig.parentRef.nativeElement;
        if (this.animationFrameService) {
            this.animationFrameSubscription = this.animationFrameService.tick.subscribe(function () {
                _this.placeDialog();
            });
        }
        if (this.dialogConfig.closeWhenHidden) {
            this.visibilitySubscription = this.elementService
                .visibility(parentElement, parentElement)
                .subscribe(function (value) {
                _this.placeDialog();
                if (!value.visible) {
                    _this.doClose({
                        reason: CloseReasons.hidden
                    });
                }
            });
        }
        this.placeDialog();
        // run afterDialogViewInit on the next tick
        setTimeout(function () { return _this.afterDialogViewInit(); });
    };
    /**
     * Empty method to be overridden by consuming classes to run any additional initialization code.
     */
    Dialog.prototype.onDialogInit = function () { };
    /**
     * Empty method to be overridden by consuming classes to run any additional initialization code after the view is available.
     * NOTE: this does _not_ guarantee the dialog will be positioned, simply that it will exist in the DOM
     */
    Dialog.prototype.afterDialogViewInit = function () { };
    /**
     * Uses the position service to position the `Dialog` in screen space
     */
    Dialog.prototype.placeDialog = function () {
        var _this = this;
        var positionService = new Position(this.placements);
        // helper to find the position based on the current/given environment
        var findPosition = function (reference, target, placement) {
            var pos;
            if (_this.dialogConfig.appendInline) {
                pos = _this.addGap[placement](positionService.findRelative(reference, target, placement));
            }
            else {
                pos = _this.addGap[placement](positionService.findAbsolute(reference, target, placement));
            }
            if (_this.dialogConfig.offset) {
                // Apply vertical and horizontal offsets given through the dialogConfig
                pos.top = pos.top + _this.dialogConfig.offset.y;
                pos.left = pos.left + _this.dialogConfig.offset.x;
            }
            return pos;
        };
        var parentEl = this.dialogConfig.parentRef.nativeElement;
        var el = this.dialog.nativeElement;
        var dialogPlacement = this.placement;
        // split always returns an array, so we can just use the auto position logic
        // for single positions too
        var placements = this.dialogConfig.placement.split(",");
        // find the best placement
        dialogPlacement = positionService.findBestPlacement(parentEl, el, placements);
        // calculate the final position
        var pos = findPosition(parentEl, el, dialogPlacement);
        // update the element
        positionService.setElement(el, pos);
        setTimeout(function () { _this.placement = dialogPlacement; });
    };
    /**
     * Sets up a KeyboardEvent to close `Dialog` with Escape key.
     * @param event
     */
    Dialog.prototype.escapeClose = function (event) {
        switch (event.key) {
            case "Esc": // IE specific value
            case "Escape": {
                event.stopImmediatePropagation();
                this.doClose({
                    reason: CloseReasons.interaction,
                    target: event.target
                });
                break;
            }
            case "Tab": {
                cycleTabs(event, this.elementRef.nativeElement);
                break;
            }
        }
    };
    /**
     * Sets up a event Listener to close `Dialog` if click event occurs outside
     * `Dialog` object.
     * @param event
     */
    Dialog.prototype.clickClose = function (event) {
        if (!this.elementRef.nativeElement.contains(event.target)
            && !this.dialogConfig.parentRef.nativeElement.contains(event.target)) {
            this.doClose({
                reason: CloseReasons.interaction,
                target: event.target
            });
        }
    };
    /**
     * Closes `Dialog` object by emitting the close event upwards to parents.
     */
    Dialog.prototype.doClose = function (meta) {
        if (meta === void 0) { meta = { reason: CloseReasons.interaction }; }
        this.close.emit(meta);
    };
    /**
     * At destruction of component, `Dialog` unsubscribes from all the subscriptions.
     */
    Dialog.prototype.ngOnDestroy = function () {
        this.visibilitySubscription.unsubscribe();
        if (this.animationFrameSubscription) {
            this.animationFrameSubscription.unsubscribe();
        }
    };
    Dialog.decorators = [
        { type: Component, args: [{
                    selector: "ibm-dialog",
                    template: ""
                }] }
    ];
    /** @nocollapse */
    Dialog.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ElementService },
        { type: AnimationFrameService, decorators: [{ type: Optional }] }
    ]; };
    Dialog.propDecorators = {
        close: [{ type: Output }],
        dialogConfig: [{ type: Input }],
        dialog: [{ type: ViewChild, args: ["dialog", { static: false },] }],
        escapeClose: [{ type: HostListener, args: ["keydown", ["$event"],] }],
        clickClose: [{ type: HostListener, args: ["document:click", ["$event"],] }]
    };
    return Dialog;
}());
export { Dialog };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlhbG9nLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvZGlhbG9nLyIsInNvdXJjZXMiOlsiZGlhbG9nLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUNOLFNBQVMsRUFDVCxLQUFLLEVBQ0wsTUFBTSxFQUNOLFlBQVksRUFDWixVQUFVLEVBQ1YsU0FBUyxFQUlULFlBQVksRUFDWixRQUFRLEVBQ1IsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUVOLFlBQVksRUFDWixNQUFNLE1BQU0sQ0FBQztBQUNkLHVFQUF1RTtBQUN2RSxPQUFPLFFBQVEsRUFBRSxFQUFFLFFBQVEsRUFBK0IsTUFBTSx3QkFBd0IsQ0FBQztBQUN6RixPQUFPLEVBQUUsU0FBUyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFDbEYsT0FBTyxFQUFhLFlBQVksRUFBZ0IsTUFBTSwyQkFBMkIsQ0FBQztBQUNsRixPQUFPLEVBQUUscUJBQXFCLEVBQUUsY0FBYyxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFFeEY7OztHQUdHO0FBQ0g7SUFvREM7Ozs7T0FJRztJQUNILGdCQUNXLFVBQXNCLEVBQ3RCLGNBQThCLEVBQ2xCLHFCQUFtRDtRQUFuRCxzQ0FBQSxFQUFBLDRCQUFtRDtRQUgxRSxpQkFJSTtRQUhPLGVBQVUsR0FBVixVQUFVLENBQVk7UUFDdEIsbUJBQWMsR0FBZCxjQUFjLENBQWdCO1FBQ2xCLDBCQUFxQixHQUFyQixxQkFBcUIsQ0FBOEI7UUF2RDFFOztXQUVHO1FBQ08sVUFBSyxHQUE0QixJQUFJLFlBQVksRUFBRSxDQUFDO1FBWTlEOztXQUVHO1FBQ0ksU0FBSSxHQUFHLEVBQUUsQ0FBQztRQU9QLDJCQUFzQixHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFFNUMsK0JBQTBCLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUUxRDs7O1dBR0c7UUFDTyxX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LENBQUMsMEJBQTBCLEVBQUU7WUFDcEMsSUFBSSxDQUFDLDBCQUEwQixDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQzlDO0lBQ0YsQ0FBQzs7Z0JBcE9ELFNBQVMsU0FBQztvQkFDVixRQUFRLEVBQUUsWUFBWTtvQkFDdEIsUUFBUSxFQUFFLEVBQUU7aUJBQ1o7Ozs7Z0JBekJBLFVBQVU7Z0JBZ0JxQixjQUFjO2dCQUFyQyxxQkFBcUIsdUJBa0UzQixRQUFROzs7d0JBcERULE1BQU07K0JBS04sS0FBSzt5QkFLTCxTQUFTLFNBQUMsUUFBUSxFQUFFLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRTs4QkFnS3JDLFlBQVksU0FBQyxTQUFTLEVBQUUsQ0FBQyxRQUFRLENBQUM7NkJBd0JsQyxZQUFZLFNBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxRQUFRLENBQUM7O0lBMkIzQyxhQUFDO0NBQUEsQUFyT0QsSUFxT0M7U0FqT1ksTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdENvbXBvbmVudCxcblx0SW5wdXQsXG5cdE91dHB1dCxcblx0RXZlbnRFbWl0dGVyLFxuXHRFbGVtZW50UmVmLFxuXHRWaWV3Q2hpbGQsXG5cdE9uSW5pdCxcblx0QWZ0ZXJWaWV3SW5pdCxcblx0T25EZXN0cm95LFxuXHRIb3N0TGlzdGVuZXIsXG5cdE9wdGlvbmFsXG59IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQge1xuXHRPYnNlcnZhYmxlLFxuXHRTdWJzY3JpcHRpb25cbn0gZnJvbSBcInJ4anNcIjtcbi8vIHRoZSBBYnNvbHV0ZVBvc2l0aW9uIGlzIHJlcXVpcmVkIHRvIGltcG9ydCB0aGUgZGVjbGFyYXRpb24gY29ycmVjdGx5XG5pbXBvcnQgUG9zaXRpb24sIHsgcG9zaXRpb24sIEFic29sdXRlUG9zaXRpb24sIFBvc2l0aW9ucyB9IGZyb20gXCJAY2FyYm9uL3V0aWxzLXBvc2l0aW9uXCI7XG5pbXBvcnQgeyBjeWNsZVRhYnMsIGdldEZvY3VzRWxlbWVudExpc3QgfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9jb21tb25cIjtcbmltcG9ydCB7IENsb3NlTWV0YSwgQ2xvc2VSZWFzb25zLCBEaWFsb2dDb25maWcgfSBmcm9tIFwiLi9kaWFsb2ctY29uZmlnLmludGVyZmFjZVwiO1xuaW1wb3J0IHsgQW5pbWF0aW9uRnJhbWVTZXJ2aWNlLCBFbGVtZW50U2VydmljZSB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL3V0aWxzXCI7XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIGBEaWFsb2dgIHRoYXQgY2FuIGJlIHBvc2l0aW9uZWQgYW55d2hlcmUgb24gdGhlIHBhZ2UuXG4gKiBVc2VkIHRvIGltcGxlbWVudCBhIHBvcG92ZXIgb3IgdG9vbHRpcC5cbiAqL1xuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiBcImlibS1kaWFsb2dcIixcblx0dGVtcGxhdGU6IFwiXCJcbn0pXG5leHBvcnQgY2xhc3MgRGlhbG9nIGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXHQvKipcblx0ICogRW1pdHMgZXZlbnQgdGhhdCBoYW5kbGVzIHRoZSBjbG9zaW5nIG9mIGEgYERpYWxvZ2Agb2JqZWN0LlxuXHQgKi9cblx0QE91dHB1dCgpIGNsb3NlOiBFdmVudEVtaXR0ZXI8Q2xvc2VNZXRhPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblx0LyoqXG5cdCAqIFJlY2VpdmVzIGBEaWFsb2dDb25maWdgIGludGVyZmFjZSBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIG9mIGBEaWFsb2dgXG5cdCAqIGV4cGxpY2l0bHkgZGVmaW5lZC5cblx0ICovXG5cdEBJbnB1dCgpIGRpYWxvZ0NvbmZpZzogRGlhbG9nQ29uZmlnO1xuXHQvKipcblx0ICogTWFpbnRhaW5zIGEgcmVmZXJlbmNlIHRvIHRoZSB2aWV3IERPTSBlbGVtZW50IG9mIHRoZSBgRGlhbG9nYC5cblx0ICovXG5cdC8vIEB0cy1pZ25vcmVcblx0QFZpZXdDaGlsZChcImRpYWxvZ1wiLCB7IHN0YXRpYzogZmFsc2UgfSkgZGlhbG9nOiBFbGVtZW50UmVmO1xuXG5cdC8qKlxuXHQgKiBTdG9yZXMgdGhlIGRhdGEgcmVjZWl2ZWQgZnJvbSBgZGlhbG9nQ29uZmlnYC5cblx0ICovXG5cdHB1YmxpYyBkYXRhID0ge307XG5cblx0LyoqXG5cdCAqIFRoZSBwbGFjZW1lbnQgb2YgdGhlIGBEaWFsb2dgIGlzIHJlY2VpdmVkIGZyb20gdGhlIGBQb3NpdGlvbmAgc2VydmljZS5cblx0ICovXG5cdHB1YmxpYyBwbGFjZW1lbnQ6IHN0cmluZztcblxuXHRwcm90ZWN0ZWQgdmlzaWJpbGl0eVN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcblxuXHRwcm90ZWN0ZWQgYW5pbWF0aW9uRnJhbWVTdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgb2Zmc2V0dGluZyB0aGUgYERpYWxvZ2AgaXRlbSBiYXNlZCBvbiB0aGUgZGVmaW5lZCBwb3NpdGlvblxuXHQgKiB0byBub3Qgb2JzY3VyZSB0aGUgY29udGVudCBiZW5lYXRoLlxuXHQgKi9cblx0cHJvdGVjdGVkIGFkZEdhcCA9IHtcblx0XHRcImxlZnRcIjogcG9zID0+IHBvc2l0aW9uLmFkZE9mZnNldChwb3MsIDAsIC10aGlzLmRpYWxvZ0NvbmZpZy5nYXApLFxuXHRcdFwicmlnaHRcIjogcG9zID0+IHBvc2l0aW9uLmFkZE9mZnNldChwb3MsIDAsIHRoaXMuZGlhbG9nQ29uZmlnLmdhcCksXG5cdFx0XCJ0b3BcIjogcG9zID0+IHBvc2l0aW9uLmFkZE9mZnNldChwb3MsIC10aGlzLmRpYWxvZ0NvbmZpZy5nYXApLFxuXHRcdFwiYm90dG9tXCI6IHBvcyA9PiBwb3NpdGlvbi5hZGRPZmZzZXQocG9zLCB0aGlzLmRpYWxvZ0NvbmZpZy5nYXApLFxuXHRcdFwibGVmdC1ib3R0b21cIjogcG9zID0+IHBvc2l0aW9uLmFkZE9mZnNldChwb3MsIDAsIC10aGlzLmRpYWxvZ0NvbmZpZy5nYXApLFxuXHRcdFwicmlnaHQtYm90dG9tXCI6IHBvcyA9PiBwb3NpdGlvbi5hZGRPZmZzZXQocG9zLCAwLCB0aGlzLmRpYWxvZ0NvbmZpZy5nYXApXG5cdH07XG5cblx0LyoqXG5cdCAqIEV4dHJhIHBsYWNlbWVudHMuIENoaWxkIGNsYXNzZXMgY2FuIGFkZCB0byB0aGlzIGZvciB1c2UgaW4gYHBsYWNlRGlhbG9nYC5cblx0ICovXG5cdHByb3RlY3RlZCBwbGFjZW1lbnRzOiBQb3NpdGlvbnMgPSB7fTtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBgRGlhbG9nYC5cblx0ICogQHBhcmFtIGVsZW1lbnRSZWZcblx0ICogQHBhcmFtIGVsZW1lbnRTZXJ2aWNlXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihcblx0XHRwcm90ZWN0ZWQgZWxlbWVudFJlZjogRWxlbWVudFJlZixcblx0XHRwcm90ZWN0ZWQgZWxlbWVudFNlcnZpY2U6IEVsZW1lbnRTZXJ2aWNlLFxuXHRcdEBPcHRpb25hbCgpIHByb3RlY3RlZCBhbmltYXRpb25GcmFtZVNlcnZpY2U6IEFuaW1hdGlvbkZyYW1lU2VydmljZSA9IG51bGxcblx0KSB7fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIHRoZSBgRGlhbG9nYCwgc2V0IHRoZSBwbGFjZW1lbnQgYW5kIGdhcCwgYW5kIGFkZCBhIGBTdWJzY3JpcHRpb25gIHRvIHJlc2l6ZSBldmVudHMuXG5cdCAqL1xuXHRuZ09uSW5pdCgpIHtcblx0XHR0aGlzLnBsYWNlbWVudCA9IHRoaXMuZGlhbG9nQ29uZmlnLnBsYWNlbWVudC5zcGxpdChcIixcIilbMF07XG5cdFx0dGhpcy5kYXRhID0gdGhpcy5kaWFsb2dDb25maWcuZGF0YTtcblxuXHRcdC8vIHJ1biBhbnkgYWRkaXRpb25hbCBpbml0aWFsaXphdGlvbiBjb2RlIHRoYXQgY29uc3VtaW5nIGNsYXNzZXMgbWF5IGhhdmVcblx0XHR0aGlzLm9uRGlhbG9nSW5pdCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFmdGVyIHRoZSBET00gaXMgcmVhZHksIGZvY3VzIGlzIHNldCBhbmQgZGlhbG9nIGlzIHBsYWNlZFxuXHQgKiBpbiByZXNwZWN0IHRvIHRoZSBwYXJlbnQgZWxlbWVudC5cblx0ICovXG5cdG5nQWZ0ZXJWaWV3SW5pdCgpIHtcblx0XHRjb25zdCBkaWFsb2dFbGVtZW50ID0gdGhpcy5kaWFsb2cubmF0aXZlRWxlbWVudDtcblx0XHQvLyBzcGxpdCB0aGUgd3JhcHBlciBjbGFzcyBsaXN0IGFuZCBhcHBseSBzZXBhcmF0ZWx5IHRvIGF2b2lkIElFXG5cdFx0Ly8gMS4gdGhyb3dpbmcgYW4gZXJyb3IgZHVlIHRvIGFzc2lnbmluZyBhIHJlYWRvbmx5IHByb3BlcnR5IChjbGFzc0xpc3QpXG5cdFx0Ly8gMi4gdGhyb3dpbmcgYSBTeW50YXhFcnJvciBkdWUgdG8gcGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgdG8gYGFkZGBcblx0XHRpZiAodGhpcy5kaWFsb2dDb25maWcud3JhcHBlckNsYXNzKSB7XG5cdFx0XHRmb3IgKGNvbnN0IGV4dHJhQ2xhc3Mgb2YgdGhpcy5kaWFsb2dDb25maWcud3JhcHBlckNsYXNzLnNwbGl0KFwiIFwiKSkge1xuXHRcdFx0XHRkaWFsb2dFbGVtZW50LmNsYXNzTGlzdC5hZGQoZXh0cmFDbGFzcyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gb25seSBmb2N1cyB0aGUgZGlhbG9nIGlmIHRoZXJlIGFyZSBmb2N1c2FibGUgZWxlbWVudHMgd2l0aGluIHRoZSBkaWFsb2dcblx0XHRpZiAoZ2V0Rm9jdXNFbGVtZW50TGlzdCh0aGlzLmRpYWxvZy5uYXRpdmVFbGVtZW50KS5sZW5ndGggPiAwKSB7XG5cdFx0XHRkaWFsb2dFbGVtZW50LmZvY3VzKCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcGFyZW50RWxlbWVudCA9IHRoaXMuZGlhbG9nQ29uZmlnLnBhcmVudFJlZi5uYXRpdmVFbGVtZW50O1xuXG5cdFx0aWYgKHRoaXMuYW5pbWF0aW9uRnJhbWVTZXJ2aWNlKSB7XG5cdFx0XHR0aGlzLmFuaW1hdGlvbkZyYW1lU3Vic2NyaXB0aW9uID0gdGhpcy5hbmltYXRpb25GcmFtZVNlcnZpY2UudGljay5zdWJzY3JpYmUoKCkgPT4ge1xuXHRcdFx0XHR0aGlzLnBsYWNlRGlhbG9nKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5kaWFsb2dDb25maWcuY2xvc2VXaGVuSGlkZGVuKSB7XG5cdFx0XHR0aGlzLnZpc2liaWxpdHlTdWJzY3JpcHRpb24gPSB0aGlzLmVsZW1lbnRTZXJ2aWNlXG5cdFx0XHRcdC52aXNpYmlsaXR5KHBhcmVudEVsZW1lbnQsIHBhcmVudEVsZW1lbnQpXG5cdFx0XHRcdC5zdWJzY3JpYmUodmFsdWUgPT4ge1xuXHRcdFx0XHRcdHRoaXMucGxhY2VEaWFsb2coKTtcblx0XHRcdFx0XHRpZiAoIXZhbHVlLnZpc2libGUpIHtcblx0XHRcdFx0XHRcdHRoaXMuZG9DbG9zZSh7XG5cdFx0XHRcdFx0XHRcdHJlYXNvbjogQ2xvc2VSZWFzb25zLmhpZGRlblxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHRoaXMucGxhY2VEaWFsb2coKTtcblx0XHQvLyBydW4gYWZ0ZXJEaWFsb2dWaWV3SW5pdCBvbiB0aGUgbmV4dCB0aWNrXG5cdFx0c2V0VGltZW91dCgoKSA9PiB0aGlzLmFmdGVyRGlhbG9nVmlld0luaXQoKSk7XG5cdH1cblxuXHQvKipcblx0ICogRW1wdHkgbWV0aG9kIHRvIGJlIG92ZXJyaWRkZW4gYnkgY29uc3VtaW5nIGNsYXNzZXMgdG8gcnVuIGFueSBhZGRpdGlvbmFsIGluaXRpYWxpemF0aW9uIGNvZGUuXG5cdCAqL1xuXHRvbkRpYWxvZ0luaXQoKSB7fVxuXG5cdC8qKlxuXHQgKiBFbXB0eSBtZXRob2QgdG8gYmUgb3ZlcnJpZGRlbiBieSBjb25zdW1pbmcgY2xhc3NlcyB0byBydW4gYW55IGFkZGl0aW9uYWwgaW5pdGlhbGl6YXRpb24gY29kZSBhZnRlciB0aGUgdmlldyBpcyBhdmFpbGFibGUuXG5cdCAqIE5PVEU6IHRoaXMgZG9lcyBfbm90XyBndWFyYW50ZWUgdGhlIGRpYWxvZyB3aWxsIGJlIHBvc2l0aW9uZWQsIHNpbXBseSB0aGF0IGl0IHdpbGwgZXhpc3QgaW4gdGhlIERPTVxuXHQgKi9cblx0YWZ0ZXJEaWFsb2dWaWV3SW5pdCgpIHt9XG5cblx0LyoqXG5cdCAqIFVzZXMgdGhlIHBvc2l0aW9uIHNlcnZpY2UgdG8gcG9zaXRpb24gdGhlIGBEaWFsb2dgIGluIHNjcmVlbiBzcGFjZVxuXHQgKi9cblx0cGxhY2VEaWFsb2coKTogdm9pZCB7XG5cdFx0Y29uc3QgcG9zaXRpb25TZXJ2aWNlID0gbmV3IFBvc2l0aW9uKHRoaXMucGxhY2VtZW50cyk7XG5cdFx0Ly8gaGVscGVyIHRvIGZpbmQgdGhlIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBjdXJyZW50L2dpdmVuIGVudmlyb25tZW50XG5cdFx0Y29uc3QgZmluZFBvc2l0aW9uID0gKHJlZmVyZW5jZSwgdGFyZ2V0LCBwbGFjZW1lbnQpID0+IHtcblx0XHRcdGxldCBwb3M7XG5cdFx0XHRpZiAodGhpcy5kaWFsb2dDb25maWcuYXBwZW5kSW5saW5lKSB7XG5cdFx0XHRcdHBvcyA9IHRoaXMuYWRkR2FwW3BsYWNlbWVudF0ocG9zaXRpb25TZXJ2aWNlLmZpbmRSZWxhdGl2ZShyZWZlcmVuY2UsIHRhcmdldCwgcGxhY2VtZW50KSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwb3MgPSB0aGlzLmFkZEdhcFtwbGFjZW1lbnRdKHBvc2l0aW9uU2VydmljZS5maW5kQWJzb2x1dGUocmVmZXJlbmNlLCB0YXJnZXQsIHBsYWNlbWVudCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5kaWFsb2dDb25maWcub2Zmc2V0KSB7XG5cdFx0XHRcdC8vIEFwcGx5IHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIG9mZnNldHMgZ2l2ZW4gdGhyb3VnaCB0aGUgZGlhbG9nQ29uZmlnXG5cdFx0XHRcdHBvcy50b3AgPSBwb3MudG9wICsgdGhpcy5kaWFsb2dDb25maWcub2Zmc2V0Lnk7XG5cdFx0XHRcdHBvcy5sZWZ0ID0gcG9zLmxlZnQgKyB0aGlzLmRpYWxvZ0NvbmZpZy5vZmZzZXQueDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHBvcztcblx0XHR9O1xuXG5cdFx0bGV0IHBhcmVudEVsID0gdGhpcy5kaWFsb2dDb25maWcucGFyZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG5cdFx0bGV0IGVsID0gdGhpcy5kaWFsb2cubmF0aXZlRWxlbWVudDtcblx0XHRsZXQgZGlhbG9nUGxhY2VtZW50ID0gdGhpcy5wbGFjZW1lbnQ7XG5cblx0XHQvLyBzcGxpdCBhbHdheXMgcmV0dXJucyBhbiBhcnJheSwgc28gd2UgY2FuIGp1c3QgdXNlIHRoZSBhdXRvIHBvc2l0aW9uIGxvZ2ljXG5cdFx0Ly8gZm9yIHNpbmdsZSBwb3NpdGlvbnMgdG9vXG5cdFx0Y29uc3QgcGxhY2VtZW50cyA9IHRoaXMuZGlhbG9nQ29uZmlnLnBsYWNlbWVudC5zcGxpdChcIixcIik7XG5cblx0XHQvLyBmaW5kIHRoZSBiZXN0IHBsYWNlbWVudFxuXHRcdGRpYWxvZ1BsYWNlbWVudCA9IHBvc2l0aW9uU2VydmljZS5maW5kQmVzdFBsYWNlbWVudChwYXJlbnRFbCwgZWwsIHBsYWNlbWVudHMpO1xuXG5cdFx0Ly8gY2FsY3VsYXRlIHRoZSBmaW5hbCBwb3NpdGlvblxuXHRcdGNvbnN0IHBvcyA9IGZpbmRQb3NpdGlvbihwYXJlbnRFbCwgZWwsIGRpYWxvZ1BsYWNlbWVudCk7XG5cblx0XHQvLyB1cGRhdGUgdGhlIGVsZW1lbnRcblx0XHRwb3NpdGlvblNlcnZpY2Uuc2V0RWxlbWVudChlbCwgcG9zKTtcblx0XHRzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5wbGFjZW1lbnQgPSBkaWFsb2dQbGFjZW1lbnQ7IH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdXAgYSBLZXlib2FyZEV2ZW50IHRvIGNsb3NlIGBEaWFsb2dgIHdpdGggRXNjYXBlIGtleS5cblx0ICogQHBhcmFtIGV2ZW50XG5cdCAqL1xuXHRASG9zdExpc3RlbmVyKFwia2V5ZG93blwiLCBbXCIkZXZlbnRcIl0pXG5cdGVzY2FwZUNsb3NlKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG5cdFx0c3dpdGNoIChldmVudC5rZXkpIHtcblx0XHRcdGNhc2UgXCJFc2NcIjogLy8gSUUgc3BlY2lmaWMgdmFsdWVcblx0XHRcdGNhc2UgXCJFc2NhcGVcIjoge1xuXHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0dGhpcy5kb0Nsb3NlKHtcblx0XHRcdFx0XHRyZWFzb246IENsb3NlUmVhc29ucy5pbnRlcmFjdGlvbixcblx0XHRcdFx0XHR0YXJnZXQ6IGV2ZW50LnRhcmdldFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRjYXNlIFwiVGFiXCI6IHtcblx0XHRcdFx0Y3ljbGVUYWJzKGV2ZW50LCB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHVwIGEgZXZlbnQgTGlzdGVuZXIgdG8gY2xvc2UgYERpYWxvZ2AgaWYgY2xpY2sgZXZlbnQgb2NjdXJzIG91dHNpZGVcblx0ICogYERpYWxvZ2Agb2JqZWN0LlxuXHQgKiBAcGFyYW0gZXZlbnRcblx0ICovXG5cdEBIb3N0TGlzdGVuZXIoXCJkb2N1bWVudDpjbGlja1wiLCBbXCIkZXZlbnRcIl0pXG5cdGNsaWNrQ2xvc2UoZXZlbnQpIHtcblx0XHRpZiAoIXRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldClcblx0XHRcdCYmICF0aGlzLmRpYWxvZ0NvbmZpZy5wYXJlbnRSZWYubmF0aXZlRWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpICkge1xuXHRcdFx0dGhpcy5kb0Nsb3NlKHtcblx0XHRcdFx0cmVhc29uOiBDbG9zZVJlYXNvbnMuaW50ZXJhY3Rpb24sXG5cdFx0XHRcdHRhcmdldDogZXZlbnQudGFyZ2V0XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2xvc2VzIGBEaWFsb2dgIG9iamVjdCBieSBlbWl0dGluZyB0aGUgY2xvc2UgZXZlbnQgdXB3YXJkcyB0byBwYXJlbnRzLlxuXHQgKi9cblx0cHVibGljIGRvQ2xvc2UobWV0YTogQ2xvc2VNZXRhID0geyByZWFzb246IENsb3NlUmVhc29ucy5pbnRlcmFjdGlvbiB9KSB7XG5cdFx0dGhpcy5jbG9zZS5lbWl0KG1ldGEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEF0IGRlc3RydWN0aW9uIG9mIGNvbXBvbmVudCwgYERpYWxvZ2AgdW5zdWJzY3JpYmVzIGZyb20gYWxsIHRoZSBzdWJzY3JpcHRpb25zLlxuXHQgKi9cblx0bmdPbkRlc3Ryb3koKSB7XG5cdFx0dGhpcy52aXNpYmlsaXR5U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG5cdFx0aWYgKHRoaXMuYW5pbWF0aW9uRnJhbWVTdWJzY3JpcHRpb24pIHtcblx0XHRcdHRoaXMuYW5pbWF0aW9uRnJhbWVTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcblx0XHR9XG5cdH1cbn1cbiJdfQ==