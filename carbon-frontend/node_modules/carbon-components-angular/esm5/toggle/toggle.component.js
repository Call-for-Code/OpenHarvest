/**
 *
 * carbon-angular v0.0.0 | toggle.component.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import * as tslib_1 from "tslib";
import { Checkbox } from "carbon-components-angular/checkbox";
import { ChangeDetectorRef, Component, Input, Output, EventEmitter, TemplateRef } from "@angular/core";
import { NG_VALUE_ACCESSOR } from "@angular/forms";
import { I18n } from "carbon-components-angular/i18n";
/**
 * Defines the set of states for a toggle component.
 */
export var ToggleState;
(function (ToggleState) {
    ToggleState[ToggleState["Init"] = 0] = "Init";
    ToggleState[ToggleState["Indeterminate"] = 1] = "Indeterminate";
    ToggleState[ToggleState["Checked"] = 2] = "Checked";
    ToggleState[ToggleState["Unchecked"] = 3] = "Unchecked";
})(ToggleState || (ToggleState = {}));
/**
 * Used to emit changes performed on toggle components.
 *
 * @deprecated since v4
 */
var ToggleChange = /** @class */ (function () {
    function ToggleChange() {
    }
    return ToggleChange;
}());
export { ToggleChange };
/**
 * [See demo](../../?path=/story/toggle--basic)
 *
 * ```html
 * <ibm-toggle [(ngModel)]="toggleState">Toggle</ibm-toggle>
 * ```
 *
 * <example-url>../../iframe.html?id=toggle--basic</example-url>
 */
var Toggle = /** @class */ (function (_super) {
    tslib_1.__extends(Toggle, _super);
    /**
     * Creates an instance of Toggle.
     */
    function Toggle(changeDetectorRef, i18n) {
        var _this = _super.call(this, changeDetectorRef) || this;
        _this.changeDetectorRef = changeDetectorRef;
        _this.i18n = i18n;
        /**
         * Size of the toggle component.
         */
        _this.size = "md";
        /**
         * Set to `true` for a loading toggle.
         */
        _this.skeleton = false;
        /**
         * The unique id allocated to the `Toggle`.
         */
        _this.id = "toggle-" + Toggle.toggleCount;
        /**
         * Emits event notifying other classes when a change in state occurs on a toggle after a
         * click.
         *
         * @deprecated since v4
         */
        _this.change = new EventEmitter();
        _this._offValues = _this.i18n.getOverridable("TOGGLE.OFF");
        _this._onValues = _this.i18n.getOverridable("TOGGLE.ON");
        Toggle.toggleCount++;
        return _this;
    }
    Object.defineProperty(Toggle.prototype, "offText", {
        get: function () {
            return this._offValues.value;
        },
        /**
         * Text that is set on the left side of the toggle.
         */
        set: function (value) {
            this._offValues.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Toggle.prototype, "onText", {
        get: function () {
            return this._onValues.value;
        },
        /**
         * Text that is set on the right side of the toggle.
         */
        set: function (value) {
            this._onValues.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Toggle.prototype.getOffText = function () {
        return this._offValues.subject;
    };
    Toggle.prototype.getOnText = function () {
        return this._onValues.subject;
    };
    /**
     * Creates instance of `ToggleChange` used to propagate the change event.
     */
    Toggle.prototype.emitChangeEvent = function () {
        /* begin deprecation */
        var event = new ToggleChange();
        event.source = this;
        event.checked = this.checked;
        this.change.emit(event);
        /* end deprecation */
        this.checkedChange.emit(this.checked);
        this.propagateChange(this.checked);
    };
    Toggle.prototype.isTemplate = function (value) {
        return value instanceof TemplateRef;
    };
    /**
     * Variable used for creating unique ids for toggle components.
     */
    Toggle.toggleCount = 0;
    Toggle.decorators = [
        { type: Component, args: [{
                    selector: "ibm-toggle",
                    template: "\n\t\t<label *ngIf=\"label\" [id]=\"ariaLabelledby\" class=\"bx--label\">\n\t\t\t<ng-container *ngIf=\"!isTemplate(label)\">{{label}}</ng-container>\n\t\t\t<ng-template *ngIf=\"isTemplate(label)\" [ngTemplateOutlet]=\"label\"></ng-template>\n\t\t</label>\n\t\t<input\n\t\t\tclass=\"bx--toggle-input\"\n\t\t\ttype=\"checkbox\"\n\t\t\t[ngClass]=\"{\n\t\t\t\t'bx--toggle-input--small': size === 'sm',\n\t\t\t\t'bx--skeleton': skeleton\n\t\t\t}\"\n\t\t\t[id]=\"id\"\n\t\t\t[value]=\"value\"\n\t\t\t[name]=\"name\"\n\t\t\t[required]=\"required\"\n\t\t\t[checked]=\"checked\"\n\t\t\t[disabled]=\"disabled\"\n\t\t\t[attr.aria-labelledby]=\"ariaLabelledby\"\n\t\t\t[attr.aria-checked]=\"checked\"\n\t\t\t(change)=\"onChange($event)\"\n\t\t\t(click)=\"onClick($event)\">\n\t\t<label\n\t\t\tclass=\"bx--toggle-input__label\"\n\t\t\t[for]=\"id\"\n\t\t\t[ngClass]=\"{\n\t\t\t\t'bx--skeleton': skeleton\n\t\t\t}\">\n\t\t\t<span class=\"bx--toggle__switch\">\n\t\t\t\t<span class=\"bx--toggle__text--off\">{{(!skeleton ? getOffText() : null) | async }}</span>\n\t\t\t\t<span class=\"bx--toggle__text--on\">{{(!skeleton ? getOnText() : null) | async}}</span>\n\t\t\t</span>\n\t\t</label>\n\t",
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: Toggle,
                            multi: true
                        }
                    ]
                }] }
    ];
    /** @nocollapse */
    Toggle.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: I18n }
    ]; };
    Toggle.propDecorators = {
        offText: [{ type: Input }],
        onText: [{ type: Input }],
        label: [{ type: Input }],
        size: [{ type: Input }],
        skeleton: [{ type: Input }],
        change: [{ type: Output }]
    };
    return Toggle;
}(Checkbox));
export { Toggle };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9nZ2xlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvdG9nZ2xlLyIsInNvdXJjZXMiOlsidG9nZ2xlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLG9DQUFvQyxDQUFDO0FBQzlELE9BQU8sRUFDTixpQkFBaUIsRUFDakIsU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLFdBQVcsRUFDWCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVuRCxPQUFPLEVBQUUsSUFBSSxFQUFlLE1BQU0sZ0NBQWdDLENBQUM7QUFHbkU7O0dBRUc7QUFDSCxNQUFNLENBQU4sSUFBWSxXQUtYO0FBTEQsV0FBWSxXQUFXO0lBQ3RCLDZDQUFJLENBQUE7SUFDSiwrREFBYSxDQUFBO0lBQ2IsbURBQU8sQ0FBQTtJQUNQLHVEQUFTLENBQUE7QUFDVixDQUFDLEVBTFcsV0FBVyxLQUFYLFdBQVcsUUFLdEI7QUFFRDs7OztHQUlHO0FBQ0g7SUFBQTtJQVNBLENBQUM7SUFBRCxtQkFBQztBQUFELENBQUMsQUFURCxJQVNDOztBQUVEOzs7Ozs7OztHQVFHO0FBQ0g7SUE0QzRCLGtDQUFRO0lBeURuQzs7T0FFRztJQUNILGdCQUFzQixpQkFBb0MsRUFBWSxJQUFVO1FBQWhGLFlBQ0Msa0JBQU0saUJBQWlCLENBQUMsU0FFeEI7UUFIcUIsdUJBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtRQUFZLFVBQUksR0FBSixJQUFJLENBQU07UUEzQmhGOztXQUVHO1FBQ00sVUFBSSxHQUFnQixJQUFJLENBQUM7UUFDbEM7O1dBRUc7UUFDTSxjQUFRLEdBQUcsS0FBSyxDQUFDO1FBRTFCOztXQUVHO1FBQ0gsUUFBRSxHQUFHLFNBQVMsR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDO1FBRXBDOzs7OztXQUtHO1FBQ08sWUFBTSxHQUFHLElBQUksWUFBWSxFQUFnQixDQUFDO1FBRTFDLGdCQUFVLEdBQUcsS0FBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDcEQsZUFBUyxHQUFHLEtBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBTTNELE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQzs7SUFDdEIsQ0FBQztJQXRERCxzQkFDSSwyQkFBTzthQUlYO1lBQ0MsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQztRQUM5QixDQUFDO1FBVkQ7O1dBRUc7YUFDSCxVQUNZLEtBQWtDO1lBQzdDLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2pDLENBQUM7OztPQUFBO0lBU0Qsc0JBQ0ksMEJBQU07YUFJVjtZQUNDLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUM7UUFDN0IsQ0FBQztRQVZEOztXQUVHO2FBQ0gsVUFDVyxLQUFrQztZQUM1QyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNoQyxDQUFDOzs7T0FBQTtJQXlDRCwyQkFBVSxHQUFWO1FBQ0MsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQztJQUNoQyxDQUFDO0lBRUQsMEJBQVMsR0FBVDtRQUNDLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUM7SUFDL0IsQ0FBQztJQUVEOztPQUVHO0lBQ0gsZ0NBQWUsR0FBZjtRQUNDLHVCQUF1QjtRQUN2QixJQUFJLEtBQUssR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBQy9CLEtBQUssQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO1FBQ3BCLEtBQUssQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUM3QixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN4QixxQkFBcUI7UUFFckIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3RDLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFTSwyQkFBVSxHQUFqQixVQUFrQixLQUFLO1FBQ3RCLE9BQU8sS0FBSyxZQUFZLFdBQVcsQ0FBQztJQUNyQyxDQUFDO0lBekZEOztPQUVHO0lBQ0ksa0JBQVcsR0FBRyxDQUFDLENBQUM7O2dCQWhEdkIsU0FBUyxTQUFDO29CQUNWLFFBQVEsRUFBRSxZQUFZO29CQUN0QixRQUFRLEVBQUUsMHBDQWlDVDtvQkFDRCxTQUFTLEVBQUU7d0JBQ1Y7NEJBQ0MsT0FBTyxFQUFFLGlCQUFpQjs0QkFDMUIsV0FBVyxFQUFFLE1BQU07NEJBQ25CLEtBQUssRUFBRSxJQUFJO3lCQUNYO3FCQUNEO2lCQUNEOzs7O2dCQTFGQSxpQkFBaUI7Z0JBU1QsSUFBSTs7OzBCQTJGWCxLQUFLO3lCQVlMLEtBQUs7d0JBV0wsS0FBSzt1QkFJTCxLQUFLOzJCQUlMLEtBQUs7eUJBYUwsTUFBTTs7SUFzQ1IsYUFBQztDQUFBLEFBdklELENBNEM0QixRQUFRLEdBMkZuQztTQTNGWSxNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hlY2tib3ggfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9jaGVja2JveFwiO1xuaW1wb3J0IHtcblx0Q2hhbmdlRGV0ZWN0b3JSZWYsXG5cdENvbXBvbmVudCxcblx0SW5wdXQsXG5cdE91dHB1dCxcblx0RXZlbnRFbWl0dGVyLFxuXHRUZW1wbGF0ZVJlZlxufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tIFwiQGFuZ3VsYXIvZm9ybXNcIjtcblxuaW1wb3J0IHsgSTE4biwgT3ZlcnJpZGFibGUgfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9pMThuXCI7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSBcInJ4anNcIjtcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBzZXQgb2Ygc3RhdGVzIGZvciBhIHRvZ2dsZSBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBlbnVtIFRvZ2dsZVN0YXRlIHtcblx0SW5pdCxcblx0SW5kZXRlcm1pbmF0ZSxcblx0Q2hlY2tlZCxcblx0VW5jaGVja2VkXG59XG5cbi8qKlxuICogVXNlZCB0byBlbWl0IGNoYW5nZXMgcGVyZm9ybWVkIG9uIHRvZ2dsZSBjb21wb25lbnRzLlxuICpcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHY0XG4gKi9cbmV4cG9ydCBjbGFzcyBUb2dnbGVDaGFuZ2Uge1xuXHQvKipcblx0ICogQ29udGFpbnMgdGhlIGBUb2dnbGVgIHRoYXQgaGFzIGJlZW4gY2hhbmdlZC5cblx0ICovXG5cdHNvdXJjZTogVG9nZ2xlO1xuXHQvKipcblx0ICogVGhlIHN0YXRlIG9mIHRoZSBgVG9nZ2xlYCBlbmNvbXBhc3NlZCBpbiB0aGUgYFRvZ2dsZUNoYW5nZWAgY2xhc3MuXG5cdCAqL1xuXHRjaGVja2VkOiBib29sZWFuO1xufVxuXG4vKipcbiAqIFtTZWUgZGVtb10oLi4vLi4vP3BhdGg9L3N0b3J5L3RvZ2dsZS0tYmFzaWMpXG4gKlxuICogYGBgaHRtbFxuICogPGlibS10b2dnbGUgWyhuZ01vZGVsKV09XCJ0b2dnbGVTdGF0ZVwiPlRvZ2dsZTwvaWJtLXRvZ2dsZT5cbiAqIGBgYFxuICpcbiAqIDxleGFtcGxlLXVybD4uLi8uLi9pZnJhbWUuaHRtbD9pZD10b2dnbGUtLWJhc2ljPC9leGFtcGxlLXVybD5cbiAqL1xuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiBcImlibS10b2dnbGVcIixcblx0dGVtcGxhdGU6IGBcblx0XHQ8bGFiZWwgKm5nSWY9XCJsYWJlbFwiIFtpZF09XCJhcmlhTGFiZWxsZWRieVwiIGNsYXNzPVwiYngtLWxhYmVsXCI+XG5cdFx0XHQ8bmctY29udGFpbmVyICpuZ0lmPVwiIWlzVGVtcGxhdGUobGFiZWwpXCI+e3tsYWJlbH19PC9uZy1jb250YWluZXI+XG5cdFx0XHQ8bmctdGVtcGxhdGUgKm5nSWY9XCJpc1RlbXBsYXRlKGxhYmVsKVwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImxhYmVsXCI+PC9uZy10ZW1wbGF0ZT5cblx0XHQ8L2xhYmVsPlxuXHRcdDxpbnB1dFxuXHRcdFx0Y2xhc3M9XCJieC0tdG9nZ2xlLWlucHV0XCJcblx0XHRcdHR5cGU9XCJjaGVja2JveFwiXG5cdFx0XHRbbmdDbGFzc109XCJ7XG5cdFx0XHRcdCdieC0tdG9nZ2xlLWlucHV0LS1zbWFsbCc6IHNpemUgPT09ICdzbScsXG5cdFx0XHRcdCdieC0tc2tlbGV0b24nOiBza2VsZXRvblxuXHRcdFx0fVwiXG5cdFx0XHRbaWRdPVwiaWRcIlxuXHRcdFx0W3ZhbHVlXT1cInZhbHVlXCJcblx0XHRcdFtuYW1lXT1cIm5hbWVcIlxuXHRcdFx0W3JlcXVpcmVkXT1cInJlcXVpcmVkXCJcblx0XHRcdFtjaGVja2VkXT1cImNoZWNrZWRcIlxuXHRcdFx0W2Rpc2FibGVkXT1cImRpc2FibGVkXCJcblx0XHRcdFthdHRyLmFyaWEtbGFiZWxsZWRieV09XCJhcmlhTGFiZWxsZWRieVwiXG5cdFx0XHRbYXR0ci5hcmlhLWNoZWNrZWRdPVwiY2hlY2tlZFwiXG5cdFx0XHQoY2hhbmdlKT1cIm9uQ2hhbmdlKCRldmVudClcIlxuXHRcdFx0KGNsaWNrKT1cIm9uQ2xpY2soJGV2ZW50KVwiPlxuXHRcdDxsYWJlbFxuXHRcdFx0Y2xhc3M9XCJieC0tdG9nZ2xlLWlucHV0X19sYWJlbFwiXG5cdFx0XHRbZm9yXT1cImlkXCJcblx0XHRcdFtuZ0NsYXNzXT1cIntcblx0XHRcdFx0J2J4LS1za2VsZXRvbic6IHNrZWxldG9uXG5cdFx0XHR9XCI+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImJ4LS10b2dnbGVfX3N3aXRjaFwiPlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImJ4LS10b2dnbGVfX3RleHQtLW9mZlwiPnt7KCFza2VsZXRvbiA/IGdldE9mZlRleHQoKSA6IG51bGwpIHwgYXN5bmMgfX08L3NwYW4+XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiYngtLXRvZ2dsZV9fdGV4dC0tb25cIj57eyghc2tlbGV0b24gPyBnZXRPblRleHQoKSA6IG51bGwpIHwgYXN5bmN9fTwvc3Bhbj5cblx0XHRcdDwvc3Bhbj5cblx0XHQ8L2xhYmVsPlxuXHRgLFxuXHRwcm92aWRlcnM6IFtcblx0XHR7XG5cdFx0XHRwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcblx0XHRcdHVzZUV4aXN0aW5nOiBUb2dnbGUsXG5cdFx0XHRtdWx0aTogdHJ1ZVxuXHRcdH1cblx0XVxufSlcbmV4cG9ydCBjbGFzcyBUb2dnbGUgZXh0ZW5kcyBDaGVja2JveCB7XG5cdC8qKlxuXHQgKiBWYXJpYWJsZSB1c2VkIGZvciBjcmVhdGluZyB1bmlxdWUgaWRzIGZvciB0b2dnbGUgY29tcG9uZW50cy5cblx0ICovXG5cdHN0YXRpYyB0b2dnbGVDb3VudCA9IDA7XG5cblx0LyoqXG5cdCAqIFRleHQgdGhhdCBpcyBzZXQgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgdG9nZ2xlLlxuXHQgKi9cblx0QElucHV0KClcblx0c2V0IG9mZlRleHQodmFsdWU6IHN0cmluZyB8IE9ic2VydmFibGU8c3RyaW5nPikge1xuXHRcdHRoaXMuX29mZlZhbHVlcy5vdmVycmlkZSh2YWx1ZSk7XG5cdH1cblxuXHRnZXQgb2ZmVGV4dCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fb2ZmVmFsdWVzLnZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRleHQgdGhhdCBpcyBzZXQgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHRvZ2dsZS5cblx0ICovXG5cdEBJbnB1dCgpXG5cdHNldCBvblRleHQodmFsdWU6IHN0cmluZyB8IE9ic2VydmFibGU8c3RyaW5nPikge1xuXHRcdHRoaXMuX29uVmFsdWVzLm92ZXJyaWRlKHZhbHVlKTtcblx0fVxuXG5cdGdldCBvblRleHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX29uVmFsdWVzLnZhbHVlO1xuXHR9XG5cdC8qKlxuXHQgKiBUZXh0IHRoYXQgaXMgc2V0IGFzIHRoZSBsYWJlbCBvZiB0aGUgdG9nZ2xlLlxuXHQgKi9cblx0QElucHV0KCkgbGFiZWw6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cdC8qKlxuXHQgKiBTaXplIG9mIHRoZSB0b2dnbGUgY29tcG9uZW50LlxuXHQgKi9cblx0QElucHV0KCkgc2l6ZTogXCJzbVwiIHwgXCJtZFwiID0gXCJtZFwiO1xuXHQvKipcblx0ICogU2V0IHRvIGB0cnVlYCBmb3IgYSBsb2FkaW5nIHRvZ2dsZS5cblx0ICovXG5cdEBJbnB1dCgpIHNrZWxldG9uID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIFRoZSB1bmlxdWUgaWQgYWxsb2NhdGVkIHRvIHRoZSBgVG9nZ2xlYC5cblx0ICovXG5cdGlkID0gXCJ0b2dnbGUtXCIgKyBUb2dnbGUudG9nZ2xlQ291bnQ7XG5cblx0LyoqXG5cdCAqIEVtaXRzIGV2ZW50IG5vdGlmeWluZyBvdGhlciBjbGFzc2VzIHdoZW4gYSBjaGFuZ2UgaW4gc3RhdGUgb2NjdXJzIG9uIGEgdG9nZ2xlIGFmdGVyIGFcblx0ICogY2xpY2suXG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHY0XG5cdCAqL1xuXHRAT3V0cHV0KCkgY2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxUb2dnbGVDaGFuZ2U+KCk7XG5cblx0cHJvdGVjdGVkIF9vZmZWYWx1ZXMgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUT0dHTEUuT0ZGXCIpO1xuXHRwcm90ZWN0ZWQgX29uVmFsdWVzID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVE9HR0xFLk9OXCIpO1xuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBUb2dnbGUuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLCBwcm90ZWN0ZWQgaTE4bjogSTE4bikge1xuXHRcdHN1cGVyKGNoYW5nZURldGVjdG9yUmVmKTtcblx0XHRUb2dnbGUudG9nZ2xlQ291bnQrKztcblx0fVxuXG5cdGdldE9mZlRleHQoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcblx0XHRyZXR1cm4gdGhpcy5fb2ZmVmFsdWVzLnN1YmplY3Q7XG5cdH1cblxuXHRnZXRPblRleHQoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcblx0XHRyZXR1cm4gdGhpcy5fb25WYWx1ZXMuc3ViamVjdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGluc3RhbmNlIG9mIGBUb2dnbGVDaGFuZ2VgIHVzZWQgdG8gcHJvcGFnYXRlIHRoZSBjaGFuZ2UgZXZlbnQuXG5cdCAqL1xuXHRlbWl0Q2hhbmdlRXZlbnQoKSB7XG5cdFx0LyogYmVnaW4gZGVwcmVjYXRpb24gKi9cblx0XHRsZXQgZXZlbnQgPSBuZXcgVG9nZ2xlQ2hhbmdlKCk7XG5cdFx0ZXZlbnQuc291cmNlID0gdGhpcztcblx0XHRldmVudC5jaGVja2VkID0gdGhpcy5jaGVja2VkO1xuXHRcdHRoaXMuY2hhbmdlLmVtaXQoZXZlbnQpO1xuXHRcdC8qIGVuZCBkZXByZWNhdGlvbiAqL1xuXG5cdFx0dGhpcy5jaGVja2VkQ2hhbmdlLmVtaXQodGhpcy5jaGVja2VkKTtcblx0XHR0aGlzLnByb3BhZ2F0ZUNoYW5nZSh0aGlzLmNoZWNrZWQpO1xuXHR9XG5cblx0cHVibGljIGlzVGVtcGxhdGUodmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlZjtcblx0fVxufVxuIl19