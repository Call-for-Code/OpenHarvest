/**
 *
 * carbon-angular v0.0.0 | checkbox.component.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, Input, Output, ViewChild, HostBinding, HostListener } from "@angular/core";
import { NG_VALUE_ACCESSOR } from "@angular/forms";
/**
 * Defines the set of states for a checkbox component.
 */
export var CheckboxState;
(function (CheckboxState) {
    CheckboxState[CheckboxState["Init"] = 0] = "Init";
    CheckboxState[CheckboxState["Indeterminate"] = 1] = "Indeterminate";
    CheckboxState[CheckboxState["Checked"] = 2] = "Checked";
    CheckboxState[CheckboxState["Unchecked"] = 3] = "Unchecked";
})(CheckboxState || (CheckboxState = {}));
/**
 * Used to emit changes performed on checkbox components.
 *
 * @deprecated since v4
 */
var CheckboxChange = /** @class */ (function () {
    function CheckboxChange() {
    }
    return CheckboxChange;
}());
export { CheckboxChange };
/**
 * [See demo](../../?path=/story/checkbox--basic)
 *
 * <example-url>../../iframe.html?id=checkbox--basic</example-url>
 */
var Checkbox = /** @class */ (function () {
    /**
     * Creates an instance of `Checkbox`.
     */
    function Checkbox(changeDetectorRef) {
        this.changeDetectorRef = changeDetectorRef;
        /**
         * Size of the checkbox.
         *
         * @deprecated since v4
         */
        this.size = "md";
        /**
         * Set to `true` for checkbox to be rendered without any classes on the host element.
         */
        this.inline = false;
        /**
         * Set to `true` for a disabled checkbox.
         */
        this.disabled = false;
        /**
         * Set to `true` for a loading checkbox.
         */
        this.skeleton = false;
        /**
         * Set to `true` to hide the checkbox labels.
         */
        this.hideLabel = false;
        /**
         * The unique id for the checkbox component.
         */
        this.id = "checkbox-" + Checkbox.checkboxCount;
        // TODO: drop the `_`
        // tslint:disable-next-line:no-input-rename
        this._ariaLabel = "";
        /**
         * Emits click event.
         */
        this.click = new EventEmitter();
        /**
         * Emits event notifying other classes when a change in state occurs on a checkbox after a
         * click.
         *
         * @deprecated since v4 use `checked` and `checkedChange` instead
         */
        this.change = new EventEmitter();
        /**
         * Emits an event when the value of the checkbox changes.
         *
         * Allows double biding with the `checked` Input.
         */
        this.checkedChange = new EventEmitter();
        /**
         * Emits event notifying other classes when a change in state occurs specifically
         * on an indeterminate checkbox.
         */
        this.indeterminateChange = new EventEmitter();
        /**
         * Set to `true` if the input checkbox is selected (or checked).
         */
        this._checked = false;
        /**
         * Set to `true` if the input checkbox is in state indeterminate.
         */
        this._indeterminate = false;
        /**
         * Keeps a reference to the checkboxes current state, as defined in `CheckboxState`.
         */
        this.currentCheckboxState = CheckboxState.Init;
        /**
         * Called when checkbox is blurred. Needed to properly implement `ControlValueAccessor`.
         */
        this.onTouched = function () { };
        /**
         * Method set in `registerOnChange` to propagate changes back to the form.
         */
        this.propagateChange = function (_) { };
        Checkbox.checkboxCount++;
    }
    Object.defineProperty(Checkbox.prototype, "ariaLabel", {
        get: function () {
            return this._ariaLabel;
        },
        /**
         * Used to set the `aria-label` attribute on the input element.
         *
         * @deprecated since v4 use the `ariaLabel` input instead
         */
        // tslint:disable-next-line:no-input-rename
        set: function (value) {
            this._ariaLabel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Checkbox.prototype, "ariaLabelledby", {
        get: function () {
            return this._ariaLabelledby;
        },
        /**
         * Used to set the `aria-labelledby` attribute on the input element.
         *
         * @deprecated since v4 use the `ariaLabelledby` input instead
         */
        // tslint:disable-next-line:no-input-rename
        set: function (value) {
            this._ariaLabelledby = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Checkbox.prototype, "indeterminate", {
        /**
         * Reflects whether the checkbox state is indeterminate.
         */
        get: function () {
            return this._indeterminate;
        },
        /**
         * Set the checkbox's indeterminate state to match the parameter and transition the view to reflect the change.
         *
         * Allows double binding with the `indeterminateChange` Output.
         */
        set: function (indeterminate) {
            if (indeterminate === this._indeterminate) {
                return;
            }
            this._indeterminate = indeterminate;
            if (this._indeterminate) {
                this.transitionCheckboxState(CheckboxState.Indeterminate);
            }
            else {
                this.transitionCheckboxState(this.checked ? CheckboxState.Checked : CheckboxState.Unchecked);
            }
            this.inputCheckbox.nativeElement.indeterminate = indeterminate;
            this.changeDetectorRef.markForCheck();
            this.indeterminateChange.emit(this._indeterminate);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Checkbox.prototype, "checked", {
        /**
         * Returns value `true` if state is selected for the checkbox.
         */
        get: function () {
            return this._checked;
        },
        /**
         * Sets the `checked` state. `true` for checked, `false` for unchecked
         *
         * Allows double binding with the `checkedChange` Output.
         */
        set: function (checked) {
            this.setChecked(checked, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Checkbox.prototype, "checkboxWrapperClass", {
        get: function () {
            return !this.inline;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Checkbox.prototype, "formItemClass", {
        get: function () {
            return !this.inline;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Toggle the selected state of the checkbox.
     */
    Checkbox.prototype.toggle = function () {
        // Flip checked and reset indeterminate
        this.setChecked(!this.checked, true);
    };
    /**
     * Writes a value from `ngModel` to the component.
     *
     * In this case the value is the `checked` property.
     *
     * @param value boolean, corresponds to the `checked` property.
     */
    Checkbox.prototype.writeValue = function (value) {
        // Set checked and reset indeterminate
        this.setChecked(!!value, true);
    };
    /**
     * Sets a method in order to propagate changes back to the form.
     */
    Checkbox.prototype.registerOnChange = function (fn) {
        this.propagateChange = fn;
    };
    /**
     * Registers a callback to be triggered when the control has been touched.
     * @param fn Callback to be triggered when the checkbox is touched.
     */
    Checkbox.prototype.registerOnTouched = function (fn) {
        this.onTouched = fn;
    };
    Checkbox.prototype.focusOut = function () {
        this.onTouched();
    };
    /**
     * Executes on the event of a change within `Checkbox` to block propagation.
     */
    Checkbox.prototype.onChange = function (event) {
        event.stopPropagation();
    };
    /**
     * Handles click events on the `Checkbox` and emits changes to other classes.
     */
    Checkbox.prototype.onClick = function (event) {
        if (this.click.observers.length) {
            // Disable default checkbox activation behavior which flips checked and resets indeterminate.
            // This allows the parent component to control the checked/indeterminate properties.
            event.preventDefault();
            this.click.emit();
            return;
        }
        if (!this.disabled) {
            this.toggle();
            this.transitionCheckboxState(this._checked ? CheckboxState.Checked : CheckboxState.Unchecked);
            this.emitChangeEvent();
        }
    };
    /**
     * Handles changes between checkbox states.
     */
    Checkbox.prototype.transitionCheckboxState = function (newState) {
        this.currentCheckboxState = newState;
    };
    /**
     * Creates instance of `CheckboxChange` used to propagate the change event.
     */
    Checkbox.prototype.emitChangeEvent = function () {
        /* begin deprecation */
        var event = new CheckboxChange();
        event.source = this;
        event.checked = this.checked;
        this.change.emit(event);
        /* end deprecation */
        this.checkedChange.emit(this.checked);
        this.propagateChange(this.checked);
    };
    /**
     * Updates the checkbox if it is in the indeterminate state.
     */
    Checkbox.prototype.ngAfterViewInit = function () {
        if (this.indeterminate) {
            this.inputCheckbox.nativeElement.indeterminate = true;
        }
    };
    /**
     * Sets checked state and optionally resets indeterminate state.
     */
    Checkbox.prototype.setChecked = function (checked, resetIndeterminate) {
        var _this = this;
        if (checked === this._checked) {
            return;
        }
        this._checked = checked;
        // Reset indeterminate if requested
        if (resetIndeterminate && this._indeterminate) {
            this._indeterminate = false;
            Promise.resolve().then(function () {
                _this.indeterminateChange.emit(_this._indeterminate);
            });
        }
        this.changeDetectorRef.markForCheck();
    };
    /**
     * Variable used for creating unique ids for checkbox components.
     */
    Checkbox.checkboxCount = 0;
    Checkbox.decorators = [
        { type: Component, args: [{
                    selector: "ibm-checkbox",
                    template: "\n\t\t<div class=\"bx--form-item bx--checkbox-wrapper\">\n\t\t\t<input\n\t\t\t\t#inputCheckbox\n\t\t\t\tclass=\"bx--checkbox\"\n\t\t\t\ttype=\"checkbox\"\n\t\t\t\t[id]=\"id + '_input'\"\n\t\t\t\t[value]=\"value\"\n\t\t\t\t[name]=\"name\"\n\t\t\t\t[required]=\"required\"\n\t\t\t\t[checked]=\"checked\"\n\t\t\t\t[disabled]=\"disabled\"\n\t\t\t\t[attr.aria-labelledby]=\"ariaLabelledby\"\n\t\t\t\t[attr.aria-checked]=\"(indeterminate ? 'mixed' : checked)\"\n\t\t\t\t(change)=\"onChange($event)\"\n\t\t\t\t(click)=\"onClick($event)\">\n\t\t\t<label\n\t\t\t\t[for]=\"id + '_input'\"\n\t\t\t\t[attr.aria-label]=\"ariaLabel\"\n\t\t\t\tclass=\"bx--checkbox-label\"\n\t\t\t\t[ngClass]=\"{\n\t\t\t\t\t'bx--skeleton' : skeleton\n\t\t\t\t}\">\n\t\t\t\t<span [ngClass]=\"{'bx--visually-hidden' : hideLabel}\" class=\"bx--checkbox-label-text\">\n\t\t\t\t\t<ng-content></ng-content>\n\t\t\t\t</span>\n\t\t\t</label>\n\t\t</div>\n\t",
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: Checkbox,
                            multi: true
                        }
                    ],
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    Checkbox.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    Checkbox.propDecorators = {
        size: [{ type: Input }],
        nested: [{ type: Input }],
        inline: [{ type: Input }],
        disabled: [{ type: Input }],
        skeleton: [{ type: Input }],
        hideLabel: [{ type: Input }],
        name: [{ type: Input }],
        id: [{ type: Input }],
        required: [{ type: Input }],
        value: [{ type: Input }],
        ariaLabel: [{ type: Input, args: ["aria-label",] }],
        _ariaLabel: [{ type: Input, args: ["ariaLabel",] }],
        ariaLabelledby: [{ type: Input, args: ["aria-labelledby",] }],
        _ariaLabelledby: [{ type: Input, args: ["ariaLabelledby",] }],
        indeterminate: [{ type: Input }],
        checked: [{ type: Input }],
        checkboxWrapperClass: [{ type: HostBinding, args: ["class.bx--checkbox-wrapper",] }],
        formItemClass: [{ type: HostBinding, args: ["class.bx--form-item",] }],
        click: [{ type: Output }],
        change: [{ type: Output }],
        checkedChange: [{ type: Output }],
        indeterminateChange: [{ type: Output }],
        inputCheckbox: [{ type: ViewChild, args: ["inputCheckbox", { static: false },] }],
        focusOut: [{ type: HostListener, args: ["focusout",] }]
    };
    return Checkbox;
}());
export { Checkbox };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2tib3guY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9jaGVja2JveC8iLCJzb3VyY2VzIjpbImNoZWNrYm94LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRU4sdUJBQXVCLEVBQ3ZCLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixLQUFLLEVBQ0wsTUFBTSxFQUNOLFNBQVMsRUFDVCxXQUFXLEVBQ1gsWUFBWSxFQUNaLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxpQkFBaUIsRUFBd0IsTUFBTSxnQkFBZ0IsQ0FBQztBQUd6RTs7R0FFRztBQUNILE1BQU0sQ0FBTixJQUFZLGFBS1g7QUFMRCxXQUFZLGFBQWE7SUFDeEIsaURBQUksQ0FBQTtJQUNKLG1FQUFhLENBQUE7SUFDYix1REFBTyxDQUFBO0lBQ1AsMkRBQVMsQ0FBQTtBQUNWLENBQUMsRUFMVyxhQUFhLEtBQWIsYUFBYSxRQUt4QjtBQUVEOzs7O0dBSUc7QUFDSDtJQUFBO0lBU0EsQ0FBQztJQUFELHFCQUFDO0FBQUQsQ0FBQyxBQVRELElBU0M7O0FBRUQ7Ozs7R0FJRztBQUNIO0lBZ09DOztPQUVHO0lBQ0gsa0JBQXNCLGlCQUFvQztRQUFwQyxzQkFBaUIsR0FBakIsaUJBQWlCLENBQW1CO1FBckwxRDs7OztXQUlHO1FBQ00sU0FBSSxHQUFnQixJQUFJLENBQUM7UUFPbEM7O1dBRUc7UUFDTSxXQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ3hCOztXQUVHO1FBQ00sYUFBUSxHQUFHLEtBQUssQ0FBQztRQUMxQjs7V0FFRztRQUNNLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFDMUI7O1dBRUc7UUFDTSxjQUFTLEdBQUcsS0FBSyxDQUFDO1FBSzNCOztXQUVHO1FBQ00sT0FBRSxHQUFHLGNBQVksUUFBUSxDQUFDLGFBQWUsQ0FBQztRQXVCbkQscUJBQXFCO1FBQ3JC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bUJBQW1CLENBQUMsSUFBSSxDQUFDLEtBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUNwRCxDQUFDLENBQUMsQ0FBQztTQUNIO1FBQ0QsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ3ZDLENBQUM7SUF6VEQ7O09BRUc7SUFDSSxzQkFBYSxHQUFHLENBQUMsQ0FBQzs7Z0JBNUN6QixTQUFTLFNBQUM7b0JBQ1YsUUFBUSxFQUFFLGNBQWM7b0JBQ3hCLFFBQVEsRUFBRSx1NUJBNEJUO29CQUNELFNBQVMsRUFBRTt3QkFDVjs0QkFDQyxPQUFPLEVBQUUsaUJBQWlCOzRCQUMxQixXQUFXLEVBQUUsUUFBUTs0QkFDckIsS0FBSyxFQUFFLElBQUk7eUJBQ1g7cUJBQ0Q7b0JBQ0QsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07aUJBQy9DOzs7O2dCQW5GQSxpQkFBaUI7Ozt1QkErRmhCLEtBQUs7eUJBTUwsS0FBSzt5QkFJTCxLQUFLOzJCQUlMLEtBQUs7MkJBSUwsS0FBSzs0QkFJTCxLQUFLO3VCQUlMLEtBQUs7cUJBSUwsS0FBSzsyQkFJTCxLQUFLO3dCQUlMLEtBQUs7NEJBT0wsS0FBSyxTQUFDLFlBQVk7NkJBVWxCLEtBQUssU0FBQyxXQUFXO2lDQVFqQixLQUFLLFNBQUMsaUJBQWlCO2tDQVV2QixLQUFLLFNBQUMsZ0JBQWdCO2dDQU90QixLQUFLOzBCQThCTCxLQUFLO3VDQVdMLFdBQVcsU0FBQyw0QkFBNEI7Z0NBR3hDLFdBQVcsU0FBQyxxQkFBcUI7d0JBT2pDLE1BQU07eUJBT04sTUFBTTtnQ0FPTixNQUFNO3NDQU1OLE1BQU07Z0NBb0JOLFNBQVMsU0FBQyxlQUFlLEVBQUUsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFOzJCQTRDNUMsWUFBWSxTQUFDLFVBQVU7O0lBeUZ6QixlQUFDO0NBQUEsQUFuV0QsSUFtV0M7U0EzVFksUUFBUSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdEFmdGVyVmlld0luaXQsXG5cdENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuXHRDaGFuZ2VEZXRlY3RvclJlZixcblx0Q29tcG9uZW50LFxuXHRFbGVtZW50UmVmLFxuXHRFdmVudEVtaXR0ZXIsXG5cdElucHV0LFxuXHRPdXRwdXQsXG5cdFZpZXdDaGlsZCxcblx0SG9zdEJpbmRpbmcsXG5cdEhvc3RMaXN0ZW5lclxufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgTkdfVkFMVUVfQUNDRVNTT1IsIENvbnRyb2xWYWx1ZUFjY2Vzc29yIH0gZnJvbSBcIkBhbmd1bGFyL2Zvcm1zXCI7XG5pbXBvcnQgeyBDaGVja2JveFZhbHVlIH0gZnJvbSBcIi4vY2hlY2tib3gudHlwZXNcIjtcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBzZXQgb2Ygc3RhdGVzIGZvciBhIGNoZWNrYm94IGNvbXBvbmVudC5cbiAqL1xuZXhwb3J0IGVudW0gQ2hlY2tib3hTdGF0ZSB7XG5cdEluaXQsXG5cdEluZGV0ZXJtaW5hdGUsXG5cdENoZWNrZWQsXG5cdFVuY2hlY2tlZFxufVxuXG4vKipcbiAqIFVzZWQgdG8gZW1pdCBjaGFuZ2VzIHBlcmZvcm1lZCBvbiBjaGVja2JveCBjb21wb25lbnRzLlxuICpcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHY0XG4gKi9cbmV4cG9ydCBjbGFzcyBDaGVja2JveENoYW5nZSB7XG5cdC8qKlxuXHQgKiBDb250YWlucyB0aGUgYENoZWNrYm94YCB0aGF0IGhhcyBiZWVuIGNoYW5nZWQuXG5cdCAqL1xuXHRzb3VyY2U6IENoZWNrYm94O1xuXHQvKipcblx0ICogVGhlIHN0YXRlIG9mIHRoZSBgQ2hlY2tib3hgIGVuY29tcGFzc2VkIGluIHRoZSBgQ2hlY2tib3hDaGFuZ2VgIGNsYXNzLlxuXHQgKi9cblx0Y2hlY2tlZDogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBbU2VlIGRlbW9dKC4uLy4uLz9wYXRoPS9zdG9yeS9jaGVja2JveC0tYmFzaWMpXG4gKlxuICogPGV4YW1wbGUtdXJsPi4uLy4uL2lmcmFtZS5odG1sP2lkPWNoZWNrYm94LS1iYXNpYzwvZXhhbXBsZS11cmw+XG4gKi9cbkBDb21wb25lbnQoe1xuXHRzZWxlY3RvcjogXCJpYm0tY2hlY2tib3hcIixcblx0dGVtcGxhdGU6IGBcblx0XHQ8ZGl2IGNsYXNzPVwiYngtLWZvcm0taXRlbSBieC0tY2hlY2tib3gtd3JhcHBlclwiPlxuXHRcdFx0PGlucHV0XG5cdFx0XHRcdCNpbnB1dENoZWNrYm94XG5cdFx0XHRcdGNsYXNzPVwiYngtLWNoZWNrYm94XCJcblx0XHRcdFx0dHlwZT1cImNoZWNrYm94XCJcblx0XHRcdFx0W2lkXT1cImlkICsgJ19pbnB1dCdcIlxuXHRcdFx0XHRbdmFsdWVdPVwidmFsdWVcIlxuXHRcdFx0XHRbbmFtZV09XCJuYW1lXCJcblx0XHRcdFx0W3JlcXVpcmVkXT1cInJlcXVpcmVkXCJcblx0XHRcdFx0W2NoZWNrZWRdPVwiY2hlY2tlZFwiXG5cdFx0XHRcdFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG5cdFx0XHRcdFthdHRyLmFyaWEtbGFiZWxsZWRieV09XCJhcmlhTGFiZWxsZWRieVwiXG5cdFx0XHRcdFthdHRyLmFyaWEtY2hlY2tlZF09XCIoaW5kZXRlcm1pbmF0ZSA/ICdtaXhlZCcgOiBjaGVja2VkKVwiXG5cdFx0XHRcdChjaGFuZ2UpPVwib25DaGFuZ2UoJGV2ZW50KVwiXG5cdFx0XHRcdChjbGljayk9XCJvbkNsaWNrKCRldmVudClcIj5cblx0XHRcdDxsYWJlbFxuXHRcdFx0XHRbZm9yXT1cImlkICsgJ19pbnB1dCdcIlxuXHRcdFx0XHRbYXR0ci5hcmlhLWxhYmVsXT1cImFyaWFMYWJlbFwiXG5cdFx0XHRcdGNsYXNzPVwiYngtLWNoZWNrYm94LWxhYmVsXCJcblx0XHRcdFx0W25nQ2xhc3NdPVwie1xuXHRcdFx0XHRcdCdieC0tc2tlbGV0b24nIDogc2tlbGV0b25cblx0XHRcdFx0fVwiPlxuXHRcdFx0XHQ8c3BhbiBbbmdDbGFzc109XCJ7J2J4LS12aXN1YWxseS1oaWRkZW4nIDogaGlkZUxhYmVsfVwiIGNsYXNzPVwiYngtLWNoZWNrYm94LWxhYmVsLXRleHRcIj5cblx0XHRcdFx0XHQ8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdDwvbGFiZWw+XG5cdFx0PC9kaXY+XG5cdGAsXG5cdHByb3ZpZGVyczogW1xuXHRcdHtcblx0XHRcdHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuXHRcdFx0dXNlRXhpc3Rpbmc6IENoZWNrYm94LFxuXHRcdFx0bXVsdGk6IHRydWVcblx0XHR9XG5cdF0sXG5cdGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIENoZWNrYm94IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIEFmdGVyVmlld0luaXQge1xuXHQvKipcblx0ICogVmFyaWFibGUgdXNlZCBmb3IgY3JlYXRpbmcgdW5pcXVlIGlkcyBmb3IgY2hlY2tib3ggY29tcG9uZW50cy5cblx0ICovXG5cdHN0YXRpYyBjaGVja2JveENvdW50ID0gMDtcblxuXHQvKipcblx0ICogU2l6ZSBvZiB0aGUgY2hlY2tib3guXG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHY0XG5cdCAqL1xuXHRASW5wdXQoKSBzaXplOiBcInNtXCIgfCBcIm1kXCIgPSBcIm1kXCI7XG5cdC8qKlxuXHQgKiBTZXQgdG8gYHRydWVgIGZvciBjaGVja2JveCB0byBiZSByZW5kZXJlZCB3aXRoIG5lc3RlZCBzdHlsZXMuXG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHY0XG5cdCAqL1xuXHRASW5wdXQoKSBuZXN0ZWQ6IGJvb2xlYW47XG5cdC8qKlxuXHQgKiBTZXQgdG8gYHRydWVgIGZvciBjaGVja2JveCB0byBiZSByZW5kZXJlZCB3aXRob3V0IGFueSBjbGFzc2VzIG9uIHRoZSBob3N0IGVsZW1lbnQuXG5cdCAqL1xuXHRASW5wdXQoKSBpbmxpbmUgPSBmYWxzZTtcblx0LyoqXG5cdCAqIFNldCB0byBgdHJ1ZWAgZm9yIGEgZGlzYWJsZWQgY2hlY2tib3guXG5cdCAqL1xuXHRASW5wdXQoKSBkaXNhYmxlZCA9IGZhbHNlO1xuXHQvKipcblx0ICogU2V0IHRvIGB0cnVlYCBmb3IgYSBsb2FkaW5nIGNoZWNrYm94LlxuXHQgKi9cblx0QElucHV0KCkgc2tlbGV0b24gPSBmYWxzZTtcblx0LyoqXG5cdCAqIFNldCB0byBgdHJ1ZWAgdG8gaGlkZSB0aGUgY2hlY2tib3ggbGFiZWxzLlxuXHQgKi9cblx0QElucHV0KCkgaGlkZUxhYmVsID0gZmFsc2U7XG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBuYW1lIGF0dHJpYnV0ZSBvbiB0aGUgYGlucHV0YCBlbGVtZW50LlxuXHQgKi9cblx0QElucHV0KCkgbmFtZTogc3RyaW5nO1xuXHQvKipcblx0ICogVGhlIHVuaXF1ZSBpZCBmb3IgdGhlIGNoZWNrYm94IGNvbXBvbmVudC5cblx0ICovXG5cdEBJbnB1dCgpIGlkID0gYGNoZWNrYm94LSR7Q2hlY2tib3guY2hlY2tib3hDb3VudH1gO1xuXHQvKipcblx0ICogUmVmbGVjdHMgdGhlIHJlcXVpcmVkIGF0dHJpYnV0ZSBvZiB0aGUgYGlucHV0YCBlbGVtZW50LlxuXHQgKi9cblx0QElucHV0KCkgcmVxdWlyZWQ6IGJvb2xlYW47XG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgb24gdGhlIGBpbnB1dGAgZWxlbWVudC5cblx0ICovXG5cdEBJbnB1dCgpIHZhbHVlOiBDaGVja2JveFZhbHVlO1xuXHQvKipcblx0ICogVXNlZCB0byBzZXQgdGhlIGBhcmlhLWxhYmVsYCBhdHRyaWJ1dGUgb24gdGhlIGlucHV0IGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHY0IHVzZSB0aGUgYGFyaWFMYWJlbGAgaW5wdXQgaW5zdGVhZFxuXHQgKi9cblx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWlucHV0LXJlbmFtZVxuXHRASW5wdXQoXCJhcmlhLWxhYmVsXCIpIHNldCBhcmlhTGFiZWwodmFsdWU6IHN0cmluZykge1xuXHRcdHRoaXMuX2FyaWFMYWJlbCA9IHZhbHVlO1xuXHR9XG5cblx0Z2V0IGFyaWFMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fYXJpYUxhYmVsO1xuXHR9XG5cblx0Ly8gVE9ETzogZHJvcCB0aGUgYF9gXG5cdC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbnB1dC1yZW5hbWVcblx0QElucHV0KFwiYXJpYUxhYmVsXCIpIF9hcmlhTGFiZWwgPSBcIlwiO1xuXG5cdC8qKlxuXHQgKiBVc2VkIHRvIHNldCB0aGUgYGFyaWEtbGFiZWxsZWRieWAgYXR0cmlidXRlIG9uIHRoZSBpbnB1dCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2NCB1c2UgdGhlIGBhcmlhTGFiZWxsZWRieWAgaW5wdXQgaW5zdGVhZFxuXHQgKi9cblx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWlucHV0LXJlbmFtZVxuXHRASW5wdXQoXCJhcmlhLWxhYmVsbGVkYnlcIikgc2V0IGFyaWFMYWJlbGxlZGJ5KHZhbHVlOiBzdHJpbmcpIHtcblx0XHR0aGlzLl9hcmlhTGFiZWxsZWRieSA9IHZhbHVlO1xuXHR9XG5cblx0Z2V0IGFyaWFMYWJlbGxlZGJ5KCkge1xuXHRcdHJldHVybiB0aGlzLl9hcmlhTGFiZWxsZWRieTtcblx0fVxuXG5cdC8vIFRPRE86IGRyb3AgdGhlIGBfYFxuXHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW5wdXQtcmVuYW1lXG5cdEBJbnB1dChcImFyaWFMYWJlbGxlZGJ5XCIpIF9hcmlhTGFiZWxsZWRieTogc3RyaW5nO1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGNoZWNrYm94J3MgaW5kZXRlcm1pbmF0ZSBzdGF0ZSB0byBtYXRjaCB0aGUgcGFyYW1ldGVyIGFuZCB0cmFuc2l0aW9uIHRoZSB2aWV3IHRvIHJlZmxlY3QgdGhlIGNoYW5nZS5cblx0ICpcblx0ICogQWxsb3dzIGRvdWJsZSBiaW5kaW5nIHdpdGggdGhlIGBpbmRldGVybWluYXRlQ2hhbmdlYCBPdXRwdXQuXG5cdCAqL1xuXHRASW5wdXQoKSBzZXQgaW5kZXRlcm1pbmF0ZShpbmRldGVybWluYXRlOiBib29sZWFuKSB7XG5cdFx0aWYgKGluZGV0ZXJtaW5hdGUgPT09IHRoaXMuX2luZGV0ZXJtaW5hdGUpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9pbmRldGVybWluYXRlID0gaW5kZXRlcm1pbmF0ZTtcblxuXHRcdGlmICh0aGlzLl9pbmRldGVybWluYXRlKSB7XG5cdFx0XHR0aGlzLnRyYW5zaXRpb25DaGVja2JveFN0YXRlKENoZWNrYm94U3RhdGUuSW5kZXRlcm1pbmF0ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudHJhbnNpdGlvbkNoZWNrYm94U3RhdGUodGhpcy5jaGVja2VkID8gQ2hlY2tib3hTdGF0ZS5DaGVja2VkIDogQ2hlY2tib3hTdGF0ZS5VbmNoZWNrZWQpO1xuXHRcdH1cblxuXHRcdHRoaXMuaW5wdXRDaGVja2JveC5uYXRpdmVFbGVtZW50LmluZGV0ZXJtaW5hdGUgPSBpbmRldGVybWluYXRlO1xuXHRcdHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG5cdFx0dGhpcy5pbmRldGVybWluYXRlQ2hhbmdlLmVtaXQodGhpcy5faW5kZXRlcm1pbmF0ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVmbGVjdHMgd2hldGhlciB0aGUgY2hlY2tib3ggc3RhdGUgaXMgaW5kZXRlcm1pbmF0ZS5cblx0ICovXG5cdGdldCBpbmRldGVybWluYXRlKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbmRldGVybWluYXRlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGBjaGVja2VkYCBzdGF0ZS4gYHRydWVgIGZvciBjaGVja2VkLCBgZmFsc2VgIGZvciB1bmNoZWNrZWRcblx0ICpcblx0ICogQWxsb3dzIGRvdWJsZSBiaW5kaW5nIHdpdGggdGhlIGBjaGVja2VkQ2hhbmdlYCBPdXRwdXQuXG5cdCAqL1xuXHRASW5wdXQoKSBzZXQgY2hlY2tlZCAoY2hlY2tlZDogYm9vbGVhbikge1xuXHRcdHRoaXMuc2V0Q2hlY2tlZChjaGVja2VkLCBmYWxzZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB2YWx1ZSBgdHJ1ZWAgaWYgc3RhdGUgaXMgc2VsZWN0ZWQgZm9yIHRoZSBjaGVja2JveC5cblx0ICovXG5cdGdldCBjaGVja2VkKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGVja2VkO1xuXHR9XG5cblx0QEhvc3RCaW5kaW5nKFwiY2xhc3MuYngtLWNoZWNrYm94LXdyYXBwZXJcIikgZ2V0IGNoZWNrYm94V3JhcHBlckNsYXNzKCkge1xuXHRcdHJldHVybiAhdGhpcy5pbmxpbmU7XG5cdH1cblx0QEhvc3RCaW5kaW5nKFwiY2xhc3MuYngtLWZvcm0taXRlbVwiKSBnZXQgZm9ybUl0ZW1DbGFzcygpIHtcblx0XHRyZXR1cm4gIXRoaXMuaW5saW5lO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVtaXRzIGNsaWNrIGV2ZW50LlxuXHQgKi9cblx0QE91dHB1dCgpIGNsaWNrID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXHQvKipcblx0ICogRW1pdHMgZXZlbnQgbm90aWZ5aW5nIG90aGVyIGNsYXNzZXMgd2hlbiBhIGNoYW5nZSBpbiBzdGF0ZSBvY2N1cnMgb24gYSBjaGVja2JveCBhZnRlciBhXG5cdCAqIGNsaWNrLlxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2NCB1c2UgYGNoZWNrZWRgIGFuZCBgY2hlY2tlZENoYW5nZWAgaW5zdGVhZFxuXHQgKi9cblx0QE91dHB1dCgpIGNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG5cdC8qKlxuXHQgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSB2YWx1ZSBvZiB0aGUgY2hlY2tib3ggY2hhbmdlcy5cblx0ICpcblx0ICogQWxsb3dzIGRvdWJsZSBiaWRpbmcgd2l0aCB0aGUgYGNoZWNrZWRgIElucHV0LlxuXHQgKi9cblx0QE91dHB1dCgpIGNoZWNrZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cblx0LyoqXG5cdCAqIEVtaXRzIGV2ZW50IG5vdGlmeWluZyBvdGhlciBjbGFzc2VzIHdoZW4gYSBjaGFuZ2UgaW4gc3RhdGUgb2NjdXJzIHNwZWNpZmljYWxseVxuXHQgKiBvbiBhbiBpbmRldGVybWluYXRlIGNoZWNrYm94LlxuXHQgKi9cblx0QE91dHB1dCgpIGluZGV0ZXJtaW5hdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cblx0LyoqXG5cdCAqIFNldCB0byBgdHJ1ZWAgaWYgdGhlIGlucHV0IGNoZWNrYm94IGlzIHNlbGVjdGVkIChvciBjaGVja2VkKS5cblx0ICovXG5cdF9jaGVja2VkID0gZmFsc2U7XG5cdC8qKlxuXHQgKiBTZXQgdG8gYHRydWVgIGlmIHRoZSBpbnB1dCBjaGVja2JveCBpcyBpbiBzdGF0ZSBpbmRldGVybWluYXRlLlxuXHQgKi9cblx0X2luZGV0ZXJtaW5hdGUgPSBmYWxzZTtcblxuXHQvKipcblx0ICogS2VlcHMgYSByZWZlcmVuY2UgdG8gdGhlIGNoZWNrYm94ZXMgY3VycmVudCBzdGF0ZSwgYXMgZGVmaW5lZCBpbiBgQ2hlY2tib3hTdGF0ZWAuXG5cdCAqL1xuXHRjdXJyZW50Q2hlY2tib3hTdGF0ZSA9IENoZWNrYm94U3RhdGUuSW5pdDtcblxuXHQvKipcblx0ICogTWFpbnRhaW5zIGEgcmVmZXJlbmNlIHRvIHRoZSB2aWV3IERPTSBlbGVtZW50IG9mIHRoZSBgQ2hlY2tib3hgLlxuXHQgKi9cblx0Ly8gQHRzLWlnbm9yZVxuXHRAVmlld0NoaWxkKFwiaW5wdXRDaGVja2JveFwiLCB7IHN0YXRpYzogZmFsc2UgfSkgaW5wdXRDaGVja2JveDogRWxlbWVudFJlZjtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBgQ2hlY2tib3hgLlxuXHQgKi9cblx0Y29uc3RydWN0b3IocHJvdGVjdGVkIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge1xuXHRcdENoZWNrYm94LmNoZWNrYm94Q291bnQrKztcblx0fVxuXG5cdC8qKlxuXHQgKiBUb2dnbGUgdGhlIHNlbGVjdGVkIHN0YXRlIG9mIHRoZSBjaGVja2JveC5cblx0ICovXG5cdHB1YmxpYyB0b2dnbGUoKSB7XG5cdFx0Ly8gRmxpcCBjaGVja2VkIGFuZCByZXNldCBpbmRldGVybWluYXRlXG5cdFx0dGhpcy5zZXRDaGVja2VkKCF0aGlzLmNoZWNrZWQsIHRydWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFdyaXRlcyBhIHZhbHVlIGZyb20gYG5nTW9kZWxgIHRvIHRoZSBjb21wb25lbnQuXG5cdCAqXG5cdCAqIEluIHRoaXMgY2FzZSB0aGUgdmFsdWUgaXMgdGhlIGBjaGVja2VkYCBwcm9wZXJ0eS5cblx0ICpcblx0ICogQHBhcmFtIHZhbHVlIGJvb2xlYW4sIGNvcnJlc3BvbmRzIHRvIHRoZSBgY2hlY2tlZGAgcHJvcGVydHkuXG5cdCAqL1xuXHRwdWJsaWMgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KSB7XG5cdFx0Ly8gU2V0IGNoZWNrZWQgYW5kIHJlc2V0IGluZGV0ZXJtaW5hdGVcblx0XHR0aGlzLnNldENoZWNrZWQoISF2YWx1ZSwgdHJ1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBhIG1ldGhvZCBpbiBvcmRlciB0byBwcm9wYWdhdGUgY2hhbmdlcyBiYWNrIHRvIHRoZSBmb3JtLlxuXHQgKi9cblx0cHVibGljIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSkge1xuXHRcdHRoaXMucHJvcGFnYXRlQ2hhbmdlID0gZm47XG5cdH1cblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIGNvbnRyb2wgaGFzIGJlZW4gdG91Y2hlZC5cblx0ICogQHBhcmFtIGZuIENhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBjaGVja2JveCBpcyB0b3VjaGVkLlxuXHQgKi9cblx0cHVibGljIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpIHtcblx0XHR0aGlzLm9uVG91Y2hlZCA9IGZuO1xuXHR9XG5cblx0QEhvc3RMaXN0ZW5lcihcImZvY3Vzb3V0XCIpXG5cdGZvY3VzT3V0KCkge1xuXHRcdHRoaXMub25Ub3VjaGVkKCk7XG5cdH1cblxuXHQvKipcblx0ICogRXhlY3V0ZXMgb24gdGhlIGV2ZW50IG9mIGEgY2hhbmdlIHdpdGhpbiBgQ2hlY2tib3hgIHRvIGJsb2NrIHByb3BhZ2F0aW9uLlxuXHQgKi9cblx0b25DaGFuZ2UoZXZlbnQ6IEV2ZW50KSB7XG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyBjbGljayBldmVudHMgb24gdGhlIGBDaGVja2JveGAgYW5kIGVtaXRzIGNoYW5nZXMgdG8gb3RoZXIgY2xhc3Nlcy5cblx0ICovXG5cdG9uQ2xpY2soZXZlbnQ6IEV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuY2xpY2sub2JzZXJ2ZXJzLmxlbmd0aCkge1xuXHRcdFx0Ly8gRGlzYWJsZSBkZWZhdWx0IGNoZWNrYm94IGFjdGl2YXRpb24gYmVoYXZpb3Igd2hpY2ggZmxpcHMgY2hlY2tlZCBhbmQgcmVzZXRzIGluZGV0ZXJtaW5hdGUuXG5cdFx0XHQvLyBUaGlzIGFsbG93cyB0aGUgcGFyZW50IGNvbXBvbmVudCB0byBjb250cm9sIHRoZSBjaGVja2VkL2luZGV0ZXJtaW5hdGUgcHJvcGVydGllcy5cblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR0aGlzLmNsaWNrLmVtaXQoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCF0aGlzLmRpc2FibGVkKSB7XG5cdFx0XHR0aGlzLnRvZ2dsZSgpO1xuXHRcdFx0dGhpcy50cmFuc2l0aW9uQ2hlY2tib3hTdGF0ZSh0aGlzLl9jaGVja2VkID8gQ2hlY2tib3hTdGF0ZS5DaGVja2VkIDogQ2hlY2tib3hTdGF0ZS5VbmNoZWNrZWQpO1xuXHRcdFx0dGhpcy5lbWl0Q2hhbmdlRXZlbnQoKTtcblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiBjaGVja2JveCBpcyBibHVycmVkLiBOZWVkZWQgdG8gcHJvcGVybHkgaW1wbGVtZW50IGBDb250cm9sVmFsdWVBY2Nlc3NvcmAuXG5cdCAqL1xuXHRvblRvdWNoZWQ6ICgpID0+IGFueSA9ICgpID0+IHt9O1xuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIGNoYW5nZXMgYmV0d2VlbiBjaGVja2JveCBzdGF0ZXMuXG5cdCAqL1xuXHR0cmFuc2l0aW9uQ2hlY2tib3hTdGF0ZShuZXdTdGF0ZTogQ2hlY2tib3hTdGF0ZSkge1xuXHRcdHRoaXMuY3VycmVudENoZWNrYm94U3RhdGUgPSBuZXdTdGF0ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGluc3RhbmNlIG9mIGBDaGVja2JveENoYW5nZWAgdXNlZCB0byBwcm9wYWdhdGUgdGhlIGNoYW5nZSBldmVudC5cblx0ICovXG5cdGVtaXRDaGFuZ2VFdmVudCgpIHtcblx0XHQvKiBiZWdpbiBkZXByZWNhdGlvbiAqL1xuXHRcdGxldCBldmVudCA9IG5ldyBDaGVja2JveENoYW5nZSgpO1xuXHRcdGV2ZW50LnNvdXJjZSA9IHRoaXM7XG5cdFx0ZXZlbnQuY2hlY2tlZCA9IHRoaXMuY2hlY2tlZDtcblx0XHR0aGlzLmNoYW5nZS5lbWl0KGV2ZW50KTtcblx0XHQvKiBlbmQgZGVwcmVjYXRpb24gKi9cblxuXHRcdHRoaXMuY2hlY2tlZENoYW5nZS5lbWl0KHRoaXMuY2hlY2tlZCk7XG5cdFx0dGhpcy5wcm9wYWdhdGVDaGFuZ2UodGhpcy5jaGVja2VkKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBjaGVja2JveCBpZiBpdCBpcyBpbiB0aGUgaW5kZXRlcm1pbmF0ZSBzdGF0ZS5cblx0ICovXG5cdG5nQWZ0ZXJWaWV3SW5pdCgpIHtcblx0XHRpZiAodGhpcy5pbmRldGVybWluYXRlKSB7XG5cdFx0XHR0aGlzLmlucHV0Q2hlY2tib3gubmF0aXZlRWxlbWVudC5pbmRldGVybWluYXRlID0gdHJ1ZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTWV0aG9kIHNldCBpbiBgcmVnaXN0ZXJPbkNoYW5nZWAgdG8gcHJvcGFnYXRlIGNoYW5nZXMgYmFjayB0byB0aGUgZm9ybS5cblx0ICovXG5cdHByb3BhZ2F0ZUNoYW5nZSA9IChfOiBhbnkpID0+IHt9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIGNoZWNrZWQgc3RhdGUgYW5kIG9wdGlvbmFsbHkgcmVzZXRzIGluZGV0ZXJtaW5hdGUgc3RhdGUuXG5cdCAqL1xuXHRwcml2YXRlIHNldENoZWNrZWQoY2hlY2tlZDogYm9vbGVhbiwgcmVzZXRJbmRldGVybWluYXRlOiBib29sZWFuKSB7XG5cdFx0aWYgKGNoZWNrZWQgPT09IHRoaXMuX2NoZWNrZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5fY2hlY2tlZCA9IGNoZWNrZWQ7XG5cdFx0Ly8gUmVzZXQgaW5kZXRlcm1pbmF0ZSBpZiByZXF1ZXN0ZWRcblx0XHRpZiAocmVzZXRJbmRldGVybWluYXRlICYmIHRoaXMuX2luZGV0ZXJtaW5hdGUpIHtcblx0XHRcdHRoaXMuX2luZGV0ZXJtaW5hdGUgPSBmYWxzZTtcblx0XHRcdFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHR0aGlzLmluZGV0ZXJtaW5hdGVDaGFuZ2UuZW1pdCh0aGlzLl9pbmRldGVybWluYXRlKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHR0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuXHR9XG59XG4iXX0=