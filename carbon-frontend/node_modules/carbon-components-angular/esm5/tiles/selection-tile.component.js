/**
 *
 * carbon-angular v0.0.0 | selection-tile.component.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Component, Input, Output, EventEmitter, ViewChild, HostListener } from "@angular/core";
import { I18n } from "carbon-components-angular/i18n";
var SelectionTile = /** @class */ (function () {
    function SelectionTile(i18n) {
        this.i18n = i18n;
        /**
         * The unique id for the input.
         */
        this.id = "tile-" + SelectionTile.tileCount;
        /**
         * Internal event used to notify the containing `TileGroup` of changes.
         */
        this.change = new EventEmitter();
        /**
         * Set by the containing `TileGroup`. Used for the `name` property on the input.
         */
        this.name = "tile-group-unbound";
        /**
         * Defines whether or not the `SelectionTile` supports selecting multiple tiles as opposed to single
         * tile selection.
         */
        this.multiple = true; // Set to true because of the way tile group sets it up.
        // If an initial selected value is set before input exists, we save
        // the value and check again when input exists in `AfterViewInit`.
        this._selected = null;
        SelectionTile.tileCount++;
    }
    Object.defineProperty(SelectionTile.prototype, "selected", {
        get: function () {
            return this.input ? this.input.nativeElement.checked : false;
        },
        /**
         * Updating the state of the input to match the state of the parameter passed in.
         * Set to `true` if this tile should be selected.
         */
        set: function (value) {
            // If an initial selected value is set before input exists, we save
            // the value and check again when input exists in `AfterViewInit`.
            this._selected = value ? true : null;
            if (this.input) {
                this.input.nativeElement.checked = this._selected;
            }
        },
        enumerable: true,
        configurable: true
    });
    SelectionTile.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (this.input) {
            setTimeout(function () {
                _this.input.nativeElement.checked = _this._selected;
            });
        }
    };
    SelectionTile.prototype.keyboardInput = function (event) {
        if (event.key === "Enter" || event.key === "Spacebar" || event.key === " ") {
            this.selected = !this.selected;
            this.change.emit(event);
        }
    };
    SelectionTile.prototype.onChange = function (event) {
        this.change.emit(event);
    };
    SelectionTile.tileCount = 0;
    SelectionTile.decorators = [
        { type: Component, args: [{
                    selector: "ibm-selection-tile",
                    template: "\n\t\t<label\n\t\t\tclass=\"bx--tile bx--tile--selectable\"\n\t\t\ttabindex=\"0\"\n\t\t\t[for]=\"id\"\n\t\t\t[ngClass]=\"{'bx--tile--is-selected' : selected}\"\n\t\t\t[attr.aria-label]=\"i18n.get('TILES.TILE') | async\">\n\t\t\t<input\n\t\t\t\t#input\n\t\t\t\ttabindex=\"-1\"\n\t\t\t\tclass=\"bx--tile-input\"\n\t\t\t\t[id]=\"id\"\n\t\t\t\t[type]=\"(multiple ? 'checkbox': 'radio')\"\n\t\t\t\t[value]=\"value\"\n\t\t\t\t[name]=\"name\"\n\t\t\t\t(change)=\"onChange($event)\"/>\n\t\t\t<div class=\"bx--tile__checkmark\">\n\t\t\t\t<svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\">\n\t\t\t\t\t<path d=\"M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16zm3.646-10.854L6.75 10.043 4.354 7.646l-.708.708 3.104 3.103 5.604-5.603-.708-.708z\"\n\t\t\t\t\t\tfill-rule=\"evenodd\"/>\n\t\t\t\t</svg>\n\t\t\t</div>\n\t\t\t<div class=\"bx--tile-content\">\n\t\t\t\t<ng-content></ng-content>\n\t\t\t</div>\n\t\t</label>\n\t"
                }] }
    ];
    /** @nocollapse */
    SelectionTile.ctorParameters = function () { return [
        { type: I18n }
    ]; };
    SelectionTile.propDecorators = {
        id: [{ type: Input }],
        selected: [{ type: Input }],
        value: [{ type: Input }],
        change: [{ type: Output }],
        input: [{ type: ViewChild, args: ["input", { static: true },] }],
        keyboardInput: [{ type: HostListener, args: ["keydown", ["$event"],] }]
    };
    return SelectionTile;
}());
export { SelectionTile };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0aW9uLXRpbGUuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci90aWxlcy8iLCJzb3VyY2VzIjpbInNlbGVjdGlvbi10aWxlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLFNBQVMsRUFDVCxZQUFZLEVBRVosTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBRXREO0lBK0VDLHVCQUFtQixJQUFVO1FBQVYsU0FBSSxHQUFKLElBQUksQ0FBTTtRQS9DN0I7O1dBRUc7UUFDTSxPQUFFLEdBQUcsVUFBUSxhQUFhLENBQUMsU0FBVyxDQUFDO1FBcUJoRDs7V0FFRztRQUNPLFdBQU0sR0FBd0IsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUUzRDs7V0FFRztRQUNILFNBQUksR0FBRyxvQkFBb0IsQ0FBQztRQUM1Qjs7O1dBR0c7UUFDSCxhQUFRLEdBQUcsSUFBSSxDQUFDLENBQUMsd0RBQXdEO1FBTXpFLG1FQUFtRTtRQUNuRSxrRUFBa0U7UUFDeEQsY0FBUyxHQUFHLElBQUksQ0FBQztRQUcxQixhQUFhLENBQUMsU0FBUyxFQUFFLENBQUM7SUFDM0IsQ0FBQztJQXpDRCxzQkFBYSxtQ0FBUTthQVNyQjtZQUNDLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7UUFDOUQsQ0FBQztRQWZEOzs7V0FHRzthQUNILFVBQXNCLEtBQWM7WUFDbkMsbUVBQW1FO1lBQ25FLGtFQUFrRTtZQUNsRSxJQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFDckMsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO2dCQUNmLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO2FBQ2xEO1FBQ0YsQ0FBQzs7O09BQUE7SUFvQ0QsdUNBQWUsR0FBZjtRQUFBLGlCQU1DO1FBTEEsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ2YsVUFBVSxDQUFDO2dCQUNWLEtBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLE9BQU8sR0FBRyxLQUFJLENBQUMsU0FBUyxDQUFDO1lBQ25ELENBQUMsQ0FBQyxDQUFDO1NBQ0g7SUFDRixDQUFDO0lBR0QscUNBQWEsR0FEYixVQUNjLEtBQUs7UUFDbEIsSUFBSSxLQUFLLENBQUMsR0FBRyxLQUFLLE9BQU8sSUFBSSxLQUFLLENBQUMsR0FBRyxLQUFLLFVBQVUsSUFBSSxLQUFLLENBQUMsR0FBRyxLQUFLLEdBQUcsRUFBRTtZQUMzRSxJQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztZQUMvQixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUN4QjtJQUNGLENBQUM7SUFFRCxnQ0FBUSxHQUFSLFVBQVMsS0FBSztRQUNiLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3pCLENBQUM7SUF0RU0sdUJBQVMsR0FBRyxDQUFDLENBQUM7O2dCQS9CckIsU0FBUyxTQUFDO29CQUNWLFFBQVEsRUFBRSxvQkFBb0I7b0JBQzlCLFFBQVEsRUFBRSxvNEJBMEJUO2lCQUNEOzs7O2dCQS9CUSxJQUFJOzs7cUJBcUNYLEtBQUs7MkJBS0wsS0FBSzt3QkFlTCxLQUFLO3lCQUlMLE1BQU07d0JBY04sU0FBUyxTQUFDLE9BQU8sRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7Z0NBa0JuQyxZQUFZLFNBQUMsU0FBUyxFQUFFLENBQUMsUUFBUSxDQUFDOztJQVdwQyxvQkFBQztDQUFBLEFBdEdELElBc0dDO1NBeEVZLGFBQWEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRDb21wb25lbnQsXG5cdElucHV0LFxuXHRPdXRwdXQsXG5cdEV2ZW50RW1pdHRlcixcblx0Vmlld0NoaWxkLFxuXHRIb3N0TGlzdGVuZXIsXG5cdEFmdGVyVmlld0luaXRcbn0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSBcIkBhbmd1bGFyL2Zvcm1zXCI7XG5pbXBvcnQgeyBJMThuIH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvaTE4blwiO1xuXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6IFwiaWJtLXNlbGVjdGlvbi10aWxlXCIsXG5cdHRlbXBsYXRlOiBgXG5cdFx0PGxhYmVsXG5cdFx0XHRjbGFzcz1cImJ4LS10aWxlIGJ4LS10aWxlLS1zZWxlY3RhYmxlXCJcblx0XHRcdHRhYmluZGV4PVwiMFwiXG5cdFx0XHRbZm9yXT1cImlkXCJcblx0XHRcdFtuZ0NsYXNzXT1cInsnYngtLXRpbGUtLWlzLXNlbGVjdGVkJyA6IHNlbGVjdGVkfVwiXG5cdFx0XHRbYXR0ci5hcmlhLWxhYmVsXT1cImkxOG4uZ2V0KCdUSUxFUy5USUxFJykgfCBhc3luY1wiPlxuXHRcdFx0PGlucHV0XG5cdFx0XHRcdCNpbnB1dFxuXHRcdFx0XHR0YWJpbmRleD1cIi0xXCJcblx0XHRcdFx0Y2xhc3M9XCJieC0tdGlsZS1pbnB1dFwiXG5cdFx0XHRcdFtpZF09XCJpZFwiXG5cdFx0XHRcdFt0eXBlXT1cIihtdWx0aXBsZSA/ICdjaGVja2JveCc6ICdyYWRpbycpXCJcblx0XHRcdFx0W3ZhbHVlXT1cInZhbHVlXCJcblx0XHRcdFx0W25hbWVdPVwibmFtZVwiXG5cdFx0XHRcdChjaGFuZ2UpPVwib25DaGFuZ2UoJGV2ZW50KVwiLz5cblx0XHRcdDxkaXYgY2xhc3M9XCJieC0tdGlsZV9fY2hlY2ttYXJrXCI+XG5cdFx0XHRcdDxzdmcgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgdmlld0JveD1cIjAgMCAxNiAxNlwiPlxuXHRcdFx0XHRcdDxwYXRoIGQ9XCJNOCAxNkE4IDggMCAxIDEgOCAwYTggOCAwIDAgMSAwIDE2em0zLjY0Ni0xMC44NTRMNi43NSAxMC4wNDMgNC4zNTQgNy42NDZsLS43MDguNzA4IDMuMTA0IDMuMTAzIDUuNjA0LTUuNjAzLS43MDgtLjcwOHpcIlxuXHRcdFx0XHRcdFx0ZmlsbC1ydWxlPVwiZXZlbm9kZFwiLz5cblx0XHRcdFx0PC9zdmc+XG5cdFx0XHQ8L2Rpdj5cblx0XHRcdDxkaXYgY2xhc3M9XCJieC0tdGlsZS1jb250ZW50XCI+XG5cdFx0XHRcdDxuZy1jb250ZW50PjwvbmctY29udGVudD5cblx0XHRcdDwvZGl2PlxuXHRcdDwvbGFiZWw+XG5cdGBcbn0pXG5leHBvcnQgY2xhc3MgU2VsZWN0aW9uVGlsZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xuXHRzdGF0aWMgdGlsZUNvdW50ID0gMDtcblx0LyoqXG5cdCAqIFRoZSB1bmlxdWUgaWQgZm9yIHRoZSBpbnB1dC5cblx0ICovXG5cdEBJbnB1dCgpIGlkID0gYHRpbGUtJHtTZWxlY3Rpb25UaWxlLnRpbGVDb3VudH1gO1xuXHQvKipcblx0ICogVXBkYXRpbmcgdGhlIHN0YXRlIG9mIHRoZSBpbnB1dCB0byBtYXRjaCB0aGUgc3RhdGUgb2YgdGhlIHBhcmFtZXRlciBwYXNzZWQgaW4uXG5cdCAqIFNldCB0byBgdHJ1ZWAgaWYgdGhpcyB0aWxlIHNob3VsZCBiZSBzZWxlY3RlZC5cblx0ICovXG5cdEBJbnB1dCgpIHNldCBzZWxlY3RlZCh2YWx1ZTogYm9vbGVhbikge1xuXHRcdC8vIElmIGFuIGluaXRpYWwgc2VsZWN0ZWQgdmFsdWUgaXMgc2V0IGJlZm9yZSBpbnB1dCBleGlzdHMsIHdlIHNhdmVcblx0XHQvLyB0aGUgdmFsdWUgYW5kIGNoZWNrIGFnYWluIHdoZW4gaW5wdXQgZXhpc3RzIGluIGBBZnRlclZpZXdJbml0YC5cblx0XHR0aGlzLl9zZWxlY3RlZCA9IHZhbHVlID8gdHJ1ZSA6IG51bGw7XG5cdFx0aWYgKHRoaXMuaW5wdXQpIHtcblx0XHRcdHRoaXMuaW5wdXQubmF0aXZlRWxlbWVudC5jaGVja2VkID0gdGhpcy5fc2VsZWN0ZWQ7XG5cdFx0fVxuXHR9XG5cblx0Z2V0IHNlbGVjdGVkKCkge1xuXHRcdHJldHVybiB0aGlzLmlucHV0ID8gdGhpcy5pbnB1dC5uYXRpdmVFbGVtZW50LmNoZWNrZWQgOiBmYWxzZTtcblx0fVxuXHQvKipcblx0ICogVGhlIHZhbHVlIGZvciB0aGUgdGlsZS4gUmV0dXJuZWQgdmlhIGBuZ01vZGVsYCBvciBgc2VsZWN0ZWRgIGV2ZW50IG9uIHRoZSBjb250YWluaW5nIGBUaWxlR3JvdXBgLlxuXHQgKi9cblx0QElucHV0KCkgdmFsdWU6IHN0cmluZztcblx0LyoqXG5cdCAqIEludGVybmFsIGV2ZW50IHVzZWQgdG8gbm90aWZ5IHRoZSBjb250YWluaW5nIGBUaWxlR3JvdXBgIG9mIGNoYW5nZXMuXG5cdCAqL1xuXHRAT3V0cHV0KCkgY2hhbmdlOiBFdmVudEVtaXR0ZXI8RXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cdC8qKlxuXHQgKiBTZXQgYnkgdGhlIGNvbnRhaW5pbmcgYFRpbGVHcm91cGAuIFVzZWQgZm9yIHRoZSBgbmFtZWAgcHJvcGVydHkgb24gdGhlIGlucHV0LlxuXHQgKi9cblx0bmFtZSA9IFwidGlsZS1ncm91cC11bmJvdW5kXCI7XG5cdC8qKlxuXHQgKiBEZWZpbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBgU2VsZWN0aW9uVGlsZWAgc3VwcG9ydHMgc2VsZWN0aW5nIG11bHRpcGxlIHRpbGVzIGFzIG9wcG9zZWQgdG8gc2luZ2xlXG5cdCAqIHRpbGUgc2VsZWN0aW9uLlxuXHQgKi9cblx0bXVsdGlwbGUgPSB0cnVlO1x0Ly8gU2V0IHRvIHRydWUgYmVjYXVzZSBvZiB0aGUgd2F5IHRpbGUgZ3JvdXAgc2V0cyBpdCB1cC5cblx0XHRcdFx0XHRcdC8vIElmIGl0IGlzIGZpcnN0IHVuZGVmaW5lZCB0aGVuIHNldCB0byB0cnVlLCB0aGUgdHlwZSB3aWxsIGNoYW5nZSBmcm9tIHJhZGlvIHRvIGNoZWNrYm94IGFuZCBkZXNlbGVjdHMgdGhlIGlucHV0cy5cblxuXHQvLyBAdHMtaWdub3JlXG5cdEBWaWV3Q2hpbGQoXCJpbnB1dFwiLCB7IHN0YXRpYzogdHJ1ZSB9KSBpbnB1dDtcblxuXHQvLyBJZiBhbiBpbml0aWFsIHNlbGVjdGVkIHZhbHVlIGlzIHNldCBiZWZvcmUgaW5wdXQgZXhpc3RzLCB3ZSBzYXZlXG5cdC8vIHRoZSB2YWx1ZSBhbmQgY2hlY2sgYWdhaW4gd2hlbiBpbnB1dCBleGlzdHMgaW4gYEFmdGVyVmlld0luaXRgLlxuXHRwcm90ZWN0ZWQgX3NlbGVjdGVkID0gbnVsbDtcblxuXHRjb25zdHJ1Y3RvcihwdWJsaWMgaTE4bjogSTE4bikge1xuXHRcdFNlbGVjdGlvblRpbGUudGlsZUNvdW50Kys7XG5cdH1cblxuXHRuZ0FmdGVyVmlld0luaXQoKSB7XG5cdFx0aWYgKHRoaXMuaW5wdXQpIHtcblx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHR0aGlzLmlucHV0Lm5hdGl2ZUVsZW1lbnQuY2hlY2tlZCA9IHRoaXMuX3NlbGVjdGVkO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0QEhvc3RMaXN0ZW5lcihcImtleWRvd25cIiwgW1wiJGV2ZW50XCJdKVxuXHRrZXlib2FyZElucHV0KGV2ZW50KSB7XG5cdFx0aWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiIHx8IGV2ZW50LmtleSA9PT0gXCJTcGFjZWJhclwiIHx8IGV2ZW50LmtleSA9PT0gXCIgXCIpIHtcblx0XHRcdHRoaXMuc2VsZWN0ZWQgPSAhdGhpcy5zZWxlY3RlZDtcblx0XHRcdHRoaXMuY2hhbmdlLmVtaXQoZXZlbnQpO1xuXHRcdH1cblx0fVxuXG5cdG9uQ2hhbmdlKGV2ZW50KSB7XG5cdFx0dGhpcy5jaGFuZ2UuZW1pdChldmVudCk7XG5cdH1cbn1cblxuXG4iXX0=