/**
 *
 * carbon-angular v0.0.0 | table-head.component.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Component, Input, Output, EventEmitter } from "@angular/core";
import { TableModel } from "../table-model.class";
import { getScrollbarWidth } from "carbon-components-angular/utils";
import { I18n } from "carbon-components-angular/i18n";
/**
 * A subcomponent that creates the thead of the table
 *
 * ## Basic usage
 *
 * ```html
 * 	<thead ibmTableHead [model]="model"></thead>
 * ```
 */
var TableHead = /** @class */ (function () {
    function TableHead(i18n) {
        this.i18n = i18n;
        this.showSelectionColumn = true;
        this.enableSingleSelect = false;
        this.selectAllCheckboxSomeSelected = false;
        this.selectAllCheckbox = false;
        this.skeleton = false;
        this.stickyHeader = false;
        /**
         * Setting sortable to false will disable all headers including headers which are sortable. Is is
         * possible to set the sortable state on the header item to disable/enable sorting for only some headers.
         */
        this.sortable = true;
        /**
         * Size of the table rows.
         */
        this.size = "md";
        /**
         * Emits an index of the column that wants to be sorted.
         */
        this.sort = new EventEmitter();
        /**
         * Emits if all rows are selected.
         *
         * @param model
         */
        this.selectAll = new EventEmitter();
        /**
         * Emits if all rows are deselected.
         *
         * @param model
         */
        this.deselectAll = new EventEmitter();
        this.scrollbarWidth = 0;
        this._checkboxHeaderLabel = this.i18n.getOverridable("TABLE.CHECKBOX_HEADER");
        this._sortDescendingLabel = this.i18n.getOverridable("TABLE.SORT_DESCENDING");
        this._sortAscendingLabel = this.i18n.getOverridable("TABLE.SORT_ASCENDING");
        this._filterTitle = this.i18n.getOverridable("TABLE.FILTER");
    }
    Object.defineProperty(TableHead.prototype, "checkboxHeaderLabel", {
        get: function () {
            return this._checkboxHeaderLabel.value;
        },
        set: function (value) {
            this._checkboxHeaderLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableHead.prototype, "sortDescendingLabel", {
        get: function () {
            return this._sortDescendingLabel.value;
        },
        set: function (value) {
            this._sortDescendingLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableHead.prototype, "sortAscendingLabel", {
        get: function () {
            return this._sortAscendingLabel.value;
        },
        set: function (value) {
            this._sortAscendingLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableHead.prototype, "filterTitle", {
        get: function () {
            return this._filterTitle.value;
        },
        set: function (value) {
            this._filterTitle.override(value);
        },
        enumerable: true,
        configurable: true
    });
    TableHead.prototype.ngAfterViewInit = function () {
        var _this = this;
        setTimeout(function () {
            _this.scrollbarWidth = getScrollbarWidth();
        });
    };
    TableHead.prototype.onSelectAllCheckboxChange = function () {
        if (!this.selectAllCheckbox && !this.selectAllCheckboxSomeSelected) {
            this.selectAll.emit(this.model);
        }
        else {
            this.deselectAll.emit(this.model);
        }
    };
    TableHead.prototype.getCheckboxHeaderLabel = function () {
        return this._checkboxHeaderLabel.subject;
    };
    TableHead.prototype.getSortDescendingLabel = function () {
        return this._sortDescendingLabel.subject;
    };
    TableHead.prototype.getSortAscendingLabel = function () {
        return this._sortAscendingLabel.subject;
    };
    TableHead.prototype.getFilterTitle = function () {
        return this._filterTitle.subject;
    };
    TableHead.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: "[ibmTableHead]",
                    template: "\n\t<ng-container *ngIf=\"model\">\n\t\t<tr>\n\t\t\t<th\n\t\t\t\tibmTableHeadExpand\n\t\t\t\t*ngIf=\"model.hasExpandableRows()\"\n\t\t\t\tscope=\"col\"\n\t\t\t\t[ngClass]=\"{'bx--table-expand-v2': stickyHeader}\"\n\t\t\t\t[id]=\"model.getId('expand')\">\n\t\t\t</th>\n\t\t\t<th\n\t\t\t\t*ngIf=\"!skeleton && showSelectionColumn && enableSingleSelect\"\n\t\t\t\tscope=\"col\"\n\t\t\t\tstyle=\"width: 0;\"\n\t\t\t\t[id]=\"model.getId('select')\">\n\t\t\t\t<!-- add width 0; since the carbon styles don't seem to constrain this headers width -->\n\t\t\t</th>\n\t\t\t<th\n\t\t\t\tibmTableHeadCheckbox\n\t\t\t\t*ngIf=\"!skeleton && showSelectionColumn && !enableSingleSelect\"\n\t\t\t\tscope=\"col\"\n\t\t\t\t[checked]=\"selectAllCheckbox\"\n\t\t\t\t[indeterminate]=\"selectAllCheckboxSomeSelected\"\n\t\t\t\t[ariaLabel]=\"getCheckboxHeaderLabel()\"\n\t\t\t\t[size]=\"size\"\n\t\t\t\t[skeleton]=\"skeleton\"\n\t\t\t\t[name]=\"model.getHeaderId('select')\"\n\t\t\t\t(change)=\"onSelectAllCheckboxChange()\"\n\t\t\t\t[id]=\"model.getId('select')\">\n\t\t\t</th>\n\t\t\t<ng-container *ngFor=\"let column of model.header; let i = index\">\n\t\t\t\t<th\n\t\t\t\t\t*ngIf=\"column && column.visible\"\n\t\t\t\t\t[ngStyle]=\"column.style\"\n\t\t\t\t\tibmTableHeadCell\n\t\t\t\t\tscope=\"col\"\n\t\t\t\t\t[class]=\"column.className\"\n\t\t\t\t\t[sortable]=\"sortable\"\n\t\t\t\t\t[skeleton]=\"skeleton\"\n\t\t\t\t\t[id]=\"model.getId(i)\"\n\t\t\t\t\t[column]=\"column\"\n\t\t\t\t\t[skeleton]=\"skeleton\"\n\t\t\t\t\t[filterTitle]=\"getFilterTitle()\"\n\t\t\t\t\t[attr.colspan]=\"column.colSpan\"\n\t\t\t\t\t[attr.rowspan]=\"column.rowSpan\"\n\t\t\t\t\t(sort)=\"sort.emit(i)\">\n\t\t\t\t</th>\n\t\t\t</ng-container>\n\t\t\t<th *ngIf=\"!skeleton && stickyHeader && scrollbarWidth\"\n\t\t\t\tscope=\"col\"\n\t\t\t\t[ngStyle]=\"{'width': scrollbarWidth + 'px', 'padding': 0, 'border': 0}\">\n\t\t\t\t<!--\n\t\t\t\t\tScrollbar pushes body to the left so this header column is added to push\n\t\t\t\t\tthe title bar the same amount and keep the header and body columns aligned.\n\t\t\t\t-->\n\t\t\t</th>\n\t\t</tr>\n\t</ng-container>\n\t<ng-content></ng-content>\n\t",
                    styles: ["\n\t\t.bx--table-expand-v2 {\n\t\t\tpadding-left: 2.5rem;\n\t\t}\n\t"]
                }] }
    ];
    /** @nocollapse */
    TableHead.ctorParameters = function () { return [
        { type: I18n }
    ]; };
    TableHead.propDecorators = {
        model: [{ type: Input }],
        showSelectionColumn: [{ type: Input }],
        enableSingleSelect: [{ type: Input }],
        selectAllCheckboxSomeSelected: [{ type: Input }],
        selectAllCheckbox: [{ type: Input }],
        skeleton: [{ type: Input }],
        stickyHeader: [{ type: Input }],
        sortable: [{ type: Input }],
        size: [{ type: Input }],
        checkboxHeaderLabel: [{ type: Input }],
        sortDescendingLabel: [{ type: Input }],
        sortAscendingLabel: [{ type: Input }],
        filterTitle: [{ type: Input }],
        sort: [{ type: Output }],
        selectAll: [{ type: Output }],
        deselectAll: [{ type: Output }]
    };
    return TableHead;
}());
export { TableHead };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUtaGVhZC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL3RhYmxlLyIsInNvdXJjZXMiOlsiaGVhZC90YWJsZS1oZWFkLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUVaLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNsRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUNwRSxPQUFPLEVBQUUsSUFBSSxFQUFlLE1BQU0sZ0NBQWdDLENBQUM7QUFJbkU7Ozs7Ozs7O0dBUUc7QUFDSDtJQTJKQyxtQkFBc0IsSUFBVTtRQUFWLFNBQUksR0FBSixJQUFJLENBQU07UUFuRnZCLHdCQUFtQixHQUFHLElBQUksQ0FBQztRQUUzQix1QkFBa0IsR0FBRyxLQUFLLENBQUM7UUFFM0Isa0NBQTZCLEdBQUcsS0FBSyxDQUFDO1FBRXRDLHNCQUFpQixHQUFHLEtBQUssQ0FBQztRQUUxQixhQUFRLEdBQUcsS0FBSyxDQUFDO1FBRWpCLGlCQUFZLEdBQUcsS0FBSyxDQUFDO1FBRTlCOzs7V0FHRztRQUNNLGFBQVEsR0FBRyxJQUFJLENBQUM7UUFFekI7O1dBRUc7UUFDTSxTQUFJLEdBQWlCLElBQUksQ0FBQztRQXNDbkM7O1dBRUc7UUFDTyxTQUFJLEdBQUcsSUFBSSxZQUFZLEVBQVUsQ0FBQztRQUM1Qzs7OztXQUlHO1FBQ08sY0FBUyxHQUFHLElBQUksWUFBWSxFQUFjLENBQUM7UUFDckQ7Ozs7V0FJRztRQUNPLGdCQUFXLEdBQUcsSUFBSSxZQUFZLEVBQWMsQ0FBQztRQUVoRCxtQkFBYyxHQUFHLENBQUMsQ0FBQztRQUVoQix5QkFBb0IsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1FBQ3pFLHlCQUFvQixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLHVCQUF1QixDQUFDLENBQUM7UUFDekUsd0JBQW1CLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsc0JBQXNCLENBQUMsQ0FBQztRQUN2RSxpQkFBWSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBRS9CLENBQUM7SUE1RHBDLHNCQUNJLDBDQUFtQjthQUl2QjtZQUNDLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFDLEtBQUssQ0FBQztRQUN4QyxDQUFDO2FBUEQsVUFDd0IsS0FBa0M7WUFDekQsSUFBSSxDQUFDLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMzQyxDQUFDOzs7T0FBQTtJQU1ELHNCQUNJLDBDQUFtQjthQUl2QjtZQUNDLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFDLEtBQUssQ0FBQztRQUN4QyxDQUFDO2FBUEQsVUFDd0IsS0FBa0M7WUFDekQsSUFBSSxDQUFDLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMzQyxDQUFDOzs7T0FBQTtJQU1ELHNCQUNJLHlDQUFrQjthQUl0QjtZQUNDLE9BQU8sSUFBSSxDQUFDLG1CQUFtQixDQUFDLEtBQUssQ0FBQztRQUN2QyxDQUFDO2FBUEQsVUFDdUIsS0FBa0M7WUFDeEQsSUFBSSxDQUFDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMxQyxDQUFDOzs7T0FBQTtJQU1ELHNCQUNJLGtDQUFXO2FBSWY7WUFDQyxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDO1FBQ2hDLENBQUM7YUFQRCxVQUNnQixLQUFrQztZQUNqRCxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNuQyxDQUFDOzs7T0FBQTtJQWdDRCxtQ0FBZSxHQUFmO1FBQUEsaUJBSUM7UUFIQSxVQUFVLENBQUM7WUFDVixLQUFJLENBQUMsY0FBYyxHQUFHLGlCQUFpQixFQUFFLENBQUM7UUFDM0MsQ0FBQyxDQUFDLENBQUM7SUFDSixDQUFDO0lBRUQsNkNBQXlCLEdBQXpCO1FBQ0MsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsSUFBSSxDQUFDLElBQUksQ0FBQyw2QkFBNkIsRUFBRTtZQUNuRSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDaEM7YUFBTTtZQUNOLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUNsQztJQUNGLENBQUM7SUFFRCwwQ0FBc0IsR0FBdEI7UUFDQyxPQUFPLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxPQUFPLENBQUM7SUFDMUMsQ0FBQztJQUVELDBDQUFzQixHQUF0QjtRQUNDLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFDLE9BQU8sQ0FBQztJQUMxQyxDQUFDO0lBRUQseUNBQXFCLEdBQXJCO1FBQ0MsT0FBTyxJQUFJLENBQUMsbUJBQW1CLENBQUMsT0FBTyxDQUFDO0lBQ3pDLENBQUM7SUFFRCxrQ0FBYyxHQUFkO1FBQ0MsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQztJQUNsQyxDQUFDOztnQkF6TEQsU0FBUyxTQUFDO29CQUNWLDhDQUE4QztvQkFDOUMsUUFBUSxFQUFFLGdCQUFnQjtvQkFDMUIsUUFBUSxFQUFFLG9tRUEyRFQ7NkJBQ1Esc0VBSVI7aUJBQ0Q7Ozs7Z0JBakZRLElBQUk7Ozt3QkFtRlgsS0FBSztzQ0FFTCxLQUFLO3FDQUVMLEtBQUs7Z0RBRUwsS0FBSztvQ0FFTCxLQUFLOzJCQUVMLEtBQUs7K0JBRUwsS0FBSzsyQkFNTCxLQUFLO3VCQUtMLEtBQUs7c0NBRUwsS0FBSztzQ0FTTCxLQUFLO3FDQVNMLEtBQUs7OEJBU0wsS0FBSzt1QkFZTCxNQUFNOzRCQU1OLE1BQU07OEJBTU4sTUFBTTs7SUF3Q1IsZ0JBQUM7Q0FBQSxBQTFMRCxJQTBMQztTQXJIWSxTQUFTIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0Q29tcG9uZW50LFxuXHRJbnB1dCxcblx0T3V0cHV0LFxuXHRFdmVudEVtaXR0ZXIsXG5cdEFmdGVyVmlld0luaXRcbn0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcblxuaW1wb3J0IHsgVGFibGVNb2RlbCB9IGZyb20gXCIuLi90YWJsZS1tb2RlbC5jbGFzc1wiO1xuaW1wb3J0IHsgZ2V0U2Nyb2xsYmFyV2lkdGggfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci91dGlsc1wiO1xuaW1wb3J0IHsgSTE4biwgT3ZlcnJpZGFibGUgfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9pMThuXCI7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSBcInJ4anNcIjtcbmltcG9ydCB7IFRhYmxlUm93U2l6ZSB9IGZyb20gXCIuLi90YWJsZS50eXBlc1wiO1xuXG4vKipcbiAqIEEgc3ViY29tcG9uZW50IHRoYXQgY3JlYXRlcyB0aGUgdGhlYWQgb2YgdGhlIHRhYmxlXG4gKlxuICogIyMgQmFzaWMgdXNhZ2VcbiAqXG4gKiBgYGBodG1sXG4gKiBcdDx0aGVhZCBpYm1UYWJsZUhlYWQgW21vZGVsXT1cIm1vZGVsXCI+PC90aGVhZD5cbiAqIGBgYFxuICovXG5AQ29tcG9uZW50KHtcblx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmNvbXBvbmVudC1zZWxlY3RvclxuXHRzZWxlY3RvcjogXCJbaWJtVGFibGVIZWFkXVwiLFxuXHR0ZW1wbGF0ZTogYFxuXHQ8bmctY29udGFpbmVyICpuZ0lmPVwibW9kZWxcIj5cblx0XHQ8dHI+XG5cdFx0XHQ8dGhcblx0XHRcdFx0aWJtVGFibGVIZWFkRXhwYW5kXG5cdFx0XHRcdCpuZ0lmPVwibW9kZWwuaGFzRXhwYW5kYWJsZVJvd3MoKVwiXG5cdFx0XHRcdHNjb3BlPVwiY29sXCJcblx0XHRcdFx0W25nQ2xhc3NdPVwieydieC0tdGFibGUtZXhwYW5kLXYyJzogc3RpY2t5SGVhZGVyfVwiXG5cdFx0XHRcdFtpZF09XCJtb2RlbC5nZXRJZCgnZXhwYW5kJylcIj5cblx0XHRcdDwvdGg+XG5cdFx0XHQ8dGhcblx0XHRcdFx0Km5nSWY9XCIhc2tlbGV0b24gJiYgc2hvd1NlbGVjdGlvbkNvbHVtbiAmJiBlbmFibGVTaW5nbGVTZWxlY3RcIlxuXHRcdFx0XHRzY29wZT1cImNvbFwiXG5cdFx0XHRcdHN0eWxlPVwid2lkdGg6IDA7XCJcblx0XHRcdFx0W2lkXT1cIm1vZGVsLmdldElkKCdzZWxlY3QnKVwiPlxuXHRcdFx0XHQ8IS0tIGFkZCB3aWR0aCAwOyBzaW5jZSB0aGUgY2FyYm9uIHN0eWxlcyBkb24ndCBzZWVtIHRvIGNvbnN0cmFpbiB0aGlzIGhlYWRlcnMgd2lkdGggLS0+XG5cdFx0XHQ8L3RoPlxuXHRcdFx0PHRoXG5cdFx0XHRcdGlibVRhYmxlSGVhZENoZWNrYm94XG5cdFx0XHRcdCpuZ0lmPVwiIXNrZWxldG9uICYmIHNob3dTZWxlY3Rpb25Db2x1bW4gJiYgIWVuYWJsZVNpbmdsZVNlbGVjdFwiXG5cdFx0XHRcdHNjb3BlPVwiY29sXCJcblx0XHRcdFx0W2NoZWNrZWRdPVwic2VsZWN0QWxsQ2hlY2tib3hcIlxuXHRcdFx0XHRbaW5kZXRlcm1pbmF0ZV09XCJzZWxlY3RBbGxDaGVja2JveFNvbWVTZWxlY3RlZFwiXG5cdFx0XHRcdFthcmlhTGFiZWxdPVwiZ2V0Q2hlY2tib3hIZWFkZXJMYWJlbCgpXCJcblx0XHRcdFx0W3NpemVdPVwic2l6ZVwiXG5cdFx0XHRcdFtza2VsZXRvbl09XCJza2VsZXRvblwiXG5cdFx0XHRcdFtuYW1lXT1cIm1vZGVsLmdldEhlYWRlcklkKCdzZWxlY3QnKVwiXG5cdFx0XHRcdChjaGFuZ2UpPVwib25TZWxlY3RBbGxDaGVja2JveENoYW5nZSgpXCJcblx0XHRcdFx0W2lkXT1cIm1vZGVsLmdldElkKCdzZWxlY3QnKVwiPlxuXHRcdFx0PC90aD5cblx0XHRcdDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBtb2RlbC5oZWFkZXI7IGxldCBpID0gaW5kZXhcIj5cblx0XHRcdFx0PHRoXG5cdFx0XHRcdFx0Km5nSWY9XCJjb2x1bW4gJiYgY29sdW1uLnZpc2libGVcIlxuXHRcdFx0XHRcdFtuZ1N0eWxlXT1cImNvbHVtbi5zdHlsZVwiXG5cdFx0XHRcdFx0aWJtVGFibGVIZWFkQ2VsbFxuXHRcdFx0XHRcdHNjb3BlPVwiY29sXCJcblx0XHRcdFx0XHRbY2xhc3NdPVwiY29sdW1uLmNsYXNzTmFtZVwiXG5cdFx0XHRcdFx0W3NvcnRhYmxlXT1cInNvcnRhYmxlXCJcblx0XHRcdFx0XHRbc2tlbGV0b25dPVwic2tlbGV0b25cIlxuXHRcdFx0XHRcdFtpZF09XCJtb2RlbC5nZXRJZChpKVwiXG5cdFx0XHRcdFx0W2NvbHVtbl09XCJjb2x1bW5cIlxuXHRcdFx0XHRcdFtza2VsZXRvbl09XCJza2VsZXRvblwiXG5cdFx0XHRcdFx0W2ZpbHRlclRpdGxlXT1cImdldEZpbHRlclRpdGxlKClcIlxuXHRcdFx0XHRcdFthdHRyLmNvbHNwYW5dPVwiY29sdW1uLmNvbFNwYW5cIlxuXHRcdFx0XHRcdFthdHRyLnJvd3NwYW5dPVwiY29sdW1uLnJvd1NwYW5cIlxuXHRcdFx0XHRcdChzb3J0KT1cInNvcnQuZW1pdChpKVwiPlxuXHRcdFx0XHQ8L3RoPlxuXHRcdFx0PC9uZy1jb250YWluZXI+XG5cdFx0XHQ8dGggKm5nSWY9XCIhc2tlbGV0b24gJiYgc3RpY2t5SGVhZGVyICYmIHNjcm9sbGJhcldpZHRoXCJcblx0XHRcdFx0c2NvcGU9XCJjb2xcIlxuXHRcdFx0XHRbbmdTdHlsZV09XCJ7J3dpZHRoJzogc2Nyb2xsYmFyV2lkdGggKyAncHgnLCAncGFkZGluZyc6IDAsICdib3JkZXInOiAwfVwiPlxuXHRcdFx0XHQ8IS0tXG5cdFx0XHRcdFx0U2Nyb2xsYmFyIHB1c2hlcyBib2R5IHRvIHRoZSBsZWZ0IHNvIHRoaXMgaGVhZGVyIGNvbHVtbiBpcyBhZGRlZCB0byBwdXNoXG5cdFx0XHRcdFx0dGhlIHRpdGxlIGJhciB0aGUgc2FtZSBhbW91bnQgYW5kIGtlZXAgdGhlIGhlYWRlciBhbmQgYm9keSBjb2x1bW5zIGFsaWduZWQuXG5cdFx0XHRcdC0tPlxuXHRcdFx0PC90aD5cblx0XHQ8L3RyPlxuXHQ8L25nLWNvbnRhaW5lcj5cblx0PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuXHRgLFxuXHRzdHlsZXM6IFtgXG5cdFx0LmJ4LS10YWJsZS1leHBhbmQtdjIge1xuXHRcdFx0cGFkZGluZy1sZWZ0OiAyLjVyZW07XG5cdFx0fVxuXHRgXVxufSlcbmV4cG9ydCBjbGFzcyBUYWJsZUhlYWQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcblx0QElucHV0KCkgbW9kZWw6IFRhYmxlTW9kZWw7XG5cblx0QElucHV0KCkgc2hvd1NlbGVjdGlvbkNvbHVtbiA9IHRydWU7XG5cblx0QElucHV0KCkgZW5hYmxlU2luZ2xlU2VsZWN0ID0gZmFsc2U7XG5cblx0QElucHV0KCkgc2VsZWN0QWxsQ2hlY2tib3hTb21lU2VsZWN0ZWQgPSBmYWxzZTtcblxuXHRASW5wdXQoKSBzZWxlY3RBbGxDaGVja2JveCA9IGZhbHNlO1xuXG5cdEBJbnB1dCgpIHNrZWxldG9uID0gZmFsc2U7XG5cblx0QElucHV0KCkgc3RpY2t5SGVhZGVyID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIFNldHRpbmcgc29ydGFibGUgdG8gZmFsc2Ugd2lsbCBkaXNhYmxlIGFsbCBoZWFkZXJzIGluY2x1ZGluZyBoZWFkZXJzIHdoaWNoIGFyZSBzb3J0YWJsZS4gSXMgaXNcblx0ICogcG9zc2libGUgdG8gc2V0IHRoZSBzb3J0YWJsZSBzdGF0ZSBvbiB0aGUgaGVhZGVyIGl0ZW0gdG8gZGlzYWJsZS9lbmFibGUgc29ydGluZyBmb3Igb25seSBzb21lIGhlYWRlcnMuXG5cdCAqL1xuXHRASW5wdXQoKSBzb3J0YWJsZSA9IHRydWU7XG5cblx0LyoqXG5cdCAqIFNpemUgb2YgdGhlIHRhYmxlIHJvd3MuXG5cdCAqL1xuXHRASW5wdXQoKSBzaXplOiBUYWJsZVJvd1NpemUgPSBcIm1kXCI7XG5cblx0QElucHV0KClcblx0c2V0IGNoZWNrYm94SGVhZGVyTGFiZWwodmFsdWU6IHN0cmluZyB8IE9ic2VydmFibGU8c3RyaW5nPikge1xuXHRcdHRoaXMuX2NoZWNrYm94SGVhZGVyTGFiZWwub3ZlcnJpZGUodmFsdWUpO1xuXHR9XG5cblx0Z2V0IGNoZWNrYm94SGVhZGVyTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoZWNrYm94SGVhZGVyTGFiZWwudmFsdWU7XG5cdH1cblxuXHRASW5wdXQoKVxuXHRzZXQgc29ydERlc2NlbmRpbmdMYWJlbCh2YWx1ZTogc3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+KSB7XG5cdFx0dGhpcy5fc29ydERlc2NlbmRpbmdMYWJlbC5vdmVycmlkZSh2YWx1ZSk7XG5cdH1cblxuXHRnZXQgc29ydERlc2NlbmRpbmdMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc29ydERlc2NlbmRpbmdMYWJlbC52YWx1ZTtcblx0fVxuXG5cdEBJbnB1dCgpXG5cdHNldCBzb3J0QXNjZW5kaW5nTGFiZWwodmFsdWU6IHN0cmluZyB8IE9ic2VydmFibGU8c3RyaW5nPikge1xuXHRcdHRoaXMuX3NvcnRBc2NlbmRpbmdMYWJlbC5vdmVycmlkZSh2YWx1ZSk7XG5cdH1cblxuXHRnZXQgc29ydEFzY2VuZGluZ0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLl9zb3J0QXNjZW5kaW5nTGFiZWwudmFsdWU7XG5cdH1cblxuXHRASW5wdXQoKVxuXHRzZXQgZmlsdGVyVGl0bGUodmFsdWU6IHN0cmluZyB8IE9ic2VydmFibGU8c3RyaW5nPikge1xuXHRcdHRoaXMuX2ZpbHRlclRpdGxlLm92ZXJyaWRlKHZhbHVlKTtcblx0fVxuXG5cdGdldCBmaWx0ZXJUaXRsZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZmlsdGVyVGl0bGUudmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogRW1pdHMgYW4gaW5kZXggb2YgdGhlIGNvbHVtbiB0aGF0IHdhbnRzIHRvIGJlIHNvcnRlZC5cblx0ICovXG5cdEBPdXRwdXQoKSBzb3J0ID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cdC8qKlxuXHQgKiBFbWl0cyBpZiBhbGwgcm93cyBhcmUgc2VsZWN0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSBtb2RlbFxuXHQgKi9cblx0QE91dHB1dCgpIHNlbGVjdEFsbCA9IG5ldyBFdmVudEVtaXR0ZXI8VGFibGVNb2RlbD4oKTtcblx0LyoqXG5cdCAqIEVtaXRzIGlmIGFsbCByb3dzIGFyZSBkZXNlbGVjdGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0gbW9kZWxcblx0ICovXG5cdEBPdXRwdXQoKSBkZXNlbGVjdEFsbCA9IG5ldyBFdmVudEVtaXR0ZXI8VGFibGVNb2RlbD4oKTtcblxuXHRwdWJsaWMgc2Nyb2xsYmFyV2lkdGggPSAwO1xuXG5cdHByb3RlY3RlZCBfY2hlY2tib3hIZWFkZXJMYWJlbCA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlRBQkxFLkNIRUNLQk9YX0hFQURFUlwiKTtcblx0cHJvdGVjdGVkIF9zb3J0RGVzY2VuZGluZ0xhYmVsID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuU09SVF9ERVNDRU5ESU5HXCIpO1xuXHRwcm90ZWN0ZWQgX3NvcnRBc2NlbmRpbmdMYWJlbCA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlRBQkxFLlNPUlRfQVNDRU5ESU5HXCIpO1xuXHRwcm90ZWN0ZWQgX2ZpbHRlclRpdGxlID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuRklMVEVSXCIpO1xuXG5cdGNvbnN0cnVjdG9yKHByb3RlY3RlZCBpMThuOiBJMThuKSB7fVxuXG5cdG5nQWZ0ZXJWaWV3SW5pdCgpIHtcblx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdHRoaXMuc2Nyb2xsYmFyV2lkdGggPSBnZXRTY3JvbGxiYXJXaWR0aCgpO1xuXHRcdH0pO1xuXHR9XG5cblx0b25TZWxlY3RBbGxDaGVja2JveENoYW5nZSgpIHtcblx0XHRpZiAoIXRoaXMuc2VsZWN0QWxsQ2hlY2tib3ggJiYgIXRoaXMuc2VsZWN0QWxsQ2hlY2tib3hTb21lU2VsZWN0ZWQpIHtcblx0XHRcdHRoaXMuc2VsZWN0QWxsLmVtaXQodGhpcy5tb2RlbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZGVzZWxlY3RBbGwuZW1pdCh0aGlzLm1vZGVsKTtcblx0XHR9XG5cdH1cblxuXHRnZXRDaGVja2JveEhlYWRlckxhYmVsKCk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoZWNrYm94SGVhZGVyTGFiZWwuc3ViamVjdDtcblx0fVxuXG5cdGdldFNvcnREZXNjZW5kaW5nTGFiZWwoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcblx0XHRyZXR1cm4gdGhpcy5fc29ydERlc2NlbmRpbmdMYWJlbC5zdWJqZWN0O1xuXHR9XG5cblx0Z2V0U29ydEFzY2VuZGluZ0xhYmVsKCk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG5cdFx0cmV0dXJuIHRoaXMuX3NvcnRBc2NlbmRpbmdMYWJlbC5zdWJqZWN0O1xuXHR9XG5cblx0Z2V0RmlsdGVyVGl0bGUoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcblx0XHRyZXR1cm4gdGhpcy5fZmlsdGVyVGl0bGUuc3ViamVjdDtcblx0fVxufVxuIl19