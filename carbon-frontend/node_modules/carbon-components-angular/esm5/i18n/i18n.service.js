/**
 *
 * carbon-angular v0.0.0 | i18n.service.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import * as tslib_1 from "tslib";
import { Injectable } from "@angular/core";
import { BehaviorSubject, isObservable, iif } from "rxjs";
import { map } from "rxjs/operators";
import { merge } from "carbon-components-angular/utils";
import EN from "./en";
/**
 * Takes the `Observable` returned from `i18n.get` and an object of variables to replace.
 *
 * The keys specify the variable name in the string.
 *
 * Example:
 * ```typescript
 * service.set({ "TEST": "{{foo}} {{bar}}" });
 *
 * service.replace(service.get("TEST"), { foo: "test", bar: "asdf" })
 * ```
 *
 * Produces: `"test asdf"`
 *
 * @param subject the translation to replace variables on
 * @param variables object of variables to replace
 */
export var replace = function (subject, variables) { return subject.pipe(map(function (str) {
    var e_1, _a;
    var keys = Object.keys(variables);
    try {
        for (var keys_1 = tslib_1.__values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            var value = variables[key];
            str = str.replace(new RegExp("{{\\s*" + key + "\\s*}}", "g"), value);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return str;
})); };
/**
 * Represents an "overridable" translation value.
 *
 * Largely an internal usecase. There are situations where we want an `Observable` that
 * can emit events from a centralized source **OR** an `Observable` that will emit events
 * from a component local source. The key example being on/off text in a `Toggle` - In some cases
 * we want the `Toggle` to use `I18n`s global translations, but in others we'd prefer to use a local
 * override. We don't ever need to return to a non-overridden state, but we do need the ability to
 * switch _to_ an overridden sate.
 */
var Overridable = /** @class */ (function () {
    function Overridable(path, i18n) {
        this.path = path;
        this.i18n = i18n;
        /**
         * Our base non-overridden translation.
         */
        this.baseTranslation = this.i18n.get(this.path);
        /**
         * A boolean to flip between overridden and non-overridden states.
         */
        this.isOverridden = false;
        /**
         * ensure `$override` is initialized with the correct default value
         * in some cases `_value` can get changed for an `Observable` before `$override` is created
         */
        var value = this.i18n.getValueFromPath(this.path);
        this.$override = new BehaviorSubject(value);
        this._value = value;
    }
    Object.defineProperty(Overridable.prototype, "value", {
        /**
         * The raw value of the translation. Defaults to the string value, but will return the value passed to `override`
         *
         * @readonly
         */
        get: function () {
            return this._value;
        },
        set: function (v) {
            this.override(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Overridable.prototype, "subject", {
        /**
         * The translation subject. Returns either a stream of overridden values, or our base translation values.
         *
         * @readonly
         */
        get: function () {
            var _this = this;
            /**
             * since inputs are bound on template instantiation (and thusly will always have _some_ value)
             * We can use a simple boolean and the `iif` function to determine which subject to return on subscription
             */
            return iif(function () { return _this.isOverridden; }, this.$override, this.baseTranslation);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Takes a string or an `Observable` that emits strings.
     * Overrides the value provided by the `I18n` service.
     */
    Overridable.prototype.override = function (value) {
        var _this = this;
        this.isOverridden = true;
        // To ensure that there are not multiple subscriptions created for the same observable, we
        // unsubscribe if a subscription already exists for an observable before creating a new one.
        if (this.subscription) {
            this.subscription.unsubscribe();
            this.subscription = null;
        }
        this._value = value;
        if (isObservable(value)) {
            this.subscription = value.subscribe(function (v) {
                _this.$override.next(v);
            });
        }
        else {
            this.$override.next(value);
        }
    };
    return Overridable;
}());
export { Overridable };
/**
 * The I18n service is a minimal internal singleton service used to supply our components with translated strings.
 *
 * All the components that support I18n also support directly passed strings.
 * Usage of I18n is optional, and it is not recommended for application use (libraries like ngx-translate
 * are a better choice)
 *
 */
var I18n = /** @class */ (function () {
    function I18n() {
        this.translationStrings = EN;
        this.translations = new Map();
        this.locale = new BehaviorSubject("en");
    }
    /**
     * Sets the locale and optionally the translation strings. Locale is used by components that
     * are already locale aware (datepicker for example) while the translation strings are used
     * for components that are not.
     *
     * Locales set here will override locales/languages set in components
     * @param language an ISO 639-1 language code - https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
     * @param strings an object of strings, optional
     */
    I18n.prototype.setLocale = function (language, strings) {
        this.locale.next(language);
        if (strings) {
            this.set(strings);
        }
    };
    /**
     * Returns the current locale
     */
    I18n.prototype.getLocale = function () {
        return this.locale.value;
    };
    /**
     * Returns an observable that resolves to the current locale, and will update when changed
     */
    I18n.prototype.getLocaleObservable = function () {
        return this.locale.asObservable();
    };
    /**
     * Set/update the translations from an object. Also notifies all participating components of the update.
     *
     * @param strings an object of strings, should follow the same format as src/i18n/en.json
     */
    I18n.prototype.set = function (strings) {
        var e_2, _a;
        this.translationStrings = merge({}, EN, strings);
        // iterate over all our tracked translations and update each observable
        var translations = Array.from(this.translations);
        try {
            for (var translations_1 = tslib_1.__values(translations), translations_1_1 = translations_1.next(); !translations_1_1.done; translations_1_1 = translations_1.next()) {
                var _b = tslib_1.__read(translations_1_1.value, 2), path = _b[0], subject = _b[1];
                subject.next(this.getValueFromPath(path));
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (translations_1_1 && !translations_1_1.done && (_a = translations_1.return)) _a.call(translations_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    /**
     * When a path is specified returns an observable that will resolve to the translation string value.
     *
     * Returns the full translations object if path is not specified.
     *
     * @param path optional, looks like `"NOTIFICATION.CLOSE_BUTTON"`
     */
    I18n.prototype.get = function (path) {
        if (!path) {
            return this.translationStrings;
        }
        return this.getSubject(path);
    };
    /**
     * Returns all descendents of some path fragment as an object.
     *
     * @param partialPath a path fragment, for example `"NOTIFICATION"`
     */
    I18n.prototype.getMultiple = function (partialPath) {
        var e_3, _a;
        var values = this.getValueFromPath(partialPath);
        var subjects = {};
        try {
            for (var _b = tslib_1.__values(Object.keys(values)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                if (values[key] === Object(values[key])) {
                    subjects[key] = this.getMultiple(partialPath + "." + key);
                }
                else {
                    subjects[key] = this.getSubject(partialPath + "." + key);
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return subjects;
    };
    /**
     * Returns an instance of `Overridable` that can be used to optionally override the value provided by `I18n`
     * @param path looks like `"NOTIFICATION.CLOSE_BUTTON"`
     */
    I18n.prototype.getOverridable = function (path) {
        return new Overridable(path, this);
    };
    /**
     * Takes the `Observable` returned from `i18n.get` and an object of variables to replace.
     *
     * The keys specify the variable name in the string.
     *
     * Example:
     * ```
     * service.set({ "TEST": "{{foo}} {{bar}}" });
     *
     * service.replace(service.get("TEST"), { foo: "test", bar: "asdf" })
     * ```
     *
     * Produces: `"test asdf"`
     *
     * @param subject the translation to replace variables on
     * @param variables object of variables to replace
     */
    I18n.prototype.replace = function (subject, variables) {
        return replace(subject, variables);
    };
    /**
     * Trys to resolve a value from the provided path.
     *
     * @param path looks like `"NOTIFICATION.CLOSE_BUTTON"`
     */
    I18n.prototype.getValueFromPath = function (path) {
        var e_4, _a;
        var value = this.translationStrings;
        try {
            for (var _b = tslib_1.__values(path.split(".")), _c = _b.next(); !_c.done; _c = _b.next()) {
                var segment = _c.value;
                if (value[segment] !== undefined && value[segment] !== null) {
                    value = value[segment];
                }
                else {
                    throw new Error("no key " + segment + " at " + path);
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return value;
    };
    /**
     * Helper method that returns an observable from the internal cache based on the path
     *
     * @param path looks like `"NOTIFICATION.CLOSE_BUTTON"`
     */
    I18n.prototype.getSubject = function (path) {
        try {
            // we run this here to validate the path exists before adding it to the translation map
            var value = this.getValueFromPath(path);
            if (this.translations.has(path)) {
                return this.translations.get(path);
            }
            var translation = new BehaviorSubject(value);
            this.translations.set(path, translation);
            return translation;
        }
        catch (error) {
            console.error(error);
        }
    };
    I18n.decorators = [
        { type: Injectable }
    ];
    return I18n;
}());
export { I18n };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaTE4bi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9pMThuLyIsInNvdXJjZXMiOlsiaTE4bi5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFDTixlQUFlLEVBRWYsWUFBWSxFQUNaLEdBQUcsRUFFSCxNQUFNLE1BQU0sQ0FBQztBQUNkLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNyQyxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFFeEQsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBRXRCOzs7Ozs7Ozs7Ozs7Ozs7O0dBZ0JHO0FBQ0gsTUFBTSxDQUFDLElBQU0sT0FBTyxHQUFHLFVBQUMsT0FBTyxFQUFFLFNBQVMsSUFBSyxPQUFBLE9BQU8sQ0FBQyxJQUFJLENBQzFELEdBQUcsQ0FBZSxVQUFBLEdBQUc7O0lBQ3BCLElBQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7O1FBQ3BDLEtBQWtCLElBQUEsU0FBQSxpQkFBQSxJQUFJLENBQUEsMEJBQUEsNENBQUU7WUFBbkIsSUFBTSxHQUFHLGlCQUFBO1lBQ2IsSUFBTSxLQUFLLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzdCLEdBQUcsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksTUFBTSxDQUFDLFdBQVMsR0FBRyxXQUFRLEVBQUUsR0FBRyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDaEU7Ozs7Ozs7OztJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ1osQ0FBQyxDQUFDLENBQ0YsRUFUOEMsQ0FTOUMsQ0FBQztBQUVGOzs7Ozs7Ozs7R0FTRztBQUNIO0lBaURDLHFCQUFzQixJQUFZLEVBQVksSUFBVTtRQUFsQyxTQUFJLEdBQUosSUFBSSxDQUFRO1FBQVksU0FBSSxHQUFKLElBQUksQ0FBTTtRQWR4RDs7V0FFRztRQUNPLG9CQUFlLEdBQXVCLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQU16RTs7V0FFRztRQUNPLGlCQUFZLEdBQUcsS0FBSyxDQUFDO1FBRzlCOzs7V0FHRztRQUNILElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBVyxDQUFDO1FBQzlELElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxlQUFlLENBQVMsS0FBSyxDQUFDLENBQUM7UUFDcEQsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7SUFDckIsQ0FBQztJQW5ERCxzQkFBVyw4QkFBSztRQUxoQjs7OztXQUlHO2FBQ0g7WUFDQyxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDcEIsQ0FBQzthQUVELFVBQWlCLENBQThCO1lBQzlDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbEIsQ0FBQzs7O09BSkE7SUFXRCxzQkFBVyxnQ0FBTztRQUxsQjs7OztXQUlHO2FBQ0g7WUFBQSxpQkFNQztZQUxBOzs7ZUFHRztZQUNILE9BQU8sR0FBRyxDQUFDLGNBQU0sT0FBQSxLQUFJLENBQUMsWUFBWSxFQUFqQixDQUFpQixFQUFFLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQzNFLENBQUM7OztPQUFBO0lBaUNEOzs7T0FHRztJQUNILDhCQUFRLEdBQVIsVUFBUyxLQUFrQztRQUEzQyxpQkFrQkM7UUFqQkEsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7UUFDekIsMEZBQTBGO1FBQzFGLDRGQUE0RjtRQUM1RixJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDdEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNoQyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztTQUN6QjtRQUVELElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBRXBCLElBQUksWUFBWSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3hCLElBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxVQUFBLENBQUM7Z0JBQ3BDLEtBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3hCLENBQUMsQ0FBQyxDQUFDO1NBQ0g7YUFBTTtZQUNOLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzNCO0lBQ0YsQ0FBQztJQUNGLGtCQUFDO0FBQUQsQ0FBQyxBQWpGRCxJQWlGQzs7QUFRRDs7Ozs7OztHQU9HO0FBQ0g7SUFBQTtRQUVXLHVCQUFrQixHQUFHLEVBQUUsQ0FBQztRQUV4QixpQkFBWSxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7UUFFekIsV0FBTSxHQUFHLElBQUksZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBK0k5QyxDQUFDO0lBN0lBOzs7Ozs7OztPQVFHO0lBQ0ksd0JBQVMsR0FBaEIsVUFBaUIsUUFBZ0IsRUFBRSxPQUE0QjtRQUM5RCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUMzQixJQUFJLE9BQU8sRUFBRTtZQUNaLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDbEI7SUFDRixDQUFDO0lBRUQ7O09BRUc7SUFDSSx3QkFBUyxHQUFoQjtRQUNDLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7SUFDMUIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksa0NBQW1CLEdBQTFCO1FBQ0MsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ25DLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksa0JBQUcsR0FBVixVQUFXLE9BQTJCOztRQUNyQyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsS0FBSyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDakQsdUVBQXVFO1FBQ3ZFLElBQU0sWUFBWSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDOztZQUNuRCxLQUE4QixJQUFBLGlCQUFBLGlCQUFBLFlBQVksQ0FBQSwwQ0FBQSxvRUFBRTtnQkFBakMsSUFBQSw4Q0FBZSxFQUFkLFlBQUksRUFBRSxlQUFPO2dCQUN4QixPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO2FBQzFDOzs7Ozs7Ozs7SUFDRixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksa0JBQUcsR0FBVixVQUFXLElBQWE7UUFDdkIsSUFBSSxDQUFDLElBQUksRUFBRTtZQUNWLE9BQU8sSUFBSSxDQUFDLGtCQUFrQixDQUFDO1NBQy9CO1FBQ0QsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksMEJBQVcsR0FBbEIsVUFBbUIsV0FBbUI7O1FBQ3JDLElBQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNsRCxJQUFNLFFBQVEsR0FBRyxFQUFFLENBQUM7O1lBQ3BCLEtBQWtCLElBQUEsS0FBQSxpQkFBQSxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBLGdCQUFBLDRCQUFFO2dCQUFsQyxJQUFNLEdBQUcsV0FBQTtnQkFDYixJQUFJLE1BQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7b0JBQ3hDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFJLFdBQVcsU0FBSSxHQUFLLENBQUMsQ0FBQztpQkFDMUQ7cUJBQU07b0JBQ04sUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUksV0FBVyxTQUFJLEdBQUssQ0FBQyxDQUFDO2lCQUN6RDthQUNEOzs7Ozs7Ozs7UUFDRCxPQUFPLFFBQVEsQ0FBQztJQUNqQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksNkJBQWMsR0FBckIsVUFBc0IsSUFBWTtRQUNqQyxPQUFPLElBQUksV0FBVyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7T0FnQkc7SUFDSSxzQkFBTyxHQUFkLFVBQWUsT0FBMkIsRUFBRSxTQUFvQztRQUMvRSxPQUFPLE9BQU8sQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSwrQkFBZ0IsR0FBdkIsVUFBd0IsSUFBSTs7UUFDM0IsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDOztZQUNwQyxLQUFzQixJQUFBLEtBQUEsaUJBQUEsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQSxnQkFBQSw0QkFBRTtnQkFBbEMsSUFBTSxPQUFPLFdBQUE7Z0JBQ2pCLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLFNBQVMsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssSUFBSSxFQUFFO29CQUM1RCxLQUFLLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2lCQUN2QjtxQkFBTTtvQkFDTixNQUFNLElBQUksS0FBSyxDQUFDLFlBQVUsT0FBTyxZQUFPLElBQU0sQ0FBQyxDQUFDO2lCQUNoRDthQUNEOzs7Ozs7Ozs7UUFDRCxPQUFPLEtBQVksQ0FBQztJQUNyQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNPLHlCQUFVLEdBQXBCLFVBQXFCLElBQVk7UUFDaEMsSUFBSTtZQUNILHVGQUF1RjtZQUN2RixJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFXLENBQUM7WUFDcEQsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDaEMsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNuQztZQUNELElBQU0sV0FBVyxHQUFHLElBQUksZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQy9DLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQztZQUN6QyxPQUFPLFdBQVcsQ0FBQztTQUNuQjtRQUFDLE9BQU8sS0FBSyxFQUFFO1lBQ2YsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUNyQjtJQUNGLENBQUM7O2dCQXBKRCxVQUFVOztJQXFKWCxXQUFDO0NBQUEsQUFySkQsSUFxSkM7U0FwSlksSUFBSSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHtcblx0QmVoYXZpb3JTdWJqZWN0LFxuXHRPYnNlcnZhYmxlLFxuXHRpc09ic2VydmFibGUsXG5cdGlpZixcblx0U3Vic2NyaXB0aW9uXG59IGZyb20gXCJyeGpzXCI7XG5pbXBvcnQgeyBtYXAgfSBmcm9tIFwicnhqcy9vcGVyYXRvcnNcIjtcbmltcG9ydCB7IG1lcmdlIH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvdXRpbHNcIjtcblxuaW1wb3J0IEVOIGZyb20gXCIuL2VuXCI7XG5cbi8qKlxuICogVGFrZXMgdGhlIGBPYnNlcnZhYmxlYCByZXR1cm5lZCBmcm9tIGBpMThuLmdldGAgYW5kIGFuIG9iamVjdCBvZiB2YXJpYWJsZXMgdG8gcmVwbGFjZS5cbiAqXG4gKiBUaGUga2V5cyBzcGVjaWZ5IHRoZSB2YXJpYWJsZSBuYW1lIGluIHRoZSBzdHJpbmcuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIHNlcnZpY2Uuc2V0KHsgXCJURVNUXCI6IFwie3tmb299fSB7e2Jhcn19XCIgfSk7XG4gKlxuICogc2VydmljZS5yZXBsYWNlKHNlcnZpY2UuZ2V0KFwiVEVTVFwiKSwgeyBmb286IFwidGVzdFwiLCBiYXI6IFwiYXNkZlwiIH0pXG4gKiBgYGBcbiAqXG4gKiBQcm9kdWNlczogYFwidGVzdCBhc2RmXCJgXG4gKlxuICogQHBhcmFtIHN1YmplY3QgdGhlIHRyYW5zbGF0aW9uIHRvIHJlcGxhY2UgdmFyaWFibGVzIG9uXG4gKiBAcGFyYW0gdmFyaWFibGVzIG9iamVjdCBvZiB2YXJpYWJsZXMgdG8gcmVwbGFjZVxuICovXG5leHBvcnQgY29uc3QgcmVwbGFjZSA9IChzdWJqZWN0LCB2YXJpYWJsZXMpID0+IHN1YmplY3QucGlwZShcblx0bWFwPHN0cmluZywgdm9pZD4oc3RyID0+IHtcblx0XHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFyaWFibGVzKTtcblx0XHRmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG5cdFx0XHRjb25zdCB2YWx1ZSA9IHZhcmlhYmxlc1trZXldO1xuXHRcdFx0c3RyID0gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChge3tcXFxccyoke2tleX1cXFxccyp9fWAsIFwiZ1wiKSwgdmFsdWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gc3RyO1xuXHR9KVxuKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIFwib3ZlcnJpZGFibGVcIiB0cmFuc2xhdGlvbiB2YWx1ZS5cbiAqXG4gKiBMYXJnZWx5IGFuIGludGVybmFsIHVzZWNhc2UuIFRoZXJlIGFyZSBzaXR1YXRpb25zIHdoZXJlIHdlIHdhbnQgYW4gYE9ic2VydmFibGVgIHRoYXRcbiAqIGNhbiBlbWl0IGV2ZW50cyBmcm9tIGEgY2VudHJhbGl6ZWQgc291cmNlICoqT1IqKiBhbiBgT2JzZXJ2YWJsZWAgdGhhdCB3aWxsIGVtaXQgZXZlbnRzXG4gKiBmcm9tIGEgY29tcG9uZW50IGxvY2FsIHNvdXJjZS4gVGhlIGtleSBleGFtcGxlIGJlaW5nIG9uL29mZiB0ZXh0IGluIGEgYFRvZ2dsZWAgLSBJbiBzb21lIGNhc2VzXG4gKiB3ZSB3YW50IHRoZSBgVG9nZ2xlYCB0byB1c2UgYEkxOG5gcyBnbG9iYWwgdHJhbnNsYXRpb25zLCBidXQgaW4gb3RoZXJzIHdlJ2QgcHJlZmVyIHRvIHVzZSBhIGxvY2FsXG4gKiBvdmVycmlkZS4gV2UgZG9uJ3QgZXZlciBuZWVkIHRvIHJldHVybiB0byBhIG5vbi1vdmVycmlkZGVuIHN0YXRlLCBidXQgd2UgZG8gbmVlZCB0aGUgYWJpbGl0eSB0b1xuICogc3dpdGNoIF90b18gYW4gb3ZlcnJpZGRlbiBzYXRlLlxuICovXG5leHBvcnQgY2xhc3MgT3ZlcnJpZGFibGUge1xuXHQvKipcblx0ICogVGhlIHJhdyB2YWx1ZSBvZiB0aGUgdHJhbnNsYXRpb24uIERlZmF1bHRzIHRvIHRoZSBzdHJpbmcgdmFsdWUsIGJ1dCB3aWxsIHJldHVybiB0aGUgdmFsdWUgcGFzc2VkIHRvIGBvdmVycmlkZWBcblx0ICpcblx0ICogQHJlYWRvbmx5XG5cdCAqL1xuXHRwdWJsaWMgZ2V0IHZhbHVlKCk6IHN0cmluZyB8IE9ic2VydmFibGU8c3RyaW5nPiB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlO1xuXHR9XG5cblx0cHVibGljIHNldCB2YWx1ZSh2OiBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz4pIHtcblx0XHR0aGlzLm92ZXJyaWRlKHYpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSB0cmFuc2xhdGlvbiBzdWJqZWN0LiBSZXR1cm5zIGVpdGhlciBhIHN0cmVhbSBvZiBvdmVycmlkZGVuIHZhbHVlcywgb3Igb3VyIGJhc2UgdHJhbnNsYXRpb24gdmFsdWVzLlxuXHQgKlxuXHQgKiBAcmVhZG9ubHlcblx0ICovXG5cdHB1YmxpYyBnZXQgc3ViamVjdCgpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuXHRcdC8qKlxuXHRcdCAqIHNpbmNlIGlucHV0cyBhcmUgYm91bmQgb24gdGVtcGxhdGUgaW5zdGFudGlhdGlvbiAoYW5kIHRodXNseSB3aWxsIGFsd2F5cyBoYXZlIF9zb21lXyB2YWx1ZSlcblx0XHQgKiBXZSBjYW4gdXNlIGEgc2ltcGxlIGJvb2xlYW4gYW5kIHRoZSBgaWlmYCBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hpY2ggc3ViamVjdCB0byByZXR1cm4gb24gc3Vic2NyaXB0aW9uXG5cdFx0ICovXG5cdFx0cmV0dXJuIGlpZigoKSA9PiB0aGlzLmlzT3ZlcnJpZGRlbiwgdGhpcy4kb3ZlcnJpZGUsIHRoaXMuYmFzZVRyYW5zbGF0aW9uKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBPdmVycmlkZGVuIHZhbHVlLiBBY2Nlc3NlZCBieSB0aGUgcmVhZG9ubHkgZ2V0dGVyIGB2YWx1ZWAgYW5kIHNldCB0aHJvdWdoIGBvdmVycmlkZWBcblx0ICovXG5cdHByb3RlY3RlZCBfdmFsdWU6IHN0cmluZyB8IE9ic2VydmFibGU8c3RyaW5nPjtcblx0LyoqXG5cdCAqIFN1YmplY3Qgb2Ygb3ZlcnJpZGRlbiB2YWx1ZXMuIEluaXRpYWxpemVkIHdpdGggb3VyIGRlZmF1bHQgdmFsdWUuXG5cdCAqL1xuXHRwcm90ZWN0ZWQgJG92ZXJyaWRlOiBCZWhhdmlvclN1YmplY3Q8c3RyaW5nPjtcblx0LyoqXG5cdCAqIE91ciBiYXNlIG5vbi1vdmVycmlkZGVuIHRyYW5zbGF0aW9uLlxuXHQgKi9cblx0cHJvdGVjdGVkIGJhc2VUcmFuc2xhdGlvbjogT2JzZXJ2YWJsZTxzdHJpbmc+ID0gdGhpcy5pMThuLmdldCh0aGlzLnBhdGgpO1xuXG5cdC8qKlxuXHQgKiBTdWJzY3JpcHRpb24gdG8gdGhlIG9ic2VydmFibGUgcHJvdmlkZWQgYXMgYW4gb3ZlcnJpZGUgKGlmIGFueSlcblx0ICovXG5cdHByb3RlY3RlZCBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblx0LyoqXG5cdCAqIEEgYm9vbGVhbiB0byBmbGlwIGJldHdlZW4gb3ZlcnJpZGRlbiBhbmQgbm9uLW92ZXJyaWRkZW4gc3RhdGVzLlxuXHQgKi9cblx0cHJvdGVjdGVkIGlzT3ZlcnJpZGRlbiA9IGZhbHNlO1xuXG5cdGNvbnN0cnVjdG9yKHByb3RlY3RlZCBwYXRoOiBzdHJpbmcsIHByb3RlY3RlZCBpMThuOiBJMThuKSB7XG5cdFx0LyoqXG5cdFx0ICogZW5zdXJlIGAkb3ZlcnJpZGVgIGlzIGluaXRpYWxpemVkIHdpdGggdGhlIGNvcnJlY3QgZGVmYXVsdCB2YWx1ZVxuXHRcdCAqIGluIHNvbWUgY2FzZXMgYF92YWx1ZWAgY2FuIGdldCBjaGFuZ2VkIGZvciBhbiBgT2JzZXJ2YWJsZWAgYmVmb3JlIGAkb3ZlcnJpZGVgIGlzIGNyZWF0ZWRcblx0XHQgKi9cblx0XHRjb25zdCB2YWx1ZSA9IHRoaXMuaTE4bi5nZXRWYWx1ZUZyb21QYXRoKHRoaXMucGF0aCkgYXMgc3RyaW5nO1xuXHRcdHRoaXMuJG92ZXJyaWRlID0gbmV3IEJlaGF2aW9yU3ViamVjdDxzdHJpbmc+KHZhbHVlKTtcblx0XHR0aGlzLl92YWx1ZSA9IHZhbHVlO1xuXHR9XG5cdC8qKlxuXHQgKiBUYWtlcyBhIHN0cmluZyBvciBhbiBgT2JzZXJ2YWJsZWAgdGhhdCBlbWl0cyBzdHJpbmdzLlxuXHQgKiBPdmVycmlkZXMgdGhlIHZhbHVlIHByb3ZpZGVkIGJ5IHRoZSBgSTE4bmAgc2VydmljZS5cblx0ICovXG5cdG92ZXJyaWRlKHZhbHVlOiBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz4pIHtcblx0XHR0aGlzLmlzT3ZlcnJpZGRlbiA9IHRydWU7XG5cdFx0Ly8gVG8gZW5zdXJlIHRoYXQgdGhlcmUgYXJlIG5vdCBtdWx0aXBsZSBzdWJzY3JpcHRpb25zIGNyZWF0ZWQgZm9yIHRoZSBzYW1lIG9ic2VydmFibGUsIHdlXG5cdFx0Ly8gdW5zdWJzY3JpYmUgaWYgYSBzdWJzY3JpcHRpb24gYWxyZWFkeSBleGlzdHMgZm9yIGFuIG9ic2VydmFibGUgYmVmb3JlIGNyZWF0aW5nIGEgbmV3IG9uZS5cblx0XHRpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcblx0XHRcdHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG5cdFx0XHR0aGlzLnN1YnNjcmlwdGlvbiA9IG51bGw7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdmFsdWUgPSB2YWx1ZTtcblxuXHRcdGlmIChpc09ic2VydmFibGUodmFsdWUpKSB7XG5cdFx0XHR0aGlzLnN1YnNjcmlwdGlvbiA9IHZhbHVlLnN1YnNjcmliZSh2ID0+IHtcblx0XHRcdFx0dGhpcy4kb3ZlcnJpZGUubmV4dCh2KTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLiRvdmVycmlkZS5uZXh0KHZhbHVlKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBBbiBvYmplY3Qgb2Ygc3RyaW5ncywgc2hvdWxkIGZvbGxvdyB0aGUgc2FtZSBmb3JtYXQgYXMgc3JjL2kxOG4vZW4uanNvblxuICovXG5leHBvcnQgdHlwZSBUcmFuc2xhdGlvblN0cmluZ3MgPSB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG5cbi8qKlxuICogVGhlIEkxOG4gc2VydmljZSBpcyBhIG1pbmltYWwgaW50ZXJuYWwgc2luZ2xldG9uIHNlcnZpY2UgdXNlZCB0byBzdXBwbHkgb3VyIGNvbXBvbmVudHMgd2l0aCB0cmFuc2xhdGVkIHN0cmluZ3MuXG4gKlxuICogQWxsIHRoZSBjb21wb25lbnRzIHRoYXQgc3VwcG9ydCBJMThuIGFsc28gc3VwcG9ydCBkaXJlY3RseSBwYXNzZWQgc3RyaW5ncy5cbiAqIFVzYWdlIG9mIEkxOG4gaXMgb3B0aW9uYWwsIGFuZCBpdCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIGFwcGxpY2F0aW9uIHVzZSAobGlicmFyaWVzIGxpa2Ugbmd4LXRyYW5zbGF0ZVxuICogYXJlIGEgYmV0dGVyIGNob2ljZSlcbiAqXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBJMThuIHtcblx0cHJvdGVjdGVkIHRyYW5zbGF0aW9uU3RyaW5ncyA9IEVOO1xuXG5cdHByb3RlY3RlZCB0cmFuc2xhdGlvbnMgPSBuZXcgTWFwKCk7XG5cblx0cHJvdGVjdGVkIGxvY2FsZSA9IG5ldyBCZWhhdmlvclN1YmplY3QoXCJlblwiKTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgbG9jYWxlIGFuZCBvcHRpb25hbGx5IHRoZSB0cmFuc2xhdGlvbiBzdHJpbmdzLiBMb2NhbGUgaXMgdXNlZCBieSBjb21wb25lbnRzIHRoYXRcblx0ICogYXJlIGFscmVhZHkgbG9jYWxlIGF3YXJlIChkYXRlcGlja2VyIGZvciBleGFtcGxlKSB3aGlsZSB0aGUgdHJhbnNsYXRpb24gc3RyaW5ncyBhcmUgdXNlZFxuXHQgKiBmb3IgY29tcG9uZW50cyB0aGF0IGFyZSBub3QuXG5cdCAqXG5cdCAqIExvY2FsZXMgc2V0IGhlcmUgd2lsbCBvdmVycmlkZSBsb2NhbGVzL2xhbmd1YWdlcyBzZXQgaW4gY29tcG9uZW50c1xuXHQgKiBAcGFyYW0gbGFuZ3VhZ2UgYW4gSVNPIDYzOS0xIGxhbmd1YWdlIGNvZGUgLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX0lTT182MzktMV9jb2Rlc1xuXHQgKiBAcGFyYW0gc3RyaW5ncyBhbiBvYmplY3Qgb2Ygc3RyaW5ncywgb3B0aW9uYWxcblx0ICovXG5cdHB1YmxpYyBzZXRMb2NhbGUobGFuZ3VhZ2U6IHN0cmluZywgc3RyaW5ncz86IFRyYW5zbGF0aW9uU3RyaW5ncykge1xuXHRcdHRoaXMubG9jYWxlLm5leHQobGFuZ3VhZ2UpO1xuXHRcdGlmIChzdHJpbmdzKSB7XG5cdFx0XHR0aGlzLnNldChzdHJpbmdzKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY3VycmVudCBsb2NhbGVcblx0ICovXG5cdHB1YmxpYyBnZXRMb2NhbGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMubG9jYWxlLnZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBjdXJyZW50IGxvY2FsZSwgYW5kIHdpbGwgdXBkYXRlIHdoZW4gY2hhbmdlZFxuXHQgKi9cblx0cHVibGljIGdldExvY2FsZU9ic2VydmFibGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMubG9jYWxlLmFzT2JzZXJ2YWJsZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldC91cGRhdGUgdGhlIHRyYW5zbGF0aW9ucyBmcm9tIGFuIG9iamVjdC4gQWxzbyBub3RpZmllcyBhbGwgcGFydGljaXBhdGluZyBjb21wb25lbnRzIG9mIHRoZSB1cGRhdGUuXG5cdCAqXG5cdCAqIEBwYXJhbSBzdHJpbmdzIGFuIG9iamVjdCBvZiBzdHJpbmdzLCBzaG91bGQgZm9sbG93IHRoZSBzYW1lIGZvcm1hdCBhcyBzcmMvaTE4bi9lbi5qc29uXG5cdCAqL1xuXHRwdWJsaWMgc2V0KHN0cmluZ3M6IFRyYW5zbGF0aW9uU3RyaW5ncykge1xuXHRcdHRoaXMudHJhbnNsYXRpb25TdHJpbmdzID0gbWVyZ2Uoe30sIEVOLCBzdHJpbmdzKTtcblx0XHQvLyBpdGVyYXRlIG92ZXIgYWxsIG91ciB0cmFja2VkIHRyYW5zbGF0aW9ucyBhbmQgdXBkYXRlIGVhY2ggb2JzZXJ2YWJsZVxuXHRcdGNvbnN0IHRyYW5zbGF0aW9ucyA9IEFycmF5LmZyb20odGhpcy50cmFuc2xhdGlvbnMpO1xuXHRcdGZvciAoY29uc3QgW3BhdGgsIHN1YmplY3RdIG9mIHRyYW5zbGF0aW9ucykge1xuXHRcdFx0c3ViamVjdC5uZXh0KHRoaXMuZ2V0VmFsdWVGcm9tUGF0aChwYXRoKSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFdoZW4gYSBwYXRoIGlzIHNwZWNpZmllZCByZXR1cm5zIGFuIG9ic2VydmFibGUgdGhhdCB3aWxsIHJlc29sdmUgdG8gdGhlIHRyYW5zbGF0aW9uIHN0cmluZyB2YWx1ZS5cblx0ICpcblx0ICogUmV0dXJucyB0aGUgZnVsbCB0cmFuc2xhdGlvbnMgb2JqZWN0IGlmIHBhdGggaXMgbm90IHNwZWNpZmllZC5cblx0ICpcblx0ICogQHBhcmFtIHBhdGggb3B0aW9uYWwsIGxvb2tzIGxpa2UgYFwiTk9USUZJQ0FUSU9OLkNMT1NFX0JVVFRPTlwiYFxuXHQgKi9cblx0cHVibGljIGdldChwYXRoPzogc3RyaW5nKTogYW55IHtcblx0XHRpZiAoIXBhdGgpIHtcblx0XHRcdHJldHVybiB0aGlzLnRyYW5zbGF0aW9uU3RyaW5ncztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U3ViamVjdChwYXRoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFsbCBkZXNjZW5kZW50cyBvZiBzb21lIHBhdGggZnJhZ21lbnQgYXMgYW4gb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0gcGFydGlhbFBhdGggYSBwYXRoIGZyYWdtZW50LCBmb3IgZXhhbXBsZSBgXCJOT1RJRklDQVRJT05cImBcblx0ICovXG5cdHB1YmxpYyBnZXRNdWx0aXBsZShwYXJ0aWFsUGF0aDogc3RyaW5nKTogeyBba2V5OiBzdHJpbmddOiBPYnNlcnZhYmxlPHN0cmluZz4gfSB7XG5cdFx0Y29uc3QgdmFsdWVzID0gdGhpcy5nZXRWYWx1ZUZyb21QYXRoKHBhcnRpYWxQYXRoKTtcblx0XHRjb25zdCBzdWJqZWN0cyA9IHt9O1xuXHRcdGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhbHVlcykpIHtcblx0XHRcdGlmICh2YWx1ZXNba2V5XSA9PT0gT2JqZWN0KHZhbHVlc1trZXldKSkge1xuXHRcdFx0XHRzdWJqZWN0c1trZXldID0gdGhpcy5nZXRNdWx0aXBsZShgJHtwYXJ0aWFsUGF0aH0uJHtrZXl9YCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdWJqZWN0c1trZXldID0gdGhpcy5nZXRTdWJqZWN0KGAke3BhcnRpYWxQYXRofS4ke2tleX1gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHN1YmplY3RzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgYE92ZXJyaWRhYmxlYCB0aGF0IGNhbiBiZSB1c2VkIHRvIG9wdGlvbmFsbHkgb3ZlcnJpZGUgdGhlIHZhbHVlIHByb3ZpZGVkIGJ5IGBJMThuYFxuXHQgKiBAcGFyYW0gcGF0aCBsb29rcyBsaWtlIGBcIk5PVElGSUNBVElPTi5DTE9TRV9CVVRUT05cImBcblx0ICovXG5cdHB1YmxpYyBnZXRPdmVycmlkYWJsZShwYXRoOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gbmV3IE92ZXJyaWRhYmxlKHBhdGgsIHRoaXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRha2VzIHRoZSBgT2JzZXJ2YWJsZWAgcmV0dXJuZWQgZnJvbSBgaTE4bi5nZXRgIGFuZCBhbiBvYmplY3Qgb2YgdmFyaWFibGVzIHRvIHJlcGxhY2UuXG5cdCAqXG5cdCAqIFRoZSBrZXlzIHNwZWNpZnkgdGhlIHZhcmlhYmxlIG5hbWUgaW4gdGhlIHN0cmluZy5cblx0ICpcblx0ICogRXhhbXBsZTpcblx0ICogYGBgXG5cdCAqIHNlcnZpY2Uuc2V0KHsgXCJURVNUXCI6IFwie3tmb299fSB7e2Jhcn19XCIgfSk7XG5cdCAqXG5cdCAqIHNlcnZpY2UucmVwbGFjZShzZXJ2aWNlLmdldChcIlRFU1RcIiksIHsgZm9vOiBcInRlc3RcIiwgYmFyOiBcImFzZGZcIiB9KVxuXHQgKiBgYGBcblx0ICpcblx0ICogUHJvZHVjZXM6IGBcInRlc3QgYXNkZlwiYFxuXHQgKlxuXHQgKiBAcGFyYW0gc3ViamVjdCB0aGUgdHJhbnNsYXRpb24gdG8gcmVwbGFjZSB2YXJpYWJsZXMgb25cblx0ICogQHBhcmFtIHZhcmlhYmxlcyBvYmplY3Qgb2YgdmFyaWFibGVzIHRvIHJlcGxhY2Vcblx0ICovXG5cdHB1YmxpYyByZXBsYWNlKHN1YmplY3Q6IE9ic2VydmFibGU8c3RyaW5nPiwgdmFyaWFibGVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9KSB7XG5cdFx0cmV0dXJuIHJlcGxhY2Uoc3ViamVjdCwgdmFyaWFibGVzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUcnlzIHRvIHJlc29sdmUgYSB2YWx1ZSBmcm9tIHRoZSBwcm92aWRlZCBwYXRoLlxuXHQgKlxuXHQgKiBAcGFyYW0gcGF0aCBsb29rcyBsaWtlIGBcIk5PVElGSUNBVElPTi5DTE9TRV9CVVRUT05cImBcblx0ICovXG5cdHB1YmxpYyBnZXRWYWx1ZUZyb21QYXRoKHBhdGgpOiBzdHJpbmcgfCB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9IHtcblx0XHRsZXQgdmFsdWUgPSB0aGlzLnRyYW5zbGF0aW9uU3RyaW5ncztcblx0XHRmb3IgKGNvbnN0IHNlZ21lbnQgb2YgcGF0aC5zcGxpdChcIi5cIikpIHtcblx0XHRcdGlmICh2YWx1ZVtzZWdtZW50XSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlW3NlZ21lbnRdICE9PSBudWxsKSB7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWVbc2VnbWVudF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYG5vIGtleSAke3NlZ21lbnR9IGF0ICR7cGF0aH1gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlIGFzIGFueTtcblx0fVxuXG5cdC8qKlxuXHQgKiBIZWxwZXIgbWV0aG9kIHRoYXQgcmV0dXJucyBhbiBvYnNlcnZhYmxlIGZyb20gdGhlIGludGVybmFsIGNhY2hlIGJhc2VkIG9uIHRoZSBwYXRoXG5cdCAqXG5cdCAqIEBwYXJhbSBwYXRoIGxvb2tzIGxpa2UgYFwiTk9USUZJQ0FUSU9OLkNMT1NFX0JVVFRPTlwiYFxuXHQgKi9cblx0cHJvdGVjdGVkIGdldFN1YmplY3QocGF0aDogc3RyaW5nKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gd2UgcnVuIHRoaXMgaGVyZSB0byB2YWxpZGF0ZSB0aGUgcGF0aCBleGlzdHMgYmVmb3JlIGFkZGluZyBpdCB0byB0aGUgdHJhbnNsYXRpb24gbWFwXG5cdFx0XHRjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWVGcm9tUGF0aChwYXRoKSBhcyBzdHJpbmc7XG5cdFx0XHRpZiAodGhpcy50cmFuc2xhdGlvbnMuaGFzKHBhdGgpKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnRyYW5zbGF0aW9ucy5nZXQocGF0aCk7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCB0cmFuc2xhdGlvbiA9IG5ldyBCZWhhdmlvclN1YmplY3QodmFsdWUpO1xuXHRcdFx0dGhpcy50cmFuc2xhdGlvbnMuc2V0KHBhdGgsIHRyYW5zbGF0aW9uKTtcblx0XHRcdHJldHVybiB0cmFuc2xhdGlvbjtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcihlcnJvcik7XG5cdFx0fVxuXHR9XG59XG4iXX0=