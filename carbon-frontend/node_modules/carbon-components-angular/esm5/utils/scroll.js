/**
 *
 * carbon-angular v0.0.0 | scroll.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import * as tslib_1 from "tslib";
import { map } from "rxjs/operators";
import { fromEvent, merge } from "rxjs";
/**
 * Checks if a given element is scrollable.
 * If the element has an overflow set as part of its computed style it can scroll.
 * @param element the element to check scrollability
 */
export var isScrollableElement = function (element) {
    var computedStyle = getComputedStyle(element);
    return (computedStyle.overflow === "auto" ||
        computedStyle.overflow === "scroll" ||
        computedStyle["overflow-y"] === "auto" ||
        computedStyle["overflow-y"] === "scroll" ||
        computedStyle["overflow-x"] === "auto" ||
        computedStyle["overflow-x"] === "scroll");
};
/**
 * Checks if an element is visible within a container
 * @param element the element to check
 * @param container the container to check
 */
export var isVisibleInContainer = function (element, container) {
    var elementRect = element.getBoundingClientRect();
    var containerRect = container.getBoundingClientRect();
    // If there exists `height: 100%` on the `html` or `body` tag of an application,
    // it causes the calculation to return true if you need to scroll before the element is seen.
    // In that case we calculate its visibility based on the window viewport.
    if (container.tagName === "BODY" || container.tagName === "HTML") {
        // This checks if element is within the top, bottom, left and right of viewport, ie. if the element is visible in
        // the screen. This also takes into account partial visibility of an element.
        var isAboveViewport = elementRect.top < 0 && (elementRect.top + element.clientHeight) < 0;
        var isLeftOfViewport = elementRect.left < 0;
        var isBelowViewport = (elementRect.bottom - element.clientHeight) > (window.innerHeight || document.documentElement.clientHeight);
        var isRightOfViewport = elementRect.right > (window.innerWidth || document.documentElement.clientWidth);
        var isVisibleInViewport = !(isAboveViewport || isBelowViewport || isLeftOfViewport || isRightOfViewport);
        return isVisibleInViewport;
    }
    return (
    // This also accounts for partial visibility. It will still return true if the element is partially visible inside the container.
    (elementRect.bottom - element.clientHeight) <= (containerRect.bottom + (container.offsetHeight - container.clientHeight) / 2) &&
        elementRect.top >= (-element.clientHeight));
};
export var getScrollableParents = function (node) {
    var elements = [document.body];
    while (node.parentElement && node !== document.body) {
        if (isScrollableElement(node)) {
            elements.push(node);
        }
        node = node.parentElement;
    }
    return elements;
};
export var hasScrollableParents = function (node) {
    while (node.parentElement && node !== document.body) {
        if (isScrollableElement(node)) {
            return true;
        }
        node = node.parentElement;
    }
    return false;
};
/**
 * Returns an observable that emits whenever any scrollable parent element scrolls
 *
 * @param node root element to start finding scrolling parents from
 */
export var scrollableParentsObservable = function (node) {
    var windowScroll = fromEvent(window, "scroll", { passive: true }).pipe(map(function (event) { return (
    // update the event target to be something useful. In this case `body` is a sensible replacement
    Object.assign({}, event, { target: document.body })); }));
    var observables = [windowScroll];
    // walk the parents and subscribe to all the scroll events we can
    while (node.parentElement && node !== document.body) {
        if (isScrollableElement(node)) {
            observables.push(fromEvent(node, "scroll", { passive: true }));
        }
        node = node.parentElement;
    }
    return merge.apply(void 0, tslib_1.__spread(observables));
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Nyb2xsLmpzIiwic291cmNlUm9vdCI6Im5nOi8vY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci91dGlscy8iLCJzb3VyY2VzIjpbInNjcm9sbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBR3BEOzs7O0dBSUc7QUFDSCxNQUFNLENBQUMsSUFBTSxtQkFBbUIsR0FBRyxVQUFDLE9BQW9CO0lBQ3ZELElBQU0sYUFBYSxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ2hELE9BQU8sQ0FDTixhQUFhLENBQUMsUUFBUSxLQUFLLE1BQU07UUFDakMsYUFBYSxDQUFDLFFBQVEsS0FBSyxRQUFRO1FBQ25DLGFBQWEsQ0FBQyxZQUFZLENBQUMsS0FBSyxNQUFNO1FBQ3RDLGFBQWEsQ0FBQyxZQUFZLENBQUMsS0FBSyxRQUFRO1FBQ3hDLGFBQWEsQ0FBQyxZQUFZLENBQUMsS0FBSyxNQUFNO1FBQ3RDLGFBQWEsQ0FBQyxZQUFZLENBQUMsS0FBSyxRQUFRLENBQ3hDLENBQUM7QUFDSCxDQUFDLENBQUM7QUFFRjs7OztHQUlHO0FBQ0gsTUFBTSxDQUFDLElBQU0sb0JBQW9CLEdBQUcsVUFBQyxPQUFvQixFQUFFLFNBQXNCO0lBQ2hGLElBQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO0lBQ3BELElBQU0sYUFBYSxHQUFHLFNBQVMsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO0lBQ3hELGdGQUFnRjtJQUNoRiw2RkFBNkY7SUFDN0YseUVBQXlFO0lBQ3pFLElBQUksU0FBUyxDQUFDLE9BQU8sS0FBSyxNQUFNLElBQUksU0FBUyxDQUFDLE9BQU8sS0FBSyxNQUFNLEVBQUU7UUFDakUsaUhBQWlIO1FBQ2pILDZFQUE2RTtRQUM3RSxJQUFNLGVBQWUsR0FBRyxXQUFXLENB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UUFBUSxFQUFFLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztTQUMvRDtRQUNELElBQUksR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO0tBQzFCO0lBRUQsT0FBTyxLQUFLLGdDQUFJLFdBQVcsR0FBRTtBQUM5QixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtYXAgfSBmcm9tIFwicnhqcy9vcGVyYXRvcnNcIjtcbmltcG9ydCB7IGZyb21FdmVudCwgbWVyZ2UsIE9ic2VydmFibGUgfSBmcm9tIFwicnhqc1wiO1xuXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gZWxlbWVudCBpcyBzY3JvbGxhYmxlLlxuICogSWYgdGhlIGVsZW1lbnQgaGFzIGFuIG92ZXJmbG93IHNldCBhcyBwYXJ0IG9mIGl0cyBjb21wdXRlZCBzdHlsZSBpdCBjYW4gc2Nyb2xsLlxuICogQHBhcmFtIGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gY2hlY2sgc2Nyb2xsYWJpbGl0eVxuICovXG5leHBvcnQgY29uc3QgaXNTY3JvbGxhYmxlRWxlbWVudCA9IChlbGVtZW50OiBIVE1MRWxlbWVudCkgPT4ge1xuXHRjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblx0cmV0dXJuIChcblx0XHRjb21wdXRlZFN0eWxlLm92ZXJmbG93ID09PSBcImF1dG9cIiB8fFxuXHRcdGNvbXB1dGVkU3R5bGUub3ZlcmZsb3cgPT09IFwic2Nyb2xsXCIgfHxcblx0XHRjb21wdXRlZFN0eWxlW1wib3ZlcmZsb3cteVwiXSA9PT0gXCJhdXRvXCIgfHxcblx0XHRjb21wdXRlZFN0eWxlW1wib3ZlcmZsb3cteVwiXSA9PT0gXCJzY3JvbGxcIiB8fFxuXHRcdGNvbXB1dGVkU3R5bGVbXCJvdmVyZmxvdy14XCJdID09PSBcImF1dG9cIiB8fFxuXHRcdGNvbXB1dGVkU3R5bGVbXCJvdmVyZmxvdy14XCJdID09PSBcInNjcm9sbFwiXG5cdCk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBlbGVtZW50IGlzIHZpc2libGUgd2l0aGluIGEgY29udGFpbmVyXG4gKiBAcGFyYW0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBjaGVja1xuICogQHBhcmFtIGNvbnRhaW5lciB0aGUgY29udGFpbmVyIHRvIGNoZWNrXG4gKi9cbmV4cG9ydCBjb25zdCBpc1Zpc2libGVJbkNvbnRhaW5lciA9IChlbGVtZW50OiBIVE1MRWxlbWVudCwgY29udGFpbmVyOiBIVE1MRWxlbWVudCkgPT4ge1xuXHRjb25zdCBlbGVtZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdGNvbnN0IGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdC8vIElmIHRoZXJlIGV4aXN0cyBgaGVpZ2h0OiAxMDAlYCBvbiB0aGUgYGh0bWxgIG9yIGBib2R5YCB0YWcgb2YgYW4gYXBwbGljYXRpb24sXG5cdC8vIGl0IGNhdXNlcyB0aGUgY2FsY3VsYXRpb24gdG8gcmV0dXJuIHRydWUgaWYgeW91IG5lZWQgdG8gc2Nyb2xsIGJlZm9yZSB0aGUgZWxlbWVudCBpcyBzZWVuLlxuXHQvLyBJbiB0aGF0IGNhc2Ugd2UgY2FsY3VsYXRlIGl0cyB2aXNpYmlsaXR5IGJhc2VkIG9uIHRoZSB3aW5kb3cgdmlld3BvcnQuXG5cdGlmIChjb250YWluZXIudGFnTmFtZSA9PT0gXCJCT0RZXCIgfHwgY29udGFpbmVyLnRhZ05hbWUgPT09IFwiSFRNTFwiKSB7XG5cdFx0Ly8gVGhpcyBjaGVja3MgaWYgZWxlbWVudCBpcyB3aXRoaW4gdGhlIHRvcCwgYm90dG9tLCBsZWZ0IGFuZCByaWdodCBvZiB2aWV3cG9ydCwgaWUuIGlmIHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW5cblx0XHQvLyB0aGUgc2NyZWVuLiBUaGlzIGFsc28gdGFrZXMgaW50byBhY2NvdW50IHBhcnRpYWwgdmlzaWJpbGl0eSBvZiBhbiBlbGVtZW50LlxuXHRcdGNvbnN0IGlzQWJvdmVWaWV3cG9ydCA9IGVsZW1lbnRSZWN0LnRvcCA8IDAgJiYgKGVsZW1lbnRSZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50SGVpZ2h0KSA8IDA7XG5cdFx0Y29uc3QgaXNMZWZ0T2ZWaWV3cG9ydCA9IGVsZW1lbnRSZWN0LmxlZnQgPCAwO1xuXHRcdGNvbnN0IGlzQmVsb3dWaWV3cG9ydCA9XG5cdFx0XHQoZWxlbWVudFJlY3QuYm90dG9tIC0gZWxlbWVudC5jbGllbnRIZWlnaHQpID4gKHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KTtcblx0XHRjb25zdCBpc1JpZ2h0T2ZWaWV3cG9ydCA9IGVsZW1lbnRSZWN0LnJpZ2h0ID4gKHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCk7XG5cblx0XHRjb25zdCBpc1Zpc2libGVJblZpZXdwb3J0ID0gIShpc0Fib3ZlVmlld3BvcnQgfHwgaXNCZWxvd1ZpZXdwb3J0IHx8IGlzTGVmdE9mVmlld3BvcnQgfHwgaXNSaWdodE9mVmlld3BvcnQpO1xuXG5cdFx0cmV0dXJuIGlzVmlzaWJsZUluVmlld3BvcnQ7XG5cdH1cblx0cmV0dXJuIChcblx0XHQvLyBUaGlzIGFsc28gYWNjb3VudHMgZm9yIHBhcnRpYWwgdmlzaWJpbGl0eS4gSXQgd2lsbCBzdGlsbCByZXR1cm4gdHJ1ZSBpZiB0aGUgZWxlbWVudCBpcyBwYXJ0aWFsbHkgdmlzaWJsZSBpbnNpZGUgdGhlIGNvbnRhaW5lci5cblx0XHQoZWxlbWVudFJlY3QuYm90dG9tIC0gZWxlbWVudC5jbGllbnRIZWlnaHQpIDw9IChjb250YWluZXJSZWN0LmJvdHRvbSArIChjb250YWluZXIub2Zmc2V0SGVpZ2h0IC0gY29udGFpbmVyLmNsaWVudEhlaWdodCkgLyAyKSAmJlxuXHRcdGVsZW1lbnRSZWN0LnRvcCA+PSAoLSBlbGVtZW50LmNsaWVudEhlaWdodClcblx0KTtcbn07XG5cblxuZXhwb3J0IGNvbnN0IGdldFNjcm9sbGFibGVQYXJlbnRzID0gKG5vZGU6IEhUTUxFbGVtZW50KSA9PiB7XG5cdGNvbnN0IGVsZW1lbnRzID0gW2RvY3VtZW50LmJvZHldO1xuXHR3aGlsZSAobm9kZS5wYXJlbnRFbGVtZW50ICYmIG5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHtcblx0XHRpZiAoaXNTY3JvbGxhYmxlRWxlbWVudChub2RlKSkge1xuXHRcdFx0ZWxlbWVudHMucHVzaChub2RlKTtcblx0XHR9XG5cdFx0bm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcblx0fVxuXHRyZXR1cm4gZWxlbWVudHM7XG59O1xuXG5leHBvcnQgY29uc3QgaGFzU2Nyb2xsYWJsZVBhcmVudHMgPSAobm9kZTogSFRNTEVsZW1lbnQpID0+IHtcblx0d2hpbGUgKG5vZGUucGFyZW50RWxlbWVudCAmJiBub2RlICE9PSBkb2N1bWVudC5ib2R5KSB7XG5cdFx0aWYgKGlzU2Nyb2xsYWJsZUVsZW1lbnQobm9kZSkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRub2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2hlbmV2ZXIgYW55IHNjcm9sbGFibGUgcGFyZW50IGVsZW1lbnQgc2Nyb2xsc1xuICpcbiAqIEBwYXJhbSBub2RlIHJvb3QgZWxlbWVudCB0byBzdGFydCBmaW5kaW5nIHNjcm9sbGluZyBwYXJlbnRzIGZyb21cbiAqL1xuZXhwb3J0IGNvbnN0IHNjcm9sbGFibGVQYXJlbnRzT2JzZXJ2YWJsZSA9IChub2RlOiBIVE1MRWxlbWVudCk6IE9ic2VydmFibGU8RXZlbnQ+ID0+IHtcblx0Y29uc3Qgd2luZG93U2Nyb2xsID0gZnJvbUV2ZW50KHdpbmRvdywgXCJzY3JvbGxcIiwgeyBwYXNzaXZlOiB0cnVlIH0pLnBpcGUobWFwKGV2ZW50ID0+IChcblx0XHQvLyB1cGRhdGUgdGhlIGV2ZW50IHRhcmdldCB0byBiZSBzb21ldGhpbmcgdXNlZnVsLiBJbiB0aGlzIGNhc2UgYGJvZHlgIGlzIGEgc2Vuc2libGUgcmVwbGFjZW1lbnRcblx0XHRPYmplY3QuYXNzaWduKHt9LCBldmVudCwgeyB0YXJnZXQ6IGRvY3VtZW50LmJvZHkgfSkgYXMgRXZlbnRcblx0KSkpO1xuXHRsZXQgb2JzZXJ2YWJsZXMgPSBbd2luZG93U2Nyb2xsXTtcblx0Ly8gd2FsayB0aGUgcGFyZW50cyBhbmQgc3Vic2NyaWJlIHRvIGFsbCB0aGUgc2Nyb2xsIGV2ZW50cyB3ZSBjYW5cblx0d2hpbGUgKG5vZGUucGFyZW50RWxlbWVudCAmJiBub2RlICE9PSBkb2N1bWVudC5ib2R5KSB7XG5cdFx0aWYgKGlzU2Nyb2xsYWJsZUVsZW1lbnQobm9kZSkpIHtcblx0XHRcdG9ic2VydmFibGVzLnB1c2goZnJvbUV2ZW50KG5vZGUsIFwic2Nyb2xsXCIsIHsgcGFzc2l2ZTogdHJ1ZSB9KSk7XG5cdFx0fVxuXHRcdG5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG5cdH1cblxuXHRyZXR1cm4gbWVyZ2UoLi4ub2JzZXJ2YWJsZXMpO1xufTtcbiJdfQ==