/**
 *
 * carbon-angular v0.0.0 | icon.service.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import * as tslib_1 from "tslib";
import { Injectable } from "@angular/core";
import { toString } from "@carbon/icon-helpers";
/**
 * Abstract class that represent a cache of icons.
 *
 * The actual caching mechanism will be implementation specific,
 * but it's likely a good idea to key by the icons name and/or size.
 * Icon name and size will always be strings, and they will be the two consistent
 * identifiers of an icon. For the purposes of storage additonal descriptor properties may
 * be used, but the name and size are the only ones guarenteed to be passed for lookup purposes.
 */
var IconCache = /** @class */ (function () {
    function IconCache() {
    }
    return IconCache;
}());
export { IconCache };
/**
 * Custom error for when a name can't be found
 */
var IconNameNotFoundError = /** @class */ (function (_super) {
    tslib_1.__extends(IconNameNotFoundError, _super);
    function IconNameNotFoundError(name) {
        return _super.call(this, "Icon " + name + " not found") || this;
    }
    return IconNameNotFoundError;
}(Error));
export { IconNameNotFoundError };
/**
 * Custom error for when a specific size can't be found
 */
var IconSizeNotFoundError = /** @class */ (function (_super) {
    tslib_1.__extends(IconSizeNotFoundError, _super);
    function IconSizeNotFoundError(size, name) {
        return _super.call(this, "Size ${size} for ${name} not found") || this;
    }
    return IconSizeNotFoundError;
}(Error));
export { IconSizeNotFoundError };
/**
 * Concrete implementation of `IconCache` as a simple in memory cache
 */
var IconMemoryCache = /** @class */ (function (_super) {
    tslib_1.__extends(IconMemoryCache, _super);
    function IconMemoryCache() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.iconMap = new Map();
        return _this;
    }
    IconMemoryCache.prototype.get = function (name, size) {
        if (!this.iconMap.has(name)) {
            throw new IconNameNotFoundError(name);
        }
        var sizeMap = this.iconMap.get(name);
        if (!sizeMap.has(size)) {
            throw new IconSizeNotFoundError(size, name);
        }
        return sizeMap.get(size);
    };
    IconMemoryCache.prototype.set = function (name, size, descriptor) {
        if (!this.iconMap.has(name)) {
            this.iconMap.set(name, new Map());
        }
        var sizeMap = this.iconMap.get(name);
        sizeMap.set(size, descriptor);
    };
    return IconMemoryCache;
}(IconCache));
export { IconMemoryCache };
/**
 * The icon service is a singleton service responsible for registering and retriving icons from `@carbon/icons`.
 *
 * It's important to register icons before use. It's reccommended to register your icons early, likely in your app.component.
 *
 * To allow for improved tree shaking _do not_ import all the icons from `@carbon/icons` and register them.
 * Instead register only the icons in use by your application. If your application makes use of lazy loaded
 * modules you may also lazy load the icons used in that module by registering them early on in that module.
 *
 * `ngOnInit` should be sufficiantly early to register icons.
 *
 * Example:
 * ```
 * import { Accessibility16 } from "@carbon/icons";
 *
 * // ...
 *
 * class MyComponent implements OnInit {
 * 	constructor(protected iconService: IconService) {}
 *
 * 	// ...
 *
 * 	ngOnInit() {
 * 		this.iconService.register(Accessibility16);
 * 	}
 *
 * 	// ...
 * }
 * ```
 *
 * If needed it is possible to register an icon under a different name, via `registerAs`.
 */
var IconService = /** @class */ (function () {
    function IconService() {
        this.iconCache = new IconMemoryCache();
    }
    /**
     * Registers an array of icons based on the metadata provided by `@carbon/cions`
     */
    IconService.prototype.registerAll = function (descriptors) {
        var _this = this;
        descriptors.forEach(function (icon) { return _this.register(icon); });
    };
    /**
     * Registers an icon based on the metadata provided by `@carbon/icons`
     */
    IconService.prototype.register = function (descriptor) {
        var name = descriptor.name;
        this.registerAs(name, descriptor);
    };
    /**
     * Registers an icon based on a uniqe name and metadata provided by `@carbon/icons`
     */
    IconService.prototype.registerAs = function (name, descriptor) {
        var size = descriptor.size;
        this.iconCache.set(name, size.toString(), descriptor);
    };
    /**
     * Gets an icon, converts it to a string, and caches the result
     */
    IconService.prototype.get = function (name, size) {
        try {
            var icon = this.iconCache.get(name, size.toString());
            if (!icon.svg) {
                icon.svg = toString(icon);
            }
            return icon;
        }
        catch (e) {
            throw e;
        }
    };
    /**
     * Configure various service settings (caching strategy ...)
     */
    IconService.prototype.configure = function (options) {
        this.iconCache = options.cache;
    };
    IconService.decorators = [
        { type: Injectable }
    ];
    return IconService;
}());
export { IconService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWNvbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9pY29uLyIsInNvdXJjZXMiOlsiaWNvbi5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQTZFaEQ7Ozs7Ozs7O0dBUUc7QUFDSDtJQUFBO0lBU0EsQ0FBQztJQUFELGdCQUFDO0FBQUQsQ0FBQyxBQVRELElBU0M7O0FBRUQ7O0dBRUc7QUFDSDtJQUEyQyxpREFBSztJQUMvQywrQkFBWSxJQUFZO2VBQ3ZCLGtCQUFNLFVBQVEsSUFBSSxlQUFZLENBQUM7SUFDaEMsQ0FBQztJQUNGLDRCQUFDO0FBQUQsQ0FBQyxBQUpELENBQTJDLEtBQUssR0FJL0M7O0FBRUQ7O0dBRUc7QUFDSDtJQUEyQyxpREFBSztJQUMvQywrQkFBWSxJQUFZLEVBQUUsSUFBWTtlQUNyQyxrQkFBTSxvQ0FBb0MsQ0FBQztJQUM1QyxDQUFDO0lBQ0YsNEJBQUM7QUFBRCxDQUFDLEFBSkQsQ0FBMkMsS0FBSyxHQUkvQzs7QUFFRDs7R0FFRztBQUNIO0lBQXFDLDJDQUFTO0lBQTlDO1FBQUEscUVBcUJDO1FBcEJRLGFBQU8sR0FBRyxJQUFJLEdBQUcsRUFBK0IsQ0FBQzs7SUFvQjFELENBQUM7SUFsQkEsNkJBQUcsR0FBSCxVQUFJLElBQVksRUFBRSxJQUFZO1FBQzdCLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUM1QixNQUFNLElBQUkscUJBQXFCLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDdEM7UUFDRCxJQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN2QyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUN2QixNQUFNLElBQUkscUJBQXFCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQzVDO1FBQ0QsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFRCw2QkFBRyxHQUFILFVBQUksSUFBWSxFQUFFLElBQVksRUFBRSxVQUFrQjtRQUNqRCxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDNUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLElBQUksR0FBRyxFQUFFLENBQUMsQ0FBQztTQUNsQztRQUNELElBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFDRixzQkFBQztBQUFELENBQUMsQUFyQkQsQ0FBcUMsU0FBUyxHQXFCN0M7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0ErQkc7QUFDSDtJQUFBO1FBRVMsY0FBUyxHQUFjLElBQUksZUFBZSxFQUFFLENBQUM7SUE4Q3RELENBQUM7SUE1Q0E7O09BRUc7SUFDSSxpQ0FBVyxHQUFsQixVQUFtQixXQUFxQjtRQUF4QyxpQkFFQztRQURBLFdBQVcsQ0FBQyxPQUFPLENBQUMsVUFBQSxJQUFJLElBQUksT0FBQSxLQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFuQixDQUFtQixDQUFDLENBQUM7SUFDbEQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksOEJBQVEsR0FBZixVQUFnQixVQUFrQjtRQUN6QixJQUFBLHNCQUFJLENBQWtDO1FBQzlDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFRDs7T0FFRztJQUNJLGdDQUFVLEdBQWpCLFVBQWtCLElBQVksRUFBRSxVQUFrQjtRQUN6QyxJQUFBLHNCQUFJLENBQWtDO1FBQzlDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVEOztPQUVHO0lBQ0kseUJBQUcsR0FBVixVQUFXLElBQVksRUFBRSxJQUFZO1FBQ3BDLElBQUk7WUFDSCxJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFtQixDQUFDO1lBQ3pFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFO2dCQUNkLElBQUksQ0FBQyxHQUFHLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQzFCO1lBQ0QsT0FBTyxJQUFJLENBQUM7U0FDWjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1gsTUFBTSxDQUFDLENBQUM7U0FDUjtJQUNGLENBQUM7SUFFRDs7T0FFRztJQUNJLCtCQUFTLEdBQWhCLFVBQWlCLE9BQTZCO1FBQzdDLElBQUksQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztJQUNoQyxDQUFDOztnQkEvQ0QsVUFBVTs7SUFnRFgsa0JBQUM7Q0FBQSxBQWhERCxJQWdEQztTQS9DWSxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyB0b1N0cmluZyB9IGZyb20gXCJAY2FyYm9uL2ljb24taGVscGVyc1wiO1xuXG4vLyBpY29uIGltcG9ydHNcbmltcG9ydCB7XG5cdEFkZDE2LFxuXHRDYWxlbmRhcjE2LFxuXHRDYXJldERvd24xNixcblx0Q2FyZXRMZWZ0MTYsXG5cdENhcmV0UmlnaHQxNixcblx0Q2FyZXRVcDE2LFxuXHRDaGVja21hcmsxNixcblx0Q2hlY2ttYXJrRmlsbGVkMTYsXG5cdENoZWNrbWFya091dGxpbmUxNixcblx0Q2hldnJvbkRvd24xNixcblx0Q2hldnJvblJpZ2h0MTYsXG5cdENsb3NlMTYsXG5cdENvcHkxNixcblx0RGVsZXRlMTYsXG5cdERvd25sb2FkMTYsXG5cdEVycm9yRmlsbGVkMTYsXG5cdEluZm9ybWF0aW9uRmlsbGVkMTYsXG5cdE1lbnUxNixcblx0T3ZlcmZsb3dNZW51VmVydGljYWwxNixcblx0U2F2ZTE2LFxuXHRTZXR0aW5nczE2LFxuXHRXYXJuaW5nMTYsXG5cdFdhcm5pbmdGaWxsZWQxNlxufSBmcm9tIFwiQGNhcmJvbi9pY29uc1wiO1xuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSBwYXJzZWQgaWNvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEljb25EZXNjcmlwdG9yIHtcblx0LyoqXG5cdCAqIFRoZSBlbGVtZW50IHRvIHJlbmRlci4gRm9yIHRoZSByb290IHRoaXMgaXMgYHN2Z2Bcblx0ICovXG5cdGVsZW06IHN0cmluZztcblx0LyoqXG5cdCAqIEFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBlbGVtZW50LlxuXHQgKlxuXHQgKiBUaGUgdHlwZSBoZXJlIGlzIG5vbi1leGhhdXN0aXZlLlxuXHQgKi9cblx0YXR0cnM6IHtcblx0XHR4bWxuczogc3RyaW5nLFxuXHRcdC8vIG5lZWRlZCBieSB0aGUgaWNvbiBkaXJlY3RpdmUgdG8gZGV0ZXJtaW5lIG90aGVyIGF0dHJpYnV0ZXNcblx0XHR2aWV3Qm94OiBzdHJpbmcsXG5cdFx0ZmlsbDogc3RyaW5nLFxuXHRcdC8vIG5lZWRlZCBieSB0aGUgaWNvbiBkaXJlY3RpdmUgdG8gZGV0ZXJtaW5lIG90aGVyIGF0dHJpYnV0ZXNcblx0XHR3aWR0aDogc3RyaW5nLFxuXHRcdC8vIG5lZWRlZCBieSB0aGUgaWNvbiBkaXJlY3RpdmUgdG8gZGV0ZXJtaW5lIG90aGVyIGF0dHJpYnV0ZXNcblx0XHRoZWlnaHQ6IHN0cmluZyxcblx0XHRbeDogc3RyaW5nXTogc3RyaW5nXG5cdH07XG5cdC8qKlxuXHQgKiBUaGUgY29udGVudCAoY2hpbGRyZW4pIG9mIHRoZSBlbGVtZW50IGFzIGFuIGFycmF5IG9mIGBJY29uRGVzY3JpcHRvcmBzXG5cdCAqICh1c3VhbGx5IHdpdGhvdXQgYSBmZXcgZmllbGRzLCBuYW1lbHkgYG5hbWVgIGFuZCBgc2l6ZWApXG5cdCAqL1xuXHRjb250ZW50OiBJY29uRGVzY3JpcHRvcltdO1xuXHQvKipcblx0ICogVGhlIG5hbWUgb2YgdGhlIGljb24uXG5cdCAqXG5cdCAqIE5lZWRlZCBieSB0aGUgaWNvbiBzZXJ2aWNlLlxuXHQgKi9cblx0bmFtZTogc3RyaW5nO1xuXHQvKipcblx0ICogVGhlIHNpemUgb2YgdGhlIGljb24gaW4gcGl4ZWxzLlxuXHQgKlxuXHQgKiBOZWVkZWQgYnkgdGhlIGljb24gc2VydmljZS5cblx0ICovXG5cdHNpemU6IG51bWJlcjtcblx0LyoqXG5cdCAqIE9wdGlvbmFsLiBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29tcGlsZWQgc3ZnLlxuXHQgKiBJZiBtaXNzaW5nIHRoZSBpY29uIHNlcnZpY2Ugd2lsbCBhZGQgdGhpcy5cblx0ICovXG5cdHN2Zz86IHN0cmluZztcbn1cblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyB0aGF0IHJlcHJlc2VudCBhIGNhY2hlIG9mIGljb25zLlxuICpcbiAqIFRoZSBhY3R1YWwgY2FjaGluZyBtZWNoYW5pc20gd2lsbCBiZSBpbXBsZW1lbnRhdGlvbiBzcGVjaWZpYyxcbiAqIGJ1dCBpdCdzIGxpa2VseSBhIGdvb2QgaWRlYSB0byBrZXkgYnkgdGhlIGljb25zIG5hbWUgYW5kL29yIHNpemUuXG4gKiBJY29uIG5hbWUgYW5kIHNpemUgd2lsbCBhbHdheXMgYmUgc3RyaW5ncywgYW5kIHRoZXkgd2lsbCBiZSB0aGUgdHdvIGNvbnNpc3RlbnRcbiAqIGlkZW50aWZpZXJzIG9mIGFuIGljb24uIEZvciB0aGUgcHVycG9zZXMgb2Ygc3RvcmFnZSBhZGRpdG9uYWwgZGVzY3JpcHRvciBwcm9wZXJ0aWVzIG1heVxuICogYmUgdXNlZCwgYnV0IHRoZSBuYW1lIGFuZCBzaXplIGFyZSB0aGUgb25seSBvbmVzIGd1YXJlbnRlZWQgdG8gYmUgcGFzc2VkIGZvciBsb29rdXAgcHVycG9zZXMuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJY29uQ2FjaGUge1xuXHQvKipcblx0ICogRmluZHMgYW5kIHJldHVybnMgYW4gaWNvbiBiYXNlZCBvbiBpdCdzIG5hbWUgYW5kIHNpemVcblx0ICovXG5cdGFic3RyYWN0IGdldChuYW1lOiBzdHJpbmcsIHNpemU6IHN0cmluZyk6IG9iamVjdDtcblx0LyoqXG5cdCAqIHN0b3JlcyBhbiBpY29uIGRlc2NyaXB0b3IgdG8gdGhlIGNhY2hlXG5cdCAqL1xuXHRhYnN0cmFjdCBzZXQobmFtZTogc3RyaW5nLCBzaXplOiBzdHJpbmcsIGRlc2NyaXB0b3I6IG9iamVjdCk6IHZvaWQ7XG59XG5cbi8qKlxuICogQ3VzdG9tIGVycm9yIGZvciB3aGVuIGEgbmFtZSBjYW4ndCBiZSBmb3VuZFxuICovXG5leHBvcnQgY2xhc3MgSWNvbk5hbWVOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcpIHtcblx0XHRzdXBlcihgSWNvbiAke25hbWV9IG5vdCBmb3VuZGApO1xuXHR9XG59XG5cbi8qKlxuICogQ3VzdG9tIGVycm9yIGZvciB3aGVuIGEgc3BlY2lmaWMgc2l6ZSBjYW4ndCBiZSBmb3VuZFxuICovXG5leHBvcnQgY2xhc3MgSWNvblNpemVOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihzaXplOiBzdHJpbmcsIG5hbWU6IHN0cmluZykge1xuXHRcdHN1cGVyKFwiU2l6ZSAke3NpemV9IGZvciAke25hbWV9IG5vdCBmb3VuZFwiKTtcblx0fVxufVxuXG4vKipcbiAqIENvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIGBJY29uQ2FjaGVgIGFzIGEgc2ltcGxlIGluIG1lbW9yeSBjYWNoZVxuICovXG5leHBvcnQgY2xhc3MgSWNvbk1lbW9yeUNhY2hlIGV4dGVuZHMgSWNvbkNhY2hlIHtcblx0cHJpdmF0ZSBpY29uTWFwID0gbmV3IE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIG9iamVjdD4+KCk7XG5cblx0Z2V0KG5hbWU6IHN0cmluZywgc2l6ZTogc3RyaW5nKSB7XG5cdFx0aWYgKCF0aGlzLmljb25NYXAuaGFzKG5hbWUpKSB7XG5cdFx0XHR0aHJvdyBuZXcgSWNvbk5hbWVOb3RGb3VuZEVycm9yKG5hbWUpO1xuXHRcdH1cblx0XHRjb25zdCBzaXplTWFwID0gdGhpcy5pY29uTWFwLmdldChuYW1lKTtcblx0XHRpZiAoIXNpemVNYXAuaGFzKHNpemUpKSB7XG5cdFx0XHR0aHJvdyBuZXcgSWNvblNpemVOb3RGb3VuZEVycm9yKHNpemUsIG5hbWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gc2l6ZU1hcC5nZXQoc2l6ZSk7XG5cdH1cblxuXHRzZXQobmFtZTogc3RyaW5nLCBzaXplOiBzdHJpbmcsIGRlc2NyaXB0b3I6IG9iamVjdCkge1xuXHRcdGlmICghdGhpcy5pY29uTWFwLmhhcyhuYW1lKSkge1xuXHRcdFx0dGhpcy5pY29uTWFwLnNldChuYW1lLCBuZXcgTWFwKCkpO1xuXHRcdH1cblx0XHRjb25zdCBzaXplTWFwID0gdGhpcy5pY29uTWFwLmdldChuYW1lKTtcblx0XHRzaXplTWFwLnNldChzaXplLCBkZXNjcmlwdG9yKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSBpY29uIHNlcnZpY2UgaXMgYSBzaW5nbGV0b24gc2VydmljZSByZXNwb25zaWJsZSBmb3IgcmVnaXN0ZXJpbmcgYW5kIHJldHJpdmluZyBpY29ucyBmcm9tIGBAY2FyYm9uL2ljb25zYC5cbiAqXG4gKiBJdCdzIGltcG9ydGFudCB0byByZWdpc3RlciBpY29ucyBiZWZvcmUgdXNlLiBJdCdzIHJlY2NvbW1lbmRlZCB0byByZWdpc3RlciB5b3VyIGljb25zIGVhcmx5LCBsaWtlbHkgaW4geW91ciBhcHAuY29tcG9uZW50LlxuICpcbiAqIFRvIGFsbG93IGZvciBpbXByb3ZlZCB0cmVlIHNoYWtpbmcgX2RvIG5vdF8gaW1wb3J0IGFsbCB0aGUgaWNvbnMgZnJvbSBgQGNhcmJvbi9pY29uc2AgYW5kIHJlZ2lzdGVyIHRoZW0uXG4gKiBJbnN0ZWFkIHJlZ2lzdGVyIG9ubHkgdGhlIGljb25zIGluIHVzZSBieSB5b3VyIGFwcGxpY2F0aW9uLiBJZiB5b3VyIGFwcGxpY2F0aW9uIG1ha2VzIHVzZSBvZiBsYXp5IGxvYWRlZFxuICogbW9kdWxlcyB5b3UgbWF5IGFsc28gbGF6eSBsb2FkIHRoZSBpY29ucyB1c2VkIGluIHRoYXQgbW9kdWxlIGJ5IHJlZ2lzdGVyaW5nIHRoZW0gZWFybHkgb24gaW4gdGhhdCBtb2R1bGUuXG4gKlxuICogYG5nT25Jbml0YCBzaG91bGQgYmUgc3VmZmljaWFudGx5IGVhcmx5IHRvIHJlZ2lzdGVyIGljb25zLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBcbiAqIGltcG9ydCB7IEFjY2Vzc2liaWxpdHkxNiB9IGZyb20gXCJAY2FyYm9uL2ljb25zXCI7XG4gKlxuICogLy8gLi4uXG4gKlxuICogY2xhc3MgTXlDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICogXHRjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgaWNvblNlcnZpY2U6IEljb25TZXJ2aWNlKSB7fVxuICpcbiAqIFx0Ly8gLi4uXG4gKlxuICogXHRuZ09uSW5pdCgpIHtcbiAqIFx0XHR0aGlzLmljb25TZXJ2aWNlLnJlZ2lzdGVyKEFjY2Vzc2liaWxpdHkxNik7XG4gKiBcdH1cbiAqXG4gKiBcdC8vIC4uLlxuICogfVxuICogYGBgXG4gKlxuICogSWYgbmVlZGVkIGl0IGlzIHBvc3NpYmxlIHRvIHJlZ2lzdGVyIGFuIGljb24gdW5kZXIgYSBkaWZmZXJlbnQgbmFtZSwgdmlhIGByZWdpc3RlckFzYC5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEljb25TZXJ2aWNlIHtcblx0cHJpdmF0ZSBpY29uQ2FjaGU6IEljb25DYWNoZSA9IG5ldyBJY29uTWVtb3J5Q2FjaGUoKTtcblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGFuIGFycmF5IG9mIGljb25zIGJhc2VkIG9uIHRoZSBtZXRhZGF0YSBwcm92aWRlZCBieSBgQGNhcmJvbi9jaW9uc2Bcblx0ICovXG5cdHB1YmxpYyByZWdpc3RlckFsbChkZXNjcmlwdG9yczogb2JqZWN0W10pIHtcblx0XHRkZXNjcmlwdG9ycy5mb3JFYWNoKGljb24gPT4gdGhpcy5yZWdpc3RlcihpY29uKSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGFuIGljb24gYmFzZWQgb24gdGhlIG1ldGFkYXRhIHByb3ZpZGVkIGJ5IGBAY2FyYm9uL2ljb25zYFxuXHQgKi9cblx0cHVibGljIHJlZ2lzdGVyKGRlc2NyaXB0b3I6IG9iamVjdCkge1xuXHRcdGNvbnN0IHsgbmFtZSB9ID0gZGVzY3JpcHRvciBhcyBJY29uRGVzY3JpcHRvcjtcblx0XHR0aGlzLnJlZ2lzdGVyQXMobmFtZSwgZGVzY3JpcHRvcik7XG5cdH1cblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGFuIGljb24gYmFzZWQgb24gYSB1bmlxZSBuYW1lIGFuZCBtZXRhZGF0YSBwcm92aWRlZCBieSBgQGNhcmJvbi9pY29uc2Bcblx0ICovXG5cdHB1YmxpYyByZWdpc3RlckFzKG5hbWU6IHN0cmluZywgZGVzY3JpcHRvcjogb2JqZWN0KSB7XG5cdFx0Y29uc3QgeyBzaXplIH0gPSBkZXNjcmlwdG9yIGFzIEljb25EZXNjcmlwdG9yO1xuXHRcdHRoaXMuaWNvbkNhY2hlLnNldChuYW1lLCBzaXplLnRvU3RyaW5nKCksIGRlc2NyaXB0b3IpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgYW4gaWNvbiwgY29udmVydHMgaXQgdG8gYSBzdHJpbmcsIGFuZCBjYWNoZXMgdGhlIHJlc3VsdFxuXHQgKi9cblx0cHVibGljIGdldChuYW1lOiBzdHJpbmcsIHNpemU6IHN0cmluZyk6IEljb25EZXNjcmlwdG9yIHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgaWNvbiA9IHRoaXMuaWNvbkNhY2hlLmdldChuYW1lLCBzaXplLnRvU3RyaW5nKCkpIGFzIEljb25EZXNjcmlwdG9yO1xuXHRcdFx0aWYgKCFpY29uLnN2Zykge1xuXHRcdFx0XHRpY29uLnN2ZyA9IHRvU3RyaW5nKGljb24pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGljb247XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0dGhyb3cgZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ29uZmlndXJlIHZhcmlvdXMgc2VydmljZSBzZXR0aW5ncyAoY2FjaGluZyBzdHJhdGVneSAuLi4pXG5cdCAqL1xuXHRwdWJsaWMgY29uZmlndXJlKG9wdGlvbnM6IHsgY2FjaGU6IEljb25DYWNoZSB9KSB7XG5cdFx0dGhpcy5pY29uQ2FjaGUgPSBvcHRpb25zLmNhY2hlO1xuXHR9XG59XG4iXX0=