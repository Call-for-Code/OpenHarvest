/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-modal.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { __extends } from 'tslib';
import { tap, delay } from 'rxjs/operators';
import { cycleTabs, getFocusElementList } from 'carbon-components-angular/common';
import { CommonModule } from '@angular/common';
import { ButtonModule } from 'carbon-components-angular/forms';
import { I18n, I18nModule } from 'carbon-components-angular/i18n';
import { PlaceholderService, PlaceholderModule } from 'carbon-components-angular/placeholder';
import { ExperimentalService, ExperimentalModule } from 'carbon-components-angular/experimental';
import { Output, EventEmitter, Input, Directive, Component, Inject, ViewChild, Optional, ComponentFactoryResolver, Injector, Injectable, HostListener, HostBinding, NgModule } from '@angular/core';
import { IconModule } from 'carbon-components-angular/icon';

/**
 * Extend `BaseModal` in your custom modal implementations to ensure consistent close behavior.
 *
 * `ModalService` depends on the `close` event to correctly clean up the component.
 */
var BaseModal = /** @class */ (function () {
    function BaseModal() {
        /**
         * Base event emitter to propagate close events
         */
        this.close = new EventEmitter();
        /**
         * Controls the open state of the modal
         */
        this.open = false;
    }
    /**
     * Default method to handle closing the modal
     */
    BaseModal.prototype.closeModal = function () {
        this.close.emit();
    };
    BaseModal.decorators = [
        { type: Directive, args: [{ selector: "[ibmBaseModal]" },] }
    ];
    BaseModal.propDecorators = {
        close: [{ type: Output }],
        open: [{ type: Input }]
    };
    return BaseModal;
}());

/**
 * Component to create standard modals for presenting content or asking for user's input.
 * It can show as a passive modal showing only text or show as a transactional modal with
 * multiple buttons for different actions for the user to choose from.
 *
 * Using a modal in your application requires `ibm-placeholder` which would generally be
 * placed near the end of your app component template (app.component.ts or app.component.html) as:
 *
 * ```html
 * <ibm-placeholder></ibm-placeholder>
 * ```
 *
 * Example of opening the modal:
 *
 * ```typescript
 * \@Component({
 *  selector: "app-modal-demo",
 *  template: `
 *   <button class="btn--primary" (click)="openModal()">Open modal</button>
 *   <ibm-placeholder></ibm-placeholder>`
 * })
 * export class ModalDemo {
 * 	openModal() {
 * 		this.modalService.show({
 *			modalType: "default",
 *			label: "optional header text",
 *			title: "Modal title",
 *			text: "Modal text",
 *			buttons: [{
 *				text: "Button text",
 *				type: "primary",
 *				click: clickFunction
 *			}]
 *		});
 * 	}
 * }
 * ```
 */
var AlertModal = /** @class */ (function (_super) {
    __extends(AlertModal, _super);
    /**
     * Creates an instance of `AlertModal`.
     */
    function AlertModal(type, label, title, content, size, hasScrollingContent, buttons, onClose) {
        if (type === void 0) { type = "default"; }
        if (hasScrollingContent === void 0) { hasScrollingContent = null; }
        if (buttons === void 0) { buttons = []; }
        var _this = _super.call(this) || this;
        _this.type = type;
        _this.label = label;
        _this.title = title;
        _this.content = content;
        _this.size = size;
        _this.hasScrollingContent = hasScrollingContent;
        _this.buttons = buttons;
        _this.onClose = onClose;
        for (var i = 0; i < _this.buttons.length; i++) {
            var button = _this.buttons[i];
            if (!button.id) {
                button.id = "alert-modal-button-" + i;
            }
            if (!button.type) {
                button.type = "secondary";
            }
        }
        return _this;
    }
    AlertModal.prototype.ngAfterViewInit = function () {
        if (!this.modalContent) {
            return false;
        }
        var element = this.modalContent.nativeElement;
        if (element.scrollHeight > element.clientHeight) {
            element.tabIndex = 0;
        }
        else {
            element.tabIndex = -1;
        }
    };
    AlertModal.prototype.buttonClicked = function (buttonIndex) {
        var button = this.buttons[buttonIndex];
        if (button.click) {
            button.click();
        }
        this.closeModal();
    };
    AlertModal.prototype.dismissModal = function (trigger) {
        if (this.onClose && this.onClose(trigger) === false) {
            return;
        }
        this.closeModal();
    };
    AlertModal.decorators = [
        { type: Component, args: [{
                    selector: "ibm-alert-modal",
                    template: "\n\t\t<ibm-modal\n\t\t\t[size]=\"size\"\n\t\t\t[theme]=\"type\"\n\t\t\t[ariaLabel]=\"title\"\n\t\t\t[hasScrollingContent]=\"hasScrollingContent\"\n\t\t\t[open]=\"open\"\n\t\t\t(overlaySelected)=\"dismissModal('overlay')\">\n\t\t\t<ibm-modal-header (closeSelect)=\"dismissModal('close')\">\n\t\t\t\t<p ibmModalHeaderLabel class=\"bx--type-delta\">{{label}}</p>\n\t\t\t\t<p ibmModalHeaderHeading class=\"bx--type-beta\">{{title}}</p>\n\t\t\t</ibm-modal-header>\n\t\t\t<div ibmModalContent #modalContent>\n\t\t\t\t<p [innerHTML]=\"content\"></p>\n\t\t\t</div>\n\t\t\t<ibm-modal-footer *ngIf=\"buttons.length > 0\">\n\t\t\t\t<ng-container *ngFor=\"let button of buttons; let i = index\">\n\t\t\t\t\t<button\n\t\t\t\t\t\t[ibmButton]=\"button.type\"\n\t\t\t\t\t\t(click)=\"buttonClicked(i)\"\n\t\t\t\t\t\t[id]=\"button.id\"\n\t\t\t\t\t\t[attr.modal-primary-focus]=\"(button.type.indexOf('primary') !== -1 ? '' : null)\">\n\t\t\t\t\t\t{{button.text}}\n\t\t\t\t\t</button>\n\t\t\t\t</ng-container>\n\t\t\t</ibm-modal-footer>\n\t\t</ibm-modal>\n\t"
                }] }
    ];
    /** @nocollapse */
    AlertModal.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: ["type",] }] },
        { type: String, decorators: [{ type: Optional }, { type: Inject, args: ["label",] }] },
        { type: String, decorators: [{ type: Optional }, { type: Inject, args: ["title",] }] },
        { type: String, decorators: [{ type: Optional }, { type: Inject, args: ["content",] }] },
        { type: String, decorators: [{ type: Optional }, { type: Inject, args: ["size",] }] },
        { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: ["hasScrollingContent",] }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: ["buttons",] }] },
        { type: Function, decorators: [{ type: Optional }, { type: Inject, args: ["close",] }] }
    ]; };
    AlertModal.propDecorators = {
        modalContent: [{ type: ViewChild, args: ["modalContent", { static: true },] }]
    };
    return AlertModal;
}(BaseModal));

var AlertModalType;
(function (AlertModalType) {
    AlertModalType["default"] = "default";
    AlertModalType["danger"] = "danger";
})(AlertModalType || (AlertModalType = {}));
var ModalButtonType;
(function (ModalButtonType) {
    ModalButtonType["primary"] = "primary";
    ModalButtonType["secondary"] = "secondary";
    ModalButtonType["tertiary"] = "tertiary";
    ModalButtonType["ghost"] = "ghost";
    ModalButtonType["danger"] = "danger";
    ModalButtonType["danger_primary"] = "danger--primary";
})(ModalButtonType || (ModalButtonType = {}));

var ModalFooter = /** @class */ (function () {
    function ModalFooter() {
    }
    ModalFooter.decorators = [
        { type: Component, args: [{
                    selector: "ibm-modal-footer",
                    template: "\n\t\t<footer class=\"bx--modal-footer\">\n\t\t\t<ng-content></ng-content>\n\t\t</footer>\n\t"
                }] }
    ];
    return ModalFooter;
}());

/**
 * ***Inputs***
 * ```html
 * <ibm-modal-header>Header text</ibm-modal-header>
 * ```
 *
 * ***Outputs***
 * ```html
 * <ibm-modal-header (closeSelect)="closeModal()">Header text</ibm-modal-header>
 * ```
 */
var ModalHeader = /** @class */ (function () {
    function ModalHeader(i18n, experimental) {
        this.i18n = i18n;
        this.experimental = experimental;
        /**
         * Sets the style on the modal heading based on its category.
         */
        this.theme = "default";
        /**
         * Accessible label for the header close button.
         * Defaults to the `MODAL.CLOSE` value from the i18n service.
         */
        this.closeLabel = this.i18n.get().MODAL.CLOSE;
        /**
         * To emit the event of clicking on the close icon within the modal.
         */
        this.closeSelect = new EventEmitter();
    }
    /**
     * Handles click for the close icon button within the `Modal`.
     */
    ModalHeader.prototype.onClose = function () {
        this.closeSelect.emit();
    };
    ModalHeader.decorators = [
        { type: Component, args: [{
                    selector: "ibm-modal-header",
                    template: "\n\t\t<header class=\"{{theme}} bx--modal-header\">\n\t\t\t<ng-content></ng-content>\n\t\t\t<button\n\t\t\t\ttype=\"button\"\n\t\t\t\tclass=\"bx--modal-close\"\n\t\t\t\t(click)=\"onClose()\">\n\t\t\t\t<span class=\"bx--assistive-text\">{{ closeLabel }}</span>\n\t\t\t\t<svg ibmIcon=\"close\" size=\"20\" class=\"bx--modal-close__icon\"></svg>\n\t\t\t</button>\n\t\t</header>\n\n\t"
                }] }
    ];
    /** @nocollapse */
    ModalHeader.ctorParameters = function () { return [
        { type: I18n },
        { type: ExperimentalService }
    ]; };
    ModalHeader.propDecorators = {
        theme: [{ type: Input }],
        closeLabel: [{ type: Input }],
        closeSelect: [{ type: Output }]
    };
    return ModalHeader;
}());

/**
 * Modal service handles instantiating and destroying modal instances.
 * Uses PlaceholderService to track open instances, and for it's placeholder view reference.
 */
var ModalService = /** @class */ (function () {
    /**
     * Creates an instance of `ModalService`.
     */
    function ModalService(resolver, placeholderService) {
        this.resolver = resolver;
        this.placeholderService = placeholderService;
    }
    /**
     * Creates and renders the modal component that is passed in.
     * `inputs` is an optional parameter of `data` that can be passed to the `Modal` component.
     */
    ModalService.prototype.create = function (data) {
        var _this = this;
        var defaults = { inputs: {} };
        data = Object.assign({}, defaults, data);
        var inputProviders = Object.keys(data.inputs).map(function (inputName) { return ({
            provide: inputName,
            useValue: data.inputs[inputName]
        }); });
        var injector = Injector.create(inputProviders);
        var factory = this.resolver.resolveComponentFactory(data.component);
        var focusedElement = document.activeElement;
        var component = this.placeholderService.createComponent(factory, injector);
        setTimeout(function () {
            component.instance.open = true;
        });
        component["previouslyFocusedElement"] = focusedElement; // used to return focus to previously focused element
        component.instance.close.pipe(
        // trigger the close animation
        tap(function () {
            component.instance.open = false;
        }), 
        // delay closing by an arbitrary amount to allow the animation to finish
        delay(150)).subscribe(function () {
            _this.placeholderService.destroyComponent(component);
            // filter out our component
            ModalService.modalList = ModalService.modalList.filter(function (c) { return c !== component; });
        });
        component.onDestroy(function () {
            focusedElement.focus();
        });
        ModalService.modalList.push(component);
        return component;
    };
    /**
     * Creates and renders a new alert modal component.
     * @param data You can pass in:
     * `type` - "default" | "danger" = "default",
     * `label` - a label shown over the title,
     * `title` - modal's title,
     * `content` - modal's content, could include HTML tags.
     * `buttons` is an array of objects
     * `close` custom close function
     * ```
     * {
     * 		text: "Button text",
     * 		type: "primary" | "secondary" | "tertiary" | "ghost" | "danger" | "danger--primary" = "primary",
     * 		click: clickFunction,
     * }
     * ```
     */
    ModalService.prototype.show = function (data) {
        return this.create({
            component: AlertModal,
            inputs: {
                type: data.type,
                label: data.label,
                title: data.title,
                content: data.content,
                hasScrollingContent: data.hasScrollingContent || null,
                size: data.size,
                buttons: data.buttons || [],
                close: data.close || (function () { })
            }
        });
    };
    /**
     * Destroys the modal on the supplied index.
     * When called without parameters it destroys the most recently created/top most modal.
     */
    ModalService.prototype.destroy = function (index) {
        if (index === void 0) { index = -1; }
        // return if nothing to destroy because it's already destroyed
        if (index >= ModalService.modalList.length || ModalService.modalList.length === 0) {
            return;
        }
        // on negative index destroy the last on the list (top modal)
        if (index < 0) {
            index = ModalService.modalList.length - 1;
        }
        this.placeholderService.destroyComponent(ModalService.modalList[index]);
        ModalService.modalList.splice(index, 1);
    };
    // track all our open modals
    ModalService.modalList = [];
    ModalService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    ModalService.ctorParameters = function () { return [
        { type: ComponentFactoryResolver },
        { type: PlaceholderService }
    ]; };
    return ModalService;
}());

/**
 * Component to create modals for presenting content.
 *
 * [See demo](../../?path=/story/modal--basic)
 *
 * Using a modal in your application requires `ibm-placeholder` which would generally be
 * placed near the end of your app component template (app.component.ts or app.component.html) as:
 *
```html
<ibm-placeholder></ibm-placeholder>
```
 *
 * A more complete example for `Modal` is given as follows:
 *
 * Example modal definition:
 *
```typescript
@Component({
    selector: "app-sample-modal",
    template: `
                <ibm-modal size="xl" (overlaySelected)="closeModal()">
                    <ibm-modal-header (closeSelect)="closeModal()">Header text</ibm-modal-header>
                        <section class="modal-body">
                            <h1>Sample modal works.</h1>
                            <button class="btn--icon-link" nPopover="Hello there" title="Popover title" placement="right" appendInline="true">
                                <svg ibmIcon="info" size="sm"></ibm-icon>
                            </button>
                            {{modalText}}
                        </section>
                    <ibm-modal-footer><button ibmButton="primary" (click)="closeModal()">Close</button></ibm-modal-footer>
                </ibm-modal>`,
    styleUrls: ["./sample-modal.component.scss"]
})
export class SampleModal extends BaseModal {
    modalText: string;
    constructor(protected injector: Injector) {
        super();
        this.modalText = this.injector.get("modalText");
    }
}
```
 *
 * Example of opening the modal:
 *
```typescript
@Component({
    selector: "app-modal-demo",
    template: `
                <button ibmButton="primary" (click)="openModal('drill')">Drill-down modal</button>
                <ibm-placeholder></ibm-placeholder>`
})
export class ModalDemo {
    openModal() {
        this.modalService.create({component: SampleModal, inputs: {modalText: "Hello universe."}});
    }
}
```
 *
 * <example-url>../../iframe.html?id=modal--basic</example-url>
 */
var Modal = /** @class */ (function () {
    /**
     * Creates an instance of `Modal`.
     */
    function Modal(modalService) {
        this.modalService = modalService;
        /**
         * Classification of the modal.
         */
        this.theme = "default";
        this.ariaLabel = "default";
        /**
         * Controls the visibility of the modal when used directly in a template
         */
        this.open = false;
        /**
         * Specify whether the modal contains scrolling content. This property overrides the automatic
         * detection of the existence of scrolling content. Set this property to `true` to force
         * overflow indicator to show up or to `false` to force overflow indicator to disappear.
         * It is set to `null` by default which indicates not to override automatic detection.
         */
        this.hasScrollingContent = null;
        /**
         * Emits event when click occurs within `n-overlay` element. This is to track click events occurring outside bounds of the `Modal` object.
         */
        this.overlaySelected = new EventEmitter();
        /**
         * To emit the closing event of the modal window.
         */
        this.close = new EventEmitter();
        /**
         * An element should have 'modal-primary-focus' as an attribute to receive initial focus within the `Modal` component.
         */
        this.selectorPrimaryFocus = "[modal-primary-focus]";
    }
    Object.defineProperty(Modal.prototype, "modalLabel", {
        get: function () {
            return this.ariaLabel;
        },
        /**
         * Label for the modal.
         *
         * @deprecated since v4
         */
        set: function (value) {
            this.ariaLabel = value;
        },
        enumerable: true,
        configurable: true
    });
    Modal.prototype.ngOnChanges = function (_a) {
        var _this = this;
        var open = _a.open;
        if (open) {
            if (open.currentValue) {
                // `100` is just enough time to allow the modal
                // to become visible, so that we can set focus
                setTimeout(function () { return _this.focusInitialElement(); }, 100);
            }
            else if (this.trigger) {
                this.trigger.focus();
            }
        }
    };
    /**
     * Set document focus to be on the modal component after it is initialized.
     */
    Modal.prototype.ngAfterViewInit = function () {
        this.focusInitialElement();
    };
    /**
     * Handle keyboard events to close modal and tab through the content within the modal.
     */
    Modal.prototype.handleKeyboardEvent = function (event) {
        switch (event.key) {
            case "Escape": {
                event.stopImmediatePropagation(); // prevents events being fired for multiple modals if more than 2 open
                this.modalService.destroy(); // destroy top (latest) modal
                this.close.emit();
                break;
            }
            case "Tab": {
                cycleTabs(event, this.modal.nativeElement);
                break;
            }
        }
    };
    Object.defineProperty(Modal.prototype, "shouldShowScrollbar", {
        /**
         * This detects whether or not the modal contains scrolling content.
         *
         * To force trigger a detection (ie. on window resize), change or reset the value of the modal content.
         *
         * Use the `hasScrollingContent` input to manually override the overflow indicator.
         */
        get: function () {
            var modalContent = this.modal ? this.modal.nativeElement.querySelector(".bx--modal-content") : null;
            if (modalContent) {
                var modalContentHeight = modalContent.getBoundingClientRect().height;
                var modalContentScrollHeight = modalContent.scrollHeight;
                return modalContentScrollHeight > modalContentHeight;
            }
            else {
                return false;
            }
        },
        enumerable: true,
        configurable: true
    });
    Modal.prototype.focusInitialElement = function () {
        var _this = this;
        var primaryFocusElement = this.modal.nativeElement.querySelector(this.selectorPrimaryFocus);
        if (primaryFocusElement && primaryFocusElement.focus) {
            setTimeout(function () { return primaryFocusElement.focus(); });
        }
        else if (getFocusElementList(this.modal.nativeElement).length > 0) {
            setTimeout(function () { return getFocusElementList(_this.modal.nativeElement)[0].focus(); });
        }
        else {
            setTimeout(function () { return _this.modal.nativeElement.focus(); });
        }
    };
    Modal.decorators = [
        { type: Component, args: [{
                    selector: "ibm-modal",
                    template: "\n\t\t<ibm-overlay\n\t\t\t[theme]=\"theme\"\n\t\t\t[open]=\"open\"\n\t\t\t(overlaySelect)=\"overlaySelected.emit()\">\n\t\t\t<div\n\t\t\t\tclass=\"bx--modal-container\"\n\t\t\t\t[ngClass]=\"{\n\t\t\t\t\t'bx--modal-container--xs': size === 'xs',\n\t\t\t\t\t'bx--modal-container--sm': size === 'sm',\n\t\t\t\t\t'bx--modal-container--lg': size === 'lg'\n\t\t\t\t}\"\n\t\t\t\trole=\"dialog\"\n\t\t\t\taria-modal=\"true\"\n\t\t\t\tstyle=\"z-index:1;\"\n\t\t\t\t[attr.aria-label]=\"ariaLabel\"\n\t\t\t\t#modal>\n\t\t\t\t<ng-content></ng-content>\n\t\t\t\t<div\n\t\t\t\t\t*ngIf=\"hasScrollingContent !== null ? hasScrollingContent : shouldShowScrollbar\"\n\t\t\t\t\tclass=\"bx--modal-content--overflow-indicator\">\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</ibm-overlay>\n\t"
                }] }
    ];
    /** @nocollapse */
    Modal.ctorParameters = function () { return [
        { type: ModalService }
    ]; };
    Modal.propDecorators = {
        size: [{ type: Input }],
        theme: [{ type: Input }],
        modalLabel: [{ type: Input }],
        ariaLabel: [{ type: Input }],
        open: [{ type: Input }],
        trigger: [{ type: Input }],
        hasScrollingContent: [{ type: Input }],
        overlaySelected: [{ type: Output }],
        close: [{ type: Output }],
        modal: [{ type: ViewChild, args: ["modal", { static: true },] }],
        handleKeyboardEvent: [{ type: HostListener, args: ["keydown", ["$event"],] }]
    };
    return Modal;
}());

/**
 * Component for the overlay object that acts as a backdrop to the `Modal` component.
 *
 * The main purpose for this component is to be able to handle click events that fall outside
 * the bounds of the `Modal` component.
 */
var Overlay = /** @class */ (function () {
    function Overlay() {
        /**
         * Classification of the modal.
         */
        this.theme = "default";
        this.open = false;
        /**
         * To emit the event where the user selects the overlay behind the `Modal`.
         */
        this.overlaySelect = new EventEmitter();
    }
    /**
     * Handles the user clicking on the `Overlay` which resides outside the `Modal` object.
     */
    Overlay.prototype.overlayClick = function (event) {
        if (event.target !== this.overlay.nativeElement) {
            return;
        }
        event.stopPropagation();
        this.overlaySelect.emit(event);
    };
    Overlay.decorators = [
        { type: Component, args: [{
                    selector: "ibm-overlay",
                    template: "\n\t\t<section\n\t\t\tclass=\"bx--modal bx--modal-tall\"\n\t\t\t[ngClass]=\"{\n\t\t\t\t'bx--modal--danger': theme === 'danger',\n\t\t\t\t'is-visible': open\n\t\t\t}\"\n\t\t\t(click)=\"overlayClick($event)\"\n\t\t\t#overlay>\n\t\t\t<ng-content></ng-content>\n\t\t</section>\n\t"
                }] }
    ];
    Overlay.propDecorators = {
        theme: [{ type: Input }],
        open: [{ type: Input }],
        overlaySelect: [{ type: Output }],
        overlay: [{ type: ViewChild, args: ["overlay", { static: true },] }]
    };
    return Overlay;
}());

var ModalContent = /** @class */ (function () {
    function ModalContent() {
        this.modalContentClass = true;
        /**
         * Provide whether the modal content has a form element.
         * If `true` is used here, non-form child content should have `bx--modal-content__regular-content` class.
         */
        this.hasForm = false;
    }
    ModalContent.decorators = [
        { type: Directive, args: [{
                    selector: "[ibmModalContent]"
                },] }
    ];
    ModalContent.propDecorators = {
        modalContentClass: [{ type: HostBinding, args: ["class.bx--modal-content",] }],
        hasForm: [{ type: HostBinding, args: ["class.bx--modal-content--with-form",] }, { type: Input }]
    };
    return ModalContent;
}());

var ModalContentText = /** @class */ (function () {
    function ModalContentText() {
        this.modalContentTextClass = true;
    }
    ModalContentText.decorators = [
        { type: Directive, args: [{
                    selector: "[ibmModalContentText]"
                },] }
    ];
    ModalContentText.propDecorators = {
        modalContentTextClass: [{ type: HostBinding, args: ["class.bx--modal-content__text",] }]
    };
    return ModalContentText;
}());

var ModalHeaderHeading = /** @class */ (function () {
    function ModalHeaderHeading() {
        this.modalHeaderHeadingClass = true;
    }
    ModalHeaderHeading.decorators = [
        { type: Directive, args: [{
                    selector: "[ibmModalHeaderHeading]"
                },] }
    ];
    ModalHeaderHeading.propDecorators = {
        modalHeaderHeadingClass: [{ type: HostBinding, args: ["class.bx--modal-header__heading",] }]
    };
    return ModalHeaderHeading;
}());

var ModalHeaderLabel = /** @class */ (function () {
    function ModalHeaderLabel() {
        this.modalHeaderLabelClass = true;
    }
    ModalHeaderLabel.decorators = [
        { type: Directive, args: [{
                    selector: "[ibmModalHeaderLabel]"
                },] }
    ];
    ModalHeaderLabel.propDecorators = {
        modalHeaderLabelClass: [{ type: HostBinding, args: ["class.bx--modal-header__label",] }]
    };
    return ModalHeaderLabel;
}());

// modules
var ModalModule = /** @class */ (function () {
    function ModalModule() {
    }
    ModalModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        AlertModal,
                        Modal,
                        ModalHeader,
                        ModalFooter,
                        Overlay,
                        ModalContent,
                        ModalContentText,
                        ModalHeaderHeading,
                        ModalHeaderLabel,
                        BaseModal
                    ],
                    exports: [
                        AlertModal,
                        Modal,
                        ModalHeader,
                        ModalFooter,
                        ModalContent,
                        ModalContentText,
                        ModalHeaderHeading,
                        ModalHeaderLabel,
                        BaseModal
                    ],
                    entryComponents: [
                        AlertModal,
                        Modal,
                        ModalFooter,
                        ModalHeader
                    ],
                    providers: [ModalService],
                    imports: [
                        CommonModule,
                        ButtonModule,
                        I18nModule,
                        PlaceholderModule,
                        ExperimentalModule,
                        IconModule
                    ]
                },] }
    ];
    return ModalModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { AlertModal, AlertModalType, ModalButtonType, BaseModal, ModalFooter, ModalHeader, Modal, ModalModule, ModalService, Overlay, ModalContent, ModalContentText, ModalHeaderHeading, ModalHeaderLabel };

//# sourceMappingURL=carbon-components-angular-modal.js.map