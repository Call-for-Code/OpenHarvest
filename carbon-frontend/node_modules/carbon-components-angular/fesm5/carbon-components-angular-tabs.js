/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-tabs.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Subscription } from 'rxjs';
import { Component, Input, Output, EventEmitter, TemplateRef, HostBinding, ViewChild, ElementRef, HostListener, ContentChildren, ChangeDetectorRef, ViewChildren, ContentChild, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { EventService, UtilsModule } from 'carbon-components-angular/utils';

var nextId = 0;
/**
* The `Tab` component is a child of the `Tabs` component.
* It represents one `Tab` item and its content within a panel of other `Tab` items.
*
*
* `Tab` takes a string or `TemplateRef` for the header, and any content for the body of the tab.
* Disabled states should be handled by the application (ie. switch to the tab, but display some
* indication as to _why_ the tab is disabled).
*
* When the tab is selected the `select` output will be triggered.
* The `select` output will also be triggered for the active tab when the tabs are loaded or updated.
*
*
* Tab with string header:
*
* ```html
* <ibm-tab heading='tab1'>
* 	tab 1 content
* </ibm-tab>
* ```
*
* Tab with custom header:
*
* ```html
* <ng-template #tabHeading>
* 	<svg ibmIcon="facebook"
* 		size="sm"
* 		style="margin-right: 7px;">
* 	</svg>
* 	Hello Tab 1
* </ng-template>
* <ibm-tabs>
* 	<ibm-tab [heading]="tabHeading">
* 		Tab 1 content <svg ibmIcon="alert" size="lg"></svg>
* 	</ibm-tab>
* 	<ibm-tab heading='Tab2'>
* 		Tab 2 content
* 	</ibm-tab>
* 	<ibm-tab heading='Tab3'>
* 		Tab 3 content
* 	</ibm-tab>
* </ibm-tabs>
* ```
*/
var Tab = /** @class */ (function () {
    function Tab() {
        /**
         * Boolean value reflects if the `Tab` is using a custom template for the heading.
         * Default value is false.
         */
        this.headingIsTemplate = false;
        /**
         * Indicates whether the `Tab` is active/selected.
         * Determines whether it's `TabPanel` is rendered.
         */
        this.active = false;
        /**
         * Indicates whether or not the `Tab` item is disabled.
         */
        this.disabled = false;
        this.tabIndex = 0;
        // do we need id's?
        /**
         * Sets the id of the `Tab`. Will be uniquely generated if not provided.
         */
        this.id = "n-tab-" + nextId++;
        /**
         * Value 'selected' to be emitted after a new `Tab` is selected.
         */
        this.selected = new EventEmitter();
        /**
         * Used to set the id property on the element.
         */
        this.attrClass = this.id;
        this._cacheActive = false;
    }
    Object.defineProperty(Tab.prototype, "cacheActive", {
        get: function () {
            return this._cacheActive;
        },
        /**
         * Set to true to have Tab items cached and not reloaded on tab switching.
         */
        set: function (shouldCache) {
            this._cacheActive = shouldCache;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Checks for custom heading template on initialization and updates the value
     * of the boolean 'headingIsTemplate'.
     */
    Tab.prototype.ngOnInit = function () {
        if (this.heading instanceof TemplateRef) {
            this.headingIsTemplate = true;
        }
    };
    /**
     * Emit the status of the `Tab`, specifically 'select' and 'selected' properties.
     */
    Tab.prototype.doSelect = function () {
        this.selected.emit();
    };
    /**
    * Returns value indicating whether this `Tab` should be rendered in a `TabPanel`.
    */
    Tab.prototype.shouldRender = function () {
        return this.active || this.cacheActive;
    };
    Tab.decorators = [
        { type: Component, args: [{
                    selector: "ibm-tab",
                    template: "\n\t\t<div\n\t\t\t[attr.tabindex]=\"tabIndex\"\n\t\t\trole=\"tabpanel\"\n\t\t\t*ngIf=\"shouldRender()\"\n\t\t\tclass=\"bx--tab-content\"\n\t\t\t[ngStyle]=\"{'display': active ? null : 'none'}\"\n\t\t\t[attr.aria-labelledby]=\"id + '-header'\"\n\t\t\taria-live=\"polite\">\n\t\t\t<ng-content></ng-content>\n\t\t</div>\n\t"
                }] }
    ];
    Tab.propDecorators = {
        heading: [{ type: Input }],
        title: [{ type: Input }],
        context: [{ type: Input }],
        active: [{ type: Input }],
        disabled: [{ type: Input }],
        tabIndex: [{ type: Input }],
        id: [{ type: Input }],
        cacheActive: [{ type: Input }],
        selected: [{ type: Output }],
        attrClass: [{ type: HostBinding, args: ["attr.id",] }]
    };
    return Tab;
}());

var TabHeader = /** @class */ (function () {
    function TabHeader() {
        /**
         * Indicates whether the `Tab` is active/selected.
         * Determines whether it's `TabPanel` is rendered.
         */
        this.active = false;
        /**
         * Indicates whether or not the `Tab` item is disabled.
         */
        this.disabled = false;
        /**
         * Value 'selected' to be emitted after a new `Tab` is selected.
         */
        this.selected = new EventEmitter();
        this._cacheActive = false;
    }
    Object.defineProperty(TabHeader.prototype, "cacheActive", {
        get: function () {
            return this._cacheActive;
        },
        /**
         * Set to 'true' to have pane reference cached and not reloaded on tab switching.
         */
        set: function (shouldCache) {
            this._cacheActive = shouldCache;
            // Updates the pane references associated with the tab header when cache active is changed.
            if (this.paneReference) {
                this.paneReference.cacheActive = this.cacheActive;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabHeader.prototype, "paneTabIndex", {
        set: function (tabIndex) {
            if (this.paneReference) {
                this.paneReference.tabIndex = tabIndex;
            }
        },
        enumerable: true,
        configurable: true
    });
    TabHeader.prototype.ngAfterViewInit = function () {
        var _this = this;
        setTimeout(function () {
            _this.title = _this.title ? _this.title : _this.tabItem.nativeElement.textContent;
        });
    };
    TabHeader.prototype.selectTab = function () {
        this.tabItem.nativeElement.focus();
        if (!this.disabled) {
            this.selected.emit();
            this.active = true;
            if (this.paneReference) {
                this.paneReference.active = true;
            }
        }
    };
    TabHeader.decorators = [
        { type: Component, args: [{
                    selector: "ibm-tab-header",
                    template: "\n\t\t<li\n\t\t\t[ngClass]=\"{\n\t\t\t\t'bx--tabs__nav-item--selected bx--tabs--scrollable__nav-item--selected': active,\n\t\t\t\t'bx--tabs__nav-item--disabled bx--tabs--scrollable__nav-item--disabled': disabled\n\t\t\t}\"\n\t\t\tclass=\"bx--tabs--scrollable__nav-item\"\n\t\t\trole=\"presentation\"\n\t\t\t(click)=\"selectTab()\">\n\t\t\t<button\n\t\t\t\t#tabItem\n\t\t\t\t[attr.aria-selected]=\"active\"\n\t\t\t\tdraggable=\"false\"\n\t\t\t\tclass=\"bx--tabs--scrollable__nav-link\"\n\t\t\t\thref=\"javascript:void(0)\"\n\t\t\t\t[title]=\"title\"\n\t\t\t\t[attr.tabindex]=\"(active? 0 : -1)\"\n\t\t\t\trole=\"tab\">\n\t\t\t\t<ng-content></ng-content>\n\t\t\t</button>\n\t\t</li>\n\t"
                }] }
    ];
    TabHeader.propDecorators = {
        active: [{ type: Input }],
        disabled: [{ type: Input }],
        paneReference: [{ type: Input }],
        title: [{ type: Input }],
        cacheActive: [{ type: Input }],
        paneTabIndex: [{ type: Input }],
        selected: [{ type: Output }],
        tabItem: [{ type: ViewChild, args: ["tabItem", { static: true },] }]
    };
    return TabHeader;
}());

var TabHeaderGroup = /** @class */ (function () {
    function TabHeaderGroup(elementRef, changeDetectorRef, eventService) {
        this.elementRef = elementRef;
        this.changeDetectorRef = changeDetectorRef;
        this.eventService = eventService;
        /**
         * Set to `true` to put tabs in a loading state.
         */
        this.skeleton = false;
        /**
         * Set to 'true' to have all pane references associated with each tab header
         * in the tab header group cached and not reloaded on tab switching.
         */
        this.cacheActive = false;
        this.isNavigation = false;
        this.type = "default";
        /**
         * Keeps track of all the subscriptions to the tab header selection events.
         */
        this.selectedSubscriptionTracker = new Subscription();
        /**
         * Controls the manual focusing done by tabbing through headings.
         */
        this.currentSelectedIndex = 0;
        // width of the overflow buttons
        this.OVERFLOW_BUTTON_OFFSET = 40;
        this._cacheActive = false;
    }
    Object.defineProperty(TabHeaderGroup.prototype, "hasHorizontalOverflow", {
        get: function () {
            var tabList = this.headerContainer.nativeElement;
            return tabList.scrollWidth > tabList.clientWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabHeaderGroup.prototype, "leftOverflowNavButtonHidden", {
        get: function () {
            var tabList = this.headerContainer.nativeElement;
            return !this.hasHorizontalOverflow || !tabList.scrollLeft;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabHeaderGroup.prototype, "rightOverflowNavButtonHidden", {
        get: function () {
            var tabList = this.headerContainer.nativeElement;
            return !this.hasHorizontalOverflow ||
                (tabList.scrollLeft + tabList.clientWidth) === tabList.scrollWidth;
        },
        enumerable: true,
        configurable: true
    });
    // keyboard accessibility
    /**
     * Controls the keydown events used for tabbing through the headings.
     */
    TabHeaderGroup.prototype.keyboardInput = function (event) {
        var tabHeadersArray = Array.from(this.tabHeaderQuery);
        if (event.key === "Right" || event.key === "ArrowRight") {
            if (this.currentSelectedIndex < tabHeadersArray.length - 1) {
                event.preventDefault();
                if (this.followFocus && !tabHeadersArray[this.currentSelectedIndex + 1].disabled) {
                    tabHeadersArray[this.currentSelectedIndex + 1].selectTab();
                }
                else {
                    tabHeadersArray[this.currentSelectedIndex + 1].tabItem.nativeElement.focus();
                    this.currentSelectedIndex++;
                }
            }
            else {
                event.preventDefault();
                if (this.followFocus && !tabHeadersArray[0].disabled) {
                    tabHeadersArray[0].selectTab();
                }
                else {
                    tabHeadersArray[0].tabItem.nativeElement.focus();
                    this.currentSelectedIndex = 0;
                }
            }
        }
        if (event.key === "Left" || event.key === "ArrowLeft") {
            if (this.currentSelectedIndex > 0) {
                event.preventDefault();
                if (this.followFocus && !tabHeadersArray[this.currentSelectedIndex - 1].disabled) {
                    tabHeadersArray[this.currentSelectedIndex - 1].selectTab();
                }
                else {
                    tabHeadersArray[this.currentSelectedIndex - 1].tabItem.nativeElement.focus();
                    this.currentSelectedIndex--;
                }
            }
            else {
                event.preventDefault();
                if (this.followFocus && !tabHeadersArray[tabHeadersArray.length - 1].disabled) {
                    tabHeadersArray[tabHeadersArray.length - 1].selectTab();
                }
                else {
                    tabHeadersArray[tabHeadersArray.length - 1].tabItem.nativeElement.focus();
                    this.currentSelectedIndex = tabHeadersArray.length - 1;
                }
            }
        }
        if (event.key === "Home") {
            event.preventDefault();
            if (this.followFocus && !tabHeadersArray[0].disabled) {
                tabHeadersArray[0].selectTab();
            }
            else {
                tabHeadersArray[0].tabItem.nativeElement.focus();
                this.currentSelectedIndex = 0;
            }
        }
        if (event.key === "End") {
            event.preventDefault();
            if (this.followFocus && !tabHeadersArray[tabHeadersArray.length - 1].disabled) {
                tabHeadersArray[tabHeadersArray.length - 1].selectTab();
            }
            else {
                tabHeadersArray[tabHeadersArray.length - 1].tabItem.nativeElement.focus();
                this.currentSelectedIndex = tabHeadersArray.length - 1;
            }
        }
        // `"Spacebar"` is IE11 specific value
        if ((event.key === " " || event.key === "Spacebar") && !this.followFocus) {
            tabHeadersArray[this.currentSelectedIndex].selectTab();
        }
    };
    TabHeaderGroup.prototype.ngOnInit = function () {
        var _this = this;
        this.eventService.on(window, "resize", function () { return _this.handleScroll(); });
    };
    TabHeaderGroup.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.selectedSubscriptionTracker.unsubscribe();
        if (this.tabHeaderQuery) {
            this.tabHeaderQuery.toArray()
                .forEach(function (tabHeader) {
                tabHeader.cacheActive = _this.cacheActive;
                tabHeader.paneTabIndex = _this.isNavigation ? null : 0;
            });
        }
        var selectedSubscriptions = this.tabHeaderQuery.toArray().forEach(function (tabHeader) {
            tabHeader.selected.subscribe(function () {
                _this.currentSelectedIndex = _this.tabHeaderQuery.toArray().indexOf(tabHeader);
                // The Filter takes the current selected tab out, then all other headers are
                // deactivated and their associated pane references are also deactivated.
                _this.tabHeaderQuery.toArray().filter(function (header) { return header !== tabHeader; })
                    .forEach(function (filteredHeader) {
                    filteredHeader.active = false;
                    if (filteredHeader.paneReference) {
                        filteredHeader.paneReference.active = false;
                    }
                });
            });
        });
        this.selectedSubscriptionTracker.add(selectedSubscriptions);
        setTimeout(function () { return _this.tabHeaderQuery.toArray()[_this.currentSelectedIndex].selectTab(); });
    };
    TabHeaderGroup.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (this.tabHeaderQuery) {
            if (changes.cacheActive) {
                this.tabHeaderQuery.toArray().forEach(function (tabHeader) { return tabHeader.cacheActive = _this.cacheActive; });
            }
            if (changes.isNavigation) {
                this.tabHeaderQuery.toArray()
                    .forEach(function (tabHeader) { return tabHeader.paneTabIndex = _this.isNavigation ? null : 0; });
            }
        }
    };
    TabHeaderGroup.prototype.getSelectedTab = function () {
        var selected = this.tabHeaderQuery.toArray()[this.currentSelectedIndex];
        if (selected) {
            return selected;
        }
        return {
            headingIsTemplate: false,
            heading: ""
        };
    };
    TabHeaderGroup.prototype.handleScroll = function () {
        this.changeDetectorRef.markForCheck();
    };
    TabHeaderGroup.prototype.handleOverflowNavClick = function (direction, multiplier) {
        if (multiplier === void 0) { multiplier = 15; }
        var tabList = this.headerContainer.nativeElement;
        var clientWidth = tabList.clientWidth, scrollLeft = tabList.scrollLeft, scrollWidth = tabList.scrollWidth;
        if (direction === 1 && !scrollLeft) {
            tabList.scrollLeft += this.OVERFLOW_BUTTON_OFFSET;
        }
        tabList.scrollLeft += direction * multiplier;
        var leftEdgeReached = direction === -1 && scrollLeft < this.OVERFLOW_BUTTON_OFFSET;
        var rightEdgeReached = direction === 1 &&
            scrollLeft + clientWidth >= scrollWidth - this.OVERFLOW_BUTTON_OFFSET;
        if (leftEdgeReached) {
            this.rightOverflowNavButton.nativeElement.focus();
        }
        if (rightEdgeReached) {
            this.leftOverflowNavButton.nativeElement.focus();
        }
    };
    TabHeaderGroup.prototype.handleOverflowNavMouseDown = function (direction) {
        var _this = this;
        var tabList = this.headerContainer.nativeElement;
        this.overflowNavInterval = setInterval(function () {
            var clientWidth = tabList.clientWidth, scrollLeft = tabList.scrollLeft, scrollWidth = tabList.scrollWidth;
            // clear interval if scroll reaches left or right edge
            var leftEdgeReached = direction === -1 && scrollLeft < _this.OVERFLOW_BUTTON_OFFSET;
            var rightEdgeReached = direction === 1 &&
                scrollLeft + clientWidth >= scrollWidth - _this.OVERFLOW_BUTTON_OFFSET;
            if (leftEdgeReached || rightEdgeReached) {
                clearInterval(_this.overflowNavInterval);
            }
            // account for overflow button appearing and causing tablist width change
            _this.handleOverflowNavClick(direction);
        });
    };
    TabHeaderGroup.prototype.handleOverflowNavMouseUp = function () {
        clearInterval(this.overflowNavInterval);
    };
    TabHeaderGroup.decorators = [
        { type: Component, args: [{
                    selector: "ibm-tab-header-group",
                    template: "\n\t<nav\n\t\tclass=\"bx--tabs bx--tabs--scrollable\"\n\t\t[ngClass]=\"{\n\t\t\t'bx--skeleton': skeleton,\n\t\t\t'bx--tabs--container bx--tabs--scrollable--container': type === 'container'\n\t\t}\"\n\t\trole=\"navigation\"\n\t\t[attr.aria-label]=\"ariaLabel\"\n\t\t[attr.aria-labelledby]=\"ariaLabelledby\">\n\t\t<button\n\t\t\t#leftOverflowNavButton\n\t\t\ttype=\"button\"\n\t\t\t[ngClass]=\"{\n\t\t\t\t'bx--tab--overflow-nav-button': hasHorizontalOverflow,\n\t\t\t\t'bx--tab--overflow-nav-button--hidden': leftOverflowNavButtonHidden\n\t\t\t}\"\n\t\t\t(click)=\"handleOverflowNavClick(-1)\"\n\t\t\t(mousedown)=\"handleOverflowNavMouseDown(-1)\"\n\t\t\t(mouseup)=\"handleOverflowNavMouseUp()\">\n\t\t\t<svg\n\t\t\t\tfocusable=\"false\"\n\t\t\t\tpreserveAspectRatio=\"xMidYMid meet\"\n\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\t\tfill=\"currentColor\"\n\t\t\t\twidth=\"16\"\n\t\t\t\theight=\"16\"\n\t\t\t\tviewBox=\"0 0 16 16\"\n\t\t\t\taria-hidden=\"true\">\n\t\t\t\t<path d=\"M5 8L10 3 10.7 3.7 6.4 8 10.7 12.3 10 13z\"></path>\n\t\t\t</svg>\n\t\t</button>\n\t\t<div *ngIf=\"!leftOverflowNavButtonHidden\" class=\"bx--tabs__overflow-indicator--left\"></div>\n\t\t<ul\n\t\t\t#tabList\n\t\t\tclass=\"bx--tabs--scrollable__nav\"\n\t\t\trole=\"tablist\"\n\t\t\t(scroll)=\"handleScroll()\">\n\t\t\t<li role=\"presentation\">\n\t\t\t\t<ng-container *ngIf=\"contentBefore\" [ngTemplateOutlet]=\"contentBefore\"></ng-container>\n\t\t\t</li>\n\t\t\t<ng-content></ng-content>\n\t\t\t<li role=\"presentation\">\n\t\t\t\t<ng-container *ngIf=\"contentAfter\" [ngTemplateOutlet]=\"contentAfter\"></ng-container>\n\t\t\t</li>\n\t\t</ul>\n\t\t<div *ngIf=\"!rightOverflowNavButtonHidden\" class=\"bx--tabs__overflow-indicator--right\"></div>\n\t\t<button\n\t\t\t#rightOverflowNavButton\n\t\t\ttype=\"button\"\n\t\t\t[ngClass]=\"{\n\t\t\t\t'bx--tab--overflow-nav-button': hasHorizontalOverflow,\n\t\t\t\t'bx--tab--overflow-nav-button--hidden': rightOverflowNavButtonHidden\n\t\t\t}\"\n\t\t\t(click)=\"handleOverflowNavClick(1)\"\n\t\t\t(mousedown)=\"handleOverflowNavMouseDown(1)\"\n\t\t\t(mouseup)=\"handleOverflowNavMouseUp()\">\n\t\t\t<svg\n\t\t\t\tfocusable=\"false\"\n\t\t\t\tpreserveAspectRatio=\"xMidYMid meet\"\n\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\t\tfill=\"currentColor\"\n\t\t\t\twidth=\"16\"\n\t\t\t\theight=\"16\"\n\t\t\t\tviewBox=\"0 0 16 16\"\n\t\t\t\taria-hidden=\"true\">\n\t\t\t\t<path d=\"M11 8L6 13 5.3 12.3 9.6 8 5.3 3.7 6 3z\"></path>\n\t\t\t</svg>\n\t\t</button>\n\t</nav>\n\t"
                }] }
    ];
    /** @nocollapse */
    TabHeaderGroup.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ChangeDetectorRef },
        { type: EventService }
    ]; };
    TabHeaderGroup.propDecorators = {
        followFocus: [{ type: Input }],
        skeleton: [{ type: Input }],
        ariaLabel: [{ type: Input }],
        ariaLabelledby: [{ type: Input }],
        contentAfter: [{ type: Input }],
        contentBefore: [{ type: Input }],
        cacheActive: [{ type: Input }],
        isNavigation: [{ type: Input }],
        type: [{ type: Input }],
        tabHeaderQuery: [{ type: ContentChildren, args: [TabHeader,] }],
        headerContainer: [{ type: ViewChild, args: ["tabList", { static: true },] }],
        rightOverflowNavButton: [{ type: ViewChild, args: ["rightOverflowNavButton", { static: true },] }],
        leftOverflowNavButton: [{ type: ViewChild, args: ["leftOverflowNavButton", { static: true },] }],
        keyboardInput: [{ type: HostListener, args: ["keydown", ["$event"],] }]
    };
    return TabHeaderGroup;
}());

/**
 * The `TabHeaders` component contains the `Tab` items and controls scroll functionality
 * if content has overflow.
 */
var TabHeaders = /** @class */ (function () {
    function TabHeaders(elementRef, changeDetectorRef, eventService) {
        this.elementRef = elementRef;
        this.changeDetectorRef = changeDetectorRef;
        this.eventService = eventService;
        /**
         * Set to 'true' to have `Tab` items cached and not reloaded on tab switching.
         * Duplicate from `n-tabs` to support standalone headers
         */
        this.cacheActive = false;
        /**
         * Set to `true` to put tabs in a loading state.
         */
        this.skeleton = false;
        this.type = "default";
        /**
         * The index of the first visible tab.
         */
        this.firstVisibleTab = 0;
        // width of the overflow buttons
        this.OVERFLOW_BUTTON_OFFSET = 40;
    }
    Object.defineProperty(TabHeaders.prototype, "hasHorizontalOverflow", {
        get: function () {
            var tabList = this.headerContainer.nativeElement;
            return tabList.scrollWidth > tabList.clientWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabHeaders.prototype, "leftOverflowNavButtonHidden", {
        get: function () {
            var tabList = this.headerContainer.nativeElement;
            return !this.hasHorizontalOverflow || !tabList.scrollLeft;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabHeaders.prototype, "rightOverflowNavButtonHidden", {
        get: function () {
            var tabList = this.headerContainer.nativeElement;
            return !this.hasHorizontalOverflow ||
                (tabList.scrollLeft + tabList.clientWidth) === tabList.scrollWidth;
        },
        enumerable: true,
        configurable: true
    });
    // keyboard accessibility
    /**
     * Controls the keydown events used for tabbing through the headings.
     */
    TabHeaders.prototype.keyboardInput = function (event) {
        var tabsArray = Array.from(this.tabs);
        // "Right" is an ie11 specific value
        if (event.key === "Right" || event.key === "ArrowRight") {
            if (this.currentSelectedTab < this.allTabHeaders.length - 1) {
                event.preventDefault();
                if (this.followFocus) {
                    this.selectTab(event.target, tabsArray[this.currentSelectedTab + 1], this.currentSelectedTab);
                }
                this.allTabHeaders.toArray()[this.currentSelectedTab + 1].nativeElement.focus();
            }
            else {
                event.preventDefault();
                if (this.followFocus) {
                    this.selectTab(event.target, tabsArray[0], 0);
                }
                this.allTabHeaders.first.nativeElement.focus();
            }
        }
        // "Left" is an ie11 specific value
        if (event.key === "Left" || event.key === "ArrowLeft") {
            if (this.currentSelectedTab > 0) {
                event.preventDefault();
                if (this.followFocus) {
                    this.selectTab(event.target, tabsArray[this.currentSelectedTab - 1], this.currentSelectedTab);
                }
                this.allTabHeaders.toArray()[this.currentSelectedTab - 1].nativeElement.focus();
            }
            else {
                event.preventDefault();
                if (this.followFocus) {
                    this.selectTab(event.target, tabsArray[this.allTabHeaders.length - 1], this.allTabHeaders.length);
                }
                this.allTabHeaders.toArray()[this.allTabHeaders.length - 1].nativeElement.focus();
            }
        }
        if (event.key === "Home") {
            event.preventDefault();
            if (this.followFocus) {
                this.selectTab(event.target, tabsArray[0], 0);
            }
            this.allTabHeaders.toArray()[0].nativeElement.focus();
        }
        if (event.key === "End") {
            event.preventDefault();
            if (this.followFocus) {
                this.selectTab(event.target, tabsArray[this.allTabHeaders.length - 1], this.allTabHeaders.length);
            }
            this.allTabHeaders.toArray()[this.allTabHeaders.length - 1].nativeElement.focus();
        }
        // `"Spacebar"` is IE11 specific value
        if ((event.key === " " || event.key === "Spacebar") && !this.followFocus) {
            this.selectTab(event.target, tabsArray[this.currentSelectedTab], this.currentSelectedTab);
        }
    };
    TabHeaders.prototype.ngOnInit = function () {
        var _this = this;
        this.eventService.on(window, "resize", function () { return _this.handleScroll(); });
    };
    TabHeaders.prototype.ngAfterContentInit = function () {
        var _this = this;
        if (!this.tabInput) {
            this.tabs = this.tabQuery;
        }
        else {
            this.tabs = this.tabInput;
        }
        this.tabs.forEach(function (tab) { return tab.cacheActive = _this.cacheActive; });
        this.tabs.changes.subscribe(function () {
            _this.setFirstTab();
        });
        this.setFirstTab();
    };
    TabHeaders.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (this.tabs && changes.cacheActive) {
            this.tabs.forEach(function (tab) { return tab.cacheActive = _this.cacheActive; });
        }
    };
    /**
     * Controls manually focusing tabs.
     */
    TabHeaders.prototype.onTabFocus = function (ref, index) {
        this.currentSelectedTab = index;
        // reset scroll left because we're already handling it
        this.headerContainer.nativeElement.parentElement.scrollLeft = 0;
    };
    TabHeaders.prototype.getSelectedTab = function () {
        var selected = this.tabs.find(function (tab) { return tab.active; });
        if (selected) {
            return selected;
        }
        return { headingIsTemplate: false, heading: "" };
    };
    /**
     * Selects `Tab` 'tab' and moves it into view on the view DOM if it is not already.
     */
    TabHeaders.prototype.selectTab = function (ref, tab, tabIndex) {
        if (tab.disabled) {
            return;
        }
        this.currentSelectedTab = tabIndex;
        this.tabs.forEach(function (_tab) { return _tab.active = false; });
        tab.active = true;
        tab.doSelect();
    };
    TabHeaders.prototype.handleScroll = function () {
        this.changeDetectorRef.markForCheck();
    };
    TabHeaders.prototype.handleOverflowNavClick = function (direction, multiplier) {
        if (multiplier === void 0) { multiplier = 15; }
        var tabList = this.headerContainer.nativeElement;
        var clientWidth = tabList.clientWidth, scrollLeft = tabList.scrollLeft, scrollWidth = tabList.scrollWidth;
        if (direction === 1 && !scrollLeft) {
            tabList.scrollLeft += this.OVERFLOW_BUTTON_OFFSET;
        }
        tabList.scrollLeft += direction * multiplier;
        var leftEdgeReached = direction === -1 && scrollLeft < this.OVERFLOW_BUTTON_OFFSET;
        var rightEdgeReached = direction === 1 &&
            scrollLeft + clientWidth >= scrollWidth - this.OVERFLOW_BUTTON_OFFSET;
        if (leftEdgeReached) {
            this.rightOverflowNavButton.nativeElement.focus();
        }
        if (rightEdgeReached) {
            this.leftOverflowNavButton.nativeElement.focus();
        }
    };
    TabHeaders.prototype.handleOverflowNavMouseDown = function (direction) {
        var _this = this;
        var tabList = this.headerContainer.nativeElement;
        this.overflowNavInterval = setInterval(function () {
            var clientWidth = tabList.clientWidth, scrollLeft = tabList.scrollLeft, scrollWidth = tabList.scrollWidth;
            // clear interval if scroll reaches left or right edge
            var leftEdgeReached = direction === -1 && scrollLeft < _this.OVERFLOW_BUTTON_OFFSET;
            var rightEdgeReached = direction === 1 &&
                scrollLeft + clientWidth >= scrollWidth - _this.OVERFLOW_BUTTON_OFFSET;
            if (leftEdgeReached || rightEdgeReached) {
                clearInterval(_this.overflowNavInterval);
            }
            // account for overflow button appearing and causing tablist width change
            _this.handleOverflowNavClick(direction);
        });
    };
    TabHeaders.prototype.handleOverflowNavMouseUp = function () {
        clearInterval(this.overflowNavInterval);
    };
    /**
     * Determines which `Tab` is initially selected.
     */
    TabHeaders.prototype.setFirstTab = function () {
        var _this = this;
        setTimeout(function () {
            var firstTab = _this.tabs.find(function (tab) { return tab.active; });
            if (!firstTab && _this.tabs.first) {
                firstTab = _this.tabs.first;
                firstTab.active = true;
            }
            if (firstTab) {
                firstTab.doSelect();
            }
        });
    };
    TabHeaders.decorators = [
        { type: Component, args: [{
                    selector: "ibm-tab-headers",
                    template: "\n\t\t<nav\n\t\t\tclass=\"bx--tabs--scrollable\"\n\t\t\t[ngClass]=\"{\n\t\t\t\t'bx--skeleton': skeleton,\n\t\t\t\t'bx--tabs--container bx--tabs--scrollable--container': type === 'container'\n\t\t\t}\"\n\t\t\trole=\"navigation\"\n\t\t\t[attr.aria-label]=\"ariaLabel\"\n\t\t\t[attr.aria-labelledby]=\"ariaLabelledby\">\n\t\t\t<button\n\t\t\t\t#leftOverflowNavButton\n\t\t\t\ttype=\"button\"\n\t\t\t\t[ngClass]=\"{\n\t\t\t\t\t'bx--tab--overflow-nav-button': hasHorizontalOverflow,\n\t\t\t\t\t'bx--tab--overflow-nav-button--hidden': leftOverflowNavButtonHidden\n\t\t\t\t}\"\n\t\t\t\t(click)=\"handleOverflowNavClick(-1)\"\n\t\t\t\t(mousedown)=\"handleOverflowNavMouseDown(-1)\"\n\t\t\t\t(mouseup)=\"handleOverflowNavMouseUp()\">\n\t\t\t\t<svg\n\t\t\t\t\tfocusable=\"false\"\n\t\t\t\t\tpreserveAspectRatio=\"xMidYMid meet\"\n\t\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\t\t\tfill=\"currentColor\"\n\t\t\t\t\twidth=\"16\"\n\t\t\t\t\theight=\"16\"\n\t\t\t\t\tviewBox=\"0 0 16 16\"\n\t\t\t\t\taria-hidden=\"true\">\n\t\t\t\t\t<path d=\"M5 8L10 3 10.7 3.7 6.4 8 10.7 12.3 10 13z\"></path>\n\t\t\t\t</svg>\n\t\t\t</button>\n\t\t\t<div *ngIf=\"!leftOverflowNavButtonHidden\" class=\"bx--tabs__overflow-indicator--left\"></div>\n\t\t\t<ul\n\t\t\t\t#tabList\n\t\t\t\tclass=\"bx--tabs--scrollable__nav\"\n\t\t\t\trole=\"tablist\"\n\t\t\t\t(scroll)=\"handleScroll()\">\n\t\t\t\t<li role=\"presentation\">\n\t\t\t\t\t<ng-container *ngIf=\"contentBefore\" [ngTemplateOutlet]=\"contentBefore\"></ng-container>\n\t\t\t\t</li>\n\t\t\t\t<li\n\t\t\t\t\t*ngFor=\"let tab of tabs; let i = index;\"\n\t\t\t\t\t[ngClass]=\"{\n\t\t\t\t\t\t'bx--tabs__nav-item--selected bx--tabs--scrollable__nav-item--selected': tab.active,\n\t\t\t\t\t\t'bx--tabs__nav-item--disabled bx--tabs--scrollable__nav-item--disabled': tab.disabled\n\t\t\t\t\t}\"\n\t\t\t\t\tclass=\"bx--tabs--scrollable__nav-item\"\n\t\t\t\t\trole=\"presentation\"\n\t\t\t\t\t(click)=\"selectTab(tabItem, tab, i)\">\n\t\t\t\t\t<button\n\t\t\t\t\t\t#tabItem\n\t\t\t\t\t\t[attr.aria-selected]=\"tab.active\"\n\t\t\t\t\t\t[attr.tabindex]=\"(tab.active?0:-1)\"\n\t\t\t\t\t\t[attr.aria-controls]=\"tab.id\"\n\t\t\t\t\t\t[attr.aria-disabled]=\"tab.disabled\"\n\t\t\t\t\t\t(focus)=\"onTabFocus(tabItem, i)\"\n\t\t\t\t\t\t(click)=\"$event.preventDefault()\"\n\t\t\t\t\t\tdraggable=\"false\"\n\t\t\t\t\t\tid=\"{{tab.id}}-header\"\n\t\t\t\t\t\tclass=\"bx--tabs--scrollable__nav-link\"\n\t\t\t\t\t\t[title]=\"tab.title ? tab.title : tab.heading\"\n\t\t\t\t\t\thref=\"#\"\n\t\t\t\t\t\trole=\"tab\">\n\t\t\t\t\t\t<ng-container *ngIf=\"!tab.headingIsTemplate\">\n\t\t\t\t\t\t\t{{ tab.heading }}\n\t\t\t\t\t\t</ng-container>\n\t\t\t\t\t\t<ng-template\n\t\t\t\t\t\t\t*ngIf=\"tab.headingIsTemplate\"\n\t\t\t\t\t\t\t[ngTemplateOutlet]=\"tab.heading\"\n\t\t\t\t\t\t\t[ngTemplateOutletContext]=\"{$implicit: tab.context}\">\n\t\t\t\t\t\t</ng-template>\n\t\t\t\t\t</button>\n\t\t\t\t</li>\n\t\t\t\t<li role=\"presentation\">\n\t\t\t\t\t<ng-container *ngIf=\"contentAfter\" [ngTemplateOutlet]=\"contentAfter\"></ng-container>\n\t\t\t\t</li>\n\t\t\t</ul>\n\t\t\t<div *ngIf=\"!rightOverflowNavButtonHidden\" class=\"bx--tabs__overflow-indicator--right\"></div>\n\t\t\t<button\n\t\t\t\t#rightOverflowNavButton\n\t\t\t\ttype=\"button\"\n\t\t\t\t[ngClass]=\"{\n\t\t\t\t\t'bx--tab--overflow-nav-button': hasHorizontalOverflow,\n\t\t\t\t\t'bx--tab--overflow-nav-button--hidden': rightOverflowNavButtonHidden\n\t\t\t\t}\"\n\t\t\t\t(click)=\"handleOverflowNavClick(1)\"\n\t\t\t\t(mousedown)=\"handleOverflowNavMouseDown(1)\"\n\t\t\t\t(mouseup)=\"handleOverflowNavMouseUp()\">\n\t\t\t\t<svg\n\t\t\t\t\tfocusable=\"false\"\n\t\t\t\t\tpreserveAspectRatio=\"xMidYMid meet\"\n\t\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\t\t\tfill=\"currentColor\"\n\t\t\t\t\twidth=\"16\"\n\t\t\t\t\theight=\"16\"\n\t\t\t\t\tviewBox=\"0 0 16 16\"\n\t\t\t\t\taria-hidden=\"true\">\n\t\t\t\t\t<path d=\"M11 8L6 13 5.3 12.3 9.6 8 5.3 3.7 6 3z\"></path>\n\t\t\t\t</svg>\n\t\t\t</button>\n\t\t</nav>\n\t"
                }] }
    ];
    /** @nocollapse */
    TabHeaders.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ChangeDetectorRef },
        { type: EventService }
    ]; };
    TabHeaders.propDecorators = {
        tabInput: [{ type: Input, args: ["tabs",] }],
        cacheActive: [{ type: Input }],
        followFocus: [{ type: Input }],
        skeleton: [{ type: Input }],
        ariaLabel: [{ type: Input }],
        ariaLabelledby: [{ type: Input }],
        contentBefore: [{ type: Input }],
        contentAfter: [{ type: Input }],
        type: [{ type: Input }],
        headerContainer: [{ type: ViewChild, args: ["tabList", { static: true },] }],
        rightOverflowNavButton: [{ type: ViewChild, args: ["rightOverflowNavButton", { static: true },] }],
        leftOverflowNavButton: [{ type: ViewChild, args: ["leftOverflowNavButton", { static: true },] }],
        tabQuery: [{ type: ContentChildren, args: [Tab,] }],
        allTabHeaders: [{ type: ViewChildren, args: ["tabItem",] }],
        keyboardInput: [{ type: HostListener, args: ["keydown", ["$event"],] }]
    };
    return TabHeaders;
}());

/**
 * Build out your application's tabs using this component.
 * This is the parent of the `Tab` and `TabHeader` components.
 *
 * [See demo](../../?path=/story/tabs--basic)
 *
 * `Tabs` expects a set of `n-tab` elements
 *
 * ```html
 * <ibm-tabs>
 * 	<ibm-tab heading='tab1'>
 * 		tab 1 content
 * 	</ibm-tab>
 * 	<ibm-tab heading='tab1'>
 * 		tab 2 content
 * 	</ibm-tab>
 * 	<!-- ... -->
 * 	<ibm-tab heading='tab1'>
 * 		tab n content
 * 	</ibm-tab>
 * </ibm-tabs>
 * ```
 *
 * <example-url>../../iframe.html?id=tabs--basic</example-url>
 */
var Tabs = /** @class */ (function () {
    function Tabs() {
        /**
         * Takes either the string value 'top' or 'bottom' to place TabHeader
         * relative to the `TabPanel`s.
         */
        this.position = "top";
        /**
         * Set to 'true' to have `Tab` items cached and not reloaded on tab switching.
         */
        this.cacheActive = false;
        /**
         * Set to 'true' to have tabs automatically activated and have their content displayed when they receive focus.
         */
        this.followFocus = true;
        /**
         * Set to `true` to put tabs in a loading state.
         */
        this.skeleton = false;
        /**
         * Set to `true` to have the tabIndex of the all tabpanels be -1.
         */
        this.isNavigation = false;
        /**
         * Sets the type of the `TabHeader`s
         */
        this.type = "default";
    }
    /**
     * After content is initialized update `Tab`s to cache (if turned on) and set the initial
     * selected Tab item.
     */
    Tabs.prototype.ngAfterContentInit = function () {
        var _this = this;
        if (this.tabHeaders) {
            this.tabHeaders.cacheActive = this.cacheActive;
        }
        this.tabs.forEach(function (tab) {
            tab.tabIndex = _this.isNavigation ? null : 0;
        });
    };
    Tabs.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (this.tabHeaders && changes.cacheActive) {
            this.tabHeaders.cacheActive = this.cacheActive;
        }
        if (this.tabs && changes.isNavigation) {
            this.tabs.forEach(function (tab) {
                tab.tabIndex = _this.isNavigation ? null : 0;
            });
        }
    };
    /**
     * true if the n-tab's are passed directly to the component as children
     */
    Tabs.prototype.hasTabHeaders = function () {
        return this.tabs.length > 0;
    };
    Tabs.decorators = [
        { type: Component, args: [{
                    selector: "ibm-tabs",
                    template: "\n\t\t\t<ibm-tab-headers\n\t\t\t\t*ngIf=\"hasTabHeaders() && position === 'top'\"\n\t\t\t\t[skeleton]=\"skeleton\"\n\t\t\t\t[tabs]=\"tabs\"\n\t\t\t\t[followFocus]=\"followFocus\"\n\t\t\t\t[cacheActive]=\"cacheActive\"\n\t\t\t\t[contentBefore]=\"before\"\n\t\t\t\t[contentAfter]=\"after\"\n\t\t\t\t[ariaLabel]=\"ariaLabel\"\n\t\t\t\t[ariaLabelledby]=\"ariaLabelledby\"\n\t\t\t\t[type]=\"type\">\n\t\t\t</ibm-tab-headers>\n\t\t\t<ng-content></ng-content>\n\t\t\t<ng-template #before>\n\t\t\t\t<ng-content select=\"[before]\"></ng-content>\n\t\t\t</ng-template>\n\t\t\t<ng-template #after>\n\t\t\t\t<ng-content select=\"[after]\"></ng-content>\n\t\t\t</ng-template>\n\t\t\t<ibm-tab-headers\n\t\t\t\t*ngIf=\"hasTabHeaders() && position === 'bottom'\"\n\t\t\t\t[skeleton]=\"skeleton\"\n\t\t\t\t[tabs]=\"tabs\"\n\t\t\t\t[cacheActive]=\"cacheActive\"\n\t\t\t\t[type]=\"type\">\n\t\t\t</ibm-tab-headers>\n\t"
                }] }
    ];
    Tabs.propDecorators = {
        position: [{ type: Input }],
        cacheActive: [{ type: Input }],
        followFocus: [{ type: Input }],
        skeleton: [{ type: Input }],
        isNavigation: [{ type: Input }],
        ariaLabel: [{ type: Input }],
        ariaLabelledby: [{ type: Input }],
        type: [{ type: Input }],
        tabs: [{ type: ContentChildren, args: [Tab, { descendants: false },] }],
        tabHeaders: [{ type: ContentChild, args: [TabHeaders, { static: false },] }]
    };
    return Tabs;
}());

var TabsModule = /** @class */ (function () {
    function TabsModule() {
    }
    TabsModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        Tabs,
                        Tab,
                        TabHeaders,
                        TabHeader,
                        TabHeaderGroup
                    ],
                    exports: [
                        Tabs,
                        Tab,
                        TabHeaders,
                        TabHeader,
                        TabHeaderGroup
                    ],
                    imports: [
                        CommonModule,
                        UtilsModule
                    ]
                },] }
    ];
    return TabsModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { TabHeaderGroup, TabHeader, TabHeaders, Tab, Tabs, TabsModule };

//# sourceMappingURL=carbon-components-angular-tabs.js.map