/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-notification.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { of, isObservable } from 'rxjs';
import { ButtonModule } from 'carbon-components-angular/button';
import { CommonModule } from '@angular/common';
import { __extends } from 'tslib';
import { Injectable, ApplicationRef, Directive, HostBinding, Component, Input, Output, EventEmitter, ViewChild, ComponentFactoryResolver, Injector, NgZone, NgModule } from '@angular/core';
import { I18n, I18nModule } from 'carbon-components-angular/i18n';
import { ExperimentalService, ExperimentalModule } from 'carbon-components-angular/experimental';
import { LinkModule } from 'carbon-components-angular/link';
import { IconModule } from 'carbon-components-angular/icon';

var NotificationDisplayService = /** @class */ (function () {
    function NotificationDisplayService(applicationRef) {
        this.applicationRef = applicationRef;
    }
    /**
     * Programatically closes notification based on `notificationRef`.	 *
     */
    NotificationDisplayService.prototype.close = function (notificationRef) {
        var _this = this;
        if (notificationRef.hostView) {
            setTimeout(function () {
                _this.applicationRef.detachView(notificationRef.hostView);
                notificationRef.destroy();
            }, 200);
        }
    };
    NotificationDisplayService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    NotificationDisplayService.ctorParameters = function () { return [
        { type: ApplicationRef }
    ]; };
    return NotificationDisplayService;
}());

var NotificationSubtitle = /** @class */ (function () {
    function NotificationSubtitle() {
        this.baseClass = true;
    }
    NotificationSubtitle.decorators = [
        { type: Directive, args: [{
                    selector: "[ibmNotificationSubtitle]"
                },] }
    ];
    NotificationSubtitle.propDecorators = {
        baseClass: [{ type: HostBinding, args: ["class.bx--inline-notification__subtitle",] }]
    };
    return NotificationSubtitle;
}());

var NotificationTitle = /** @class */ (function () {
    function NotificationTitle() {
        this.baseClass = true;
    }
    NotificationTitle.decorators = [
        { type: Directive, args: [{
                    selector: "[ibmNotificationTitle]"
                },] }
    ];
    NotificationTitle.propDecorators = {
        baseClass: [{ type: HostBinding, args: ["class.bx--inline-notification__title",] }]
    };
    return NotificationTitle;
}());

/**
 * Notification messages are displayed toward the top of the UI and do not interrupt userâ€™s work.
 *
 * [See demo](../../?path=/story/notification--basic)
 *
 * <example-url>../../iframe.html?id=notification--basic</example-url>
 */
var Notification = /** @class */ (function () {
    function Notification(notificationDisplayService, i18n) {
        this.notificationDisplayService = notificationDisplayService;
        this.i18n = i18n;
        /**
         * Emits on close.
         */
        this.close = new EventEmitter();
        this.notificationID = "notification-" + Notification.notificationCount++;
        this.notificationClass = true;
        this.role = "alert";
        this.defaultNotificationObj = {
            title: "",
            message: "",
            type: "info",
            showClose: true,
            closeLabel: this.i18n.get("NOTIFICATION.CLOSE_BUTTON")
        };
        this._notificationObj = Object.assign({}, this.defaultNotificationObj);
    }
    Object.defineProperty(Notification.prototype, "notificationObj", {
        /**
         * Can have `type`, `title`, and `message` members.
         *
         * `type` can be one of `"info"`, `"warning"`, `"error"`, `"success"`
         *
         * `message` is the message to display
         */
        get: function () {
            return this._notificationObj;
        },
        set: function (obj) {
            if (obj.closeLabel) {
                obj.closeLabel = of(obj.closeLabel);
            }
            this._notificationObj = Object.assign({}, this.defaultNotificationObj, obj);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Notification.prototype, "isError", {
        get: function () { return this.notificationObj.type === "error"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Notification.prototype, "isInfo", {
        get: function () { return this.notificationObj.type === "info"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Notification.prototype, "isSuccess", {
        get: function () { return this.notificationObj.type === "success"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Notification.prototype, "isWarning", {
        get: function () { return this.notificationObj.type === "warning"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Notification.prototype, "isLowContrast", {
        get: function () { return this.notificationObj.lowContrast; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Notification.prototype, "isCloseHidden", {
        get: function () { return !this._notificationObj.showClose; },
        enumerable: true,
        configurable: true
    });
    /**
     * Emits close event.
     */
    Notification.prototype.onClose = function () {
        this.close.emit();
    };
    Notification.prototype.onClick = function (action, event) {
        if (!action.click) {
            return;
        }
        if (isObservable(action.click)) {
            action.click.next({ event: event, action: action });
        }
        else {
            action.click({ event: event, action: action });
        }
    };
    Notification.prototype.destroy = function () {
        this.notificationDisplayService.close(this);
    };
    Notification.notificationCount = 0;
    Notification.decorators = [
        { type: Component, args: [{
                    selector: "ibm-notification",
                    template: "\n\t\t<div class=\"bx--inline-notification__details\">\n\t\t\t<svg\n\t\t\t\tibmIcon=\"error--filled\"\n\t\t\t\tsize=\"16\"\n\t\t\t\t*ngIf=\"notificationObj.type === 'error'\"\n\t\t\t\tclass=\"bx--inline-notification__icon\">\n\t\t\t</svg>\n\t\t\t<svg\n\t\t\t\tibmIcon=\"warning--filled\"\n\t\t\t\tsize=\"16\"\n\t\t\t\t*ngIf=\"notificationObj.type === 'warning'\"\n\t\t\t\tclass=\"bx--inline-notification__icon\">\n\t\t\t</svg>\n\t\t\t<svg\n\t\t\t\tibmIcon=\"checkmark--filled\"\n\t\t\t\tsize=\"16\"\n\t\t\t\t*ngIf=\"notificationObj.type === 'success'\"\n\t\t\t\tclass=\"bx--inline-notification__icon\">\n\t\t\t</svg>\n\t\t\t<svg\n\t\t\t\tibmIcon=\"information--filled\"\n\t\t\t\tsize=\"16\"\n\t\t\t\t*ngIf=\"notificationObj.type === 'info'\"\n\t\t\t\tclass=\"bx--inline-notification__icon\">\n\t\t\t</svg>\n\t\t\t<div class=\"bx--inline-notification__text-wrapper\">\n\t\t\t\t<p *ngIf=\"!notificationObj.template\" ibmNotificationTitle [innerHTML]=\"notificationObj.title\"></p>\n\t\t\t\t<div *ngIf=\"!notificationObj.template\" ibmNotificationSubtitle>\n\t\t\t\t\t<span [innerHTML]=\"notificationObj.message\"></span>\n\t\t\t\t\t<ng-container *ngFor=\"let link of notificationObj.links\">\n\t\t\t\t\t\t<a ibmLink [href]=\"link.href\"> {{link.text}}</a>\n\t\t\t\t\t</ng-container>\n\t\t\t\t</div>\n\t\t\t\t<ng-container *ngTemplateOutlet=\"notificationObj.template; context: { $implicit: notificationObj}\"></ng-container>\n\t\t\t</div>\n\t\t</div>\n\t\t<div *ngFor=\"let action of notificationObj.actions\">\n\t\t\t<button\n\t\t\t\t(click)=\"onClick(action, $event)\"\n\t\t\t\tibmButton=\"ghost\"\n\t\t\t\tsize=\"sm\"\n\t\t\t\tclass=\"bx--inline-notification__action-button\"\n\t\t\t\ttype=\"button\">\n\t\t\t\t{{action.text}}\n\t\t\t</button>\n\t\t</div>\n\t\t<button\n\t\t\t*ngIf=\"!isCloseHidden\"\n\t\t\t(click)=\"onClose()\"\n\t\t\tclass=\"bx--inline-notification__close-button\"\n\t\t\t[attr.aria-label]=\"notificationObj.closeLabel | async\"\n\t\t\ttype=\"button\">\n\t\t\t<svg ibmIcon=\"close\" size=\"16\" class=\"bx--inline-notification__close-icon\"></svg>\n\t\t</button>\n\t"
                }] }
    ];
    /** @nocollapse */
    Notification.ctorParameters = function () { return [
        { type: NotificationDisplayService },
        { type: I18n }
    ]; };
    Notification.propDecorators = {
        notificationObj: [{ type: Input }],
        close: [{ type: Output }],
        notification: [{ type: ViewChild, args: ["notification", { static: false },] }],
        notificationID: [{ type: HostBinding, args: ["attr.id",] }],
        notificationClass: [{ type: HostBinding, args: ["class.bx--inline-notification",] }],
        role: [{ type: HostBinding, args: ["attr.role",] }],
        isError: [{ type: HostBinding, args: ["class.bx--inline-notification--error",] }],
        isInfo: [{ type: HostBinding, args: ["class.bx--inline-notification--info",] }],
        isSuccess: [{ type: HostBinding, args: ["class.bx--inline-notification--success",] }],
        isWarning: [{ type: HostBinding, args: ["class.bx--inline-notification--warning",] }],
        isLowContrast: [{ type: HostBinding, args: ["class.bx--inline-notification--low-contrast",] }],
        isCloseHidden: [{ type: HostBinding, args: ["class.bx--inline-notification--hide-close-button",] }]
    };
    return Notification;
}());

/**
 * Toast messages are displayed toward the top of the UI and do not interrupt userâ€™s work.
 *
 * [See demo](../../?path=/story/notification--toast)
 *
 * <example-url>../../iframe.html?id=notification--toast</example-url>
 */
var Toast = /** @class */ (function (_super) {
    __extends(Toast, _super);
    function Toast(notificationDisplayService, i18n, experimental) {
        var _this = _super.call(this, notificationDisplayService, i18n) || this;
        _this.notificationDisplayService = notificationDisplayService;
        _this.i18n = i18n;
        _this.experimental = experimental;
        _this.toastID = "toast-" + Toast.toastCount++;
        _this.toastClass = true;
        _this.role = "alert";
        // disable inline notification styles
        _this.notificationClass = false;
        return _this;
    }
    Object.defineProperty(Toast.prototype, "isError", {
        get: function () { return this.notificationObj["type"] === "error"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Toast.prototype, "isInfo", {
        get: function () { return this.notificationObj["type"] === "info"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Toast.prototype, "isSuccess", {
        get: function () { return this.notificationObj["type"] === "success"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Toast.prototype, "isWarning", {
        get: function () { return this.notificationObj["type"] === "warning"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Toast.prototype, "isLowContrast", {
        get: function () { return this.notificationObj.lowContrast; },
        enumerable: true,
        configurable: true
    });
    Toast.prototype.ngOnInit = function () {
        if (!this.notificationObj.closeLabel) {
            this.notificationObj.closeLabel = this.i18n.get().NOTIFICATION.CLOSE_BUTTON;
        }
    };
    Toast.toastCount = 0;
    Toast.decorators = [
        { type: Component, args: [{
                    selector: "ibm-toast",
                    template: "\n\t\t<svg\n\t\t\tibmIcon=\"error--filled\"\n\t\t\tsize=\"16\"\n\t\t\t*ngIf=\"notificationObj.type === 'error'\"\n\t\t\tclass=\"bx--toast-notification__icon\">\n\t\t</svg>\n\t\t<svg\n\t\t\tibmIcon=\"warning--filled\"\n\t\t\tsize=\"16\"\n\t\t\t*ngIf=\"notificationObj.type === 'warning'\"\n\t\t\tclass=\"bx--toast-notification__icon\">\n\t\t</svg>\n\t\t<svg\n\t\t\tibmIcon=\"checkmark--filled\"\n\t\t\tsize=\"16\"\n\t\t\t*ngIf=\"notificationObj.type === 'success'\"\n\t\t\tclass=\"bx--toast-notification__icon\">\n\t\t</svg>\n\t\t<svg\n\t\t\tibmIcon=\"information--filled\"\n\t\t\tsize=\"16\"\n\t\t\t*ngIf=\"notificationObj.type === 'info'\"\n\t\t\tclass=\"bx--toast-notification__icon\">\n\t\t</svg>\n\t\t<div class=\"bx--toast-notification__details\">\n\t\t\t<h3 *ngIf=\"!notificationObj.template\" ibmToastTitle [innerHTML]=\"notificationObj.title\"></h3>\n\t\t\t<div *ngIf=\"!notificationObj.template\" ibmToastSubtitle>\n\t\t\t\t<span [innerHTML]=\"notificationObj.subtitle\"></span>\n\t\t\t\t<ng-container *ngFor=\"let link of notificationObj.links\">\n\t\t\t\t\t<a ibmLink [href]=\"link.href\"> {{link.text}}</a>\n\t\t\t\t</ng-container>\n\t\t\t</div>\n\t\t\t<p *ngIf=\"!notificationObj.template\" ibmToastCaption [innerHTML]=\"notificationObj.caption\"></p>\n\t\t\t<ng-container *ngTemplateOutlet=\"notificationObj.template; context: { $implicit: notificationObj}\"></ng-container>\n\t\t</div>\n\t\t<button\n\t\t\t*ngIf=\"!isCloseHidden\"\n\t\t\tclass=\"bx--toast-notification__close-button\"\n\t\t\ttype=\"button\"\n\t\t\t[attr.aria-label]=\"notificationObj.closeLabel\"\n\t\t\t(click)=\"onClose()\">\n\t\t\t<svg ibmIcon=\"close\" size=\"16\" class=\"bx--toast-notification__close-icon\"></svg>\n\t\t</button>\n\t"
                }] }
    ];
    /** @nocollapse */
    Toast.ctorParameters = function () { return [
        { type: NotificationDisplayService },
        { type: I18n },
        { type: ExperimentalService }
    ]; };
    Toast.propDecorators = {
        notificationObj: [{ type: Input }],
        toastID: [{ type: HostBinding, args: ["attr.id",] }],
        toastClass: [{ type: HostBinding, args: ["class.bx--toast-notification",] }],
        role: [{ type: HostBinding, args: ["attr.role",] }],
        isError: [{ type: HostBinding, args: ["class.bx--toast-notification--error",] }],
        isInfo: [{ type: HostBinding, args: ["class.bx--toast-notification--info",] }],
        isSuccess: [{ type: HostBinding, args: ["class.bx--toast-notification--success",] }],
        isWarning: [{ type: HostBinding, args: ["class.bx--toast-notification--warning",] }],
        isLowContrast: [{ type: HostBinding, args: ["class.bx--toast-notification--low-contrast",] }]
    };
    return Toast;
}(Notification));

var ToastTitle = /** @class */ (function () {
    function ToastTitle() {
        this.baseClass = true;
    }
    ToastTitle.decorators = [
        { type: Directive, args: [{
                    selector: "[ibmToastTitle]"
                },] }
    ];
    ToastTitle.propDecorators = {
        baseClass: [{ type: HostBinding, args: ["class.bx--toast-notification__title",] }]
    };
    return ToastTitle;
}());

var ToastSubtitle = /** @class */ (function () {
    function ToastSubtitle() {
        this.baseClass = true;
    }
    ToastSubtitle.decorators = [
        { type: Directive, args: [{
                    selector: "[ibmToastSubtitle]"
                },] }
    ];
    ToastSubtitle.propDecorators = {
        baseClass: [{ type: HostBinding, args: ["class.bx--toast-notification__subtitle",] }]
    };
    return ToastSubtitle;
}());

var ToastCaption = /** @class */ (function () {
    function ToastCaption() {
        this.baseClass = true;
    }
    ToastCaption.decorators = [
        { type: Directive, args: [{
                    selector: "[ibmToastCaption]"
                },] }
    ];
    ToastCaption.propDecorators = {
        baseClass: [{ type: HostBinding, args: ["class.bx--toast-notification__caption",] }]
    };
    return ToastCaption;
}());

/**
 * Provides a way to use the notification component.
 *
 * Notifications are displayed toward the top of the UI and do not interrupt the userâ€™s work.
 */
var NotificationService = /** @class */ (function () {
    /**
     * Constructs NotificationService.
     *
     * @param injector
     * @param componentFactoryResolver
     * @param applicationRef
     */
    function NotificationService(injector, componentFactoryResolver, applicationRef, ngZone) {
        this.injector = injector;
        this.componentFactoryResolver = componentFactoryResolver;
        this.applicationRef = applicationRef;
        this.ngZone = ngZone;
        /**
         * An array containing `ComponentRef`s to all the notifications this service instance
         * is responsible for.
         *
         */
        this.notificationRefs = new Array();
        this.onClose = new EventEmitter();
    }
    /**
     * Shows the notification based on the `notificationObj`.
     *
     * @param notificationObj Can have `type`, `message`, `target`, `duration` and `smart` members.
     *
     * **Members:**
     *
     * * `type` can be one of `"info"`, `"warning"`, `"danger"`, `"success"`
     * * `message` is message for notification to display
     * * `target` is css selector defining an element to append notification to. If not provided,
     * `showNotification()` creates a place for the notification in `body`
     * * `duration` is number of ms to close the notification after. If used in combination with `smart`,
     * it's added to the calculated timeout
     * * `smart`, set to `true` if you want to use smart notification.
     *
     * **Example:**
     * ```typescript
     * // Info notification, saying "Sample message." added to the element with id notification-container
     * // uses smart timeout with added duration of 1 second.
     * {
     *	type: "info",
     *	message: "Sample message.",
     *	target: "#notification-container",
     *	duration: 1000,
     *	smart: true
     * }
     * ```
     *
     * @param [notificationComp=Notification] If provided, used to resolve component factory
     */
    NotificationService.prototype.showNotification = function (notificationObj, notificationComp) {
        var _this = this;
        if (notificationComp === void 0) { notificationComp = Notification; }
        var componentFactory = this.componentFactoryResolver.resolveComponentFactory(notificationComp);
        var notificationRef = componentFactory.create(this.injector);
        notificationRef.instance.notificationObj = notificationObj; // typescript isn't being very smart here, so we type to any
        this.notificationRefs.push(notificationRef);
        this.onClose = notificationRef.instance.close;
        this.applicationRef.attachView(notificationRef.hostView);
        if (notificationObj.target) {
            document.querySelector(notificationObj.target).appendChild(notificationRef.location.nativeElement);
        }
        else {
            var body = document.querySelector("body");
            // get or create a container for alert list
            var notificationClassName = "notification-overlay";
            var notificationList = body.querySelector("." + notificationClassName);
            if (!notificationList) {
                notificationList = document.createElement("div");
                notificationList.className = notificationClassName;
                body.appendChild(notificationList);
            }
            // add the notification to the top of the list
            if (notificationList.firstChild) {
                notificationList.insertBefore(notificationRef.location.nativeElement, notificationList.firstChild);
            }
            else {
                notificationList.appendChild(notificationRef.location.nativeElement);
            }
        }
        if (notificationObj.duration && notificationObj.duration > 0) {
            this.ngZone.runOutsideAngular(function () {
                setTimeout(function () {
                    _this.ngZone.run(function () {
                        _this.close(notificationRef);
                    });
                }, notificationObj.duration);
            });
        }
        if (notificationObj.smart) {
            this.ngZone.runOutsideAngular(function () {
                // let it disappear after calculated timeout
                setTimeout(function () {
                    _this.ngZone.run(function () {
                        _this.close(notificationRef);
                    });
                }, _this.getSmartTimeout(notificationObj));
            });
        }
        this.onClose.subscribe(function () {
            _this.close(notificationRef);
        });
        notificationRef.instance.componentRef = notificationRef;
        return notificationRef.instance;
    };
    NotificationService.prototype.showToast = function (notificationObj, notificationComp) {
        if (notificationComp === void 0) { notificationComp = Toast; }
        return this.showNotification(notificationObj, notificationComp);
    };
    /**
     * Programatically closes notification based on `notificationRef`.
     *
     * @param notificationRef `ComponentRef` of a notification or `Notification` component you wish to close
     */
    NotificationService.prototype.close = function (notificationRef) {
        if (notificationRef) {
            if (notificationRef instanceof Notification) {
                this.close(notificationRef.componentRef);
            }
            else {
                this.applicationRef.detachView(notificationRef.hostView);
                notificationRef.destroy();
                var index = this.notificationRefs.indexOf(notificationRef);
                if (index !== -1) {
                    this.notificationRefs.splice(index, 1);
                }
            }
        }
    };
    /**
     * Calculates the amount of time user needs to read the message in the notification.
     *
     * @param notificationObj Same object used to instantiate notification.
     *
     * In addition to `type` and `message` members, use `duration` member to add
     * some extra time (in ms) to timeout if you need to.
     * @returns calculated timeout (in ms) for smart notification
     */
    NotificationService.prototype.getSmartTimeout = function (notificationObj) {
        // calculate timeout
        var timeout = 600; // start with reaction time
        // custom duration
        timeout += notificationObj.duration || 0;
        // message type
        switch (notificationObj.type) {
            case "info":
            case "success":
            default: {
                break;
            }
            case "danger": {
                timeout += 3000;
                break;
            }
            case "warning": {
                timeout += 1500;
                break;
            }
        }
        // message length
        // average reader reads around 200 words per minute, or it takes them ~0.3s per word
        // let's use 1.5 factor for below average speed readers and have 0.45s per word
        var wordCount = notificationObj.message.trim().split(/\s+/).length;
        timeout += wordCount * 450;
        return timeout;
    };
    /**
     * OnDestroy hook.
     *
     * Destroys all living notifications it is responsible for.
     *
     */
    NotificationService.prototype.ngOnDestroy = function () {
        if (this.notificationRefs.length > 0) {
            for (var i = 0; i < this.notificationRefs.length; i++) {
                var notificationRef = this.notificationRefs[i];
                this.applicationRef.detachView(notificationRef.hostView);
                notificationRef.destroy();
            }
            this.notificationRefs.length = 0;
        }
    };
    NotificationService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    NotificationService.ctorParameters = function () { return [
        { type: Injector },
        { type: ComponentFactoryResolver },
        { type: ApplicationRef },
        { type: NgZone }
    ]; };
    return NotificationService;
}());

var NotificationModule = /** @class */ (function () {
    function NotificationModule() {
    }
    NotificationModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        Notification,
                        Toast,
                        ToastTitle,
                        ToastSubtitle,
                        ToastCaption,
                        NotificationTitle,
                        NotificationSubtitle
                    ],
                    exports: [
                        Notification,
                        Toast,
                        ToastTitle,
                        ToastSubtitle,
                        ToastCaption,
                        NotificationTitle,
                        NotificationSubtitle
                    ],
                    entryComponents: [Notification, Toast],
                    imports: [
                        ButtonModule,
                        CommonModule,
                        I18nModule,
                        ExperimentalModule,
                        LinkModule,
                        IconModule
                    ],
                    providers: [NotificationService, NotificationDisplayService]
                },] }
    ];
    return NotificationModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { NotificationDisplayService, NotificationSubtitle, NotificationTitle, Notification, NotificationModule, NotificationService, ToastCaption, ToastSubtitle, ToastTitle, Toast };

//# sourceMappingURL=carbon-components-angular-notification.js.map