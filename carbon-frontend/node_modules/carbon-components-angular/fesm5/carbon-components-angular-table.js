/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-table.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Subject, BehaviorSubject, combineLatest, Subscription, fromEvent } from 'rxjs';
import { tabbableSelectorIgnoreTabIndex, getFocusElementList } from 'carbon-components-angular/common';
import { merge, getScrollbarWidth } from 'carbon-components-angular/utils';
import { map } from 'rxjs/operators';
import { EventEmitter, Component, Input, Output, HostBinding, Directive, HostListener, ApplicationRef, ElementRef, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { NFormsModule } from 'carbon-components-angular/forms';
import { DialogModule } from 'carbon-components-angular/dialog';
import { I18n, I18nModule } from 'carbon-components-angular/i18n';
import { ButtonModule } from 'carbon-components-angular/button';
import { Search, SearchModule } from 'carbon-components-angular/search';
import { IconModule } from 'carbon-components-angular/icon';
import { __extends, __values, __read, __spread } from 'tslib';

var TableHeaderItem = /** @class */ (function () {
    /**
     * Creates an instance of TableHeaderItem.
     */
    function TableHeaderItem(rawData) {
        var e_1, _a;
        /**
         * Defines if column under this TableHeaderItem should be displayed.
         *
         */
        this.visible = true;
        /**
         * Disables sorting by default.
         *
         */
        this.sorted = false;
        /**
         * Enables sorting on click by default.
         * If false then this column won't show a sorting arrow at all.
         *
         */
        this.sortable = true;
        /**
         * Number of applied filters.
         *
         * `filter()` should set it to appropriate number.
         *
         */
        this.filterCount = 0;
        /**
         * The number of rows to span
         * **NOTE:** not supported by the default carbon table
         */
        this.rowSpan = 1;
        /**
         * The number of columns to span
         */
        this.colSpan = 1;
        /**
         * Style for the column, applied to every element in the column.
         *
         * ngStyle-like format
         *
         */
        this.style = {};
        /**
         * used in `ascending`
         *
         * @protected
         */
        this._ascending = true;
        // defaults so we dont leave things empty
        var defaults = {
            data: "",
            visible: this.visible,
            style: this.style,
            filterCount: this.filterCount,
            filterData: { data: "" }
        };
        // fill our object with provided props, and fallback to defaults
        var data = Object.assign({}, defaults, rawData);
        try {
            for (var _b = __values(Object.getOwnPropertyNames(data)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var property = _c.value;
                if (data.hasOwnProperty(property)) {
                    this[property] = data[property];
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    Object.defineProperty(TableHeaderItem.prototype, "ascending", {
        get: function () {
            return this._ascending;
        },
        /**
         * If true, sort is set to ascending, if false descending will be true.
         *
         */
        set: function (asc) {
            this._ascending = asc;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableHeaderItem.prototype, "descending", {
        get: function () {
            return !this._ascending;
        },
        /**
         * If true, sort is set to descending, if false ascending will be true.
         *
         */
        set: function (desc) {
            this._ascending = !desc;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Used for sorting rows of the table.
     *
     * Override to enable different sorting.
     *
     * < 0 if `one` should go before `two`
     * > 0 if `one` should go after `two`
     * 0 if it doesn't matter (they are the same)
     */
    TableHeaderItem.prototype.compare = function (one, two) {
        if (!one || !two) {
            return 0;
        }
        if (typeof one.data === "string") {
            return one.data.localeCompare(two.data);
        }
        if (one.data < two.data) {
            return -1;
        }
        else if (one.data > two.data) {
            return 1;
        }
        else {
            return 0;
        }
    };
    /**
     * Used to filter rows in the table.
     *
     * Override to make a custom filter.
     *
     * Even though there is just one filter function, there can be multiple filters.
     * When implementing filter, set `filterCount` before returning.
     *
     * `true` to hide the row
     * `false` to show the row
     */
    TableHeaderItem.prototype.filter = function (item) {
        this.filterCount = 0;
        return false;
    };
    return TableHeaderItem;
}());

var TableItem = /** @class */ (function () {
    /**
     * Creates an instance of TableItem.
     */
    function TableItem(rawData) {
        var e_1, _a;
        /**
         * The number of rows to span
         */
        this.rowSpan = 1;
        /**
         * The number of columns to span
         */
        this.colSpan = 1;
        // defaults so we dont leave things empty
        var defaults = {
            data: ""
        };
        // fill our object with provided props, and fallback to defaults
        var data = Object.assign({}, defaults, rawData);
        try {
            for (var _b = __values(Object.getOwnPropertyNames(data)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var property = _c.value;
                if (data.hasOwnProperty(property)) {
                    this[property] = data[property];
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    Object.defineProperty(TableItem.prototype, "title", {
        get: function () {
            if (this._title) {
                return this._title;
            }
            if (!this.data) {
                return "";
            }
            if (typeof this.data === "string") {
                return this.data;
            }
            if (this.data.toString &&
                this.data.constructor !== ({}).constructor) {
                return this.data.toString();
            }
            // data canâ€™t be reasonably converted to an end user readable string
            return "";
        },
        set: function (title) {
            this._title = title;
        },
        enumerable: true,
        configurable: true
    });
    return TableItem;
}());

/**
 * TableModel represents a data model for two-dimensional data. It's used for all things table
 * (table component, table toolbar, pagination, etc)
 *
 * TableModel manages its internal data integrity very well if you use the provided helper
 * functions for modifying rows and columns and assigning header and data in that order.
 *
 * It also provides direct access to the data so you can read and modify it.
 * If you change the structure of the data (by directly pushing into the arrays or otherwise),
 * keep in mind to keep the data structure intact.
 *
 * Header length and length of every line in the data should be equal.
 *
 * If they are not consistent, unexpected things will happen.
 *
 * Use the provided functions when in doubt.
 */
var TableModel = /** @class */ (function () {
    function TableModel() {
        this.dataChange = new EventEmitter();
        this.rowsSelectedChange = new EventEmitter();
        this.rowsExpandedChange = new EventEmitter();
        /**
         * Gets emitted when `selectAll` is called. Emits false if all rows are deselected and true if
         * all rows are selected.
         */
        this.selectAllChange = new Subject();
        /**
         * Contains information about selection state of rows in the table.
         */
        this.rowsSelected = [];
        /**
         * Contains information about expanded state of rows in the table.
         */
        this.rowsExpanded = [];
        /**
         * Contains information about the context of the row.
         *
         * It affects styling of the row to reflect the context.
         *
         * string can be one of `"success" | "warning" | "info" | "error" | ""` and it's
         * empty or undefined by default
         */
        this.rowsContext = [];
        /**
         * Contains class name(s) of the row.
         *
         * It affects styling of the row to reflect the appended class name(s).
         *
         * It's empty or undefined by default
         */
        this.rowsClass = [];
        /**
         * Contains information about the header cells of the table.
         */
        this.header = [];
        /**
         * Tracks the current page.
         */
        this.currentPage = 1;
        /**
         * Length of page.
         */
        this.pageLength = 10;
        /**
         * Set to true when there is no more data to load in the table
         */
        this.isEnd = false;
        /**
         * Set to true when lazy loading to show loading indicator
         */
        this.isLoading = false;
        /**
         * Used in `data`
         */
        this._data = [[]];
        /**
         * The number of models instantiated, this is to make sure each table has a different
         * model count for unique id generation.
         */
        this.tableModelCount = 0;
        this.tableModelCount = TableModel.COUNT++;
    }
    Object.defineProperty(TableModel.prototype, "data", {
        /**
         * Gets the full data.
         *
         * You can use it to alter individual `TableItem`s but if you need to change
         * table structure, use `addRow()` and/or `addColumn()`
         */
        get: function () {
            return this._data;
        },
        /**
         * Sets data of the table.
         *
         * Make sure all rows are the same length to keep the column count accurate.
         */
        set: function (newData) {
            if (!newData || (Array.isArray(newData) && newData.length === 0)) {
                newData = [[]];
            }
            this._data = newData;
            // init rowsSelected
            this.rowsSelected = new Array(this._data.length).fill(false);
            this.rowsExpanded = new Array(this._data.length).fill(false);
            // init rowsContext
            this.rowsContext = new Array(this._data.length);
            // init rowsClass
            this.rowsClass = new Array(this._data.length);
            // only create a fresh header if necessary (header doesn't exist or differs in length)
            if (this.header == null || (this.header.length !== this._data[0].length && this._data[0].length > 0)) {
                var header = new Array();
                for (var i = 0; i < this._data[0].length; i++) {
                    header.push(new TableHeaderItem());
                }
                this.header = header;
            }
            this.dataChange.emit();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableModel.prototype, "totalDataLength", {
        /**
         * Total length of data that table has access to, or the amount manually set
         */
        get: function () {
            // if manually set data length
            if (this._totalDataLength !== null && this._totalDataLength >= 0) {
                return this._totalDataLength;
            }
            // if empty dataset
            if (this.data && this.data.length === 1 && this.data[0].length === 0) {
                return 0;
            }
            return this.data.length;
        },
        /**
         * Manually set data length in case the data in the table doesn't
         * correctly reflect all the data that table is to display.
         *
         * Example: if you have multiple pages of data that table will display
         * but you're loading one at a time.
         *
         * Set to `null` to reset to default behavior.
         */
        set: function (length) {
            // if this function is called without a parameter we need to set to null to avoid having undefined != null
            this._totalDataLength = length || null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns an id for the given column
     *
     * @param column the column to generate an id for
     * @param row the row of the header to generate an id for
     */
    TableModel.prototype.getId = function (column, row) {
        if (row === void 0) { row = 0; }
        return "table-header-" + row + "-" + column + "-" + this.tableModelCount;
    };
    /**
     * Returns the id of the header. Used to link the cells with headers (or headers with headers)
     *
     * @param column the column to start getting headers for
     * @param colSpan the number of columns to get headers for (defaults to 1)
     */
    TableModel.prototype.getHeaderId = function (column, colSpan) {
        if (colSpan === void 0) { colSpan = 1; }
        if (column === "select" || column === "expand") {
            return this.getId(column);
        }
        var ids = [];
        for (var i = column; i >= 0; i--) {
            if (this.header[i]) {
                for (var j = 0; j < colSpan; j++) {
                    ids.push(this.getId(i + j));
                }
                break;
            }
        }
        return ids.join(" ");
    };
    /**
     * Finds closest header by trying the `column` and then working its way to the left
     *
     * @param column the target column
     */
    TableModel.prototype.getHeader = function (column) {
        if (!this.header) {
            return null;
        }
        for (var i = column; i >= 0; i--) {
            var headerCell = this.header[i];
            if (headerCell) {
                return headerCell;
            }
        }
        return null;
    };
    /**
     * Returns how many rows is currently selected
     */
    TableModel.prototype.selectedRowsCount = function () {
        var count = 0;
        if (this.rowsSelected) {
            this.rowsSelected.forEach(function (rowSelected) {
                if (rowSelected) {
                    count++;
                }
            });
        }
        return count;
    };
    /**
     * Returns how many rows is currently expanded
     */
    TableModel.prototype.expandedRowsCount = function () {
        var count = 0;
        if (this.rowsExpanded) {
            this.rowsExpanded.forEach(function (rowExpanded) {
                if (rowExpanded) {
                    count++;
                }
            });
        }
        return count;
    };
    /**
     * Returns `index`th row of the table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    TableModel.prototype.row = function (index) {
        return this.data[this.realRowIndex(index)];
    };
    /**
     * Adds a row to the `index`th row or appends to table if index not provided.
     *
     * If row is shorter than other rows or not provided, it will be padded with
     * empty `TableItem` elements.
     *
     * If row is longer than other rows, others will be extended to match so no data is lost.
     *
     * If called on an empty table with no parameters, it creates a 1x1 table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param [row]
     * @param [index]
     */
    TableModel.prototype.addRow = function (row, index) {
        // if table empty create table with row
        if (!this.data || this.data.length === 0 || this.data[0].length === 0) {
            var newData = new Array();
            newData.push(row ? row : [new TableItem()]); // row or one empty one column row
            this.data = newData;
            return;
        }
        var realRow = row;
        var columnCount = this.data[0].length;
        if (row == null) {
            realRow = new Array();
            for (var i = 0; i < columnCount; i++) {
                realRow.push(new TableItem());
            }
        }
        if (realRow.length < columnCount) {
            // extend the length of realRow
            var difference = columnCount - realRow.length;
            for (var i = 0; i < difference; i++) {
                realRow.push(new TableItem());
            }
        }
        else if (realRow.length > columnCount) {
            // extend the length of header
            var difference = realRow.length - this.header.length;
            for (var j = 0; j < difference; j++) {
                this.header.push(new TableHeaderItem());
            }
            // extend the length of every other row
            for (var i = 0; i < this.data.length; i++) {
                var currentRow = this.data[i];
                difference = realRow.length - currentRow.length;
                for (var j = 0; j < difference; j++) {
                    currentRow.push(new TableItem());
                }
            }
        }
        if (index == null) {
            this.data.push(realRow);
            // update rowsSelected property for length
            this.rowsSelected.push(false);
            // update rowsExpanded property for length
            this.rowsExpanded.push(false);
            // update rowsContext property for length
            this.rowsContext.push(undefined);
            // update rowsClass property for length
            this.rowsClass.push(undefined);
        }
        else {
            var ri = this.realRowIndex(index);
            this.data.splice(ri, 0, realRow);
            // update rowsSelected property for length
            this.rowsSelected.splice(ri, 0, false);
            // update rowsExpanded property for length
            this.rowsExpanded.splice(ri, 0, false);
            // update rowsContext property for length
            this.rowsContext.splice(ri, 0, undefined);
            // update rowsClass property for length
            this.rowsClass.splice(ri, 0, undefined);
        }
        this.dataChange.emit();
    };
    /**
     * Deletes `index`th row.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    TableModel.prototype.deleteRow = function (index) {
        var rri = this.realRowIndex(index);
        this.data.splice(rri, 1);
        this.rowsSelected.splice(rri, 1);
        this.rowsExpanded.splice(rri, 1);
        this.rowsContext.splice(rri, 1);
        this.rowsClass.splice(rri, 1);
        this.dataChange.emit();
    };
    TableModel.prototype.hasExpandableRows = function () {
        return this.data.some(function (data) { return data.some(function (d) { return d && d.expandedData; }); }); // checking for some in 2D array
    };
    TableModel.prototype.isRowExpandable = function (index) {
        return this.data[index].some(function (d) { return d && d.expandedData; });
    };
    TableModel.prototype.isRowExpanded = function (index) {
        return this.rowsExpanded[index];
    };
    TableModel.prototype.getRowContext = function (index) {
        return this.rowsContext[index];
    };
    /**
     * Returns `index`th column of the table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    TableModel.prototype.column = function (index) {
        var column = new Array();
        var ri = this.realColumnIndex(index);
        var rc = this.data.length;
        for (var i = 0; i < rc; i++) {
            var row = this.data[i];
            column.push(row[ri]);
        }
        return column;
    };
    /**
     * Adds a column to the `index`th column or appends to table if index not provided.
     *
     * If column is shorter than other columns or not provided, it will be padded with
     * empty `TableItem` elements.
     *
     * If column is longer than other columns, others will be extended to match so no data is lost.
     *
     * If called on an empty table with no parameters, it creates a 1x1 table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param [column]
     * @param [index]
     */
    TableModel.prototype.addColumn = function (column, index) {
        // if table empty create table with row
        if (!this.data || this.data.length === 0 || this.data[0].length === 0) {
            var newData = new Array();
            if (column == null) {
                newData.push([new TableItem()]);
            }
            else {
                for (var i = 0; i < column.length; i++) {
                    var item = column[i];
                    newData.push([item]);
                }
            }
            this.data = newData;
            return;
        }
        var rc = this.data.length; // row count
        var ci = this.realColumnIndex(index);
        // append missing rows
        for (var i = 0; column != null && i < column.length - rc; i++) {
            this.addRow();
        }
        rc = this.data.length;
        if (index == null) {
            // append to end
            for (var i = 0; i < rc; i++) {
                var row = this.data[i];
                row.push(column == null || column[i] == null ? new TableItem() : column[i]);
            }
            // update header if not already set by user
            if (this.header.length < this.data[0].length) {
                this.header.push(new TableHeaderItem());
            }
        }
        else {
            if (index >= this.data[0].length) {
                // if trying to append
                ci++;
            }
            // insert
            for (var i = 0; i < rc; i++) {
                var row = this.data[i];
                row.splice(ci, 0, column == null || column[i] == null ? new TableItem() : column[i]);
            }
            // update header if not already set by user
            if (this.header.length < this.data[0].length) {
                this.header.splice(ci, 0, new TableHeaderItem());
            }
        }
        this.dataChange.emit();
    };
    /**
     * Deletes `index`th column.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    TableModel.prototype.deleteColumn = function (index) {
        var rci = this.realColumnIndex(index);
        var rowCount = this.data.length;
        for (var i = 0; i < rowCount; i++) {
            this.data[i].splice(rci, 1);
        }
        // update header if not already set by user
        if (this.header.length > this.data[0].length) {
            this.header.splice(rci, 1);
        }
        this.dataChange.emit();
    };
    TableModel.prototype.moveColumn = function (indexFrom, indexTo) {
        var headerFrom = this.header[indexFrom];
        this.addColumn(this.column(indexFrom), indexTo);
        this.deleteColumn(indexFrom + (indexTo < indexFrom ? 1 : 0));
        this.header[indexTo + (indexTo > indexFrom ? -1 : 0)] = headerFrom;
    };
    /**
     * Sorts the data currently present in the model based on `compare()`
     *
     * Direction is set by `ascending` and `descending` properties of `TableHeaderItem`
     * in `index`th column.
     *
     * @param index The column based on which it's sorting
     */
    TableModel.prototype.sort = function (index) {
        var _this = this;
        this.pushRowStateToModelData();
        this.data.sort(function (a, b) { return (_this.header[index].descending ? -1 : 1) * _this.header[index].compare(a[index], b[index]); });
        this.popRowStateFromModelData();
        this.header.forEach(function (column) { return column.sorted = false; });
        this.header[index].sorted = true;
    };
    /**
     * Appends `rowsSelected` and `rowsExpanded` info to model data.
     *
     * When sorting rows, do this first so information about row selection
     * gets sorted with the other row info.
     *
     * Call `popRowSelectionFromModelData()` after sorting to make everything
     * right with the world again.
     */
    TableModel.prototype.pushRowStateToModelData = function () {
        for (var i = 0; i < this.data.length; i++) {
            var rowSelectedMark = new TableItem();
            rowSelectedMark.data = this.rowsSelected[i];
            this.data[i].push(rowSelectedMark);
            var rowExpandedMark = new TableItem();
            rowExpandedMark.data = this.rowsExpanded[i];
            this.data[i].push(rowExpandedMark);
            var rowContext = new TableItem();
            rowContext.data = this.rowsContext[i];
            this.data[i].push(rowContext);
            var rowClass = new TableItem();
            rowClass.data = this.rowsClass[i];
            this.data[i].push(rowClass);
        }
    };
    /**
     * Restores `rowsSelected` from data pushed by `pushRowSelectionToModelData()`
     *
     * Call after sorting data (if you previously pushed to maintain selection order)
     * to make everything right with the world again.
     */
    TableModel.prototype.popRowStateFromModelData = function () {
        for (var i = 0; i < this.data.length; i++) {
            this.rowsClass[i] = this.data[i].pop().data;
            this.rowsContext[i] = this.data[i].pop().data;
            this.rowsExpanded[i] = !!this.data[i].pop().data;
            this.rowsSelected[i] = !!this.data[i].pop().data;
        }
    };
    /**
     * Checks if row is filtered out.
     *
     * @param index
     * @returns true if any of the filters in header filters out the `index`th row
     */
    TableModel.prototype.isRowFiltered = function (index) {
        var _this = this;
        var realIndex = this.realRowIndex(index);
        return this.header.some(function (item, i) { return item && item.filter(_this.row(realIndex)[i]); });
    };
    /**
     * Select/deselect `index`th row based on value
     *
     * @param index index of the row to select
     * @param value state to set the row to. Defaults to `true`
     */
    TableModel.prototype.selectRow = function (index, value) {
        if (value === void 0) { value = true; }
        if (this.isRowDisabled(index)) {
            return;
        }
        this.rowsSelected[index] = value;
        this.rowsSelectedChange.emit(index);
    };
    /**
     * Selects or deselects all rows in the model
     *
     * @param value state to set all rows to. Defaults to `true`
     */
    TableModel.prototype.selectAll = function (value) {
        if (value === void 0) { value = true; }
        if (this.data.length >= 1) {
            for (var i = 0; i < this.rowsSelected.length; i++) {
                this.selectRow(i, value);
            }
        }
        this.selectAllChange.next(value);
    };
    TableModel.prototype.isRowSelected = function (index) {
        return this.rowsSelected[index];
    };
    /**
     * Checks if row is disabled or not.
     */
    TableModel.prototype.isRowDisabled = function (index) {
        var row = this.data[index];
        return !!row.disabled;
    };
    /**
     * Expands/Collapses `index`th row based on value
     *
     * @param index index of the row to expand or collapse
     * @param value expanded state of the row. `true` is expanded and `false` is collapsed
     */
    TableModel.prototype.expandRow = function (index, value) {
        if (value === void 0) { value = true; }
        this.rowsExpanded[index] = value;
        this.rowsExpandedChange.emit(index);
    };
    /**
     * Gets the true index of a row based on it's relative position.
     * Like in Python, positive numbers start from the top and
     * negative numbers start from the bottom.
     *
     * @param index
     */
    TableModel.prototype.realRowIndex = function (index) {
        return this.realIndex(index, this.data.length);
    };
    /**
     * Gets the true index of a column based on it's relative position.
     * Like in Python, positive numbers start from the top and
     * negative numbers start from the bottom.
     *
     * @param index
     */
    TableModel.prototype.realColumnIndex = function (index) {
        return this.realIndex(index, this.data[0].length);
    };
    /**
     * Generic function to calculate the real index of something.
     * Used by `realRowIndex()` and `realColumnIndex()`
     *
     * @param index
     * @param length
     */
    TableModel.prototype.realIndex = function (index, length) {
        if (index == null) {
            return length - 1;
        }
        else if (index >= 0) {
            return index >= length ? length - 1 : index;
        }
        else {
            return -index >= length ? 0 : length + index;
        }
    };
    /**
     * The number of models instantiated, used for (among other things) unique id generation
     */
    TableModel.COUNT = 0;
    return TableModel;
}());

/**
 * The table toolbar is reserved for global table actions such as table settings, complex filter, export, or editing table data.
 *
 * ## Basic usage
 *
 * ```html
 * <ibm-table-toolbar [model]="model">
 *		<ibm-table-toolbar-actions>
 *			<button ibmButton="primary">
 *				Delete
 *				<svg ibmIcon="delete" size="16" class="bx--btn__icon"></svg>
 *			</button>
 *			<button ibmButton="primary">
 *				Save
 *				<svg ibmIcon="save" size="16" class="bx--btn__icon"></svg>
 *			</button>
 *			<button ibmButton="primary">
 *				Download
 *				<svg ibmIcon="download" size="16" class="bx--btn__icon"></svg>
 *			</button>
 *		</ibm-table-toolbar-actions>
 *			<ibm-table-toolbar-content>
 *			<ibm-table-toolbar-search [expandable]="true"></ibm-table-toolbar-search>
 *			<button ibmButton="toolbar-action">
 *				<svg ibmIcon="settings" size="16" class="bx--toolbar-action__icon"></ibm-icon-settings>
 *			</button>
 *			<button ibmButton="primary" size="sm">
 *				Primary Button
 *				<svg ibmIcon="add" size="20" class="bx--btn__icon"></svg>
 *			</button>
 *		</ibm-table-toolbar-content>
 *	</ibm-table-toolbar>
 * ```
 *
 */
var TableToolbar = /** @class */ (function () {
    function TableToolbar(i18n) {
        this.i18n = i18n;
        this.size = "md";
        this.cancel = new EventEmitter();
        this.actionBarLabel = this.i18n.getOverridable("TABLE_TOOLBAR.ACTION_BAR");
        this._cancelText = this.i18n.getOverridable("TABLE_TOOLBAR.CANCEL");
        this._batchTextLegacy = this.i18n.getOverridable("TABLE_TOOLBAR.BATCH_TEXT");
        this._batchTextSingle = this.i18n.getOverridable("TABLE_TOOLBAR.BATCH_TEXT_SINGLE");
        this._batchTextMultiple = this.i18n.getOverridable("TABLE_TOOLBAR.BATCH_TEXT_MULTIPLE");
    }
    Object.defineProperty(TableToolbar.prototype, "batchText", {
        set: function (value) {
            if (typeof value === "object") {
                this._batchTextSingle.override(value.SINGLE);
                this._batchTextMultiple.override(value.MULTIPLE);
            }
            else {
                // For compatibility with old code
                this._batchTextLegacy.override(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableToolbar.prototype, "ariaLabel", {
        set: function (value) {
            this.actionBarLabel.override(value.ACTION_BAR);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableToolbar.prototype, "cancelText", {
        get: function () {
            return { CANCEL: this._cancelText.value };
        },
        set: function (value) {
            this._cancelText.override(value.CANCEL);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableToolbar.prototype, "count", {
        get: function () {
            return this.model.totalDataLength > 0 ? this.model.rowsSelected.reduce(function (previous, current) { return previous + (current ? 1 : 0); }, 0) : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableToolbar.prototype, "selected", {
        get: function () {
            return this.model.totalDataLength > 0 ? this.model.rowsSelected.some(function (item) { return item; }) : false;
        },
        enumerable: true,
        configurable: true
    });
    TableToolbar.prototype.onCancel = function () {
        this.model.selectAll(false);
        this.cancel.emit();
    };
    TableToolbar.decorators = [
        { type: Component, args: [{
                    selector: "ibm-table-toolbar",
                    template: "\n\t<section\n\t\tclass=\"bx--table-toolbar\"\n\t\t[ngClass]=\"{'bx--table-toolbar--small' : size === 'sm'}\">\n\t\t<div\n\t\t\t*ngIf=\"model\"\n\t\t\tclass=\"bx--batch-actions\"\n\t\t\t[ngClass]=\"{\n\t\t\t\t'bx--batch-actions--active': selected\n\t\t\t}\"\n\t\t\t[attr.aria-label]=\"actionBarLabel.subject | async\">\n\t\t\t<div class=\"bx--action-list\">\n\t\t\t\t<ng-content select=\"ibm-table-toolbar-actions\"></ng-content>\n\t\t\t\t<button\n\t\t\t\t\tibmButton=\"primary\"\n\t\t\t\t\tclass=\"bx--batch-summary__cancel\"\n\t\t\t\t\t[tabindex]=\"selected ? 0 : -1\"\n\t\t\t\t\t(click)=\"onCancel()\">\n\t\t\t\t\t{{_cancelText.subject | async}}\n\t\t\t\t</button>\n\t\t\t</div>\n\t\t\t<div class=\"bx--batch-summary\">\n\t\t\t\t<p class=\"bx--batch-summary__para\" *ngIf=\"count as n\">\n\t\t\t\t\t<ng-container *ngIf=\"_batchTextLegacy.subject | async as legacyText; else batchTextBlock\">\n\t\t\t\t\t\t<span>{{n}}</span> {{legacyText}}\n\t\t\t\t\t</ng-container>\n\t\t\t\t\t<ng-template #batchTextBlock>\n\t\t\t\t\t\t<span *ngIf=\"n === 1\">{{_batchTextSingle.subject | async}}</span>\n\t\t\t\t\t\t<span *ngIf=\"n !== 1\">{{_batchTextMultiple.subject | i18nReplace: {count: n} | async}}</span>\n\t\t\t\t\t</ng-template>\n\t\t\t\t</p>\n\t\t\t</div>\n\t\t</div>\n\t\t<ng-content></ng-content>\n\t</section>\n\t"
                }] }
    ];
    /** @nocollapse */
    TableToolbar.ctorParameters = function () { return [
        { type: I18n }
    ]; };
    TableToolbar.propDecorators = {
        model: [{ type: Input }],
        batchText: [{ type: Input }],
        ariaLabel: [{ type: Input }],
        cancelText: [{ type: Input }],
        size: [{ type: Input }],
        cancel: [{ type: Output }]
    };
    return TableToolbar;
}());

var TableToolbarActions = /** @class */ (function () {
    function TableToolbarActions() {
    }
    TableToolbarActions.decorators = [
        { type: Component, args: [{
                    selector: "ibm-table-toolbar-actions",
                    template: "<ng-content></ng-content>"
                }] }
    ];
    return TableToolbarActions;
}());

var TableToolbarSearch = /** @class */ (function (_super) {
    __extends(TableToolbarSearch, _super);
    function TableToolbarSearch() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.tableSearch = true;
        _this.expandable = false;
        return _this;
    }
    Object.defineProperty(TableToolbarSearch.prototype, "persistentClass", {
        get: function () { return !this.expandable; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableToolbarSearch.prototype, "activeClass", {
        get: function () {
            return this.active && (this.value !== null || this.value !== "");
        },
        enumerable: true,
        configurable: true
    });
    TableToolbarSearch.prototype.ngOnInit = function () {
        this.size = "sm";
        if (this.expandable) {
            this.toolbar = true;
        }
    };
    TableToolbarSearch.prototype.ngAfterViewInit = function () {
        var _this = this;
        setTimeout(function () {
            if (_this.value) {
                _this.openSearch();
            }
        });
    };
    TableToolbarSearch.decorators = [
        { type: Component, args: [{
                    selector: "ibm-table-toolbar-search",
                    template: "<div\n\tclass=\"bx--search\"\n\t[ngClass]=\"{\n\t\t'bx--search--sm': size === 'sm',\n\t\t'bx--search--lg': size === 'md',\n\t\t'bx--search--xl': size === 'xl',\n\t\t'bx--search--light': theme === 'light',\n\t\t'bx--skeleton': skeleton,\n\t\t'bx--toolbar-search': toolbar,\n\t\t'bx--toolbar-search--active': toolbar && active\n\t}\"\n\trole=\"search\"\n\t[attr.aria-label]=\"ariaLabel\"\n\ttabindex=\"0\"\n\t(click)=\"openSearch()\">\n\t<label class=\"bx--label\" [for]=\"id\">{{label}}</label>\n\n\t<div *ngIf=\"skeleton; else enableInput\" class=\"bx--search-input\"></div>\n\t<ng-template #enableInput>\n\t\t<input\n\t\t\t#input\n\t\t\tclass=\"bx--search-input\"\n\t\t\t[type]=\"tableSearch || !toolbar ? 'text' : 'search'\"\n\t\t\t[id]=\"id\"\n\t\t\t[value]=\"value\"\n\t\t\t[autocomplete]=\"autocomplete\"\n\t\t\t[placeholder]=\"placeholder\"\n\t\t\t[disabled]=\"disabled\"\n\t\t\t[required]=\"required\"\n\t\t\t(input)=\"onSearch($event.target.value)\"\n\t\t\t(keyup.enter)=\"onEnter()\"/>\n\t\t<button\n\t\t\t*ngIf=\"!tableSearch && toolbar\"\n\t\t\tclass=\"bx--toolbar-search__btn\"\n\t\t\t(click)=\"openSearch()\"\n\t\t\taria-label=\"Open search\">\n\t\t\t<svg ibmIcon=\"search\" size=\"16\" class=\"bx--search-magnifier\"></svg>\n\t\t</button>\n\t\t<svg\n\t\t\tibmIcon=\"search\"\n\t\t\t*ngIf=\"tableSearch || !toolbar\"\n\t\t\tclass=\"bx--search-magnifier\"\n\t\t\tsize=\"16\">\n\t\t</svg>\n\t</ng-template>\n\n\t<button\n\t\t*ngIf=\"tableSearch || !toolbar\"\n\t\tclass=\"bx--search-close\"\n\t\t[ngClass]=\"{\n\t\t\t'bx--search-close--hidden': !value || value.length === 0\n\t\t}\"\n\t\t[title]=\"clearButtonTitle\"\n\t\t(click)=\"clearSearch()\">\n\t\t<span class=\"bx--visually-hidden\">{{ clearButtonTitle }}</span>\n\t\t<svg ibmIcon=\"close\" size=\"16\"></svg>\n\t</button>\n</div>\n",
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: TableToolbarSearch,
                            multi: true
                        }
                    ]
                }] }
    ];
    TableToolbarSearch.propDecorators = {
        expandable: [{ type: HostBinding, args: ["class.bx--toolbar-search-container-expandable",] }, { type: Input }],
        persistentClass: [{ type: HostBinding, args: ["class.bx--toolbar-search-container-persistent",] }],
        activeClass: [{ type: HostBinding, args: ["class.bx--toolbar-search-container-active",] }]
    };
    return TableToolbarSearch;
}(Search));

var TableToolbarContent = /** @class */ (function () {
    function TableToolbarContent() {
        this.class = true;
    }
    TableToolbarContent.decorators = [
        { type: Component, args: [{
                    selector: "ibm-table-toolbar-content",
                    template: "<ng-content></ng-content>"
                }] }
    ];
    TableToolbarContent.propDecorators = {
        class: [{ type: HostBinding, args: ["class.bx--toolbar-content",] }]
    };
    return TableToolbarContent;
}());

var TableContainer = /** @class */ (function () {
    function TableContainer() {
        this.containerClass = true;
    }
    TableContainer.decorators = [
        { type: Component, args: [{
                    selector: "ibm-table-container",
                    template: "<ng-content></ng-content>",
                    styles: ["\n\t\t:host { display: block }\n\t"]
                }] }
    ];
    TableContainer.propDecorators = {
        containerClass: [{ type: HostBinding, args: ["class.bx--data-table-container",] }]
    };
    return TableContainer;
}());

var TableHeader = /** @class */ (function () {
    function TableHeader() {
        this.headerClass = true;
        this.displayStyle = "block";
    }
    TableHeader.decorators = [
        { type: Component, args: [{
                    selector: "ibm-table-header",
                    template: "\n\t\t<ng-content></ng-content>\n\t"
                }] }
    ];
    TableHeader.propDecorators = {
        headerClass: [{ type: HostBinding, args: ["class.bx--data-table-header",] }],
        displayStyle: [{ type: HostBinding, args: ["style.display",] }]
    };
    return TableHeader;
}());

var TableHeaderTitle = /** @class */ (function () {
    function TableHeaderTitle() {
        this.titleClass = true;
    }
    TableHeaderTitle.decorators = [
        { type: Directive, args: [{
                    selector: "[ibmTableHeaderTitle]"
                },] }
    ];
    TableHeaderTitle.propDecorators = {
        titleClass: [{ type: HostBinding, args: ["class.bx--data-table-header__title",] }]
    };
    return TableHeaderTitle;
}());

var TableHeadCellLabel = /** @class */ (function () {
    function TableHeadCellLabel() {
        this.baseClass = true;
    }
    TableHeadCellLabel.decorators = [
        { type: Directive, args: [{
                    selector: "[ibmTableHeadCellLabel]"
                },] }
    ];
    TableHeadCellLabel.propDecorators = {
        baseClass: [{ type: HostBinding, args: ["class.bx--table-header-label",] }]
    };
    return TableHeadCellLabel;
}());

var TableHeaderDescription = /** @class */ (function () {
    function TableHeaderDescription() {
        this.descriptionClass = true;
    }
    TableHeaderDescription.decorators = [
        { type: Directive, args: [{
                    selector: "[ibmTableHeaderDescription]"
                },] }
    ];
    TableHeaderDescription.propDecorators = {
        descriptionClass: [{ type: HostBinding, args: ["class.bx--data-table-header__description",] }]
    };
    return TableHeaderDescription;
}());

var ExpandedRowHover = /** @class */ (function () {
    function ExpandedRowHover() {
    }
    ExpandedRowHover.prototype.addHoverClass = function (event) {
        event.target.previousElementSibling.classList.add("bx--expandable-row--hover");
    };
    ExpandedRowHover.prototype.removeHoverClass = function (event) {
        event.target.previousElementSibling.classList.remove("bx--expandable-row--hover");
    };
    ExpandedRowHover.decorators = [
        { type: Directive, args: [{
                    selector: "[ibmExpandedRowHover]"
                },] }
    ];
    ExpandedRowHover.propDecorators = {
        addHoverClass: [{ type: HostListener, args: ["mouseenter", ["$event"],] }],
        removeHoverClass: [{ type: HostListener, args: ["mouseleave", ["$event"],] }]
    };
    return ExpandedRowHover;
}());

/**
 * `DataGridInteractionModel` provides centralized control over arbitrary 2d grids, following the w3 specs.
 *
 * Refs:
 *  - https://www.w3.org/TR/wai-aria-practices/examples/grid/dataGrids.html
 *  - https://www.w3.org/TR/wai-aria-practices/#grid
 *
 * Example usage (taken from `table.component`):
```typescript
// a standard HTML table
const table = this.elementRef.nativeElement.querySelector("table") as HTMLTableElement;

// `TableDomAdapter` implements `TableAdapter` and provides a consistent interface to query rows and columns in a table
const tableAdapter = new TableDomAdapter(table);

// the keydown events that we'll use for keyboard navigation of the table
const keydownEventStream = fromEvent<KeyboardEvent>(table, "keydown");

// the click events we'll use to ensure focus is updated correctly on click
const clickEventStream = fromEvent<MouseEvent>(table, "click");

// the `DataGridInteractionModel` instance!
this.interactionModel = new DataGridInteractionModel(keydownEventStream, clickEventStream, tableAdapter);

// subscribe to the combined position updates
this.interactionModel.position.subscribe(event => {
    const [currentRow, currentColumn] = event.current;
    const [previousRow, previousColumn] = event.previous;

    // query the TableAdapter for the cell at the current row and column ...
    const currentElement = tableAdapter.getCell(currentRow, currentColumn);
    // ... and make it focusable it
    Table.setTabIndex(currentElement, 0);

    // if the model has just initialized don't focus or reset anything
    if (previousRow === -1 || previousColumn === -1) { return; }

    // query the TableAdapter for the cell at the previous row and column ...
    const previousElement = tableAdapter.getCell(previousRow, previousColumn);
    // ... and make it unfocusable (now there is only a single focusable cell)
    Table.setTabIndex(previousElement, -1);

    // finally, focus the current cell (skipped during initilzation)
    Table.focus(currentElement);
});
```
 */
var DataGridInteractionModel = /** @class */ (function () {
    /**
     * `DataGridInteractionModel` requires knowledge of events, and a representation of your table/grid to be useful.
     *
     * @param keyboardEventStream an Observable of KeyboardEvents. Should be scoped to the table container.
     * @param clickEventStream an Observable of ClickEvents. should only include clicks that take action on items known by the TableAdapter
     * @param tableAdapter an instance of a concrete class that implements TableAdapter. The standard carbon table uses TableDomAdapter
     */
    function DataGridInteractionModel(keyboardEventStream, clickEventStream, tableAdapter) {
        this.keyboardEventStream = keyboardEventStream;
        this.clickEventStream = clickEventStream;
        this.tableAdapter = tableAdapter;
        /**
         * Internal subject to handle changes in row
         */
        this.rowSubject = new BehaviorSubject({ current: 0, previous: -1 });
        /**
         * Internal subject to handle changes in column
         */
        this.columnSubject = new BehaviorSubject({ current: 0, previous: -1 });
        this.rowIndex = this.rowSubject.asObservable();
        this.columnIndex = this.columnSubject.asObservable();
        this.position = combineLatest(this.rowIndex, this.columnIndex).pipe(map(function (positions) {
            var _a = __read(positions, 2), row = _a[0], column = _a[1];
            return {
                current: [row.current, column.current],
                previous: [row.previous, column.previous]
            };
        }));
        this.keyboardEventStream.subscribe(this.handleKeyboardEvent.bind(this));
        this.clickEventStream.subscribe(this.handleClickEvent.bind(this));
    }
    Object.defineProperty(DataGridInteractionModel.prototype, "currentRow", {
        /**
         * The latest value emitted by the rowSubject
         */
        get: function () {
            return this.rowSubject.getValue().current;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataGridInteractionModel.prototype, "currentColumn", {
        /**
         * The latest value emitted by the columnSubject
         */
        get: function () {
            return this.columnSubject.getValue().current;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataGridInteractionModel.prototype, "lastColumn", {
        /**
         * The last column as reported by the adapter
         */
        get: function () {
            return this.tableAdapter.lastColumnIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataGridInteractionModel.prototype, "lastRow", {
        /**
         * The last row as reported by the adapter
         */
        get: function () {
            return this.tableAdapter.lastRowIndex;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handles moving the position according to the w3 datagrid navigation specs
     *
     * Refs:
     *  - https://www.w3.org/TR/wai-aria-practices/examples/grid/dataGrids.html
     *  - https://www.w3.org/TR/wai-aria-practices/#grid
     *
     * @param event the KeyboardEvent to handle
     */
    DataGridInteractionModel.prototype.handleKeyboardEvent = function (event) {
        var currentCell = this.tableAdapter.getCell(this.currentRow, this.currentColumn);
        var currentColumn = this.tableAdapter.findColumnIndex(currentCell);
        var currentRow = this.tableAdapter.findRowIndex(currentCell);
        switch (event.key) {
            case "Right": // IE specific value
            case "ArrowRight":
                event.preventDefault();
                // add the colspan since findColumnIndex will return the
                // first column containing the cell (of N columns it may span)
                // and we want to navigate to the next "real" column
                this.goToColumn(currentColumn + currentCell.colSpan);
                break;
            case "Left": // IE specific value
            case "ArrowLeft":
                event.preventDefault();
                // we only ever need to subtract 1 from the column, since findColumnIndex returns the
                // first of N columns containing the cell
                this.goToColumn(currentColumn - 1);
                break;
            case "Down": // IE specific value
            case "ArrowDown":
                event.preventDefault();
                this.goToRow(currentRow + currentCell.rowSpan);
                break;
            case "Up": // IE specific value
            case "ArrowUp":
                event.preventDefault();
                this.goToRow(currentRow - 1);
                break;
            case "Home":
                event.preventDefault();
                if (event.ctrlKey) {
                    this.goTo({ row: 0, column: 0 });
                }
                else {
                    this.goToColumn(0);
                }
                break;
            case "End":
                event.preventDefault();
                if (event.ctrlKey) {
                    this.goTo({ row: this.lastRow, column: this.lastColumn });
                }
                else {
                    this.goToColumn(this.lastColumn);
                }
                break;
        }
    };
    /**
     * Handles moving the position to the clicked cell
     *
     * @param event the MouseEvent to handle
     */
    DataGridInteractionModel.prototype.handleClickEvent = function (event) {
        var cell = event.target.closest("td, th");
        var _a = __read(this.tableAdapter.findIndex(cell), 2), rowIndex = _a[0], cellIndex = _a[1];
        this.goTo({ row: rowIndex, column: cellIndex });
    };
    /**
     * Jump to a specific column without changing the row
     *
     * @param index column to jump to
     */
    DataGridInteractionModel.prototype.goToColumn = function (index) {
        if (index > this.lastColumn || index < 0) {
            return;
        }
        this.goTo({ row: this.currentRow, column: index });
    };
    /**
     * Jump to a specific row without changing the column
     *
     * @param index row to jump to
     */
    DataGridInteractionModel.prototype.goToRow = function (index) {
        if (index > this.lastRow || index < 0) {
            return;
        }
        this.goTo({ row: index, column: this.currentColumn });
    };
    /**
     * Jump to the specified row and column
     *
     * @param param0 an object that contains `row` and `column` properties
     */
    DataGridInteractionModel.prototype.goTo = function (_a) {
        var row = _a.row, column = _a.column;
        this.rowSubject.next({ current: row, previous: this.currentRow });
        this.columnSubject.next({ current: column, previous: this.currentColumn });
    };
    /**
     * Convenience method to reset the tab indexes on a standard carbon table.
     * For custom tables you may want to reset the indexes manually and simply call `.reset()`
     */
    DataGridInteractionModel.prototype.resetTabIndexes = function (newTabIndex) {
        if (newTabIndex === void 0) { newTabIndex = -1; }
        var e_1, _a;
        for (var i = 0; i < this.tableAdapter.lastRowIndex; i++) {
            var row = this.tableAdapter.getRow(i);
            try {
                for (var _b = __values(Array.from(row.cells)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var cell = _c.value;
                    var tabbableElements = getFocusElementList(cell, tabbableSelectorIgnoreTabIndex);
                    tabbableElements.forEach(function (node) { return node.tabIndex = newTabIndex; });
                    cell.tabIndex = newTabIndex;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        this.reset();
    };
    /**
     * Resets the models focus position
     */
    DataGridInteractionModel.prototype.reset = function () {
        this.rowSubject.next({ current: 0, previous: -1 });
        this.columnSubject.next({ current: 0, previous: -1 });
    };
    return DataGridInteractionModel;
}());

/**
 * An abstract class that represents a cell in a table
 */
var TableCellAdapter = /** @class */ (function () {
    function TableCellAdapter() {
    }
    return TableCellAdapter;
}());
/**
 * An abstract class that represents a row in a table
 */
var TableRowAdapter = /** @class */ (function () {
    function TableRowAdapter() {
    }
    return TableRowAdapter;
}());
/**
 * An abstract representation of a table that provides
 * a standard interface to query 2d tables for cell and row information.
 */
var TableAdapter = /** @class */ (function () {
    function TableAdapter() {
    }
    Object.defineProperty(TableAdapter.prototype, "lastColumnIndex", {
        /**
         * The last accessible column in the table
         */
        get: function () { return; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableAdapter.prototype, "lastRowIndex", {
        /**
         * The last accessible row in the table
         */
        get: function () { return; },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a cell from the table
     *
     * @param row index of the row
     * @param column index of the column
     */
    TableAdapter.prototype.getCell = function (row, column) { return; };
    /**
     * Returns a row from the table
     *
     * @param column index of the column
     */
    TableAdapter.prototype.getColumn = function (column) { return; };
    /**
     * Returns a row from the table
     *
     * @param row index of the row
     */
    TableAdapter.prototype.getRow = function (row) { return; };
    /**
     * Finds the column index of a given cell
     *
     * @param cell the cell to search for
     */
    TableAdapter.prototype.findColumnIndex = function (cell) { return; };
    /**
     * Finds the row index of a given cell
     *
     * @param cell the cell to search for
     */
    TableAdapter.prototype.findRowIndex = function (cell) { return; };
    /**
     * Finds the row and column index of a given cell
     *
     * @param cell the cell to search for
     * @returns a tuple that follows the `[row, column]` convention
     */
    TableAdapter.prototype.findIndex = function (cell) { return; };
    return TableAdapter;
}());
var TableDomSpanDirection;
(function (TableDomSpanDirection) {
    TableDomSpanDirection["colSpan"] = "colSpan";
    TableDomSpanDirection["rowSpan"] = "rowSpan";
})(TableDomSpanDirection || (TableDomSpanDirection = {}));
/**
 * A concrete implementation of `TableAdapter`
 *
 * Provides standard and consistent access to table cells and rows
 */
var TableDomAdapter = /** @class */ (function () {
    /**
     * `TableDomAdapter` works on a normal HTML table structure.
     * Custom tables that don't follow the standard structure should use a custom implementation of `TableAdapter`.
     *
     * The standard structure allows us to directly query rows for cells and indexes - though we do have to handle colspans specially.
     *
     * @param tableElement the root HTML table element.
     */
    function TableDomAdapter(tableElement) {
        this.tableElement = tableElement;
    }
    Object.defineProperty(TableDomAdapter.prototype, "lastColumnIndex", {
        /**
         * The last accessible column in the table
         */
        get: function () {
            return this.getRealRowLength(this.tableElement.rows[0]);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableDomAdapter.prototype, "lastRowIndex", {
        /**
         * The last accessible row in the table
         */
        get: function () {
            return this.tableElement.rows.length - 1;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a cell from the table taking colspans in to account.
     *
     * @param row index of the row
     * @param column index of the column
     */
    TableDomAdapter.prototype.getCell = function (row, column) {
        var col = this.getColumn(column);
        return this.findCellInColumn(col, row).cell;
    };
    /**
     * Returns a column from the table, using the `id` and `headers` attributes
     *
     * See here for more detail these attributes: https://www.w3.org/TR/WCAG20-TECHS/H43.html
     *
     * @param column the index of the column
     */
    TableDomAdapter.prototype.getColumn = function (column) {
        var firstHeader = Array.from(this.tableElement.rows[0].cells);
        var _a = this.findCellInRow(firstHeader, column), header = _a.cell, realColumnIndex = _a.realIndex;
        var linkedCells = [];
        for (var i = 1; i < this.tableElement.rows.length; i++) {
            var row = this.tableElement.rows[i];
            // query for any cells that are linked to the given header id
            // `~=` matches values in space separated lists - so `[headers~='foo']` would match `headers="foo bar"` and `headers="foo"`
            // but not `headers="bar"` or `headers="bar baz"`
            var linkedRowCells = row.querySelectorAll("[headers~='" + header.id + "']");
            // if we have more than one cell, get the one that is closest to the column
            if (linkedRowCells.length > 1) {
                var cell = this.findCellInRow(Array.from(linkedRowCells), column - realColumnIndex).cell;
                linkedCells.push(cell);
            }
            else if (linkedRowCells[0]) {
                linkedCells.push(linkedRowCells[0]);
            }
        }
        // return an empty array if we can't find any linked cells
        // returning anything else would be a lie
        if (!linkedCells) {
            return [];
        }
        return __spread([header], linkedCells);
    };
    /**
     * Returns a row from the table
     *
     * @param row index of the row
     */
    TableDomAdapter.prototype.getRow = function (row) {
        return this.tableElement.rows[row];
    };
    /**
     * Finds the column index of a given cell
     *
     * @param cell the cell to search for
     */
    TableDomAdapter.prototype.findColumnIndex = function (cell) {
        var e_1, _a, e_2, _b, e_3, _c, e_4, _d, e_5, _e;
        var row = this.getRow(this.findRowIndex(cell));
        if (!row) {
            return;
        }
        // if the cell has linked headers we can do a more accurate lookup
        if (cell && cell.headers) {
            var ids_2 = cell.headers.split(" ");
            var headerRows = Array.from(this.tableElement.tHead.rows);
            var indexes = [];
            try {
                // start from the last row and work up
                for (var _f = __values(headerRows.reverse()), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var headerRow = _g.value;
                    var headerCells = Array.from(headerRow.cells);
                    var header = headerCells.find(function (headerCell) { return ids_2.includes(headerCell.id); });
                    // if we have a matching header, find it's index (adjusting for colspans)
                    if (header) {
                        // this is borrowed from below
                        var cellIndex_1 = 0;
                        try {
                            for (var headerCells_1 = __values(headerCells), headerCells_1_1 = headerCells_1.next(); !headerCells_1_1.done; headerCells_1_1 = headerCells_1.next()) {
                                var c = headerCells_1_1.value;
                                if (c === header) {
                                    break;
                                }
                                cellIndex_1 += c.colSpan;
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (headerCells_1_1 && !headerCells_1_1.done && (_b = headerCells_1.return)) _b.call(headerCells_1);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                        indexes.push(cellIndex_1);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
                }
                finally { if (e_1) throw e_1.error; }
            }
            // sort the indexes largest to smallest to find the closest matching header index
            var firstIndex = indexes.sort(function (a, b) { return b - a; })[0];
            // search the row for cells that share the header
            var similarCells = [];
            try {
                for (var ids_1 = __values(ids_2), ids_1_1 = ids_1.next(); !ids_1_1.done; ids_1_1 = ids_1.next()) {
                    var id = ids_1_1.value;
                    // there's no selector that will match two space separated lists,
                    // so we have to iterate through the ids and query the row for each
                    var rowCells = Array.from(row.querySelectorAll("[headers~='" + id + "']"));
                    try {
                        for (var rowCells_1 = __values(rowCells), rowCells_1_1 = rowCells_1.next(); !rowCells_1_1.done; rowCells_1_1 = rowCells_1.next()) {
                            var rowCell = rowCells_1_1.value;
                            // only keep one set of cells
                            if (!similarCells.includes(rowCell)) {
                                similarCells.push(rowCell);
                            }
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (rowCells_1_1 && !rowCells_1_1.done && (_d = rowCells_1.return)) _d.call(rowCells_1);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (ids_1_1 && !ids_1_1.done && (_c = ids_1.return)) _c.call(ids_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            // DOM order is not preserved, so we have to sort the row
            similarCells = similarCells.sort(function (a, b) { return a.cellIndex - b.cellIndex; });
            // return the header index plus any adjustment within that headers column
            return firstIndex + similarCells.indexOf(cell);
        }
        // fallback if the cell isn't linked to any headers
        var cellIndex = 0;
        try {
            for (var _h = __values(Array.from(row.cells)), _j = _h.next(); !_j.done; _j = _h.next()) {
                var c = _j.value;
                if (c === cell) {
                    break;
                }
                cellIndex += c.colSpan;
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_j && !_j.done && (_e = _h.return)) _e.call(_h);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return cellIndex;
    };
    /**
     * Finds the row index of a given cell
     *
     * @param cell the cell to search for
     */
    TableDomAdapter.prototype.findRowIndex = function (cell) {
        var e_6, _a;
        try {
            for (var _b = __values(Array.from(this.tableElement.rows)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var row = _c.value;
                if (row.contains(cell)) {
                    return row.rowIndex;
                }
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_6) throw e_6.error; }
        }
    };
    /**
     * Finds the row and column index of a given cell
     *
     * @param cell the cell to search for
     * @returns a tuple that follows the `[row, column]` convention
     */
    TableDomAdapter.prototype.findIndex = function (cell) {
        return [this.findRowIndex(cell), this.findColumnIndex(cell)];
    };
    /**
     * Helper function that returns the "real" length of a row.
     * Only accurate with regard to colspans (though that's sufficient for it's uses here)
     *
     * TODO: Take rowSpan into account
     *
     * @param row the row to get the length of
     */
    TableDomAdapter.prototype.getRealRowLength = function (row) {
        // start at -1 since the colspans will sum to 1 index greater than the total
        return Array.from(row.cells).reduce(function (count, cell) { return count + cell.colSpan; }, -1);
    };
    /**
     * Finds a cell and it's real index given an array of cells, a target index, and the spanning direction
     *
     * @param cells An array of cells to search
     * @param targetIndex The index we think the cell is located at
     * @param spanDirection The direction of the cell spans. Should be `"colSpan"` for a row and `"rowSpan"` for a column
     */
    TableDomAdapter.prototype.findCell = function (cells, targetIndex, spanDirection) {
        // rows/cols can have fewer total cells than the actual table
        // the model pretends all rows/cols behave the same (with col/row spans > 1 being N cells long)
        // this maps that view to the HTML view (col/row spans > 1 are one element, so the array is shorter)
        var realIndex = 0;
        // i is only used for iterating the cells
        for (var i = 0; i < targetIndex;) {
            // skip the next N cells
            i += cells[realIndex][spanDirection];
            // don't bump realIndex if i now exceeds the cell we're shooting for
            if (i > targetIndex) {
                break;
            }
            // finally, increment realIndex (to keep it generally in step with i)
            realIndex++;
        }
        return {
            cell: cells[realIndex],
            realIndex: realIndex
        };
    };
    /**
     * Helper method around `findCell`, searches based on a row of cells
     *
     * @param row the row of elements to search
     * @param index the index of the element
     */
    TableDomAdapter.prototype.findCellInRow = function (row, index) {
        return this.findCell(row, index, TableDomSpanDirection.colSpan);
    };
    /**
     * Helper method around `findCell`, searches based on a column of cells
     *
     * @param col the column of elements to search
     * @param index the index of the element
     */
    TableDomAdapter.prototype.findCellInColumn = function (col, index) {
        return this.findCell(col, index, TableDomSpanDirection.rowSpan);
    };
    return TableDomAdapter;
}());

/**
 * Build your table with this component by extending things that differ from default.
 *
 * [See demo](../../?path=/story/table--basic)
 *
 * Instead of the usual write-your-own-html approach you had with `<table>`,
 * carbon table uses model-view-controller approach.
 *
 * Here, you create a view (with built-in controller) and provide it a model.
 * Changes you make to the model are reflected in the view. Provide same model you use
 * in the table to the `<ibm-pagination>` components.
 * They provide a different view over the same data.
 *
 * ## Basic usage
 *
 * ```html
 * <ibm-table [model]="model"></ibm-table>
 * ```
 *
 * ```typescript
 * public model = new TableModel();
 *
 * this.model.data = [
 * 	[new TableItem({data: "asdf"}), new TableItem({data: "qwer"})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "zwer"})],
 * 	[new TableItem({data: "bsdf"}), new TableItem({data: "swer"})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "twer"})]
 * ];
 * ```
 *
 * ## Customization
 *
 * If you have custom data in your table, you need a way to display it. You can do that
 * by providing a template to `TableItem`.
 *
 * ```html
 * <ng-template #customTableItemTemplate let-data="data">
 * 	<a [routerLink]="data.link">{{data.name}} {{data.surname}}</a>
 * </ng-template>
 * ```
 *
 * ```typescript
 * customTableItemTemplate: TemplateRef<any>;
 *
 * this.customModel.data = [
 * 	[new TableItem({data: "asdf"}), new TableItem({data: {name: "Lessy", link: "/table"}, template: this.customTableItemTemplate})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "swer"})],
 * 	[new TableItem({data: "bsdf"}), new TableItem({data: {name: "Alice", surname: "Bob"}, template: this.customTableItemTemplate})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "twer"})],
 * ];
 * ```
 *
 * ### Sorting and filtering
 *
 * In case you need custom sorting and/or filtering you should subclass `TableHeaderItem`
 * and override needed functions.
 *
 * ```typescript
 * class FilterableHeaderItem extends TableHeaderItem {
 * 	// custom filter function
 * 	filter(item: TableItem): boolean {
 * 		if (typeof item.data === "string" && item.data.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0 ||
 * 		item.data.name && item.data.name.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0 ||
 * 		item.data.surname && item.data.surname.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0) {
 * 			return false;
 * 		}
 * 		return true;
 * 	}
 *
 * 	set filterCount(n) {}
 * 	get filterCount() {
 * 		return (this.filterData && this.filterData.data && this.filterData.data.length > 0) ? 1 : 0;
 * 	}
 *
 * 	// used for custom sorting
 * 	compare(one: TableItem, two: TableItem) {
 * 		const stringOne = (one.data.name || one.data.surname || one.data).toLowerCase();
 * 		const stringTwo = (two.data.name || two.data.surname || two.data).toLowerCase();
 *
 * 		if (stringOne > stringTwo) {
 * 			return 1;
 * 		} else if (stringOne < stringTwo) {
 * 			return -1;
 * 		} else {
 * 			return 0;
 * 		}
 * 	}
 * }
 * ```
 *
 * If you want to do your sorting on the backend or query for sorted data as a result of user
 * clicking the table header, check table [`sort`](#sort) output documentation
 *
 * See `TableHeaderItem` class for more information.
 *
 * ## No data template
 *
 * When table has no data to show, it can show a message you provide it instead.
 *
 * ```html
 * <ibm-table [model]="model">No data.</ibm-table>
 * ```
 *
 * ... will show `No data.` message, but you can get creative and provide any template you want
 * to replace table's default `tbody`.
 *
 * ## Use pagination as table footer
 *
 * ```html
 * <ibm-pagination [model]="model" (selectPage)="selectPage($event)"></ibm-pagination>
 * ```
 *
 * `selectPage()` function should fetch the data from backend, create new `data`, apply it to `model.data`,
 * and update `model.currentPage`.
 *
 * If the data your server returns is a two dimensional array of objects, it would look something like this:
 *
 * ```typescript
 * selectPage(page) {
 * 	this.getPage(page).then((data: Array<Array<any>>) => {
 * 		// set the data and update page
 * 		this.model.data = this.prepareData(data);
 * 		this.model.currentPage = page;
 * 	});
 * }
 *
 * protected prepareData(data: Array<Array<any>>) {
 * 	// create new data from the service data
 * 	let newData = [];
 * 	data.forEach(dataRow => {
 * 		let row = [];
 * 		dataRow.forEach(dataElement => {
 * 			row.push(new TableItem({
 * 				data: dataElement,
 * 				template: typeof dataElement === "string" ? undefined : this.paginationTableItemTemplate
 * 				// your template can handle all the data types so you don't have to conditionally set it
 * 				// you can also set different templates for different columns based on index
 * 			}));
 * 		});
 * 		newData.push(row);
 * 	});
 * 	return newData;
 * }
 * ```
 *
 * <example-url>../../iframe.html?id=table--basic</example-url>
 */
var Table = /** @class */ (function () {
    /**
     * Creates an instance of Table.
     */
    function Table(elementRef, applicationRef, i18n) {
        this.elementRef = elementRef;
        this.applicationRef = applicationRef;
        this.i18n = i18n;
        /**
         * Size of the table rows.
         */
        this.size = "md";
        /**
         * Set to `true` for a loading table.
         */
        this.skeleton = false;
        /**
         * Setting sortable to false will disable all headers including headers which are sortable. Is is
         * possible to set the sortable state on the header item to disable/enable sorting for only some headers.
         */
        this.sortable = true;
        this.noBorder = true;
        /**
         * Controls whether to show the selection checkboxes column or not.
         */
        this.showSelectionColumn = true;
        /**
         * Controls whether to enable multiple or single row selection.
         */
        this.enableSingleSelect = false;
        /**
         * Distance (in px) from the bottom that view has to reach before
         * `scrollLoad` event is emitted.
         */
        this.scrollLoadDistance = 0;
        /**
         * Set to `true` to enable users to resize columns.
         *
         * Works for columns with width set in pixels.
         *
         */
        this.columnsResizable = false;
        /**
         * Set to `true` to enable users to drag and drop columns.
         *
         * Changing the column order in table changes table model. Be aware of it when you add additional data
         * to the model.
         *
         */
        this.columnsDraggable = false;
        /**
         * Set to `false` to remove table rows (zebra) stripes.
         */
        this.striped = true;
        /**
         * Set to `true` to stick the header to the top of the table
         */
        this.stickyHeader = false;
        /**
         * Emits an index of the column that wants to be sorted.
         *
         * If no observers are provided (default), table will attempt to do a simple sort of the data loaded
         * into the model.
         *
         * If an observer is provided, table will not attempt any sorting of its own and it is up to the observer
         * to sort the table. This is what you typically want if you're using a backend query to get the sorted
         * data or want to sort data across multiple pages.
         *
         * Usage:
         *
         * ```typescript
         * @Component({
         * 	selector: "app-table",
         * 	template: `
         * 		<ibm-table
         * 			[model]="model"
         * 			(sort)="simpleSort($event)">
         * 			No data.
         * 		</ibm-table>
         * 	`
         * })
         * export class TableApp implements OnInit, OnChanges {
         * 	@Input() model = new TableModel();
         *
         * 	ngOnInit() {
         * 		this.model.header = [
         * 			new TableHeaderItem({ data: "Name" }),
         * 			new TableHeaderItem({ data: "hwer" })
         * 		];
         *
         * 		this.model.data = [
         * 			[new TableItem({ data: "Name 1" }), new TableItem({ data: "qwer" })],
         * 			[new TableItem({ data: "Name 3" }), new TableItem({ data: "zwer" })],
         * 			[new TableItem({ data: "Name 2" }), new TableItem({ data: "swer" })],
         * 			[new TableItem({ data: "Name 4" }), new TableItem({data: "twer"})],
         * 			[new TableItem({ data: "Name 5" }), new TableItem({data: "twer"})],
         * 			[new TableItem({ data: "Name 6" }), new TableItem({data: "twer"})]
         * 		];
         * 	}
         *
         * 	simpleSort(index: number) {
         * 		// this function does a simple sort, which is the default for the table and if that's
         * 		// all you want, you don't need to do this.
         *
         * 		// here you can query your backend and update the model.data based on the result
         * 		if (this.model.header[index].sorted) {
         * 			// if already sorted flip sorting direction
         * 			this.model.header[index].ascending = this.model.header[index].descending;
         * 		}
         * 		this.model.sort(index);
         * 	}
         * }
         * ```
         */
        this.sort = new EventEmitter();
        /**
         * Emits if all rows are selected.
         *
         * @param model
         */
        this.selectAll = new EventEmitter();
        /**
         * Emits if all rows are deselected.
         *
         * @param model
         */
        this.deselectAll = new EventEmitter();
        /**
         * Emits if a single row is selected.
         *
         * @param ({model: this.model, selectedRowIndex: index})
         */
        this.selectRow = new EventEmitter();
        /**
         * Emits if a single row is deselected.
         *
         * @param ({model: this.model, deselectedRowIndex: index})
         */
        this.deselectRow = new EventEmitter();
        /**
         * Emits if a row item excluding expandButtons, checkboxes, or radios is clicked.
         */
        this.rowClick = new EventEmitter();
        /**
         * Emits when table requires more data to be loaded.
         */
        this.scrollLoad = new EventEmitter();
        /**
         * Controls if all checkboxes are viewed as selected.
         */
        this.selectAllCheckbox = false;
        /**
         * Controls the indeterminate state of the header checkbox.
         */
        this.selectAllCheckboxSomeSelected = false;
        this.isColumnDragging = false;
        this.columnDraggedHoverIndex = -1;
        this.columnDraggedPosition = "";
        this._isDataGrid = false;
        // flag to prevent getters/setters from querying the view before it's fully instantiated
        this.isViewReady = false;
        this.subscriptions = new Subscription();
        this._expandButtonAriaLabel = this.i18n.getOverridable("TABLE.EXPAND_BUTTON");
        this._sortDescendingLabel = this.i18n.getOverridable("TABLE.SORT_DESCENDING");
        this._sortAscendingLabel = this.i18n.getOverridable("TABLE.SORT_ASCENDING");
        this._checkboxHeaderLabel = this.i18n.getOverridable("TABLE.CHECKBOX_HEADER");
        this._checkboxRowLabel = this.i18n.getOverridable("TABLE.CHECKBOX_ROW");
        this._endOfDataText = this.i18n.getOverridable("TABLE.END_OF_DATA");
        this._scrollTopText = this.i18n.getOverridable("TABLE.SCROLL_TOP");
        this._filterTitle = this.i18n.getOverridable("TABLE.FILTER");
    }
    /**
     * Creates a skeleton model with a row and column count specified by the user
     *
     * Example:
     *
     * ```typescript
     * this.model = Table.skeletonModel(5, 5);
     * ```
     */
    Table.skeletonModel = function (rowCount, columnCount) {
        var model = new TableModel();
        var header = new Array();
        var data = new Array();
        var row = new Array();
        for (var i = 0; i < columnCount; i++) {
            header.push(new TableHeaderItem());
            row.push(new TableItem());
        }
        for (var i = 0; i < rowCount - 1; i++) {
            data.push(row);
        }
        model.header = header;
        model.data = data;
        return model;
    };
    Table.setTabIndex = function (element, index) {
        var focusElementList = getFocusElementList(element, tabbableSelectorIgnoreTabIndex);
        if (element.firstElementChild && element.firstElementChild.classList.contains("bx--table-sort")) {
            focusElementList[1].tabIndex = index;
        }
        else if (focusElementList.length > 0) {
            focusElementList[0].tabIndex = index;
        }
        else {
            element.tabIndex = index;
        }
    };
    Table.focus = function (element) {
        var focusElementList = getFocusElementList(element, tabbableSelectorIgnoreTabIndex);
        if (element.firstElementChild && element.firstElementChild.classList.contains("bx--table-sort") && focusElementList.length > 1) {
            focusElementList[1].focus();
        }
        else if (focusElementList.length > 0) {
            focusElementList[0].focus();
        }
        else {
            element.focus();
        }
    };
    Object.defineProperty(Table.prototype, "model", {
        get: function () {
            return this._model;
        },
        /**
         * `TableModel` with data the table is to display.
         */
        set: function (m) {
            var _this = this;
            if (this._model) {
                this.subscriptions.unsubscribe();
                // Need to create a new subscription instance here because unsubscribing prevents any new subscriptions
                // from being added for some reason. When a new model is set, none of the subscriptions would exist.
                this.subscriptions = new Subscription();
            }
            this._model = m;
            var rowsChange = this._model.rowsSelectedChange.subscribe(function () { return _this.updateSelectAllCheckbox(); });
            var dataChange = this._model.dataChange.subscribe(function () {
                if (_this.isDataGrid) {
                    _this.resetTabIndex();
                }
                _this.updateSelectAllCheckbox();
            });
            this.subscriptions.add(rowsChange);
            this.subscriptions.add(dataChange);
            if (this.isDataGrid) {
                var expandedChange = this._model.rowsExpandedChange.subscribe(function () {
                    // Allows the expanded row to have a focus state when it exists in the DOM
                    setTimeout(function () {
                        var expandedRows = _this.elementRef.nativeElement.querySelectorAll(".bx--expandable-row:not(.bx--parent-row)");
                        Array.from(expandedRows).forEach(function (row) {
                            if (row.firstElementChild.tabIndex === undefined || row.firstElementChild.tabIndex !== -1) {
                                row.firstElementChild.tabIndex = -1;
                            }
                        });
                    });
                });
                this.subscriptions.add(expandedChange);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Table.prototype, "isDataGrid", {
        get: function () {
            return this._isDataGrid;
        },
        /**
         * Set to `true` for a data grid with keyboard interactions.
         */
        set: function (value) {
            this._isDataGrid = value;
            if (this.isViewReady) {
                if (value) {
                    this.enableDataGridInteractions();
                }
                else {
                    this.disableDataGridInteractions();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Table.prototype, "expandButtonAriaLabel", {
        get: function () {
            return this._expandButtonAriaLabel.value;
        },
        set: function (value) {
            this._expandButtonAriaLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Table.prototype, "sortDescendingLabel", {
        get: function () {
            return this._sortDescendingLabel.value;
        },
        set: function (value) {
            this._sortDescendingLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Table.prototype, "sortAscendingLabel", {
        get: function () {
            return this._sortAscendingLabel.value;
        },
        set: function (value) {
            this._sortAscendingLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Table.prototype, "translations", {
        /**
         * Expects an object that contains some or all of:
         * ```
         * {
         *		"FILTER": "Filter",
         *		"END_OF_DATA": "You've reached the end of your content",
         *		"SCROLL_TOP": "Scroll to top",
         *		"CHECKBOX_HEADER": "Select all rows",
         *		"CHECKBOX_ROW": "Select row"
         * }
         * ```
         */
        set: function (value) {
            var valueWithDefaults = merge(this.i18n.getMultiple("TABLE"), value);
            this._filterTitle.override(valueWithDefaults.FILTER);
            this._endOfDataText.override(valueWithDefaults.END_OF_DATA);
            this._scrollTopText.override(valueWithDefaults.SCROLL_TOP);
            this._checkboxHeaderLabel.override(valueWithDefaults.CHECKBOX_HEADER);
            this._checkboxRowLabel.override(valueWithDefaults.CHECKBOX_ROW);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Table.prototype, "noData", {
        get: function () {
            return !this.model.data ||
                this.model.data.length === 0 ||
                this.model.data.length === 1 && this.model.data[0].length === 0;
        },
        enumerable: true,
        configurable: true
    });
    Table.prototype.ngAfterViewInit = function () {
        this.isViewReady = true;
        if (this.isDataGrid) {
            this.enableDataGridInteractions();
        }
    };
    Table.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
        if (this.positionSubscription) {
            this.positionSubscription.unsubscribe();
        }
    };
    Table.prototype.enableDataGridInteractions = function () {
        // if we have an `interactioModel` we've already enabled datagrid
        if (this.interactionModel) {
            return;
        }
        var table = this.elementRef.nativeElement.querySelector("table");
        var tableAdapter = new TableDomAdapter(table);
        var keydownEventStream = fromEvent(table, "keydown");
        var clickEventStream = fromEvent(table, "click");
        this.interactionModel = new DataGridInteractionModel(keydownEventStream, clickEventStream, tableAdapter);
        this.positionSubscription = this.interactionModel.position.subscribe(function (event) {
            var _a = __read(event.current, 2), currentRow = _a[0], currentColumn = _a[1];
            var _b = __read(event.previous, 2), previousRow = _b[0], previousColumn = _b[1];
            var currentElement = tableAdapter.getCell(currentRow, currentColumn);
            Table.setTabIndex(currentElement, 0);
            // if the model has just initialized don't focus or reset anything
            if (previousRow === -1 || previousColumn === -1) {
                return;
            }
            // Make the previous cell unfocusable (if it's not the current)
            if (previousRow !== currentRow || previousColumn !== currentColumn) {
                var previousElement = tableAdapter.getCell(previousRow, previousColumn);
                Table.setTabIndex(previousElement, -1);
            }
            Table.focus(currentElement);
        });
        // call this after assigning `this.interactionModel` since it depends on it
        this.resetTabIndex();
    };
    Table.prototype.disableDataGridInteractions = function () {
        // unsubscribe first so we don't cause the focus to fly around
        if (this.positionSubscription) {
            this.positionSubscription.unsubscribe();
        }
        // undo tab indexing (also resets the model)
        this.resetTabIndex(0);
        // null out the model ref
        this.interactionModel = null;
    };
    Table.prototype.onSelectAll = function () {
        this.model.selectAll(true);
        this.selectAll.emit(this.model);
    };
    Table.prototype.onDeselectAll = function () {
        this.model.selectAll(false);
        this.deselectAll.emit(this.model);
    };
    Table.prototype.onSelectRow = function (event) {
        // check for the existence of the selectedRowIndex property
        if (Object.keys(event).includes("selectedRowIndex")) {
            if (this.enableSingleSelect) {
                this.model.selectAll(false);
            }
            this.model.selectRow(event.selectedRowIndex, true);
            this.selectRow.emit(event);
        }
        else {
            this.model.selectRow(event.deselectedRowIndex, false);
            this.deselectRow.emit(event);
        }
    };
    Table.prototype.onRowClick = function (index) {
        this.rowClick.emit(index);
    };
    Table.prototype.updateSelectAllCheckbox = function () {
        var selectedRowsCount = this.model.selectedRowsCount();
        if (selectedRowsCount <= 0) {
            // reset select all checkbox if nothing selected
            this.selectAllCheckbox = false;
            this.selectAllCheckboxSomeSelected = false;
        }
        else if (selectedRowsCount < this.model.data.length) {
            this.selectAllCheckbox = true;
            this.selectAllCheckboxSomeSelected = true;
        }
        else {
            this.selectAllCheckbox = true;
            this.selectAllCheckboxSomeSelected = false;
        }
    };
    Table.prototype.resetTabIndex = function (newTabIndex) {
        var _this = this;
        if (newTabIndex === void 0) { newTabIndex = -1; }
        // ensure the view is ready for the reset before we preform the actual reset
        setTimeout(function () {
            // reset all the tabIndexes we can find
            var focusElementList = getFocusElementList(_this.elementRef.nativeElement, tabbableSelectorIgnoreTabIndex);
            if (focusElementList) {
                focusElementList.forEach(function (tabbable) {
                    tabbable.tabIndex = newTabIndex;
                });
            }
            // reset interaction model positions and tabIndexes
            if (_this.interactionModel) {
                _this.interactionModel.resetTabIndexes(newTabIndex);
            }
        });
    };
    Table.prototype.columnResizeStart = function (event, column) {
        var _this = this;
        this.columnResizeWidth = parseInt(column.style.width, 10);
        this.columnResizeMouseX = event.clientX;
        event.preventDefault();
        this.mouseMoveSubscription = fromEvent(document.body, "mousemove").subscribe(function (event) {
            _this.columnResizeProgress(event, column);
        });
        this.mouseUpSubscription = fromEvent(document.body, "mouseup").subscribe(function (event) {
            _this.columnResizeEnd(event, column);
        });
    };
    Table.prototype.columnResizeProgress = function (event, column) {
        var move = event.clientX - this.columnResizeMouseX;
        column.style.width = this.columnResizeWidth + move + "px";
    };
    Table.prototype.columnResizeEnd = function (event, column) {
        this.mouseMoveSubscription.unsubscribe();
        this.mouseUpSubscription.unsubscribe();
    };
    /**
     * Triggered when the user scrolls on the `<tbody>` element.
     * Emits the `scrollLoad` event.
     */
    Table.prototype.onScroll = function (event) {
        var distanceFromBottom = event.target.scrollHeight - event.target.clientHeight - event.target.scrollTop;
        if (distanceFromBottom <= this.scrollLoadDistance) {
            this.scrollLoad.emit(this.model);
        }
        else {
            this.model.isEnd = false;
        }
    };
    Table.prototype.columnDragStart = function (event, columnIndex) {
        this.isColumnDragging = true;
        this.columnDraggedHoverIndex = columnIndex;
        event.dataTransfer.setData("columnIndex", JSON.stringify(columnIndex));
    };
    Table.prototype.columnDragEnd = function (event, columnIndex) {
        this.isColumnDragging = false;
        this.columnDraggedHoverIndex = -1;
    };
    Table.prototype.columnDragEnter = function (event, position, columnIndex) {
        this.columnDraggedPosition = position;
        this.columnDraggedHoverIndex = columnIndex;
    };
    Table.prototype.columnDragLeave = function (event, position, columnIndex) {
        this.columnDraggedPosition = "";
    };
    Table.prototype.columnDragover = function (event, position, columnIndex) {
        this.columnDraggedHoverIndex = columnIndex;
        this.columnDraggedPosition = position;
        // needed to tell browser to allow dropping
        event.preventDefault();
    };
    Table.prototype.columnDrop = function (event, position, columnIndex) {
        this.isColumnDragging = false;
        this.columnDraggedHoverIndex = -1;
        this.columnDraggedPosition = "";
        this.model.moveColumn(parseInt(event.dataTransfer.getData("columnIndex"), 10), columnIndex + (position === "right" ? 1 : 0));
    };
    Table.prototype.doSort = function (index) {
        if (this.sort.observers.length === 0) {
            // no sort provided so do the simple sort
            if (this.model.header[index].sorted) {
                // if already sorted flip sorting direction
                this.model.header[index].ascending = this.model.header[index].descending;
            }
            this.model.sort(index);
        }
        this.sort.emit(index);
    };
    /**
     * Triggered when the user scrolls on the `<tbody>` element.
     * Emits the `scrollLoad` event.
     */
    Table.prototype.scrollToTop = function (event) {
        event.target.parentElement.parentElement.parentElement.parentElement.children[1].scrollTop = 0;
        this.model.isEnd = false;
    };
    Table.prototype.getSelectionLabelValue = function (row) {
        if (!this.selectionLabelColumn) {
            return { value: this.i18n.get().TABLE.ROW };
        }
        return { value: row[this.selectionLabelColumn].data };
    };
    Table.prototype.getExpandButtonAriaLabel = function () {
        return this._expandButtonAriaLabel.subject;
    };
    Table.prototype.getSortDescendingLabel = function () {
        return this._sortDescendingLabel.subject;
    };
    Table.prototype.getSortAscendingLabel = function () {
        return this._sortAscendingLabel.subject;
    };
    Table.prototype.getCheckboxHeaderLabel = function () {
        return this._checkboxHeaderLabel.subject;
    };
    Table.prototype.getCheckboxRowLabel = function () {
        return this._checkboxRowLabel.subject;
    };
    Table.prototype.getEndOfDataText = function () {
        return this._endOfDataText.subject;
    };
    Table.prototype.getScrollTopText = function () {
        return this._scrollTopText.subject;
    };
    Table.prototype.getFilterTitle = function () {
        return this._filterTitle.subject;
    };
    Table.decorators = [
        { type: Component, args: [{
                    selector: "ibm-table",
                    template: "\n\t<table\n\t\tibmTable\n\t\t[sortable]=\"sortable\"\n\t\t[noBorder]=\"noBorder\"\n\t\t[ngClass]=\"{'bx--data-table--sticky-header': stickyHeader}\"\n\t\t[size]=\"size\"\n\t\t[striped]=\"striped\"\n\t\t[skeleton]=\"skeleton\">\n\t\t<thead\n\t\t\tibmTableHead\n\t\t\t[sortable]=\"sortable\"\n\t\t\t(deselectAll)=\"onDeselectAll()\"\n\t\t\t(selectAll)=\"onSelectAll()\"\n\t\t\t(sort)=\"doSort($event)\"\n\t\t\t[checkboxHeaderLabel]=\"getCheckboxHeaderLabel()\"\n\t\t\t[filterTitle]=\"getFilterTitle()\"\n\t\t\t[model]=\"model\"\n\t\t\t[size]=\"size\"\n\t\t\t[selectAllCheckbox]=\"selectAllCheckbox\"\n\t\t\t[selectAllCheckboxSomeSelected]=\"selectAllCheckboxSomeSelected\"\n\t\t\t[showSelectionColumn]=\"showSelectionColumn\"\n\t\t\t[enableSingleSelect]=\"enableSingleSelect\"\n\t\t\t[skeleton]=\"skeleton\"\n\t\t\t[sortAscendingLabel]=\"sortAscendingLabel\"\n\t\t\t[sortDescendingLabel]=\"sortDescendingLabel\"\n\t\t\t[stickyHeader]=\"stickyHeader\">\n\t\t</thead>\n\t\t<tbody\n\t\t\tibmTableBody\n\t\t\t(deselectRow)=\"onSelectRow($event)\"\n\t\t\t(scroll)=\"onScroll($event)\"\n\t\t\t(selectRow)=\"onSelectRow($event)\"\n\t\t\t[checkboxRowLabel]=\"getCheckboxRowLabel()\"\n\t\t\t[enableSingleSelect]=\"enableSingleSelect\"\n\t\t\t(rowClick)=\"onRowClick($event)\"\n\t\t\t[expandButtonAriaLabel]=\"expandButtonAriaLabel\"\n\t\t\t[model]=\"model\"\n\t\t\t[size]=\"size\"\n\t\t\t[ngStyle]=\"{'overflow-y': 'scroll'}\"\n\t\t\t[selectionLabelColumn]=\"selectionLabelColumn\"\n\t\t\t[showSelectionColumn]=\"showSelectionColumn\"\n\t\t\t[skeleton]=\"skeleton\"\n\t\t\t*ngIf=\"!noData; else noDataTemplate\">\n\t\t</tbody>\n\t\t<ng-template #noDataTemplate><ng-content></ng-content></ng-template>\n\t\t<tfoot>\n\t\t\t<ng-template\n\t\t\t\t[ngTemplateOutlet]=\"footerTemplate\">\n\t\t\t</ng-template>\n\t\t\t<tr *ngIf=\"this.model.isLoading\">\n\t\t\t\t<td class=\"table_loading-indicator\">\n\t\t\t\t\t<div class=\"bx--loading bx--loading--small\">\n\t\t\t\t\t\t<svg class=\"bx--loading__svg\" viewBox=\"-75 -75 150 150\">\n\t\t\t\t\t\t\t<circle class=\"bx--loading__stroke\" cx=\"0\" cy=\"0\" r=\"37.5\" />\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t<tr *ngIf=\"this.model.isEnd\">\n\t\t\t\t<td class=\"table_end-indicator\">\n\t\t\t\t\t<h5>{{getEndOfDataText() | async}}</h5>\n\t\t\t\t\t<button (click)=\"scrollToTop($event)\" class=\"btn--secondary-sm\">\n\t\t\t\t\t\t{{getScrollTopText() | async}}\n\t\t\t\t\t</button>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</tfoot>\n\t</table>\n\t"
                }] }
    ];
    /** @nocollapse */
    Table.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ApplicationRef },
        { type: I18n }
    ]; };
    Table.propDecorators = {
        model: [{ type: Input }],
        size: [{ type: Input }],
        skeleton: [{ type: Input }],
        isDataGrid: [{ type: Input }],
        sortable: [{ type: Input }],
        noBorder: [{ type: Input }],
        showSelectionColumn: [{ type: Input }],
        enableSingleSelect: [{ type: Input }],
        scrollLoadDistance: [{ type: Input }],
        columnsResizable: [{ type: Input }],
        columnsDraggable: [{ type: Input }],
        expandButtonAriaLabel: [{ type: Input }],
        sortDescendingLabel: [{ type: Input }],
        sortAscendingLabel: [{ type: Input }],
        translations: [{ type: Input }],
        striped: [{ type: Input }],
        stickyHeader: [{ type: HostBinding, args: ["class.bx--data-table_inner-container",] }, { type: Input }],
        footerTemplate: [{ type: Input }],
        selectionLabelColumn: [{ type: Input }],
        sort: [{ type: Output }],
        selectAll: [{ type: Output }],
        deselectAll: [{ type: Output }],
        selectRow: [{ type: Output }],
        deselectRow: [{ type: Output }],
        rowClick: [{ type: Output }],
        scrollLoad: [{ type: Output }]
    };
    return Table;
}());

var TableDirective = /** @class */ (function () {
    function TableDirective() {
        this.sortable = true;
        this.noBorder = true;
        this.striped = false;
        this.skeleton = false;
        /**
         * Size of the table rows.
         */
        this.size = "md";
        this.tableClass = true;
    }
    Object.defineProperty(TableDirective.prototype, "compactClass", {
        get: function () {
            return this.size === "sm";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableDirective.prototype, "tallClass", {
        get: function () {
            return this.size === "lg";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableDirective.prototype, "shortClass", {
        get: function () {
            return this.size === "sh";
        },
        enumerable: true,
        configurable: true
    });
    TableDirective.decorators = [
        { type: Directive, args: [{
                    selector: "[ibmTable]"
                },] }
    ];
    TableDirective.propDecorators = {
        sortable: [{ type: Input }, { type: HostBinding, args: ["class.bx--data-table--sort",] }],
        noBorder: [{ type: Input }, { type: HostBinding, args: ["class.bx--data-table--no-border",] }],
        striped: [{ type: Input }, { type: HostBinding, args: ["class.bx--data-table--zebra",] }],
        skeleton: [{ type: Input }, { type: HostBinding, args: ["class.bx--skeleton",] }],
        size: [{ type: Input }],
        tableClass: [{ type: HostBinding, args: ["class.bx--data-table",] }],
        compactClass: [{ type: HostBinding, args: ["class.bx--data-table--compact",] }],
        tallClass: [{ type: HostBinding, args: ["class.bx--data-table--tall",] }],
        shortClass: [{ type: HostBinding, args: ["class.bx--data-table--short",] }]
    };
    return TableDirective;
}());

/**
 * A subcomponent that creates the thead of the table
 *
 * ## Basic usage
 *
 * ```html
 * 	<thead ibmTableHead [model]="model"></thead>
 * ```
 */
var TableHead = /** @class */ (function () {
    function TableHead(i18n) {
        this.i18n = i18n;
        this.showSelectionColumn = true;
        this.enableSingleSelect = false;
        this.selectAllCheckboxSomeSelected = false;
        this.selectAllCheckbox = false;
        this.skeleton = false;
        this.stickyHeader = false;
        /**
         * Setting sortable to false will disable all headers including headers which are sortable. Is is
         * possible to set the sortable state on the header item to disable/enable sorting for only some headers.
         */
        this.sortable = true;
        /**
         * Size of the table rows.
         */
        this.size = "md";
        /**
         * Emits an index of the column that wants to be sorted.
         */
        this.sort = new EventEmitter();
        /**
         * Emits if all rows are selected.
         *
         * @param model
         */
        this.selectAll = new EventEmitter();
        /**
         * Emits if all rows are deselected.
         *
         * @param model
         */
        this.deselectAll = new EventEmitter();
        this.scrollbarWidth = 0;
        this._checkboxHeaderLabel = this.i18n.getOverridable("TABLE.CHECKBOX_HEADER");
        this._sortDescendingLabel = this.i18n.getOverridable("TABLE.SORT_DESCENDING");
        this._sortAscendingLabel = this.i18n.getOverridable("TABLE.SORT_ASCENDING");
        this._filterTitle = this.i18n.getOverridable("TABLE.FILTER");
    }
    Object.defineProperty(TableHead.prototype, "checkboxHeaderLabel", {
        get: function () {
            return this._checkboxHeaderLabel.value;
        },
        set: function (value) {
            this._checkboxHeaderLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableHead.prototype, "sortDescendingLabel", {
        get: function () {
            return this._sortDescendingLabel.value;
        },
        set: function (value) {
            this._sortDescendingLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableHead.prototype, "sortAscendingLabel", {
        get: function () {
            return this._sortAscendingLabel.value;
        },
        set: function (value) {
            this._sortAscendingLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableHead.prototype, "filterTitle", {
        get: function () {
            return this._filterTitle.value;
        },
        set: function (value) {
            this._filterTitle.override(value);
        },
        enumerable: true,
        configurable: true
    });
    TableHead.prototype.ngAfterViewInit = function () {
        var _this = this;
        setTimeout(function () {
            _this.scrollbarWidth = getScrollbarWidth();
        });
    };
    TableHead.prototype.onSelectAllCheckboxChange = function () {
        if (!this.selectAllCheckbox && !this.selectAllCheckboxSomeSelected) {
            this.selectAll.emit(this.model);
        }
        else {
            this.deselectAll.emit(this.model);
        }
    };
    TableHead.prototype.getCheckboxHeaderLabel = function () {
        return this._checkboxHeaderLabel.subject;
    };
    TableHead.prototype.getSortDescendingLabel = function () {
        return this._sortDescendingLabel.subject;
    };
    TableHead.prototype.getSortAscendingLabel = function () {
        return this._sortAscendingLabel.subject;
    };
    TableHead.prototype.getFilterTitle = function () {
        return this._filterTitle.subject;
    };
    TableHead.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: "[ibmTableHead]",
                    template: "\n\t<ng-container *ngIf=\"model\">\n\t\t<tr>\n\t\t\t<th\n\t\t\t\tibmTableHeadExpand\n\t\t\t\t*ngIf=\"model.hasExpandableRows()\"\n\t\t\t\tscope=\"col\"\n\t\t\t\t[ngClass]=\"{'bx--table-expand-v2': stickyHeader}\"\n\t\t\t\t[id]=\"model.getId('expand')\">\n\t\t\t</th>\n\t\t\t<th\n\t\t\t\t*ngIf=\"!skeleton && showSelectionColumn && enableSingleSelect\"\n\t\t\t\tscope=\"col\"\n\t\t\t\tstyle=\"width: 0;\"\n\t\t\t\t[id]=\"model.getId('select')\">\n\t\t\t\t<!-- add width 0; since the carbon styles don't seem to constrain this headers width -->\n\t\t\t</th>\n\t\t\t<th\n\t\t\t\tibmTableHeadCheckbox\n\t\t\t\t*ngIf=\"!skeleton && showSelectionColumn && !enableSingleSelect\"\n\t\t\t\tscope=\"col\"\n\t\t\t\t[checked]=\"selectAllCheckbox\"\n\t\t\t\t[indeterminate]=\"selectAllCheckboxSomeSelected\"\n\t\t\t\t[ariaLabel]=\"getCheckboxHeaderLabel()\"\n\t\t\t\t[size]=\"size\"\n\t\t\t\t[skeleton]=\"skeleton\"\n\t\t\t\t[name]=\"model.getHeaderId('select')\"\n\t\t\t\t(change)=\"onSelectAllCheckboxChange()\"\n\t\t\t\t[id]=\"model.getId('select')\">\n\t\t\t</th>\n\t\t\t<ng-container *ngFor=\"let column of model.header; let i = index\">\n\t\t\t\t<th\n\t\t\t\t\t*ngIf=\"column && column.visible\"\n\t\t\t\t\t[ngStyle]=\"column.style\"\n\t\t\t\t\tibmTableHeadCell\n\t\t\t\t\tscope=\"col\"\n\t\t\t\t\t[class]=\"column.className\"\n\t\t\t\t\t[sortable]=\"sortable\"\n\t\t\t\t\t[skeleton]=\"skeleton\"\n\t\t\t\t\t[id]=\"model.getId(i)\"\n\t\t\t\t\t[column]=\"column\"\n\t\t\t\t\t[skeleton]=\"skeleton\"\n\t\t\t\t\t[filterTitle]=\"getFilterTitle()\"\n\t\t\t\t\t[attr.colspan]=\"column.colSpan\"\n\t\t\t\t\t[attr.rowspan]=\"column.rowSpan\"\n\t\t\t\t\t(sort)=\"sort.emit(i)\">\n\t\t\t\t</th>\n\t\t\t</ng-container>\n\t\t\t<th *ngIf=\"!skeleton && stickyHeader && scrollbarWidth\"\n\t\t\t\tscope=\"col\"\n\t\t\t\t[ngStyle]=\"{'width': scrollbarWidth + 'px', 'padding': 0, 'border': 0}\">\n\t\t\t\t<!--\n\t\t\t\t\tScrollbar pushes body to the left so this header column is added to push\n\t\t\t\t\tthe title bar the same amount and keep the header and body columns aligned.\n\t\t\t\t-->\n\t\t\t</th>\n\t\t</tr>\n\t</ng-container>\n\t<ng-content></ng-content>\n\t",
                    styles: ["\n\t\t.bx--table-expand-v2 {\n\t\t\tpadding-left: 2.5rem;\n\t\t}\n\t"]
                }] }
    ];
    /** @nocollapse */
    TableHead.ctorParameters = function () { return [
        { type: I18n }
    ]; };
    TableHead.propDecorators = {
        model: [{ type: Input }],
        showSelectionColumn: [{ type: Input }],
        enableSingleSelect: [{ type: Input }],
        selectAllCheckboxSomeSelected: [{ type: Input }],
        selectAllCheckbox: [{ type: Input }],
        skeleton: [{ type: Input }],
        stickyHeader: [{ type: Input }],
        sortable: [{ type: Input }],
        size: [{ type: Input }],
        checkboxHeaderLabel: [{ type: Input }],
        sortDescendingLabel: [{ type: Input }],
        sortAscendingLabel: [{ type: Input }],
        filterTitle: [{ type: Input }],
        sort: [{ type: Output }],
        selectAll: [{ type: Output }],
        deselectAll: [{ type: Output }]
    };
    return TableHead;
}());

var TableHeadCell = /** @class */ (function () {
    function TableHeadCell(i18n) {
        this.i18n = i18n;
        this.skeleton = false;
        this.sortable = true;
        /**
         * Notifies that the column should be sorted
         */
        this.sort = new EventEmitter();
        this.theadAction = false;
        this._sortDescendingLabel = this.i18n.getOverridable("TABLE.SORT_DESCENDING");
        this._sortAscendingLabel = this.i18n.getOverridable("TABLE.SORT_ASCENDING");
        this._filterTitle = this.i18n.getOverridable("TABLE.FILTER");
    }
    Object.defineProperty(TableHeadCell.prototype, "sortDescendingLabel", {
        get: function () {
            return this._sortDescendingLabel.value;
        },
        set: function (value) {
            this._sortDescendingLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableHeadCell.prototype, "sortAscendingLabel", {
        get: function () {
            return this._sortAscendingLabel.value;
        },
        set: function (value) {
            this._sortAscendingLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableHeadCell.prototype, "filterTitle", {
        get: function () {
            return this._filterTitle.value;
        },
        set: function (value) {
            this._filterTitle.override(value);
        },
        enumerable: true,
        configurable: true
    });
    TableHeadCell.prototype.ngOnChanges = function () {
        // Since it's not an input, and it touches the view, we're using `ngOnChanges`
        // `get`ters have caused issues in the past with the view updating outside of change detection
        this.theadAction = !!this.column.filterTemplate || this.sort.observers.length > 0;
    };
    TableHeadCell.prototype.getSortDescendingLabel = function () {
        return this._sortDescendingLabel.subject.pipe(this.sortLabelMap());
    };
    TableHeadCell.prototype.getSortAscendingLabel = function () {
        return this._sortAscendingLabel.subject.pipe(this.sortLabelMap());
    };
    TableHeadCell.prototype.getFilterTitle = function () {
        return this._filterTitle.subject;
    };
    TableHeadCell.prototype.onClick = function () {
        if (!this.skeleton) {
            this.sort.emit();
        }
    };
    TableHeadCell.prototype.sortLabelMap = function () {
        var _this = this;
        return map(function (str) {
            if (_this.column.ariaSortLabel) {
                return _this.column.ariaSortLabel;
            }
            if (_this.column.formatSortLabel) {
                return _this.column.formatSortLabel(str, _this.column.ariaSortLabel);
            }
            return _this.column.data + " - " + str;
        });
    };
    TableHeadCell.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line: component-selector
                    selector: "[ibmTableHeadCell]",
                    template: "\n\t\t<button\n\t\t\tclass=\"bx--table-sort\"\n\t\t\t*ngIf=\"sortable && this.sort.observers.length > 0 && column.sortable\"\n\t\t\t[attr.aria-label]=\"(column.sorted && column.ascending ? getSortDescendingLabel() : getSortAscendingLabel()) | async\"\n\t\t\taria-live=\"polite\"\n\t\t\t[ngClass]=\"{\n\t\t\t\t'bx--table-sort--active': column.sorted,\n\t\t\t\t'bx--table-sort--ascending': column.ascending\n\t\t\t}\"\n\t\t\t(click)=\"onClick()\">\n\t\t\t<span\n\t\t\t\tclass=\"bx--table-sort__flex\"\n\t\t\t\t[title]=\"column.data\"\n\t\t\t\ttabindex=\"-1\">\n\t\t\t\t<div *ngIf=\"!skeleton && !column.template\" ibmTableHeadCellLabel>\n\t\t\t\t\t{{column.data}}\n\t\t\t\t</div>\n\t\t\t\t<ng-template\n\t\t\t\t\t*ngIf=\"!skeleton && column.template\"\n\t\t\t\t\t[ngTemplateOutlet]=\"column.template\"\n\t\t\t\t\t[ngTemplateOutletContext]=\"{data: column.data}\">\n\t\t\t\t</ng-template>\n\t\t\t\t<svg\n\t\t\t\t\t*ngIf=\"!skeleton\"\n\t\t\t\t\tfocusable=\"false\"\n\t\t\t\t\tpreserveAspectRatio=\"xMidYMid meet\"\n\t\t\t\t\tstyle=\"will-change: transform;\"\n\t\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\t\t\tclass=\"bx--table-sort__icon\"\n\t\t\t\t\twidth=\"16\"\n\t\t\t\t\theight=\"16\"\n\t\t\t\t\tviewBox=\"0 0 16 16\"\n\t\t\t\t\taria-hidden=\"true\">\n\t\t\t\t\t<path d=\"M12.3 9.3l-3.8 3.8V1h-1v12.1L3.7 9.3 3 10l5 5 5-5z\"></path>\n\t\t\t\t</svg>\n\t\t\t\t<svg\n\t\t\t\t\t*ngIf=\"!skeleton\"\n\t\t\t\t\tfocusable=\"false\"\n\t\t\t\t\tpreserveAspectRatio=\"xMidYMid meet\"\n\t\t\t\t\tstyle=\"will-change: transform;\"\n\t\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\t\t\tclass=\"bx--table-sort__icon-unsorted\"\n\t\t\t\t\twidth=\"16\"\n\t\t\t\t\theight=\"16\"\n\t\t\t\t\tviewBox=\"0 0 16 16\"\n\t\t\t\t\taria-hidden=\"true\">\n\t\t\t\t\t<path d=\"M13.8 10.3L12 12.1V2h-1v10.1l-1.8-1.8-.7.7 3 3 3-3zM4.5 2l-3 3 .7.7L4 3.9V14h1V3.9l1.8 1.8.7-.7z\"></path>\n\t\t\t\t</svg>\n\t\t\t</span>\n\t\t</button>\n\t\t<div\n\t\t\tclass=\"bx--table-header-label\"\n\t\t\t*ngIf=\"!skeleton && this.sort.observers.length === 0 || (this.sort.observers.length > 0 && !column.sortable) || !sortable\">\n\t\t\t<span *ngIf=\"!column.template\" [title]=\"column.data\">{{column.data}}</span>\n\t\t\t<ng-template\n\t\t\t\t[ngTemplateOutlet]=\"column.template\" [ngTemplateOutletContext]=\"{data: column.data}\">\n\t\t\t</ng-template>\n\t\t</div>\n\t\t<button\n\t\t\t[ngClass]=\"{'active': column.filterCount > 0}\"\n\t\t\t*ngIf=\"column.filterTemplate\"\n\t\t\ttype=\"button\"\n\t\t\taria-expanded=\"false\"\n\t\t\taria-haspopup=\"true\"\n\t\t\t[ibmTooltip]=\"column.filterTemplate\"\n\t\t\ttrigger=\"click\"\n\t\t\t[title]=\"getFilterTitle() | async\"\n\t\t\tplacement=\"bottom,top\"\n\t\t\t[data]=\"column.filterData\">\n\t\t\t<svg\n\t\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\t\tclass=\"icon--sm\"\n\t\t\t\twidth=\"16\"\n\t\t\t\theight=\"16\"\n\t\t\t\tviewBox=\"0 0 16 16\">\n\t\t\t\t<path d=\"M0 0v3l6 8v5h4v-5l6-8V0H0zm9 10.7V15H7v-4.3L1.3 3h13.5L9 10.7z\"/>\n\t\t\t</svg>\n\t\t\t<span *ngIf=\"column.filterCount > 0\">\n\t\t\t\t{{column.filterCount}}\n\t\t\t</span>\n\t\t</button>\n\t"
                }] }
    ];
    /** @nocollapse */
    TableHeadCell.ctorParameters = function () { return [
        { type: I18n }
    ]; };
    TableHeadCell.propDecorators = {
        column: [{ type: Input }],
        skeleton: [{ type: Input }],
        sortable: [{ type: Input }],
        sortDescendingLabel: [{ type: Input }],
        sortAscendingLabel: [{ type: Input }],
        filterTitle: [{ type: Input }],
        sort: [{ type: Output }],
        theadAction: [{ type: HostBinding, args: ["class.thead_action",] }]
    };
    return TableHeadCell;
}());

var TableHeadCheckbox = /** @class */ (function () {
    function TableHeadCheckbox(i18n) {
        this.i18n = i18n;
        /**
         * Size of the table rows.
         */
        this.size = "md";
        this.checked = false;
        this.indeterminate = false;
        this.skeleton = false;
        this.name = "select-all-" + TableHeadCheckbox.tableSelectAllCount++;
        this.change = new EventEmitter();
        this.hostClass = true;
        this._ariaLabel = this.i18n.getOverridable("TABLE.CHECKBOX_HEADER");
    }
    Object.defineProperty(TableHeadCheckbox.prototype, "ariaLabel", {
        get: function () {
            return this._ariaLabel.value;
        },
        set: function (value) {
            this._ariaLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    TableHeadCheckbox.prototype.getAriaLabel = function () {
        return this._ariaLabel.subject;
    };
    TableHeadCheckbox.tableSelectAllCount = 0;
    TableHeadCheckbox.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line: component-selector
                    selector: "[ibmTableHeadCheckbox]",
                    template: "\n\t\t<ibm-checkbox\n\t\t\t*ngIf=\"!skeleton\"\n\t\t\tinline=\"true\"\n\t\t\t[size]=\"(size !== 'sm' ? 'md' : 'sm')\"\n\t\t\t[name]=\"name\"\n\t\t\t[checked]=\"checked\"\n\t\t\t[indeterminate]=\"indeterminate\"\n\t\t\t(checkedChange)=\"change.emit()\"\n\t\t\t[aria-label]=\"getAriaLabel() | async\">\n\t\t</ibm-checkbox>\n\t",
                    styles: ["\n        :host { width: 10px; }\n    "]
                }] }
    ];
    /** @nocollapse */
    TableHeadCheckbox.ctorParameters = function () { return [
        { type: I18n }
    ]; };
    TableHeadCheckbox.propDecorators = {
        size: [{ type: Input }],
        checked: [{ type: Input }],
        indeterminate: [{ type: Input }],
        skeleton: [{ type: Input }],
        name: [{ type: Input }],
        ariaLabel: [{ type: Input }],
        change: [{ type: Output }],
        hostClass: [{ type: HostBinding, args: ["class.bx--table-column-checkbox",] }]
    };
    return TableHeadCheckbox;
}());

var TableHeadExpand = /** @class */ (function () {
    function TableHeadExpand() {
        this.hostClass = true;
    }
    TableHeadExpand.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line: component-selector
                    selector: "[ibmTableHeadExpand]",
                    template: "\n\t\t<ng-content></ng-content>\n\t"
                }] }
    ];
    TableHeadExpand.propDecorators = {
        hostClass: [{ type: HostBinding, args: ["class.bx--table-expand",] }]
    };
    return TableHeadExpand;
}());

var TableBody = /** @class */ (function () {
    function TableBody(i18n) {
        this.i18n = i18n;
        /**
         * Controls whether to enable multiple or single row selection.
         */
        this.enableSingleSelect = false;
        /**
         * Controls whether to show the selection checkboxes column or not.
         */
        this.showSelectionColumn = true;
        /**
         * Size of the table rows.
         */
        this.size = "md";
        this.skeleton = false;
        /**
         * Emits if a single row is selected.
         *
         * @param ({model: this.model, selectedRowIndex: index})
         */
        this.selectRow = new EventEmitter();
        /**
         * Emits if a single row is deselected.
         *
         * @param ({model: this.model, deselectedRowIndex: index})
         */
        this.deselectRow = new EventEmitter();
        /**
         * Emits if a row item excluding expandButtons, checkboxes, or radios is clicked.
         */
        this.rowClick = new EventEmitter();
        this._checkboxRowLabel = this.i18n.getOverridable("TABLE.CHECKBOX_ROW");
        this._expandButtonAriaLabel = this.i18n.getOverridable("TABLE.EXPAND_BUTTON");
    }
    Object.defineProperty(TableBody.prototype, "expandButtonAriaLabel", {
        get: function () {
            return this._expandButtonAriaLabel.value;
        },
        set: function (value) {
            this._expandButtonAriaLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableBody.prototype, "checkboxRowLabel", {
        get: function () {
            return this._checkboxRowLabel.value;
        },
        set: function (value) {
            this._checkboxRowLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Triggered when a single row is clicked.
     * Updates the header checkbox state.
     * Emits the `selectRow` or `deselectRow` event.
     */
    TableBody.prototype.onRowCheckboxChange = function (index) {
        if (this.model.isRowSelected(index)) {
            this.deselectRow.emit({ model: this.model, deselectedRowIndex: index });
        }
        else {
            this.selectRow.emit({ model: this.model, selectedRowIndex: index });
        }
    };
    TableBody.prototype.onRowClick = function (index) {
        this.rowClick.emit(index);
    };
    TableBody.prototype.getCheckboxRowLabel = function () {
        return this._checkboxRowLabel.subject;
    };
    TableBody.prototype.getExpandButtonAriaLabel = function () {
        return this._expandButtonAriaLabel.subject;
    };
    TableBody.prototype.firstExpandedDataInRow = function (row) {
        var found = row.find(function (d) { return d.expandedData; });
        if (found) {
            return found.expandedData;
        }
        return found;
    };
    TableBody.prototype.shouldExpandAsTable = function (row) {
        return row.some(function (d) { return d.expandAsTable; });
    };
    TableBody.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line: component-selector
                    selector: "[ibmTableBody]",
                    template: "\n\t\t<ng-container *ngIf=\"model\">\n\t\t\t<ng-container *ngFor=\"let row of model.data; let i = index\">\n\t\t\t\t<tr\n\t\t\t\t\tibmTableRow\n\t\t\t\t\t[model]=\"model\"\n\t\t\t\t\t[row]=\"row\"\n\t\t\t\t\t[size]=\"size\"\n\t\t\t\t\t[selected]=\"model.isRowSelected(i)\"\n\t\t\t\t\t[expandable]=\"model.isRowExpandable(i)\"\n\t\t\t\t\t[expanded]=\"model.isRowExpanded(i)\"\n\t\t\t\t\t[checkboxLabel]=\"getCheckboxRowLabel()\"\n\t\t\t\t\t[expandButtonAriaLabel]=\"getExpandButtonAriaLabel()\"\n\t\t\t\t\t[showSelectionColumn]=\"showSelectionColumn\"\n\t\t\t\t\t[enableSingleSelect]=\"enableSingleSelect\"\n\t\t\t\t\t[skeleton]=\"skeleton\"\n\t\t\t\t\t(selectRow)=\"onRowCheckboxChange(i)\"\n\t\t\t\t\t(deselectRow)=\"onRowCheckboxChange(i)\"\n\t\t\t\t\t(expandRow)=\"model.expandRow(i, !model.isRowExpanded(i))\"\n\t\t\t\t\t(rowClick)=\"onRowClick(i)\"\n\t\t\t\t\t*ngIf=\"!model.isRowFiltered(i)\"\n\t\t\t\t\t[class]=\"(model.rowsClass[i] ? model.rowsClass[i] : null)\"\n\t\t\t\t\t[ngClass]=\"{\n\t\t\t\t\t\t'tbody_row--success': !model.isRowSelected(i) && model.getRowContext(i) === 'success',\n\t\t\t\t\t\t'tbody_row--warning': !model.isRowSelected(i) && model.getRowContext(i) === 'warning',\n\t\t\t\t\t\t'tbody_row--info': !model.isRowSelected(i) && model.getRowContext(i) === 'info',\n\t\t\t\t\t\t'tbody_row--error': !model.isRowSelected(i) && model.getRowContext(i) === 'error'\n\t\t\t\t\t}\">\n\t\t\t\t</tr>\n\t\t\t\t<ng-container *ngIf=\"model.isRowExpanded(i) && !model.isRowFiltered(i)\">\n\t\t\t\t\t<tr\n\t\t\t\t\t\t*ngIf=\"!shouldExpandAsTable(row); else expandAsTableTemplate\"\n\t\t\t\t\t\tibmTableExpandedRow\n\t\t\t\t\t\tibmExpandedRowHover\n\t\t\t\t\t\t[row]=\"row\"\n\t\t\t\t\t\t[expanded]=\"model.isRowExpanded(i)\"\n\t\t\t\t\t\t[skeleton]=\"skeleton\">\n\t\t\t\t\t</tr>\n\t\t\t\t\t<ng-template #expandAsTableTemplate>\n\t\t\t\t\t\t<tr\n\t\t\t\t\t\t\t*ngFor=\"let expandedDataRow of firstExpandedDataInRow(row)\"\n\t\t\t\t\t\t\tibmTableRow\n\t\t\t\t\t\t\t[model]=\"model\"\n\t\t\t\t\t\t\t[showSelectionColumnCheckbox]=\"false\"\n\t\t\t\t\t\t\t[showSelectionColumn]=\"showSelectionColumn\"\n\t\t\t\t\t\t\t[row]=\"expandedDataRow\"\n\t\t\t\t\t\t\t[size]=\"size\"\n\t\t\t\t\t\t\t[skeleton]=\"skeleton\">\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</ng-template>\n\t\t\t\t</ng-container>\n\t\t\t</ng-container>\n\t\t</ng-container>\n\t\t<ng-content></ng-content>\n\t"
                }] }
    ];
    /** @nocollapse */
    TableBody.ctorParameters = function () { return [
        { type: I18n }
    ]; };
    TableBody.propDecorators = {
        model: [{ type: Input }],
        enableSingleSelect: [{ type: Input }],
        expandButtonAriaLabel: [{ type: Input }],
        checkboxRowLabel: [{ type: Input }],
        showSelectionColumn: [{ type: Input }],
        size: [{ type: Input }],
        selectionLabelColumn: [{ type: Input }],
        skeleton: [{ type: Input }],
        selectRow: [{ type: Output }],
        deselectRow: [{ type: Output }],
        rowClick: [{ type: Output }]
    };
    return TableBody;
}());

var TableRowComponent = /** @class */ (function () {
    function TableRowComponent(i18n) {
        this.i18n = i18n;
        this.expanded = false;
        this.expandable = false;
        this.selected = false;
        /**
         * Size of the table rows.
         */
        this.size = "md";
        /**
         * Controls whether to enable multiple or single row selection.
         */
        this.enableSingleSelect = false;
        /**
         * Controls whether to show the selection checkboxes column or not.
         */
        this.showSelectionColumn = true;
        /**
         * Shows or hide the checkbox in the selection column when `showSelectionColumn`
         * is set to true
         */
        this.showSelectionColumnCheckbox = true;
        this.skeleton = false;
        /**
         * Emits when the row is selected.
         */
        this.selectRow = new EventEmitter();
        /**
         * Emits when the row is deselected.
         */
        this.deselectRow = new EventEmitter();
        /**
         * Emits when the row is expanded
         */
        this.expandRow = new EventEmitter();
        /**
         * Emits when a row is clicked regardless of `enableSingleSelect` or `showSelectionColumn`.
         * Should only get emitted when a row item is selected excluding expand buttons,
         * checkboxes, or radios.
         */
        this.rowClick = new EventEmitter();
        this._checkboxLabel = this.i18n.getOverridable("TABLE.CHECKBOX_ROW");
        this._expandButtonAriaLabel = this.i18n.getOverridable("TABLE.EXPAND_BUTTON");
    }
    Object.defineProperty(TableRowComponent.prototype, "expandButtonAriaLabel", {
        get: function () {
            return this._expandButtonAriaLabel.value;
        },
        set: function (value) {
            this._expandButtonAriaLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableRowComponent.prototype, "checkboxLabel", {
        get: function () {
            return this._checkboxLabel.value;
        },
        set: function (value) {
            this._checkboxLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableRowComponent.prototype, "selectedClass", {
        get: function () {
            return this.selected;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableRowComponent.prototype, "parentRowClass", {
        get: function () {
            return this.expandable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableRowComponent.prototype, "expandableRowClass", {
        get: function () {
            return this.expanded;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableRowComponent.prototype, "selectableClass", {
        get: function () {
            return false; // this.singleSelect
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableRowComponent.prototype, "isParentRow", {
        get: function () {
            return this.expandable ? true : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableRowComponent.prototype, "isAccessible", {
        get: function () {
            return this.enableSingleSelect && !this.showSelectionColumn ? 0 : null;
        },
        enumerable: true,
        configurable: true
    });
    TableRowComponent.prototype.onHostClick = function () {
        if (this.enableSingleSelect && !this.showSelectionColumn) {
            this.onSelectionChange();
        }
    };
    TableRowComponent.prototype.onRowClick = function () {
        this.rowClick.emit();
    };
    TableRowComponent.prototype.onSelectionChange = function () {
        if (this.selected) {
            this.deselectRow.emit();
        }
        else {
            this.selectRow.emit();
        }
    };
    TableRowComponent.prototype.getCheckboxLabel = function () {
        return this._checkboxLabel.subject;
    };
    TableRowComponent.prototype.getExpandButtonAriaLabel = function () {
        return this._expandButtonAriaLabel.subject;
    };
    TableRowComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line: component-selector
                    selector: "[ibmTableRow]",
                    template: "\n\t\t<ng-container *ngIf=\"model\">\n\t\t\t<td\n\t\t\t\t*ngIf=\"model.hasExpandableRows()\"\n\t\t\t\tibmTableExpandButton\n\t\t\t\tclass=\"bx--table-expand-v2\"\n\t\t\t\t[expanded]=\"expanded\"\n\t\t\t\t[expandable]=\"expandable\"\n\t\t\t\t[skeleton]=\"skeleton\"\n\t\t\t\t[ariaLabel]=\"getExpandButtonAriaLabel()\"\n\t\t\t\t[headers]=\"model.getHeaderId('expand')\"\n\t\t\t\t(expandRow)=\"expandRow.emit()\">\n\t\t\t</td>\n\t\t\t<ng-container *ngIf=\"!skeleton && showSelectionColumn && !enableSingleSelect\">\n\t\t\t\t<td\n\t\t\t\t\t*ngIf=\"!showSelectionColumnCheckbox; else tableCheckboxTemplate\">\n\t\t\t\t</td>\n\t\t\t\t<ng-template #tableCheckboxTemplate>\n\t\t\t\t\t<td\n\t\t\t\t\t\tibmTableCheckbox\n\t\t\t\t\t\tclass=\"bx--table-column-checkbox\"\n\t\t\t\t\t\t[size]=\"size\"\n\t\t\t\t\t\t[selected]=\"selected\"\n\t\t\t\t\t\t[label]=\"getCheckboxLabel()\"\n\t\t\t\t\t\t[row]=\"row\"\n\t\t\t\t\t\t[skeleton]=\"skeleton\"\n\t\t\t\t\t\t[headers]=\"model.getHeaderId('select')\"\n\t\t\t\t\t\t(change)=\"onSelectionChange()\">\n\t\t\t\t\t</td>\n\t\t\t\t</ng-template>\n\t\t\t</ng-container>\n\t\t\t<td\n\t\t\t\t*ngIf=\"!skeleton && showSelectionColumn && enableSingleSelect\"\n\t\t\t\tibmTableRadio\n\t\t\t\t[selected]=\"selected\"\n\t\t\t\t[label]=\"getCheckboxLabel()\"\n\t\t\t\t[row]=\"row\"\n\t\t\t\t[skeleton]=\"skeleton\"\n\t\t\t\t[headers]=\"model.getHeaderId('select')\"\n\t\t\t\t(change)=\"onSelectionChange()\">\n\t\t\t</td>\n\t\t\t<ng-container *ngFor=\"let item of row; let j = index\">\n\t\t\t\t<td\n\t\t\t\t\t*ngIf=\"item && model.getHeader(j) && model.getHeader(j).visible\"\n\t\t\t\t\tibmTableData\n\t\t\t\t\t[headers]=\"model.getHeaderId(j, item.colSpan)\"\n\t\t\t\t\t[item]=\"item\"\n\t\t\t\t\t[title]=\"item.title\"\n\t\t\t\t\t[class]=\"model.getHeader(j).className\"\n\t\t\t\t\t[ngStyle]=\"model.getHeader(j).style\"\n\t\t\t\t\t[skeleton]=\"skeleton\"\n\t\t\t\t\t[attr.colspan]=\"item.colSpan\"\n\t\t\t\t\t[attr.rowspan]=\"item.rowSpan\"\n\t\t\t\t\t(click)=\"onRowClick()\"\n\t\t\t\t\t(keydown.enter)=\"onRowClick()\">\n\t\t\t\t</td>\n\t\t\t\t<td\n\t\t\t\t\t*ngIf=\"item && model.getHeader(j) == null\"\n\t\t\t\t\tibmTableData\n\t\t\t\t\t[headers]=\"model.getHeaderId(j, item.colSpan)\"\n\t\t\t\t\t[item]=\"item\"\n\t\t\t\t\t[title]=\"item.title\"\n\t\t\t\t\t[skeleton]=\"skeleton\"\n\t\t\t\t\t[attr.colspan]=\"item.colSpan\"\n\t\t\t\t\t[attr.rowspan]=\"item.rowSpan\"\n\t\t\t\t\t(click)=\"onRowClick()\"\n\t\t\t\t\t(keydown.enter)=\"onRowClick()\">\n\t\t\t\t</td>\n\t\t\t</ng-container>\n\t\t</ng-container>\n\t\t<ng-content></ng-content>\n\t"
                }] }
    ];
    /** @nocollapse */
    TableRowComponent.ctorParameters = function () { return [
        { type: I18n }
    ]; };
    TableRowComponent.propDecorators = {
        model: [{ type: Input }],
        row: [{ type: Input }],
        expanded: [{ type: Input }],
        expandable: [{ type: Input }],
        selected: [{ type: Input }],
        size: [{ type: Input }],
        enableSingleSelect: [{ type: Input }],
        expandButtonAriaLabel: [{ type: Input }],
        checkboxLabel: [{ type: Input }],
        showSelectionColumn: [{ type: Input }],
        showSelectionColumnCheckbox: [{ type: Input }],
        selectionLabelColumn: [{ type: Input }],
        skeleton: [{ type: Input }],
        selectRow: [{ type: Output }],
        deselectRow: [{ type: Output }],
        expandRow: [{ type: Output }],
        rowClick: [{ type: Output }],
        selectedClass: [{ type: HostBinding, args: ["class.bx--data-table--selected",] }],
        parentRowClass: [{ type: HostBinding, args: ["class.bx--parent-row",] }],
        expandableRowClass: [{ type: HostBinding, args: ["class.bx--expandable-row",] }],
        selectableClass: [{ type: HostBinding, args: ["class.tbody_row--selectable",] }],
        isParentRow: [{ type: HostBinding, args: ["attr.data-parent-row",] }],
        isAccessible: [{ type: HostBinding, args: ["attr.tabindex",] }],
        onHostClick: [{ type: HostListener, args: ["click",] }]
    };
    return TableRowComponent;
}());

var TableExpandedRow = /** @class */ (function () {
    function TableExpandedRow() {
        this.skeleton = false;
        this.expandableRowClass = true;
        this.expanded = false;
    }
    TableExpandedRow.prototype.firstExpandedTemplateInRow = function (row) {
        var found = row.find(function (d) { return d.expandedTemplate; });
        if (found) {
            return found.expandedTemplate;
        }
        return found;
    };
    TableExpandedRow.prototype.firstExpandedDataInRow = function (row) {
        var found = row.find(function (d) { return d.expandedData; });
        if (found) {
            return found.expandedData;
        }
        return found;
    };
    TableExpandedRow.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line: component-selector
                    selector: "[ibmTableExpandedRow]",
                    template: "\n\t\t<td [attr.colspan]=\"row.length + 2\">\n\t\t\t<ng-container *ngIf=\"!firstExpandedTemplateInRow(row)\">\n\t\t\t\t{{firstExpandedDataInRow(row)}}\n\t\t\t</ng-container>\n\t\t\t<ng-template\n\t\t\t\t[ngTemplateOutlet]=\"firstExpandedTemplateInRow(row)\"\n\t\t\t\t[ngTemplateOutletContext]=\"{data: firstExpandedDataInRow(row)}\">\n\t\t\t</ng-template>\n\t\t</td>\n\t"
                }] }
    ];
    TableExpandedRow.propDecorators = {
        row: [{ type: Input }],
        skeleton: [{ type: Input }],
        expandableRowClass: [{ type: HostBinding, args: ["class.bx--expandable-row",] }],
        expanded: [{ type: HostBinding, args: ["attr.data-child-row",] }, { type: Input }]
    };
    return TableExpandedRow;
}());

var TableData = /** @class */ (function () {
    function TableData() {
        this.skeleton = false;
    }
    TableData.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line: component-selector
                    selector: "[ibmTableData]",
                    template: "\n\t\t<ng-container *ngIf=\"!skeleton && !item.template\">{{item.data}}</ng-container>\n\t\t<ng-template\n\t\t\t*ngIf=\"!skeleton\"\n\t\t\t[ngTemplateOutlet]=\"item.template\"\n\t\t\t[ngTemplateOutletContext]=\"{data: item.data}\">\n\t\t</ng-template>\n\t"
                }] }
    ];
    TableData.propDecorators = {
        item: [{ type: Input }],
        skeleton: [{ type: Input }]
    };
    return TableData;
}());

var TableCheckbox = /** @class */ (function () {
    function TableCheckbox(i18n) {
        this.i18n = i18n;
        this.selected = false;
        this.name = "";
        /**
         * Size of the table rows.
         */
        this.size = "md";
        this.skeleton = false;
        /**
         * Emits if a single row is selected.
         */
        this.change = new EventEmitter();
        this._label = this.i18n.getOverridable("TABLE.CHECKBOX_ROW");
    }
    Object.defineProperty(TableCheckbox.prototype, "disabled", {
        get: function () {
            return this.row ? !!this.row.disabled : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableCheckbox.prototype, "label", {
        get: function () {
            return this._label.value;
        },
        set: function (value) {
            this._label.override(value);
        },
        enumerable: true,
        configurable: true
    });
    TableCheckbox.prototype.getSelectionLabelValue = function (row) {
        if (!this.selectionLabelColumn) {
            return { value: this.i18n.get().TABLE.ROW };
        }
        return { value: row[this.selectionLabelColumn].data };
    };
    TableCheckbox.prototype.getLabel = function () {
        return this._label.subject;
    };
    TableCheckbox.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line: component-selector
                    selector: "[ibmTableCheckbox]",
                    template: "\n\t\t<ibm-checkbox\n\t\t\t*ngIf=\"!skeleton\"\n\t\t\tinline=\"true\"\n\t\t\t[name]=\"name\"\n\t\t\t[aria-label]=\"getLabel() | i18nReplace:getSelectionLabelValue(row) | async\"\n\t\t\t[size]=\"(size !== 'sm' ? 'md' : 'sm')\"\n\t\t\t[checked]=\"selected\"\n\t\t\t[disabled]=\"disabled\"\n\t\t\t(change)=\"change.emit()\">\n\t\t</ibm-checkbox>\n\t"
                }] }
    ];
    /** @nocollapse */
    TableCheckbox.ctorParameters = function () { return [
        { type: I18n }
    ]; };
    TableCheckbox.propDecorators = {
        row: [{ type: Input }],
        selected: [{ type: Input }],
        name: [{ type: Input }],
        size: [{ type: Input }],
        label: [{ type: Input }],
        selectionLabelColumn: [{ type: Input }],
        skeleton: [{ type: Input }],
        change: [{ type: Output }]
    };
    return TableCheckbox;
}());

var TableRadio = /** @class */ (function () {
    function TableRadio(i18n) {
        this.i18n = i18n;
        this.selected = false;
        this.skeleton = false;
        /**
         * Emits if a single row is selected.
         */
        this.change = new EventEmitter();
        this._label = this.i18n.getOverridable("TABLE.CHECKBOX_ROW");
    }
    Object.defineProperty(TableRadio.prototype, "label", {
        get: function () {
            return this._label.value;
        },
        set: function (value) {
            this._label.override(value);
        },
        enumerable: true,
        configurable: true
    });
    TableRadio.prototype.getSelectionLabelValue = function (row) {
        if (!this.selectionLabelColumn) {
            return { value: this.i18n.get().TABLE.ROW };
        }
        return { value: row[this.selectionLabelColumn].data };
    };
    TableRadio.prototype.getLabel = function () {
        return this._label.subject;
    };
    TableRadio.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line: component-selector
                    selector: "[ibmTableRadio]",
                    template: "\n\t\t<ibm-radio\n\t\t\t*ngIf=\"!skeleton\"\n\t\t\t[attr.aria-label]=\"getLabel() | i18nReplace:getSelectionLabelValue(row) | async\"\n\t\t\t[ariaLabel]=\"getLabel() | i18nReplace:getSelectionLabelValue(row) | async\"\n\t\t\t[checked]=\"selected\"\n\t\t\t(change)=\"change.emit()\">\n\t\t</ibm-radio>\n\t"
                }] }
    ];
    /** @nocollapse */
    TableRadio.ctorParameters = function () { return [
        { type: I18n }
    ]; };
    TableRadio.propDecorators = {
        row: [{ type: Input }],
        selected: [{ type: Input }],
        label: [{ type: Input }],
        selectionLabelColumn: [{ type: Input }],
        skeleton: [{ type: Input }],
        change: [{ type: Output }]
    };
    return TableRadio;
}());

var TableExpandButton = /** @class */ (function () {
    function TableExpandButton(i18n) {
        this.i18n = i18n;
        /**
         * Set to true to indicate the row has expanded
         */
        this.expanded = false;
        /**
         * Set to true to indicate the row can be expanded.
         * Defaults to false to allow for correct column alignment
         */
        this.expandable = false;
        this.skeleton = false;
        this.expandClass = true;
        this.expandRow = new EventEmitter();
        this._ariaLabel = this.i18n.getOverridable("TABLE.EXPAND_BUTTON");
    }
    Object.defineProperty(TableExpandButton.prototype, "ariaLabel", {
        get: function () {
            return this._ariaLabel.value;
        },
        set: function (value) {
            this._ariaLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableExpandButton.prototype, "previousValue", {
        get: function () {
            return this.expanded ? "collapsed" : null;
        },
        enumerable: true,
        configurable: true
    });
    TableExpandButton.prototype.getAriaLabel = function () {
        return this._ariaLabel.subject;
    };
    TableExpandButton.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line: component-selector
                    selector: "[ibmTableExpandButton]",
                    template: "\n\t\t<button\n\t\t\t*ngIf=\"expandable\"\n\t\t\tclass=\"bx--table-expand__button\"\n\t\t\t[attr.aria-label]=\"getAriaLabel() | async\"\n\t\t\t(click)=\"expandRow.emit()\">\n\t\t\t<svg ibmIcon=\"chevron--right\" size=\"16\" class=\"bx--table-expand__svg\"></svg>\n\t\t</button>\n\t"
                }] }
    ];
    /** @nocollapse */
    TableExpandButton.ctorParameters = function () { return [
        { type: I18n }
    ]; };
    TableExpandButton.propDecorators = {
        expanded: [{ type: Input }],
        expandable: [{ type: Input }],
        ariaLabel: [{ type: Input }],
        skeleton: [{ type: Input }],
        expandClass: [{ type: HostBinding, args: ["class.bx--table-expand",] }],
        previousValue: [{ type: HostBinding, args: ["attr.data-previous-value",] }],
        expandRow: [{ type: Output }]
    };
    return TableExpandButton;
}());

/**
 * Represents a table row, which is essentially an array of TableItem.
 */
var TableRow = /** @class */ (function (_super) {
    __extends(TableRow, _super);
    function TableRow() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Whether row is disabled or not.
         */
        _this.disabled = false;
        return _this;
    }
    return TableRow;
}(Array));

// modules
var TableModule = /** @class */ (function () {
    function TableModule() {
    }
    TableModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        // toolbar and utility components
                        TableToolbar,
                        TableContainer,
                        TableHeader,
                        TableHeaderTitle,
                        TableHeaderDescription,
                        TableHeadCellLabel,
                        TableToolbarActions,
                        TableToolbarSearch,
                        TableToolbarContent,
                        ExpandedRowHover,
                        // core table components
                        Table,
                        TableDirective,
                        TableHead,
                        TableHeadCell,
                        TableHeadCheckbox,
                        TableHeadExpand,
                        TableBody,
                        TableRowComponent,
                        TableExpandedRow,
                        TableData,
                        TableCheckbox,
                        TableRadio,
                        TableExpandButton
                    ],
                    exports: [
                        // toolbar and utility components
                        TableToolbar,
                        TableContainer,
                        TableHeader,
                        TableHeaderTitle,
                        TableHeaderDescription,
                        TableHeadCellLabel,
                        TableToolbarActions,
                        TableToolbarSearch,
                        TableToolbarContent,
                        ExpandedRowHover,
                        // core table components
                        Table,
                        TableDirective,
                        TableHead,
                        TableHeadCell,
                        TableHeadCheckbox,
                        TableHeadExpand,
                        TableBody,
                        TableRowComponent,
                        TableExpandedRow,
                        TableData,
                        TableCheckbox,
                        TableRadio,
                        TableExpandButton
                    ],
                    imports: [
                        CommonModule,
                        NFormsModule,
                        FormsModule,
                        DialogModule,
                        ButtonModule,
                        SearchModule,
                        I18nModule,
                        IconModule
                    ]
                },] }
    ];
    return TableModule;
}());

// table utilities/toolbar imports

/**
 * Generated bundle index. Do not edit.
 */

export { TableToolbar, TableToolbarActions, TableToolbarSearch, TableToolbarContent, TableContainer, TableHeader, TableHeaderTitle, TableHeadCellLabel, TableHeaderDescription, ExpandedRowHover, Table, TableDirective, TableHead, TableHeadCell, TableHeadCheckbox, TableHeadExpand, TableBody, TableRowComponent, TableExpandedRow, TableData, TableCheckbox, TableRadio, TableExpandButton, TableModel, TableItem, TableHeaderItem, TableCellAdapter, TableRowAdapter, TableAdapter, TableDomAdapter, DataGridInteractionModel, TableModule, TableRow };

//# sourceMappingURL=carbon-components-angular-table.js.map