/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-utils.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


export { PLACEMENTS, Position, defaultPositions, position } from '@carbon/utils-position';
import { __values, __spread } from 'tslib';
import { map } from 'rxjs/operators';
import { Injectable, NgZone, NgModule, Optional, SkipSelf } from '@angular/core';
import { Subject, from, fromEvent, merge, Observable, Subscription } from 'rxjs';

function findSiblingElem(target, direction) {
    if (target[direction]) {
        if (target[direction].classList.contains("disabled")) {
            return findSiblingElem(target[direction], direction);
        }
        return target[direction];
    }
}
function findNextElem(target) {
    return findSiblingElem(target, "nextElementSibling");
}
function findPrevElem(target) {
    return findSiblingElem(target, "previousElementSibling");
}
// check for Hight contrast mode
function HcModeChecker() {
    var colorTest = "rgb(255, 0, 0)";
    var htmlChecker = document.createElement("div");
    htmlChecker.classList.add("hc-checker");
    document.body.appendChild(htmlChecker);
    if (window.getComputedStyle(htmlChecker).backgroundColor.toString() !== colorTest) {
        document.body.classList.add("a11y");
    }
    document.body.removeChild(htmlChecker);
}
function focusNextTree(elem, rootElem) {
    if (rootElem === void 0) { rootElem = null; }
    if (elem) {
        var focusable = elem.querySelector("[tabindex='0']");
        if (focusable) {
            focusable.focus();
        }
        else {
            focusNextElem(elem, rootElem);
        }
    }
}
function focusNextElem(elem, rootElem) {
    if (rootElem === void 0) { rootElem = null; }
    if (elem) {
        var nextElem = elem.nextElementSibling;
        if (nextElem) {
            var focusableElem = nextElem.querySelector("[tabindex='0']");
            if (focusableElem) {
                focusableElem.focus();
            }
            else {
                focusNextElem(nextElem, rootElem);
            }
        }
        else {
            if (rootElem) {
                var nextRootElem = rootElem.nextElementSibling;
                if (nextRootElem) {
                    focusNextTree(nextRootElem, rootElem);
                }
            }
        }
    }
}
function focusPrevElem(elem, parentRef) {
    if (parentRef === void 0) { parentRef = null; }
    if (elem) {
        var prevElem = elem.previousElementSibling;
        if (prevElem) {
            var focusableElem = prevElem.querySelector("[tabindex='0']");
            if (focusableElem) {
                if (focusableElem.getAttribute("aria-expanded") === "true") {
                    var lastFocElms = prevElem.querySelectorAll("[tabindex='0']");
                    var arrLen = lastFocElms.length - 1;
                    for (var i = arrLen; i >= 0; i--) {
                        if (!!(lastFocElms[i].offsetWidth || lastFocElms[i].offsetHeight ||
                            lastFocElms[i].getClientRects().length)) {
                            focusableElem = lastFocElms[i];
                            break;
                        }
                    }
                }
                focusableElem.focus();
            }
            else {
                focusPrevElem(prevElem, parentRef);
            }
        }
        else {
            if (parentRef) {
                parentRef.querySelector("[tabindex='0']").focus();
            }
        }
    }
}

var AnimationFrameServiceSingleton = /** @class */ (function () {
    function AnimationFrameServiceSingleton(ngZone) {
        var _this = this;
        this.ngZone = ngZone;
        this.frameSource = new Subject();
        this.tick = this.frameSource.asObservable();
        this.ngZone.runOutsideAngular(function () {
            _this.animationFrameId = requestAnimationFrame(_this.doTick.bind(_this));
        });
    }
    AnimationFrameServiceSingleton.prototype.ngOnDestroy = function () {
        cancelAnimationFrame(this.animationFrameId);
    };
    AnimationFrameServiceSingleton.prototype.doTick = function (frame) {
        var _this = this;
        this.frameSource.next(frame);
        this.ngZone.runOutsideAngular(function () {
            requestAnimationFrame(_this.doTick.bind(_this));
        });
    };
    AnimationFrameServiceSingleton.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    AnimationFrameServiceSingleton.ctorParameters = function () { return [
        { type: NgZone }
    ]; };
    return AnimationFrameServiceSingleton;
}());
var AnimationFrameService = /** @class */ (function () {
    function AnimationFrameService(singleton) {
        this.singleton = singleton;
        this.tick = from(this.singleton.tick);
    }
    AnimationFrameService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    AnimationFrameService.ctorParameters = function () { return [
        { type: AnimationFrameServiceSingleton }
    ]; };
    return AnimationFrameService;
}());

// custom deep object merge
var merge$1 = function (target) {
    var objects = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        objects[_i - 1] = arguments[_i];
    }
    var e_1, _a;
    try {
        for (var objects_1 = __values(objects), objects_1_1 = objects_1.next(); !objects_1_1.done; objects_1_1 = objects_1.next()) {
            var object = objects_1_1.value;
            for (var key in object) {
                if (object.hasOwnProperty(key)) {
                    // since we're dealing just with JSON this simple check should be enough
                    if (object[key] instanceof Object) {
                        if (!target[key]) {
                            target[key] = {};
                        }
                        // recursively merge into the target
                        // most translations only run 3 or 4 levels deep, so no stack explosions
                        target[key] = merge$1(target[key], object[key]);
                    }
                    else {
                        target[key] = object[key];
                    }
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (objects_1_1 && !objects_1_1.done && (_a = objects_1.return)) _a.call(objects_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return target;
};

/**
 * Checks if a given element is scrollable.
 * If the element has an overflow set as part of its computed style it can scroll.
 * @param element the element to check scrollability
 */
var isScrollableElement = function (element) {
    var computedStyle = getComputedStyle(element);
    return (computedStyle.overflow === "auto" ||
        computedStyle.overflow === "scroll" ||
        computedStyle["overflow-y"] === "auto" ||
        computedStyle["overflow-y"] === "scroll" ||
        computedStyle["overflow-x"] === "auto" ||
        computedStyle["overflow-x"] === "scroll");
};
/**
 * Checks if an element is visible within a container
 * @param element the element to check
 * @param container the container to check
 */
var isVisibleInContainer = function (element, container) {
    var elementRect = element.getBoundingClientRect();
    var containerRect = container.getBoundingClientRect();
    // If there exists `height: 100%` on the `html` or `body` tag of an application,
    // it causes the calculation to return true if you need to scroll before the element is seen.
    // In that case we calculate its visibility based on the window viewport.
    if (container.tagName === "BODY" || container.tagName === "HTML") {
        // This checks if element is within the top, bottom, left and right of viewport, ie. if the element is visible in
        // the screen. This also takes into account partial visibility of an element.
        var isAboveViewport = elementRect.top < 0 && (elementRect.top + element.clientHeight) < 0;
        var isLeftOfViewport = elementRect.left < 0;
        var isBelowViewport = (elementRect.bottom - element.clientHeight) > (window.innerHeight || document.documentElement.clientHeight);
        var isRightOfViewport = elementRect.right > (window.innerWidth || document.documentElement.clientWidth);
        var isVisibleInViewport = !(isAboveViewport || isBelowViewport || isLeftOfViewport || isRightOfViewport);
        return isVisibleInViewport;
    }
    return (
    // This also accounts for partial visibility. It will still return true if the element is partially visible inside the container.
    (elementRect.bottom - element.clientHeight) <= (containerRect.bottom + (container.offsetHeight - container.clientHeight) / 2) &&
        elementRect.top >= (-element.clientHeight));
};
var getScrollableParents = function (node) {
    var elements = [document.body];
    while (node.parentElement && node !== document.body) {
        if (isScrollableElement(node)) {
            elements.push(node);
        }
        node = node.parentElement;
    }
    return elements;
};
var hasScrollableParents = function (node) {
    while (node.parentElement && node !== document.body) {
        if (isScrollableElement(node)) {
            return true;
        }
        node = node.parentElement;
    }
    return false;
};
/**
 * Returns an observable that emits whenever any scrollable parent element scrolls
 *
 * @param node root element to start finding scrolling parents from
 */
var scrollableParentsObservable = function (node) {
    var windowScroll = fromEvent(window, "scroll", { passive: true }).pipe(map(function (event) { return (
    // update the event target to be something useful. In this case `body` is a sensible replacement
    Object.assign({}, event, { target: document.body })); }));
    var observables = [windowScroll];
    // walk the parents and subscribe to all the scroll events we can
    while (node.parentElement && node !== document.body) {
        if (isScrollableElement(node)) {
            observables.push(fromEvent(node, "scroll", { passive: true }));
        }
        node = node.parentElement;
    }
    return merge.apply(void 0, __spread(observables));
};

function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
function matchesAttr(el, attr, val) {
    var styles = window.getComputedStyle(el);
    return val.includes(styles[attr]);
}
function closestAttr(s, t, element) {
    var el = element;
    if (!element) {
        return null;
    }
    do {
        if (matchesAttr(el, s, t)) {
            return el;
        }
        el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1);
    return null;
}

var ElementService = /** @class */ (function () {
    function ElementService(singleton) {
        this.singleton = singleton;
        this.tick = from(this.singleton.tick);
    }
    ElementService.prototype.visibility = function (target, parentElement) {
        if (parentElement === void 0) { parentElement = target; }
        var scrollableParents = getScrollableParents(parentElement);
        return this.tick.pipe(map(function () {
            var e_1, _a;
            try {
                for (var scrollableParents_1 = __values(scrollableParents), scrollableParents_1_1 = scrollableParents_1.next(); !scrollableParents_1_1.done; scrollableParents_1_1 = scrollableParents_1.next()) {
                    var parent_1 = scrollableParents_1_1.value;
                    if (!isVisibleInContainer(target, parent_1)) {
                        return {
                            visible: false
                        };
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (scrollableParents_1_1 && !scrollableParents_1_1.done && (_a = scrollableParents_1.return)) _a.call(scrollableParents_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return {
                visible: true
            };
        }));
    };
    ElementService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    ElementService.ctorParameters = function () { return [
        { type: AnimationFrameServiceSingleton }
    ]; };
    return ElementService;
}());

var getEventObservable = function (targetElement, eventType) {
    switch (eventType) {
        case "scroll":
        case "resize":
        case "touchstart":
        case "touchmove":
        case "touchend":
            return fromEvent(targetElement, eventType, { passive: true });
        default:
            return fromEvent(targetElement, eventType);
    }
};

var DocumentService = /** @class */ (function () {
    function DocumentService() {
        this.globalEvents = new Map();
        this.documentRef = document;
        this.subscriptions = new Subscription();
    }
    DocumentService.prototype.handleEvent = function (eventType, callback) {
        if (!this.globalEvents.has(eventType)) {
            if (this.documentRef) {
                this.globalEvents.set(eventType, getEventObservable(this.documentRef, eventType));
            }
            else {
                this.globalEvents.set(eventType, new Observable());
            }
        }
        var observable = this.globalEvents.get(eventType);
        this.subscriptions.add(observable.subscribe(callback));
    };
    DocumentService.prototype.handleClick = function (callback) {
        this.handleEvent("click", callback);
    };
    DocumentService.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
        this.globalEvents = null;
    };
    DocumentService.decorators = [
        { type: Injectable }
    ];
    return DocumentService;
}());

var EventService = /** @class */ (function () {
    function EventService(documentService) {
        this.documentService = documentService;
        this.subscriptions = new Subscription();
        this.targets = new WeakMap();
    }
    EventService.prototype.on = function (targetElement, eventType, callback) {
        if (!this.targets.has(targetElement)) {
            this.targets.set(targetElement, new Map());
        }
        var eventMap = this.targets.get(targetElement);
        if (!eventMap.has(eventType)) {
            eventMap.set(eventType, getEventObservable(targetElement, eventType));
        }
        var subscription = eventMap.get(eventType).subscribe(callback);
        this.subscriptions.add(subscription);
    };
    EventService.prototype.onDocument = function (eventType, callback) {
        this.documentService.handleEvent(eventType, callback);
    };
    EventService.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
    };
    EventService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    EventService.ctorParameters = function () { return [
        { type: DocumentService }
    ]; };
    return EventService;
}());

// either provides a new instance of DocumentService, or returns the parent
function DOCUMENT_SERVICE_PROVIDER_FACTORY(parentService) {
    return parentService || new DocumentService();
}
// DocumentService *must* be a singleton to ensure that we handle events and other document level settings once (and only once)
var DOCUMENT_SERVICE_PROVIDER = {
    provide: DocumentService,
    deps: [[new Optional(), new SkipSelf(), DocumentService]],
    useFactory: DOCUMENT_SERVICE_PROVIDER_FACTORY
};
// either provides a new instance of AnimationFrameServiceSingleton, or returns the parent
function ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER_FACTORY(parentService, ngZone) {
    return parentService || new AnimationFrameServiceSingleton(ngZone);
}
// AnimationFrameServiceSingleton is a singleton so we don't have a ton of duplicate RAFs firing (better for scheduling)
var ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER = {
    provide: AnimationFrameServiceSingleton,
    deps: [[new Optional(), new SkipSelf(), AnimationFrameServiceSingleton], NgZone],
    useFactory: ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER_FACTORY
};
var UtilsModule = /** @class */ (function () {
    function UtilsModule() {
    }
    UtilsModule.decorators = [
        { type: NgModule, args: [{
                    providers: [
                        DOCUMENT_SERVICE_PROVIDER,
                        ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER,
                        AnimationFrameServiceSingleton,
                        DocumentService,
                        AnimationFrameService,
                        ElementService,
                        EventService
                    ]
                },] }
    ];
    return UtilsModule;
}());

var _scrollbarWidth = -1;
function getScrollbarWidth() {
    // lets not recreate this whole thing every time
    if (_scrollbarWidth >= 0) {
        return _scrollbarWidth;
    }
    // do the calculations the first time
    var outer = document.createElement("div");
    outer.style.visibility = "hidden";
    outer.style.width = "100px";
    outer.style.msOverflowStyle = "scrollbar"; // needed for WinJS apps
    document.body.appendChild(outer);
    var widthNoScroll = outer.offsetWidth;
    // force scrollbars
    outer.style.overflow = "scroll";
    // add innerdiv
    var inner = document.createElement("div");
    inner.style.width = "100%";
    outer.appendChild(inner);
    var widthWithScroll = inner.offsetWidth;
    // remove divs
    outer.parentNode.removeChild(outer);
    _scrollbarWidth = widthNoScroll - widthWithScroll;
    return _scrollbarWidth;
}

/**
 * Generated bundle index. Do not edit.
 */

export { HcModeChecker, findNextElem, findPrevElem, focusNextElem, focusNextTree, focusPrevElem, AnimationFrameService, AnimationFrameServiceSingleton, merge$1 as merge, getScrollableParents, hasScrollableParents, isScrollableElement, isVisibleInContainer, scrollableParentsObservable, clone, closestAttr, ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER, ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER_FACTORY, DOCUMENT_SERVICE_PROVIDER, DOCUMENT_SERVICE_PROVIDER_FACTORY, UtilsModule, getScrollbarWidth, ElementService, EventService, getEventObservable, DocumentService };

//# sourceMappingURL=carbon-components-angular-utils.js.map