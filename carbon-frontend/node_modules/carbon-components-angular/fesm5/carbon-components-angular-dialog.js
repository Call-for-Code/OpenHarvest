/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-dialog.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Subscription } from 'rxjs';
import { tabbableSelector, cycleTabs, getFocusElementList, isFocusInLastItem, isFocusInFirstItem } from 'carbon-components-angular/common';
import { __extends, __values } from 'tslib';
import Position, { position } from '@carbon/utils-position';
import { Injector, ComponentFactoryResolver, Injectable, Component, Input, Output, EventEmitter, ElementRef, ViewChild, HostListener, Optional, Directive, ViewContainerRef, HostBinding, TemplateRef, ContentChild, ViewEncapsulation, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { I18n, I18nModule } from 'carbon-components-angular/i18n';
import { PlaceholderService, PlaceholderModule } from 'carbon-components-angular/placeholder';
import { ExperimentalService, ExperimentalModule } from 'carbon-components-angular/experimental';
import { AnimationFrameService, ElementService, EventService, closestAttr, UtilsModule } from 'carbon-components-angular/utils';
import { IconModule } from 'carbon-components-angular/icon';

/**
 * An enum of the various reasons a dialog may close. For use with `CloseMeta` and `shouldClose`
 *
 * It's expected that `interaction` will be a common closure reason.
 */
var CloseReasons;
(function (CloseReasons) {
    /**
     * For when the component is closed by being destroyed
     */
    CloseReasons[CloseReasons["destroyed"] = 0] = "destroyed";
    /**
     * For use in cases where the dialog closes for programmatic reasons other than destruction
     */
    CloseReasons[CloseReasons["programmatic"] = 1] = "programmatic";
    /**
     * interaction reasons will also provide a target for the interaction
     */
    CloseReasons[CloseReasons["interaction"] = 2] = "interaction";
    /**
     * For use in cases where the dialog closes due to being hidden
     */
    CloseReasons[CloseReasons["hidden"] = 3] = "hidden";
})(CloseReasons || (CloseReasons = {}));

/**
 * `Dialog` object to be injected into other components.
 */
var DialogService = /** @class */ (function () {
    /**
     * Creates an instance of `DialogService`.
     */
    function DialogService(componentFactoryResolver, injector, placeholderService) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.injector = injector;
        this.placeholderService = placeholderService;
    }
    /**
     * Closes all known `Dialog`s. Does not focus any previous elements, since we can't know which would be correct
     */
    DialogService.closeAll = function () {
        DialogService.dialogRefs.forEach(function (ref) { return ref.instance.doClose({
            reason: CloseReasons.programmatic
        }); });
        DialogService.dialogRefs.clear();
    };
    /**
     * Set the context for the service. For example, the `component` property can be used to set the
     * default component that should be created by the service, for a given instance of the service.
     * @param options `{ component: any }` where `component` is a component that extends `dialog.component`
     */
    DialogService.prototype.setContext = function (options) {
        this.componentFactory = this.componentFactoryResolver.resolveComponentFactory(options.component);
    };
    /**
     * If `dialogRef` is defined, the Dialog is already open. If
     * `dialogRef` is undefined, we create the `Dialog` component and reference to it.
     * A subscription is created to track if the `Dialog` should close.
     *
     * @param viewContainer a `ViewContainerRef` to instantiate the component against.
     * May be `null` if an `ibm-placeholder` exists and `dialogConfig.appendInline` is false
     * @param dialogConfig the `DialogConfig` for the component
     */
    DialogService.prototype.open = function (viewContainer, dialogConfig, component) {
        var componentFactory = this.componentFactory;
        if (component) {
            componentFactory = this.componentFactoryResolver.resolveComponentFactory(component);
        }
        var dialogRef;
        if (dialogConfig.appendInline) {
            // add our component to the view
            dialogRef = viewContainer.createComponent(componentFactory, 0, this.injector);
        }
        else if (!this.placeholderService.hasPlaceholderRef()) {
            dialogRef = viewContainer.createComponent(componentFactory, 0, this.injector);
            if (dialogRef) {
                setTimeout(function () {
                    window.document.querySelector("body").appendChild(dialogRef.location.nativeElement);
                });
            }
        }
        else {
            dialogRef = this.placeholderService.createComponent(componentFactory, this.injector);
        }
        // keep track of all initialized dialogs
        DialogService.dialogRefs.add(dialogRef);
        // initialize some extra options
        dialogConfig["previouslyFocusedElement"] = document.activeElement;
        dialogRef.instance.dialogConfig = dialogConfig;
        dialogRef.instance.elementRef.nativeElement.focus();
        return dialogRef;
    };
    /**
     * On close of `Dialog` item, sets focus back to previous item, unsets
     * the current `dialogRef` item. Unsubscribes to the event of `Dialog` close.
     *
     * @param dialogRef the dialogRef to close
     */
    DialogService.prototype.close = function (dialogRef) {
        // to handle the case where we have a null `this.dialogRef`
        if (!dialogRef) {
            return;
        }
        var elementToFocus = dialogRef.instance.dialogConfig["previouslyFocusedElement"];
        dialogRef.destroy();
        // update the globally tracked dialogRefs
        if (DialogService.dialogRefs.has(dialogRef)) {
            DialogService.dialogRefs.delete(dialogRef);
        }
        // Keeps the focus on the dialog trigger if there are no focusable elements. Change focus to previously focused element
        // if there are focusable elements in the dialog.
        if (!dialogRef.location.nativeElement.querySelectorAll(tabbableSelector)) {
            elementToFocus.focus();
        }
    };
    /**
     * Closes all known `Dialog`s. Does not focus any previous elements, since we can't know which would be correct
     *
     * @deprecated since v4. Use the static `DialogService.closeAll` instead
     */
    DialogService.prototype.closeAll = function () {
        DialogService.closeAll();
    };
    /**
     * Fix for safari hijacking clicks.
     *
     * Runs on `ngOnInit` of every dialog. Ensures we don't have multiple listeners
     * because having many of them could degrade performance in certain cases (and is
     * not necessary for our use case)
     *
     * This is an internally used function, can change at any point (even get removed)
     * and changes to it won't be considered a breaking change. Use at your own risk.
     */
    DialogService.prototype.singletonClickListen = function () {
        if (!DialogService.listeningForBodyClicks) {
            document.body.firstElementChild.addEventListener("click", function () { return null; }, true);
            DialogService.listeningForBodyClicks = true;
        }
    };
    /**
     * Used in `singletonClickListen`, don't count on its existence and values.
     */
    DialogService.listeningForBodyClicks = false;
    /**
     * A set of all known dialog components
     */
    DialogService.dialogRefs = new Set();
    DialogService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    DialogService.ctorParameters = function () { return [
        { type: ComponentFactoryResolver },
        { type: Injector },
        { type: PlaceholderService }
    ]; };
    return DialogService;
}());

/**
 * Implements a `Dialog` that can be positioned anywhere on the page.
 * Used to implement a popover or tooltip.
 */
var Dialog = /** @class */ (function () {
    /**
     * Creates an instance of `Dialog`.
     * @param elementRef
     * @param elementService
     */
    function Dialog(elementRef, elementService, animationFrameService) {
        if (animationFrameService === void 0) { animationFrameService = null; }
        var _this = this;
        this.elementRef = elementRef;
        this.elementService = elementService;
        this.animationFrameService = animationFrameService;
        /**
         * Emits event that handles the closing of a `Dialog` object.
         */
        this.close = new EventEmitter();
        /**
         * Stores the data received from `dialogConfig`.
         */
        this.data = {};
        this.visibilitySubscription = new Subscription();
        this.animationFrameSubscription = new Subscription();
        /**
         * Handles offsetting the `Dialog` item based on the defined position
         * to not obscure the content beneath.
         */
        this.addGap = {
            "left": function (pos) { return position.addOffset(pos, 0, -_this.dialogConfig.gap); },
            "right": function (pos) { return position.addOffset(pos, 0, _this.dialogConfig.gap); },
            "top": function (pos) { return position.addOffset(pos, -_this.dialogConfig.gap); },
            "bottom": function (pos) { return position.addOffset(pos, _this.dialogConfig.gap); },
            "left-bottom": function (pos) { return position.addOffset(pos, 0, -_this.dialogConfig.gap); },
            "right-bottom": function (pos) { return position.addOffset(pos, 0, _this.dialogConfig.gap); }
        };
        /**
         * Extra placements. Child classes can add to this for use in `placeDialog`.
         */
        this.placements = {};
    }
    /**
     * Initialize the `Dialog`, set the placement and gap, and add a `Subscription` to resize events.
     */
    Dialog.prototype.ngOnInit = function () {
        this.placement = this.dialogConfig.placement.split(",")[0];
        this.data = this.dialogConfig.data;
        // run any additional initialization code that consuming classes may have
        this.onDialogInit();
    };
    /**
     * After the DOM is ready, focus is set and dialog is placed
     * in respect to the parent element.
     */
    Dialog.prototype.ngAfterViewInit = function () {
        var _this = this;
        var e_1, _a;
        var dialogElement = this.dialog.nativeElement;
        // split the wrapper class list and apply separately to avoid IE
        // 1. throwing an error due to assigning a readonly property (classList)
        // 2. throwing a SyntaxError due to passing an empty string to `add`
        if (this.dialogConfig.wrapperClass) {
            try {
                for (var _b = __values(this.dialogConfig.wrapperClass.split(" ")), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var extraClass = _c.value;
                    dialogElement.classList.add(extraClass);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        // only focus the dialog if there are focusable elements within the dialog
        if (getFocusElementList(this.dialog.nativeElement).length > 0) {
            dialogElement.focus();
        }
        var parentElement = this.dialogConfig.parentRef.nativeElement;
        if (this.animationFrameService) {
            this.animationFrameSubscription = this.animationFrameService.tick.subscribe(function () {
                _this.placeDialog();
            });
        }
        if (this.dialogConfig.closeWhenHidden) {
            this.visibilitySubscription = this.elementService
                .visibility(parentElement, parentElement)
                .subscribe(function (value) {
                _this.placeDialog();
                if (!value.visible) {
                    _this.doClose({
                        reason: CloseReasons.hidden
                    });
                }
            });
        }
        this.placeDialog();
        // run afterDialogViewInit on the next tick
        setTimeout(function () { return _this.afterDialogViewInit(); });
    };
    /**
     * Empty method to be overridden by consuming classes to run any additional initialization code.
     */
    Dialog.prototype.onDialogInit = function () { };
    /**
     * Empty method to be overridden by consuming classes to run any additional initialization code after the view is available.
     * NOTE: this does _not_ guarantee the dialog will be positioned, simply that it will exist in the DOM
     */
    Dialog.prototype.afterDialogViewInit = function () { };
    /**
     * Uses the position service to position the `Dialog` in screen space
     */
    Dialog.prototype.placeDialog = function () {
        var _this = this;
        var positionService = new Position(this.placements);
        // helper to find the position based on the current/given environment
        var findPosition = function (reference, target, placement) {
            var pos;
            if (_this.dialogConfig.appendInline) {
                pos = _this.addGap[placement](positionService.findRelative(reference, target, placement));
            }
            else {
                pos = _this.addGap[placement](positionService.findAbsolute(reference, target, placement));
            }
            if (_this.dialogConfig.offset) {
                // Apply vertical and horizontal offsets given through the dialogConfig
                pos.top = pos.top + _this.dialogConfig.offset.y;
                pos.left = pos.left + _this.dialogConfig.offset.x;
            }
            return pos;
        };
        var parentEl = this.dialogConfig.parentRef.nativeElement;
        var el = this.dialog.nativeElement;
        var dialogPlacement = this.placement;
        // split always returns an array, so we can just use the auto position logic
        // for single positions too
        var placements = this.dialogConfig.placement.split(",");
        // find the best placement
        dialogPlacement = positionService.findBestPlacement(parentEl, el, placements);
        // calculate the final position
        var pos = findPosition(parentEl, el, dialogPlacement);
        // update the element
        positionService.setElement(el, pos);
        setTimeout(function () { _this.placement = dialogPlacement; });
    };
    /**
     * Sets up a KeyboardEvent to close `Dialog` with Escape key.
     * @param event
     */
    Dialog.prototype.escapeClose = function (event) {
        switch (event.key) {
            case "Esc": // IE specific value
            case "Escape": {
                event.stopImmediatePropagation();
                this.doClose({
                    reason: CloseReasons.interaction,
                    target: event.target
                });
                break;
            }
            case "Tab": {
                cycleTabs(event, this.elementRef.nativeElement);
                break;
            }
        }
    };
    /**
     * Sets up a event Listener to close `Dialog` if click event occurs outside
     * `Dialog` object.
     * @param event
     */
    Dialog.prototype.clickClose = function (event) {
        if (!this.elementRef.nativeElement.contains(event.target)
            && !this.dialogConfig.parentRef.nativeElement.contains(event.target)) {
            this.doClose({
                reason: CloseReasons.interaction,
                target: event.target
            });
        }
    };
    /**
     * Closes `Dialog` object by emitting the close event upwards to parents.
     */
    Dialog.prototype.doClose = function (meta) {
        if (meta === void 0) { meta = { reason: CloseReasons.interaction }; }
        this.close.emit(meta);
    };
    /**
     * At destruction of component, `Dialog` unsubscribes from all the subscriptions.
     */
    Dialog.prototype.ngOnDestroy = function () {
        this.visibilitySubscription.unsubscribe();
        if (this.animationFrameSubscription) {
            this.animationFrameSubscription.unsubscribe();
        }
    };
    Dialog.decorators = [
        { type: Component, args: [{
                    selector: "ibm-dialog",
                    template: ""
                }] }
    ];
    /** @nocollapse */
    Dialog.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ElementService },
        { type: AnimationFrameService, decorators: [{ type: Optional }] }
    ]; };
    Dialog.propDecorators = {
        close: [{ type: Output }],
        dialogConfig: [{ type: Input }],
        dialog: [{ type: ViewChild, args: ["dialog", { static: false },] }],
        escapeClose: [{ type: HostListener, args: ["keydown", ["$event"],] }],
        clickClose: [{ type: HostListener, args: ["document:click", ["$event"],] }]
    };
    return Dialog;
}());

/**
 * A generic directive that can be inherited from to create dialogs (for example, a tooltip or popover)
 *
 * This class contains the relevant initialization code, specific templates, options, and additional inputs
 * should be specified in the derived class.
 *
 * NOTE: All child classes should add `DialogService` as a provider, otherwise they will lose context that
 * the service relies on.
 */
var DialogDirective = /** @class */ (function () {
    /**
     * Creates an instance of DialogDirective.
     * @param elementRef
     * @param viewContainerRef
     * @param dialogService
     * @param eventService
     */
    function DialogDirective(elementRef, viewContainerRef, dialogService, eventService) {
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
        this.dialogService = dialogService;
        this.eventService = eventService;
        /**
         * Title for the dialog
         */
        this.title = "";
        /**
         * Defines how the Dialog is triggered.(Hover and click behave the same on mobile - both respond to a single tap).
         * Do not add focusable elements if trigger is `hover` or `mouseenter`.
         */
        this.trigger = "click";
        /**
         * Defines how the Dialog close event is triggered.
         *
         * [See here](https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseleave_event)
         * for more on the difference between `mouseleave` and `mouseout`.
         *
         * Defaults to `click` when `trigger` is set to `click`.
         */
        this.closeTrigger = "mouseleave";
        /**
         * Placement of the dialog, usually relative to the element the directive is on.
         */
        this.placement = "left";
        /**
         * Spacing between the dialog and it's triggering element
         */
        this.gap = 0;
        /**
         * Set to `true` to open the dialog next to the triggering component
         */
        this.appendInline = false;
        /**
         * Optional data for templates
         */
        this.data = {};
        this.isOpen = false;
        /**
         * This prevents the dialog from being toggled
         */
        this.disabled = false;
        /**
         * Emits an event when the dialog is closed
         */
        this.onClose = new EventEmitter();
        /**
         * Emits an event when the dialog is opened
         */
        this.onOpen = new EventEmitter();
        /**
         * Emits an event when the state of `isOpen` changes. Allows `isOpen` to be double bound
         */
        this.isOpenChange = new EventEmitter();
        this.role = "button";
        this.hasPopup = true;
    }
    Object.defineProperty(DialogDirective.prototype, "ariaOwns", {
        get: function () {
            return this.isOpen ? this.dialogConfig.compID : null;
        },
        enumerable: true,
        configurable: true
    });
    DialogDirective.prototype.ngOnChanges = function (changes) {
        // set the config object (this can [and should!] be added to in child classes depending on what they need)
        this.dialogConfig = {
            title: this.title,
            content: this.ibmDialog,
            placement: this.placement,
            parentRef: this.elementRef,
            gap: this.gap,
            trigger: this.trigger,
            closeTrigger: this.closeTrigger,
            shouldClose: this.shouldClose || (function () { return true; }),
            appendInline: this.appendInline,
            wrapperClass: this.wrapperClass,
            data: this.data,
            offset: this.offset,
            disabled: this.disabled
        };
        if (changes.isOpen) {
            if (changes.isOpen.currentValue) {
                this.open();
            }
            else {
                this.close({
                    reason: CloseReasons.programmatic
                });
            }
        }
        // Run any code a child class may need.
        this.onDialogChanges(changes);
        this.updateConfig();
    };
    /**
     * Sets the config object and binds events for hovering or clicking before
     * running code from child class.
     */
    DialogDirective.prototype.ngOnInit = function () {
        var _this = this;
        // fix for safari hijacking clicks
        this.dialogService.singletonClickListen();
        var element = this.elementRef.nativeElement;
        this.eventService.on(element, "keydown", function (event) {
            // "Esc" is an IE specific value
            if (event.target === _this.dialogConfig.parentRef.nativeElement &&
                (event.key === "Tab" || event.key === "Tab" && event.shiftKey) ||
                event.key === "Escape" || event.key === "Esc") {
                _this.close({
                    reason: CloseReasons.interaction,
                    target: event.target
                });
            }
        });
        // bind events for hovering or clicking the host
        if (this.trigger === "hover" || this.trigger === "mouseenter") {
            this.eventService.on(element, "mouseenter", this.open.bind(this));
            this.eventService.on(element, this.closeTrigger, function (event) {
                _this.close({
                    reason: CloseReasons.interaction,
                    target: event.target
                });
            });
            this.eventService.on(element, "focus", this.open.bind(this));
            this.eventService.on(element, "blur", function (event) {
                _this.close({
                    reason: CloseReasons.interaction,
                    target: event.target
                });
            });
        }
        else {
            this.eventService.on(element, "click", function (event) {
                _this.toggle({
                    reason: CloseReasons.interaction,
                    target: event.target
                });
            });
            this.eventService.on(element, "keydown", function (event) {
                // "Spacebar" is an IE specific value
                if (event.key === "Enter" || event.key === " " || event.key === "Spacebar") {
                    setTimeout(function () {
                        _this.open();
                    });
                }
            });
        }
        DialogDirective.dialogCounter++;
        this.dialogConfig.compID = "dialog-" + DialogDirective.dialogCounter;
        // run any code a child class may need
        this.onDialogInit();
        this.updateConfig();
    };
    /**
     * When the host dies, kill the popover.
     * - Useful for use in a modal or similar.
     */
    DialogDirective.prototype.ngOnDestroy = function () {
        this.close({
            reason: CloseReasons.destroyed
        });
    };
    /**
     * Helper method to call dialogService 'open'.
     * - Enforce accessibility by updating an aria attr for nativeElement.
     */
    DialogDirective.prototype.open = function () {
        var _this = this;
        // don't allow dialogs to be opened if they're already open
        if (this.dialogRef || this.disabled) {
            return;
        }
        // actually open the dialog, emit events, and set the open state
        this.dialogRef = this.dialogService.open(this.viewContainerRef, this.dialogConfig);
        this.isOpen = true;
        this.onOpen.emit();
        this.isOpenChange.emit(true);
        // Handles emitting all the close events to clean everything up
        // Also enforce accessibility on close by updating an aria attr on the nativeElement.
        this.dialogRef.instance.close.subscribe(function (meta) {
            if (!_this.dialogRef) {
                return;
            }
            if (_this.dialogConfig.shouldClose && _this.dialogConfig.shouldClose(meta)) {
                // close the dialog, emit events, and clear out the open states
                _this.dialogService.close(_this.dialogRef);
                _this.dialogRef = null;
                _this.isOpen = false;
                _this.onClose.emit();
                _this.isOpenChange.emit(false);
            }
        });
        return this.dialogRef;
    };
    /**
     * Helper method to toggle the open state of the dialog
     */
    DialogDirective.prototype.toggle = function (meta) {
        if (meta === void 0) { meta = { reason: CloseReasons.interaction }; }
        if (!this.isOpen) {
            this.open();
        }
        else {
            this.close(meta);
        }
    };
    /**
     * Helper method to close the dialogRef.
     */
    DialogDirective.prototype.close = function (meta) {
        var _this = this;
        if (meta === void 0) { meta = { reason: CloseReasons.interaction }; }
        if (this.dialogRef) {
            setTimeout(function () {
                _this.dialogRef.instance.doClose(meta);
            });
        }
    };
    /**
     * Empty method for child classes to override and specify additional init steps.
     * Run after DialogDirective completes it's ngOnInit.
     */
    DialogDirective.prototype.onDialogInit = function () { };
    /**
     * Empty method for child to override and specify additional on changes steps.
     * run after DialogDirective completes it's ngOnChanges.
     */
    DialogDirective.prototype.onDialogChanges = function (_changes) { };
    DialogDirective.prototype.updateConfig = function () { };
    DialogDirective.dialogCounter = 0;
    DialogDirective.decorators = [
        { type: Directive, args: [{
                    selector: "[ibmDialog]",
                    exportAs: "ibmDialog",
                    providers: [
                        DialogService
                    ]
                },] }
    ];
    /** @nocollapse */
    DialogDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ViewContainerRef },
        { type: DialogService },
        { type: EventService }
    ]; };
    DialogDirective.propDecorators = {
        title: [{ type: Input }],
        ibmDialog: [{ type: Input }],
        trigger: [{ type: Input }],
        closeTrigger: [{ type: Input }],
        placement: [{ type: Input }],
        offset: [{ type: Input }],
        wrapperClass: [{ type: Input }],
        gap: [{ type: Input }],
        appendInline: [{ type: Input }],
        data: [{ type: Input }],
        isOpen: [{ type: Input }, { type: HostBinding, args: ["attr.aria-expanded",] }],
        disabled: [{ type: Input }],
        shouldClose: [{ type: Input }],
        onClose: [{ type: Output }],
        onOpen: [{ type: Output }],
        isOpenChange: [{ type: Output }],
        role: [{ type: HostBinding, args: ["attr.role",] }],
        hasPopup: [{ type: HostBinding, args: ["attr.aria-haspopup",] }],
        ariaOwns: [{ type: HostBinding, args: ["attr.aria-owns",] }]
    };
    return DialogDirective;
}());

/**
 * Extend the `Dialog` component to create a tooltip for exposing content.
 */
var Tooltip = /** @class */ (function (_super) {
    __extends(Tooltip, _super);
    function Tooltip(elementRef, elementService, animationFrameService) {
        if (animationFrameService === void 0) { animationFrameService = null; }
        var _this = _super.call(this, elementRef, elementService, animationFrameService) || this;
        _this.elementRef = elementRef;
        _this.elementService = elementService;
        _this.animationFrameService = animationFrameService;
        _this.style = "inline-block";
        /**
         * Value is set to `true` if the `Tooltip` is to display a `TemplateRef` instead of a string.
         */
        _this.hasContentTemplate = false;
        /**
         * Sets the role of the tooltip. If there's no focusable content we leave it as a `tooltip`,
         * if there _is_ focusable content we switch to the interactive `dialog` role.
         */
        _this.role = "tooltip";
        return _this;
    }
    /**
     * Check whether there is a template for the `Tooltip` content.
     */
    Tooltip.prototype.onDialogInit = function () {
        var _this = this;
        this.addGap["bottom"] = function (pos) {
            var adjustedOffset = _this.getAdjustOffset();
            return position.addOffset(pos, 3 + adjustedOffset.top, 0 + adjustedOffset.left);
        };
        this.addGap["top"] = function (pos) {
            var adjustedOffset = _this.getAdjustOffset();
            return position.addOffset(pos, -10 + adjustedOffset.top, 0 + adjustedOffset.left);
        };
        this.addGap["left"] = function (pos) {
            var adjustedOffset = _this.getAdjustOffset();
            return position.addOffset(pos, -3 + adjustedOffset.top, -6 + adjustedOffset.left);
        };
        this.addGap["right"] = function (pos) {
            var adjustedOffset = _this.getAdjustOffset();
            return position.addOffset(pos, -3 + adjustedOffset.top, 6 + adjustedOffset.left);
        };
        this.hasContentTemplate = this.dialogConfig.content instanceof TemplateRef;
    };
    Tooltip.prototype.getAdjustOffset = function () {
        var closestWithPos = closestAttr("position", ["relative", "fixed", "absolute"], this.elementRef.nativeElement.parentElement);
        var topPos = closestWithPos ? closestWithPos.getBoundingClientRect().top * -1 : 0;
        var leftPos = closestWithPos ? closestWithPos.getBoundingClientRect().left * -1 : 0;
        return { top: topPos, left: leftPos };
    };
    Tooltip.prototype.afterDialogViewInit = function () {
        var focusableElements = getFocusElementList(this.dialog.nativeElement);
        if (focusableElements.length > 0) {
            this.role = "dialog";
            focusableElements[0].focus();
        }
    };
    Tooltip.decorators = [
        { type: Component, args: [{
                    selector: "ibm-tooltip",
                    template: "\n\t\t<div\n\t\t\t#dialog\n\t\t\t[id]=\"dialogConfig.compID\"\n\t\t\t[attr.role]=\"role\"\n\t\t\t[attr.data-floating-menu-direction]=\"placement\"\n\t\t\tclass=\"bx--tooltip bx--tooltip--shown\">\n\t\t\t<span class=\"bx--tooltip__caret\" aria-hidden=\"true\"></span>\n\t\t\t<ng-template\n\t\t\t\t\t*ngIf=\"hasContentTemplate\"\n\t\t\t\t\t[ngTemplateOutlet]=\"dialogConfig.content\"\n\t\t\t\t\t[ngTemplateOutletContext]=\"{tooltip: this}\">\n\t\t\t</ng-template>\n\t\t\t<p\n\t\t\t\t*ngIf=\"!hasContentTemplate\">\n\t\t\t\t{{dialogConfig.content}}\n\t\t\t</p>\n\t\t</div>\n\t\t"
                }] }
    ];
    /** @nocollapse */
    Tooltip.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ElementService },
        { type: AnimationFrameService, decorators: [{ type: Optional }] }
    ]; };
    Tooltip.propDecorators = {
        style: [{ type: HostBinding, args: ["style.display",] }]
    };
    return Tooltip;
}(Dialog));

var TooltipDefinition = /** @class */ (function () {
    function TooltipDefinition() {
        this.id = "definition-tooltip-" + TooltipDefinition.tooltipItemCount++;
        /**
         * The placement in which the `TooltipDefinition` appears.
         * Set to `"top"` to have it positioned above the trigger text
         */
        this.placement = "bottom";
        this.alignment = "start";
        this.className = true;
        this.accessibility = true;
    }
    TooltipDefinition.tooltipItemCount = 0;
    TooltipDefinition.decorators = [
        { type: Component, args: [{
                    selector: "ibm-tooltip-definition",
                    template: "\n\t\t<button\n\t\t\ttype=\"button\"\n\t\t\t[ngClass]=\"{\n\t\t\t\t'bx--tooltip--bottom' : placement === 'bottom',\n\t\t\t\t'bx--tooltip--top' : placement === 'top',\n\t\t\t\t'bx--tooltip--align-start' : alignment === 'start',\n\t\t\t\t'bx--tooltip--align-center' : alignment === 'center',\n\t\t\t\t'bx--tooltip--align-end' : alignment === 'end'\n\t\t\t}\"\n\t\t\tclass=\"bx--tooltip__trigger bx--tooltip--a11y bx--tooltip__trigger--definition\"\n\t\t\t[attr.aria-describedby]=\"id\">\n\t\t\t<ng-content></ng-content>\n\t\t</button>\n\t\t<div class=\"bx--assistive-text\" [id]=\"id\" role=\"tooltip\">{{content}}</div>\n\t"
                }] }
    ];
    TooltipDefinition.propDecorators = {
        id: [{ type: Input }],
        content: [{ type: Input }],
        placement: [{ type: Input }],
        alignment: [{ type: Input }],
        className: [{ type: HostBinding, args: ["class.bx--tooltip--definition",] }],
        accessibility: [{ type: HostBinding, args: ["class.bx--tooltip--a11y",] }]
    };
    return TooltipDefinition;
}());

var TooltipIcon = /** @class */ (function () {
    function TooltipIcon() {
        /**
         * The placement in which the `TooltipIcon` appears.
         * Set to `"top"` to have it positioned above the icon
         */
        this.placement = "bottom";
        this.alignment = "start";
        this.className = true;
    }
    TooltipIcon.decorators = [
        { type: Component, args: [{
                    selector: "ibm-tooltip-icon",
                    template: "\n\t\t<button\n\t\t\ttype=\"button\"\n\t\t\tclass=\"bx--tooltip__trigger bx--tooltip--a11y\"\n\t\t\t[ngClass]=\"{\n\t\t\t\t'bx--tooltip--bottom' : placement === 'bottom',\n\t\t\t\t'bx--tooltip--top' : placement === 'top',\n\t\t\t\t'bx--tooltip--left' : placement === 'left',\n\t\t\t\t'bx--tooltip--right' : placement === 'right',\n\t\t\t\t'bx--tooltip--align-start' : alignment === 'start',\n\t\t\t\t'bx--tooltip--align-center' : alignment === 'center',\n\t\t\t\t'bx--tooltip--align-end' : alignment === 'end'\n\t\t\t}\">\n\t\t\t<span class=\"bx--assistive-text\">{{content}}</span>\n\t\t\t<ng-content></ng-content>\n\t\t</button>\n\t"
                }] }
    ];
    TooltipIcon.propDecorators = {
        content: [{ type: Input }],
        placement: [{ type: Input }],
        alignment: [{ type: Input }],
        className: [{ type: HostBinding, args: ["class.bx--tooltip-icon",] }]
    };
    return TooltipIcon;
}());

/**
 * Directive for extending `Dialog` to create tooltips.
 *
 * [See demo](../../?path=/story/tooltip--basic)
 *
 * class: TooltipDirective (extends PopoverDirective)
 *
 *
 * selector: `nTooltip`
 *
 *
 * ```html
 * <button nTooltip="I am a tooltip" placement="right" trigger="mouseenter" type="danger">Tooltip Right</button>
 * <button nTooltip="I am a tooltip" type="warning">Tooltip Top warning on click</button>
 * ```
 *
 * <example-url>../../iframe.html?id=tooltip--basic</example-url>
 */
var TooltipDirective = /** @class */ (function (_super) {
    __extends(TooltipDirective, _super);
    /**
     * Creates an instance of `TooltipDirective`.
     */
    function TooltipDirective(elementRef, viewContainerRef, dialogService, eventService) {
        var _this = _super.call(this, elementRef, viewContainerRef, dialogService, eventService) || this;
        _this.elementRef = elementRef;
        _this.viewContainerRef = viewContainerRef;
        _this.dialogService = dialogService;
        _this.eventService = eventService;
        /**
         * Set tooltip type to reflect 'warning' or 'error' styles.
         */
        // tslint:disable-next-line:no-input-rename
        _this.tooltipType = "";
        _this.tabIndex = 0;
        _this.className = true;
        dialogService.setContext({ component: Tooltip });
        return _this;
    }
    Object.defineProperty(TooltipDirective.prototype, "descriptorId", {
        get: function () {
            return this.isOpen ? this.dialogConfig.compID : null;
        },
        enumerable: true,
        configurable: true
    });
    TooltipDirective.prototype.updateConfig = function () {
        this.dialogConfig.content = this.ibmTooltip;
        this.dialogConfig.type = this.tooltipType;
        this.dialogConfig.offset = this.offset;
    };
    TooltipDirective.decorators = [
        { type: Directive, args: [{
                    selector: "[ibmTooltip]",
                    exportAs: "ibmTooltip",
                    providers: [
                        DialogService
                    ]
                },] }
    ];
    /** @nocollapse */
    TooltipDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ViewContainerRef },
        { type: DialogService },
        { type: EventService }
    ]; };
    TooltipDirective.propDecorators = {
        ibmTooltip: [{ type: Input }],
        tooltipType: [{ type: Input, args: ["tooltip-type",] }],
        tabIndex: [{ type: HostBinding, args: ["tabindex",] }],
        className: [{ type: HostBinding, args: ["class.bx--tooltip__trigger",] }],
        descriptorId: [{ type: HostBinding, args: ["attr.aria-describedby",] }]
    };
    return TooltipDirective;
}(DialogDirective));

/**
 * A directive that creates a tooltip `Dialog` for exposing truncated text.
 *
 * class: EllipsisTooltip (extends PopoverDirective)
 *
 * selector: `nEllipsisTooltip`
 *
 * ```html
 * <div class="ellipsis" nEllipsisTooltip>Tooltip for ellipsis because I can and I am really really long</div>
 * ```
 */
var EllipsisTooltip = /** @class */ (function (_super) {
    __extends(EllipsisTooltip, _super);
    function EllipsisTooltip() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * If text is truncated, this appends the text to the dialog as content.
     * @returns null
     * @memberof EllipsisTooltip
     */
    EllipsisTooltip.prototype.updateTooltipContent = function () {
        if (this.elementRef.nativeElement.scrollWidth <= this.elementRef.nativeElement.offsetWidth) {
            this.disabled = true;
            return;
        }
        this.disabled = false;
        this.dialogConfig.content = this.elementRef.nativeElement.innerText;
    };
    EllipsisTooltip.prototype.onClick = function () {
        if (this.trigger === "click") {
            this.updateTooltipContent();
        }
    };
    EllipsisTooltip.prototype.onHover = function () {
        if (this.trigger === "hover" || this.trigger === "mouseenter") {
            this.updateTooltipContent();
        }
    };
    EllipsisTooltip.prototype.onFocus = function () {
        this.updateTooltipContent();
    };
    EllipsisTooltip.decorators = [
        { type: Directive, args: [{
                    selector: "[ibmEllipsisTooltip]",
                    providers: [
                        DialogService
                    ]
                },] }
    ];
    EllipsisTooltip.propDecorators = {
        onClick: [{ type: HostListener, args: ["click",] }],
        onHover: [{ type: HostListener, args: ["mouseenter",] }],
        onFocus: [{ type: HostListener, args: ["focus",] }]
    };
    return EllipsisTooltip;
}(TooltipDirective));

/**
 * Extend the `Dialog` component to create an overflow menu.
 *
 * Not used directly. See overflow-menu.component and overflow-menu.directive for more
 */
var OverflowMenuPane = /** @class */ (function (_super) {
    __extends(OverflowMenuPane, _super);
    function OverflowMenuPane(elementRef, i18n, experimental, animationFrameService, 
    // mark `elementService` as optional since making it mandatory would be a breaking change
    elementService) {
        if (animationFrameService === void 0) { animationFrameService = null; }
        if (elementService === void 0) { elementService = null; }
        var _this = _super.call(this, elementRef, elementService, animationFrameService) || this;
        _this.elementRef = elementRef;
        _this.i18n = i18n;
        _this.experimental = experimental;
        _this.animationFrameService = animationFrameService;
        _this.elementService = elementService;
        return _this;
    }
    OverflowMenuPane.prototype.onDialogInit = function () {
        var _this = this;
        var positionOverflowMenu = function (pos) {
            var offset;
            /*
            * 20 is half the width of the overflow menu trigger element.
            * we also move the element by half of it's own width, since
            * position service will try and center everything
            */
            var closestRel = closestAttr("position", ["relative", "fixed", "absolute"], _this.elementRef.nativeElement);
            var topFix = closestRel ? closestRel.getBoundingClientRect().top * -1 : 0;
            var leftFix = closestRel ? closestRel.getBoundingClientRect().left * -1 : 0;
            offset = Math.round(_this.dialog.nativeElement.offsetWidth / 2) - 20;
            if (_this.dialogConfig.flip) {
                return position.addOffset(pos, topFix, (-offset + leftFix));
            }
            return position.addOffset(pos, topFix, (offset + leftFix));
        };
        this.addGap["bottom"] = positionOverflowMenu;
        this.addGap["top"] = positionOverflowMenu;
        if (!this.dialogConfig.menuLabel) {
            this.dialogConfig.menuLabel = this.i18n.get().OVERFLOW_MENU.OVERFLOW;
        }
    };
    OverflowMenuPane.prototype.hostkeys = function (event) {
        var listItems = this.listItems();
        switch (event.key) {
            case "Down": // IE specific value
            case "ArrowDown":
                event.preventDefault();
                if (!isFocusInLastItem(event, listItems)) {
                    var index = listItems.findIndex(function (item) { return item === event.target; });
                    listItems[index + 1].focus();
                }
                else {
                    listItems[0].focus();
                }
                break;
            case "Up": // IE specific value
            case "ArrowUp":
                event.preventDefault();
                if (!isFocusInFirstItem(event, listItems)) {
                    var index = listItems.findIndex(function (item) { return item === event.target; });
                    listItems[index - 1].focus();
                }
                else {
                    listItems[listItems.length - 1].focus();
                }
                break;
            case "Home":
                event.preventDefault();
                listItems[0].focus();
                break;
            case "End":
                event.preventDefault();
                listItems[listItems.length - 1].focus();
                break;
            case "Esc": // IE specific value
            case "Escape":
            case "Tab":
                event.stopImmediatePropagation();
                this.doClose({
                    reason: CloseReasons.interaction,
                    target: event.target
                });
                break;
            default: break;
        }
    };
    OverflowMenuPane.prototype.onClose = function (event) {
        this.doClose({
            reason: CloseReasons.interaction,
            target: event.target
        });
    };
    OverflowMenuPane.prototype.afterDialogViewInit = function () {
        var focusElementList = this.listItems();
        focusElementList.forEach(function (button) {
            // Allows user to set tabindex to 0.
            if (button.getAttribute("tabindex") === null) {
                button.tabIndex = -1;
            }
        });
        if (focusElementList[0]) {
            focusElementList[0].tabIndex = 0;
            focusElementList[0].focus();
        }
    };
    OverflowMenuPane.prototype.listItems = function () {
        var selector = ".bx--overflow-menu-options__option:not([disabled]) .bx--overflow-menu-options__btn";
        return Array.from(this.elementRef.nativeElement.querySelectorAll(selector));
    };
    OverflowMenuPane.decorators = [
        { type: Component, args: [{
                    selector: "ibm-overflow-menu-pane",
                    template: "\n\t\t<ul\n\t\t\t[attr.aria-label]=\"dialogConfig.menuLabel\"\n\t\t\t[ngClass]=\"{'bx--overflow-menu--flip': dialogConfig.flip}\"\n\t\t\trole=\"menu\"\n\t\t\t#dialog\n\t\t\tclass=\"bx--overflow-menu-options bx--overflow-menu-options--open\"\n\t\t\trole=\"menu\"\n\t\t\t(click)=\"onClose($event)\"\n\t\t\t[attr.aria-label]=\"dialogConfig.menuLabel\">\n\t\t\t<ng-template\n\t\t\t\t[ngTemplateOutlet]=\"dialogConfig.content\"\n\t\t\t\t[ngTemplateOutletContext]=\"{overflowMenu: this}\">\n\t\t\t</ng-template>\n\t\t</ul>\n\t"
                }] }
    ];
    /** @nocollapse */
    OverflowMenuPane.ctorParameters = function () { return [
        { type: ElementRef },
        { type: I18n },
        { type: ExperimentalService },
        { type: AnimationFrameService, decorators: [{ type: Optional }] },
        { type: ElementService, decorators: [{ type: Optional }] }
    ]; };
    OverflowMenuPane.propDecorators = {
        hostkeys: [{ type: HostListener, args: ["keydown", ["$event"],] }]
    };
    return OverflowMenuPane;
}(Dialog));

var OverflowMenuCustomPane = /** @class */ (function (_super) {
    __extends(OverflowMenuCustomPane, _super);
    function OverflowMenuCustomPane(elementRef, i18n, animationFrameService, 
    // mark `elementService` as optional since making it mandatory would be a breaking change
    elementService) {
        if (animationFrameService === void 0) { animationFrameService = null; }
        if (elementService === void 0) { elementService = null; }
        var _this = _super.call(this, elementRef, elementService, animationFrameService) || this;
        _this.elementRef = elementRef;
        _this.i18n = i18n;
        _this.animationFrameService = animationFrameService;
        _this.elementService = elementService;
        return _this;
    }
    OverflowMenuCustomPane.prototype.onDialogInit = function () {
        var _this = this;
        var positionOverflowMenu = function (pos) {
            var offset;
            /*
            * 20 is half the width of the overflow menu trigger element.
            * we also move the element by half of it's own width, since
            * position service will try and center everything
            */
            var closestRel = closestAttr("position", ["relative", "fixed", "absolute"], _this.elementRef.nativeElement);
            var topFix = closestRel ? closestRel.getBoundingClientRect().top * -1 : 0;
            var leftFix = closestRel ? closestRel.getBoundingClientRect().left * -1 : 0;
            offset = Math.round(_this.dialog.nativeElement.offsetWidth / 2) - 20;
            if (_this.dialogConfig.flip) {
                return position.addOffset(pos, topFix, (-offset + leftFix));
            }
            return position.addOffset(pos, topFix, (offset + leftFix));
        };
        this.addGap["bottom"] = positionOverflowMenu;
        this.addGap["top"] = positionOverflowMenu;
        if (!this.dialogConfig.menuLabel) {
            this.dialogConfig.menuLabel = this.i18n.get().OVERFLOW_MENU.OVERFLOW;
        }
    };
    OverflowMenuCustomPane.decorators = [
        { type: Component, args: [{
                    selector: "ibm-overflow-custom-menu-pane",
                    template: "\n\t\t<div\n\t\t\t[attr.aria-label]=\"dialogConfig.menuLabel\"\n\t\t\t[ngClass]=\"{'bx--overflow-menu--flip': dialogConfig.flip}\"\n\t\t\tclass=\"bx--overflow-menu-options bx--overflow-menu-options--open\"\n\t\t\trole=\"menu\"\n\t\t\t(click)=\"doClose()\"\n\t\t\t#dialog\n\t\t\t[attr.aria-label]=\"dialogConfig.menuLabel\">\n\t\t\t<ng-template\n\t\t\t\t[ngTemplateOutlet]=\"dialogConfig.content\"\n\t\t\t\t[ngTemplateOutletContext]=\"{overflowMenu: this}\">\n\t\t\t</ng-template>\n\t\t</div>\n\t"
                }] }
    ];
    /** @nocollapse */
    OverflowMenuCustomPane.ctorParameters = function () { return [
        { type: ElementRef },
        { type: I18n },
        { type: AnimationFrameService, decorators: [{ type: Optional }] },
        { type: ElementService, decorators: [{ type: Optional }] }
    ]; };
    return OverflowMenuCustomPane;
}(Dialog));

/**
 * Directive for extending `Dialog` to create overflow menus.
 *
 * class: OverflowMenuDirective (extends DialogDirective)
 *
 *
 * selector: `ibmOverflowMenu`
 *
 *
 * ```html
 * <div [ibmOverflowMenu]="templateRef"></div>
 * <ng-template #templateRef>
 * 	<!-- overflow menu options here -->
 * </ng-template>
 * ```
 *
 * ```html
 * <div [ibmOverflowMenu]="templateRef" [customPane]="true"></div>
 * <ng-template #templateRef>
 *  <!-- custom content goes here -->
 * </ng-template>
 * ```
 */
var OverflowMenuDirective = /** @class */ (function (_super) {
    __extends(OverflowMenuDirective, _super);
    /**
     * Creates an instance of `OverflowMenuDirective`.
     */
    function OverflowMenuDirective(elementRef, viewContainerRef, dialogService, eventService) {
        var _this = _super.call(this, elementRef, viewContainerRef, dialogService, eventService) || this;
        _this.elementRef = elementRef;
        _this.viewContainerRef = viewContainerRef;
        _this.dialogService = dialogService;
        _this.eventService = eventService;
        /**
         * Controls wether the overflow menu is flipped
         */
        _this.flip = false;
        /**
         * Classes to add to the dialog container
         */
        _this.wrapperClass = "";
        /**
         * Set to true to for custom content
         */
        _this.customPane = false;
        return _this;
    }
    OverflowMenuDirective.prototype.ngAfterContentInit = function () {
        this.dialogService.setContext({ component: this.customPane ? OverflowMenuCustomPane : OverflowMenuPane });
    };
    OverflowMenuDirective.prototype.updateConfig = function () {
        this.dialogConfig.content = this.ibmOverflowMenu;
        this.dialogConfig.flip = this.flip;
        this.dialogConfig.offset = this.offset;
        this.dialogConfig.wrapperClass = this.wrapperClass;
    };
    OverflowMenuDirective.prototype.hostkeys = function (event) {
        switch (event.key) {
            case "Enter":
            case " ":
                event.preventDefault();
                break;
        }
    };
    OverflowMenuDirective.decorators = [
        { type: Directive, args: [{
                    selector: "[ibmOverflowMenu]",
                    exportAs: "ibmOverflowMenu",
                    providers: [
                        DialogService
                    ]
                },] }
    ];
    /** @nocollapse */
    OverflowMenuDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ViewContainerRef },
        { type: DialogService },
        { type: EventService }
    ]; };
    OverflowMenuDirective.propDecorators = {
        ibmOverflowMenu: [{ type: Input }],
        flip: [{ type: Input }],
        offset: [{ type: Input }],
        wrapperClass: [{ type: Input }],
        customPane: [{ type: Input }],
        hostkeys: [{ type: HostListener, args: ["keydown", ["$event"],] }]
    };
    return OverflowMenuDirective;
}(DialogDirective));

/**
 * The OverFlow menu component encapsulates the OverFlowMenu directive, and the menu iconography into one convienent component
 *
 * [See demo](../../?path=/story/overflow-menu--basic)
 *
 * html:
 * ```
 * <ibm-overflow-menu>
 *	<ibm-overflow-menu-option>Option 1</ibm-overflow-menu-option>
 *	<ibm-overflow-menu-option>Option 2</ibm-overflow-menu-option>
 * </ibm-overflow-menu>
 * ```
 *
 * <example-url>../../iframe.html?id=overflow-menu--basic</example-url>
 */
var OverflowMenu = /** @class */ (function () {
    function OverflowMenu(elementRef, i18n) {
        this.elementRef = elementRef;
        this.i18n = i18n;
        this.buttonLabel = this.i18n.get().OVERFLOW_MENU.OVERFLOW;
        this.flip = false;
        this.placement = "bottom";
        this.open = false;
        this.openChange = new EventEmitter();
        this.wrapperClass = "";
        /**
         * This appends additional classes to the overflow trigger/button.
         */
        this.triggerClass = "";
    }
    OverflowMenu.prototype.handleOpenChange = function (event) {
        this.open = event;
        this.openChange.emit(event);
    };
    OverflowMenu.decorators = [
        { type: Component, args: [{
                    selector: "ibm-overflow-menu",
                    template: "\n\t\t<button\n\t\t\t[ibmOverflowMenu]=\"options\"\n\t\t\t[ngClass]=\"{'bx--overflow-menu--open': open}\"\n\t\t\tclass=\"bx--overflow-menu {{triggerClass}}\"\n\t\t\t[attr.aria-label]=\"buttonLabel\"\n\t\t\t[flip]=\"flip\"\n\t\t\t[isOpen]=\"open\"\n\t\t\t(isOpenChange)=\"handleOpenChange($event)\"\n\t\t\t[offset]=\"offset\"\n\t\t\t[wrapperClass]=\"wrapperClass\"\n\t\t\taria-haspopup=\"true\"\n\t\t\tclass=\"bx--overflow-menu\"\n\t\t\ttype=\"button\"\n\t\t\t[placement]=\"placement\">\n\t\t\t<ng-template *ngIf=\"customTrigger; else defaultIcon\" [ngTemplateOutlet]=\"customTrigger\"></ng-template>\n\t\t</button>\n\t\t<ng-template #options>\n\t\t\t<ng-content></ng-content>\n\t\t</ng-template>\n\t\t<ng-template #defaultIcon>\n\t\t\t<svg ibmIcon=\"overflow-menu--vertical\" size=\"16\" class=\"bx--overflow-menu__icon\"></svg>\n\t\t</ng-template>\n\t",
                    encapsulation: ViewEncapsulation.None,
                    styles: ["\n\t\t.bx--overflow-menu--open {\n\t\t\topacity: 1\n\t\t}\n\n\t\t/*\n\t\tRotate the overflow menu container as well as the icon, since\n\t\twe calculate our menu position based on the container, not the icon.\n\t\t*/\n\t\t.bx--data-table-v2 .bx--overflow-menu {\n\t\t\ttransform: rotate(90deg);\n\t\t}\n\n\t\t.bx--data-table-v2 .bx--overflow-menu__icon {\n\t\t\ttransform: rotate(180deg);\n\t\t}\n\t"]
                }] }
    ];
    /** @nocollapse */
    OverflowMenu.ctorParameters = function () { return [
        { type: ElementRef },
        { type: I18n }
    ]; };
    OverflowMenu.propDecorators = {
        buttonLabel: [{ type: Input }],
        flip: [{ type: Input }],
        placement: [{ type: Input }],
        open: [{ type: Input }],
        openChange: [{ type: Output }],
        customTrigger: [{ type: Input }],
        offset: [{ type: Input }],
        wrapperClass: [{ type: Input }],
        triggerClass: [{ type: Input }],
        overflowMenuDirective: [{ type: ContentChild, args: [OverflowMenuDirective, { static: false },] }]
    };
    return OverflowMenu;
}());

/**
 * Available HTML anchor targets
 */
var Target;
(function (Target) {
    Target["self"] = "_self";
    Target["blank"] = "_blank";
    Target["parent"] = "_parent";
    Target["top"] = "_top";
})(Target || (Target = {}));
/**
 * Security HTML anchor rel when target is set
 */
var REL = "noreferrer noopener";
/**
 * `OverflowMenuOption` represents a single option in an overflow menu
 *
 * Presently it has three possible states - normal, disabled, and danger:
 * ```
 * <ibm-overflow-menu-option>Simple option</ibm-overflow-menu-option>
 * <ibm-overflow-menu-option disabled="true">Disabled</ibm-overflow-menu-option>
 * <ibm-overflow-menu-option type="danger">Danger option</ibm-overflow-menu-option>
 * ```
 *
 * For content that expands beyond the overflow menu `OverflowMenuOption` automatically adds a title attribute.
 */
var OverflowMenuOption = /** @class */ (function () {
    function OverflowMenuOption(elementRef) {
        this.elementRef = elementRef;
        this.optionClass = "bx--overflow-menu-options__option";
        this.role = "presentation";
        /**
         * toggles between `normal` and `danger` states
         */
        this.type = "normal";
        /**
         * disable/enable interactions
         */
        this.disabled = false;
        this.selected = new EventEmitter();
        this.tabIndex = -1;
        // note: title must be a real attribute (i.e. not a getter) as of Angular@6 due to
        // change after checked errors
        this.title = null;
    }
    Object.defineProperty(OverflowMenuOption.prototype, "isDanger", {
        get: function () {
            return this.type === "danger";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OverflowMenuOption.prototype, "isDisabled", {
        get: function () {
            return this.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OverflowMenuOption.prototype, "target", {
        get: function () {
            return this._target;
        },
        /**
         * Allows to add a target to the anchor
         */
        set: function (value) {
            if (!Object.values(Target).includes(value)) {
                console.warn("`target` must have one of the following values: " + Object.values(Target).join(", ") + ".\nPlease use the `Target` enum exported by carbon-components-angular");
                return;
            }
            this._target = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OverflowMenuOption.prototype, "rel", {
        /**
         * rel only returns its value if target is defined
         */
        get: function () {
            return this._target ? REL : null;
        },
        enumerable: true,
        configurable: true
    });
    OverflowMenuOption.prototype.onClick = function () {
        this.selected.emit();
    };
    OverflowMenuOption.prototype.onFocus = function () {
        var _this = this;
        setTimeout(function () { return _this.tabIndex = 0; });
    };
    OverflowMenuOption.prototype.onBlur = function () {
        var _this = this;
        setTimeout(function () { return _this.tabIndex = -1; });
    };
    OverflowMenuOption.prototype.ngAfterViewInit = function () {
        var button = this.elementRef.nativeElement.querySelector("button, a");
        var textContainer = button.querySelector(".bx--overflow-menu-options__option-content");
        if (textContainer.scrollWidth > textContainer.offsetWidth) {
            this.title = button.textContent;
        }
    };
    OverflowMenuOption.decorators = [
        { type: Component, args: [{
                    selector: "ibm-overflow-menu-option",
                    template: "\n\t\t<button\n\t\t\t*ngIf=\"!href\"\n\t\t\tclass=\"bx--overflow-menu-options__btn\"\n\t\t\trole=\"menuitem\"\n\t\t\t[tabindex]=\"tabIndex\"\n\t\t\t(focus)=\"onFocus()\"\n\t\t\t(blur)=\"onBlur()\"\n\t\t\t(click)=\"onClick()\"\n\t\t\t[disabled]=\"disabled\"\n\t\t\t[attr.title]=\"title\">\n\t\t\t<ng-container *ngTemplateOutlet=\"tempOutlet\"></ng-container>\n\t\t</button>\n\n\t\t<a\n\t\t\t*ngIf=\"href\"\n\t\t\tclass=\"bx--overflow-menu-options__btn\"\n\t\t\trole=\"menuitem\"\n\t\t\t[tabindex]=\"tabIndex\"\n\t\t\t(focus)=\"onFocus()\"\n\t\t\t(blur)=\"onBlur()\"\n\t\t\t(click)=\"onClick()\"\n\t\t\t[attr.disabled]=\"disabled\"\n\t\t\t[href]=\"href\"\n\t\t\t[attr.target]=\"target\"\n\t\t\t[attr.rel]=\"rel\"\n\t\t\t[attr.title]=\"title\">\n\t\t\t<ng-container *ngTemplateOutlet=\"tempOutlet\"></ng-container>\n\t\t</a>\n\n\t\t<ng-template #tempOutlet>\n\t\t\t<div class=\"bx--overflow-menu-options__option-content\">\n\t\t\t\t<ng-content></ng-content>\n\t\t\t</div>\n\t\t</ng-template>\n\t"
                }] }
    ];
    /** @nocollapse */
    OverflowMenuOption.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    OverflowMenuOption.propDecorators = {
        optionClass: [{ type: HostBinding, args: ["class",] }],
        role: [{ type: HostBinding, args: ["attr.role",] }],
        isDanger: [{ type: HostBinding, args: ["class.bx--overflow-menu-options__option--danger",] }],
        isDisabled: [{ type: HostBinding, args: ["class.bx--overflow-menu-options__option--disabled",] }],
        type: [{ type: Input }],
        disabled: [{ type: Input }],
        href: [{ type: Input }],
        target: [{ type: Input }],
        selected: [{ type: Output }]
    };
    return OverflowMenuOption;
}());

// modules
var DialogModule = /** @class */ (function () {
    function DialogModule() {
    }
    DialogModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        Dialog,
                        Tooltip,
                        TooltipDefinition,
                        TooltipIcon,
                        OverflowMenu,
                        OverflowMenuPane,
                        OverflowMenuCustomPane,
                        DialogDirective,
                        TooltipDirective,
                        EllipsisTooltip,
                        OverflowMenuDirective,
                        OverflowMenuOption
                    ],
                    exports: [
                        Dialog,
                        Tooltip,
                        TooltipDefinition,
                        TooltipIcon,
                        OverflowMenu,
                        OverflowMenuPane,
                        OverflowMenuCustomPane,
                        DialogDirective,
                        TooltipDirective,
                        EllipsisTooltip,
                        OverflowMenuDirective,
                        OverflowMenuOption
                    ],
                    providers: [DialogService],
                    entryComponents: [
                        Dialog,
                        Tooltip,
                        OverflowMenuPane,
                        OverflowMenuCustomPane
                    ],
                    imports: [
                        CommonModule,
                        I18nModule,
                        PlaceholderModule,
                        ExperimentalModule,
                        UtilsModule,
                        IconModule
                    ]
                },] }
    ];
    return DialogModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { DialogService, Dialog, DialogDirective, Tooltip, TooltipDefinition, TooltipIcon, TooltipDirective, EllipsisTooltip, OverflowMenu, OverflowMenuPane, OverflowMenuCustomPane, OverflowMenuDirective, OverflowMenuOption, CloseReasons, DialogModule };

//# sourceMappingURL=carbon-components-angular-dialog.js.map